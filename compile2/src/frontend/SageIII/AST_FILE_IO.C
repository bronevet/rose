/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarAST_FileIoSource.code" */
// tps : need to include sage3basic.h -- took it out from the header file because precompiled headers cannot be included in header files
#include "sage3basic.h" // file_IO
#include "rosedefs.h"
#include "Cxx_GrammarMemoryPoolSupport.h"
#include <fstream>
#include "AST_FILE_IO.h"
#include "StorageClasses.h"
#include <sstream>
#include <string>

using namespace std;

#if 0
namespace AST_FileIO
   {
     class MemoryCheckingTraversalForAstFileIO : public ROSE_VisitTraversal
        {
          public:
               int counter;
               void visit ( SgNode* node );
        };

     void MemoryCheckingTraversalForAstFileIO::visit ( SgNode* node )
        {
          ROSE_ASSERT(node != NULL);
       // printf ("MemoryCheckingTraversalForAstFileIO::visit: node = %s \n",node->class_name().c_str());
          ROSE_ASSERT(node->get_freepointer() == AST_FileIO::IS_VALID_POINTER());
          node->checkDataMemberPointersIfInMemoryPool();
        }
    }
#endif

/* JH(01/17/2006) Initializing the static data members
*/
AstData*
AST_FILE_IO :: actualRebuildAst;

std::vector<AstData*>
AST_FILE_IO :: vectorOfASTs;

unsigned long 
AST_FILE_IO :: listOfMemoryPoolSizes [ totalNumberOfIRNodes + 1] ;

bool 
AST_FILE_IO :: freepointersOfCurrentAstAreSetToGlobalIndices;

std::map<std::string, AST_FILE_IO::CONSTRUCTOR > 
AST_FILE_IO::registeredAttributes;


/* JH (10/25/2005): Static method that computes the memory pool sizes and stores them incrementally
   in listOfAccumulatedPoolSizes at position [ V_$CLASSNAME + 1 ]. Reason for this strange issue; no global
   index must be 0, since we want to store NULL pointers as 0 ( means, we will not manipulate them ).
   Therefore, we introduce 'listOfAccumulatedPoolSizes [ 0 ] =  1', in order to calculate the index of an
   node by computing the index in its memory pool and then adding the getAccumulated sizes of the previous
   memory pools, already stored in listOfAccumulatedPoolSizes [ V_$CLASSNAME ].
*/

void 
AST_FILE_IO :: startUp( SgProject* root )
   {
   /* Our array containing the total memory pool sizes starts at startingIndex. This is the first multiple of 100
      that is greater than the indices used internally. We sort the the memory pool size at
      position [ V_$CLASSNAME + 1 ]. Concurrently, we allocate the appropriate STORAGE_class_list arrays.
      If the corresponding memory pool is empty, we set the pointer to NULL!
  */
  // DQ (4/22/2006): Added timer information for AST File I/O
     TimingPerformance timer ("AST_FILE_IO::startUp():");
 
     assert ( vectorOfASTs.empty() == true );
     assert ( root != NULL );

#if FILE_IO_EXTRA_CHECK
     {
  // DQ (4/22/2006): Added timer information for AST File I/O
     TimingPerformance nested_timer ("AST_FILE_IO::startUp() FILE_IO_EXTRA_CHECK:");

     if ( SgProject::get_verbose() > 0 )
          std::cout << "Starting check, that all IRNodes are in the memory pools ... " << std::flush;
#if 0
  // AST_FileIO::MemoryCheckingTraversalForAstFileIO memoryCheckingTraversal;
     MemoryCheckingTraversalForAstFileIO memoryCheckingTraversal;
     memoryCheckingTraversal.traverseMemoryPool();
#endif

     if ( SgProject::get_verbose() > 0 )
          std::cout << "  done ! " << std::endl;
     }
#endif

  // JH: the global index counting starts at index 1, because we want to store NULL pointers as 0!
     unsigned long globalIndexCounter = 1;

          listOfMemoryPoolSizes [ 0 ] =  globalIndexCounter;
     listOfMemoryPoolSizes [ 1 ] =  globalIndexCounter; 
     globalIndexCounter = SgAccessModifier_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 2 ] =  globalIndexCounter; 
     globalIndexCounter = SgActualArgumentExpression_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 3 ] =  globalIndexCounter; 
     globalIndexCounter = SgAddOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 4 ] =  globalIndexCounter; 
     globalIndexCounter = SgAddressOfOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 5 ] =  globalIndexCounter; 
     globalIndexCounter = SgAggregateInitializer_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 6 ] =  globalIndexCounter; 
     globalIndexCounter = SgAliasSymbol_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 7 ] =  globalIndexCounter; 
     globalIndexCounter = SgAllocateStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 8 ] =  globalIndexCounter; 
     globalIndexCounter = SgAndAssignOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 9 ] =  globalIndexCounter; 
     globalIndexCounter = SgAndOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 10 ] =  globalIndexCounter; 
     globalIndexCounter = SgArithmeticIfStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 11 ] =  globalIndexCounter; 
     globalIndexCounter = SgArrayType_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 12 ] =  globalIndexCounter; 
     globalIndexCounter = SgArrowExp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 13 ] =  globalIndexCounter; 
     globalIndexCounter = SgArrowStarOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 14 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmArmInstruction_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 15 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmArmRegisterReferenceExpression_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 16 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmBasicString_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 17 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmBinaryAdd_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 18 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmBinaryAddPostupdate_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 19 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmBinaryAddPreupdate_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 20 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmBinaryAsr_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 21 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmBinaryDivide_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 22 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmBinaryExpression_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 23 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmBinaryLsl_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 24 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmBinaryLsr_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 25 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmBinaryMod_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 26 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmBinaryMultiply_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 27 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmBinaryRor_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 28 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmBinarySubtract_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 29 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmBinarySubtractPostupdate_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 30 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmBinarySubtractPreupdate_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 31 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmBlock_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 32 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmByteValueExpression_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 33 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmCoffStrtab_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 34 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmCoffSymbol_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 35 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmCoffSymbolList_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 36 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmCoffSymbolTable_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 37 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmCommonSubExpression_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 38 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmControlFlagsExpression_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 39 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDOSExtendedHeader_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 40 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDOSFileHeader_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 41 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDoubleFloatValueExpression_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 42 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDoubleWordValueExpression_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 43 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDwarfAccessDeclaration_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 44 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDwarfArrayType_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 45 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDwarfBaseType_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 46 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDwarfCatchBlock_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 47 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDwarfClassTemplate_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 48 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDwarfClassType_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 49 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDwarfCommonBlock_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 50 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDwarfCommonInclusion_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 51 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDwarfCompilationUnit_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 52 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDwarfCompilationUnitList_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 53 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDwarfCondition_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 54 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDwarfConstType_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 55 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDwarfConstant_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 56 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDwarfConstruct_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 57 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDwarfConstructList_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 58 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDwarfDwarfProcedure_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 59 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDwarfEntryPoint_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 60 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDwarfEnumerationType_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 61 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDwarfEnumerator_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 62 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDwarfFileType_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 63 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDwarfFormalParameter_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 64 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDwarfFormatLabel_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 65 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDwarfFriend_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 66 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDwarfFunctionTemplate_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 67 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDwarfImportedDeclaration_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 68 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDwarfImportedModule_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 69 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDwarfImportedUnit_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 70 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDwarfInformation_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 71 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDwarfInheritance_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 72 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDwarfInlinedSubroutine_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 73 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDwarfInterfaceType_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 74 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDwarfLabel_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 75 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDwarfLexicalBlock_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 76 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDwarfLine_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 77 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDwarfLineList_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 78 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDwarfMacro_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 79 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDwarfMacroList_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 80 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDwarfMember_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 81 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDwarfModule_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 82 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDwarfMutableType_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 83 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDwarfNamelist_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 84 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDwarfNamelistItem_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 85 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDwarfNamespace_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 86 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDwarfPackedType_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 87 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDwarfPartialUnit_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 88 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDwarfPointerType_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 89 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDwarfPtrToMemberType_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 90 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDwarfReferenceType_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 91 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDwarfRestrictType_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 92 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDwarfSetType_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 93 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDwarfSharedType_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 94 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDwarfStringType_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 95 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDwarfStructureType_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 96 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDwarfSubprogram_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 97 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDwarfSubrangeType_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 98 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDwarfSubroutineType_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 99 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDwarfTemplateTypeParameter_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 100 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDwarfTemplateValueParameter_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 101 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDwarfThrownType_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 102 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDwarfTryBlock_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 103 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDwarfTypedef_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 104 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDwarfUnionType_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 105 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDwarfUnknownConstruct_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 106 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDwarfUnspecifiedParameters_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 107 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDwarfUnspecifiedType_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 108 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDwarfUpcRelaxedType_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 109 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDwarfUpcSharedType_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 110 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDwarfUpcStrictType_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 111 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDwarfVariable_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 112 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDwarfVariant_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 113 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDwarfVariantPart_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 114 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDwarfVolatileType_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 115 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmDwarfWithStmt_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 116 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmElfDynamicEntry_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 117 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmElfDynamicEntryList_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 118 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmElfDynamicSection_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 119 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmElfEHFrameEntryCI_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 120 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmElfEHFrameEntryCIList_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 121 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmElfEHFrameEntryFD_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 122 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmElfEHFrameEntryFDList_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 123 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmElfEHFrameSection_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 124 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmElfFileHeader_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 125 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmElfNoteEntry_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 126 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmElfNoteEntryList_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 127 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmElfNoteSection_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 128 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmElfRelocEntry_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 129 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmElfRelocEntryList_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 130 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmElfRelocSection_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 131 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmElfSection_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 132 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmElfSectionTable_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 133 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmElfSectionTableEntry_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 134 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmElfSegmentTable_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 135 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmElfSegmentTableEntry_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 136 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmElfSegmentTableEntryList_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 137 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmElfStringSection_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 138 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmElfStrtab_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 139 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmElfSymbol_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 140 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmElfSymbolList_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 141 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmElfSymbolSection_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 142 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmElfSymverDefinedAux_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 143 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmElfSymverDefinedAuxList_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 144 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmElfSymverDefinedEntry_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 145 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmElfSymverDefinedEntryList_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 146 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmElfSymverDefinedSection_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 147 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmElfSymverEntry_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 148 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmElfSymverEntryList_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 149 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmElfSymverNeededAux_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 150 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmElfSymverNeededAuxList_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 151 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmElfSymverNeededEntry_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 152 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmElfSymverNeededEntryList_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 153 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmElfSymverNeededSection_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 154 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmElfSymverSection_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 155 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmExecutableFileFormat_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 156 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmExprListExp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 157 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmExpression_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 158 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmFunction_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 159 ] =  globalIndexCounter; 
     listOfMemoryPoolSizes [ 160 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmGenericDLL_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 161 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmGenericDLLList_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 162 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmGenericFile_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 163 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmGenericFileList_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 164 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmGenericFormat_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 165 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmGenericHeader_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 166 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmGenericHeaderList_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 167 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmGenericSection_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 168 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmGenericSectionList_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 169 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmGenericString_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 170 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmGenericStrtab_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 171 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmGenericSymbol_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 172 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmGenericSymbolList_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 173 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmInstruction_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 174 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmIntegerValueExpression_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 175 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmInterpretation_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 176 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmInterpretationList_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 177 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmLEEntryPoint_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 178 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmLEEntryTable_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 179 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmLEFileHeader_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 180 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmLENameTable_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 181 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmLEPageTable_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 182 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmLEPageTableEntry_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 183 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmLERelocTable_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 184 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmLESection_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 185 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmLESectionTable_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 186 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmLESectionTableEntry_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 187 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmMemoryReferenceExpression_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 188 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmNEEntryPoint_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 189 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmNEEntryTable_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 190 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmNEFileHeader_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 191 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmNEModuleTable_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 192 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmNENameTable_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 193 ] =  globalIndexCounter; 
     listOfMemoryPoolSizes [ 194 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmNERelocEntry_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 195 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmNERelocTable_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 196 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmNESection_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 197 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmNESectionTable_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 198 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmNESectionTableEntry_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 199 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmNEStringTable_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 200 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmNode_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 201 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 202 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmOperandList_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 203 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmPEExportDirectory_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 204 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmPEExportEntry_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 205 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmPEExportEntryList_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 206 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmPEExportSection_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 207 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmPEFileHeader_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 208 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmPEImportDirectory_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 209 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmPEImportDirectoryList_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 210 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmPEImportItem_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 211 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmPEImportItemList_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 212 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmPEImportSection_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 213 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmPERVASizePair_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 214 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmPERVASizePairList_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 215 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmPESection_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 216 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmPESectionTable_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 217 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmPESectionTableEntry_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 218 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmPEStringSection_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 219 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmPowerpcInstruction_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 220 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmPowerpcRegisterReferenceExpression_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 221 ] =  globalIndexCounter; 
     listOfMemoryPoolSizes [ 222 ] =  globalIndexCounter; 
     listOfMemoryPoolSizes [ 223 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmQuadWordValueExpression_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 224 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmRegisterReferenceExpression_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 225 ] =  globalIndexCounter; 
     listOfMemoryPoolSizes [ 226 ] =  globalIndexCounter; 
     listOfMemoryPoolSizes [ 227 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmSingleFloatValueExpression_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 228 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 229 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmStaticData_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 230 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmStmt_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 231 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmStoredString_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 232 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmStringStorage_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 233 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmType_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 234 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmType128bitFloat_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 235 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmType80bitFloat_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 236 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmTypeByte_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 237 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmTypeDoubleFloat_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 238 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmTypeDoubleQuadWord_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 239 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmTypeDoubleWord_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 240 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmTypeQuadWord_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 241 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmTypeSingleFloat_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 242 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmTypeVector_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 243 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmTypeWord_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 244 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmUnaryArmSpecialRegisterList_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 245 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmUnaryExpression_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 246 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmUnaryMinus_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 247 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmUnaryPlus_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 248 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmUnaryRrx_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 249 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmValueExpression_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 250 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmVectorValueExpression_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 251 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmWordValueExpression_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 252 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmx86Instruction_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 253 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmx86RegisterReferenceExpression_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 254 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmBinaryAddressSymbol_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 255 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsmBinaryDataSymbol_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 256 ] =  globalIndexCounter; 
     globalIndexCounter = SgAssertStmt_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 257 ] =  globalIndexCounter; 
     globalIndexCounter = SgAssignInitializer_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 258 ] =  globalIndexCounter; 
     globalIndexCounter = SgAssignOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 259 ] =  globalIndexCounter; 
     globalIndexCounter = SgAssignStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 260 ] =  globalIndexCounter; 
     globalIndexCounter = SgAssignedGotoStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 261 ] =  globalIndexCounter; 
     globalIndexCounter = SgAssociateStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 262 ] =  globalIndexCounter; 
     globalIndexCounter = SgAsteriskShapeExp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 263 ] =  globalIndexCounter; 
     globalIndexCounter = SgAttribute_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 264 ] =  globalIndexCounter; 
     globalIndexCounter = SgAttributeSpecificationStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 265 ] =  globalIndexCounter; 
     globalIndexCounter = SgBackspaceStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 266 ] =  globalIndexCounter; 
     globalIndexCounter = SgBaseClass_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 267 ] =  globalIndexCounter; 
     globalIndexCounter = SgExpBaseClass_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 268 ] =  globalIndexCounter; 
     globalIndexCounter = SgBaseClassModifier_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 269 ] =  globalIndexCounter; 
     globalIndexCounter = SgBasicBlock_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 270 ] =  globalIndexCounter; 
     globalIndexCounter = SgBidirectionalGraph_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 271 ] =  globalIndexCounter; 
     globalIndexCounter = SgBinaryComposite_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 272 ] =  globalIndexCounter; 
     globalIndexCounter = SgBinaryOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 273 ] =  globalIndexCounter; 
     globalIndexCounter = SgBitAndOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 274 ] =  globalIndexCounter; 
     globalIndexCounter = SgBitAttribute_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 275 ] =  globalIndexCounter; 
     globalIndexCounter = SgBitComplementOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 276 ] =  globalIndexCounter; 
     globalIndexCounter = SgBitOrOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 277 ] =  globalIndexCounter; 
     globalIndexCounter = SgBitXorOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 278 ] =  globalIndexCounter; 
     globalIndexCounter = SgBlockDataStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 279 ] =  globalIndexCounter; 
     globalIndexCounter = SgBoolValExp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 280 ] =  globalIndexCounter; 
     globalIndexCounter = SgBreakStmt_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 281 ] =  globalIndexCounter; 
     globalIndexCounter = SgC_PreprocessorDirectiveStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 282 ] =  globalIndexCounter; 
     globalIndexCounter = SgCaseOptionStmt_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 283 ] =  globalIndexCounter; 
     globalIndexCounter = SgCastExp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 284 ] =  globalIndexCounter; 
     globalIndexCounter = SgCatchOptionStmt_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 285 ] =  globalIndexCounter; 
     globalIndexCounter = SgCatchStatementSeq_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 286 ] =  globalIndexCounter; 
     globalIndexCounter = SgCharVal_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 287 ] =  globalIndexCounter; 
     globalIndexCounter = SgClassDecl_attr_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 288 ] =  globalIndexCounter; 
     globalIndexCounter = SgClassDeclaration_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 289 ] =  globalIndexCounter; 
     globalIndexCounter = SgClassDefinition_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 290 ] =  globalIndexCounter; 
     globalIndexCounter = SgClassNameRefExp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 291 ] =  globalIndexCounter; 
     globalIndexCounter = SgClassSymbol_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 292 ] =  globalIndexCounter; 
     globalIndexCounter = SgClassType_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 293 ] =  globalIndexCounter; 
     globalIndexCounter = SgClinkageDeclarationStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 294 ] =  globalIndexCounter; 
     globalIndexCounter = SgClinkageEndStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 295 ] =  globalIndexCounter; 
     globalIndexCounter = SgClinkageStartStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 296 ] =  globalIndexCounter; 
     globalIndexCounter = SgCloseStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 297 ] =  globalIndexCounter; 
     globalIndexCounter = SgColonShapeExp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 298 ] =  globalIndexCounter; 
     globalIndexCounter = SgCommaOpExp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 299 ] =  globalIndexCounter; 
     globalIndexCounter = SgCommonBlock_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 300 ] =  globalIndexCounter; 
     globalIndexCounter = SgCommonBlockObject_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 301 ] =  globalIndexCounter; 
     globalIndexCounter = SgCommonSymbol_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 302 ] =  globalIndexCounter; 
     globalIndexCounter = SgComplexVal_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 303 ] =  globalIndexCounter; 
     globalIndexCounter = SgComprehension_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 304 ] =  globalIndexCounter; 
     listOfMemoryPoolSizes [ 305 ] =  globalIndexCounter; 
     globalIndexCounter = SgCompoundAssignOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 306 ] =  globalIndexCounter; 
     globalIndexCounter = SgCompoundInitializer_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 307 ] =  globalIndexCounter; 
     globalIndexCounter = SgComputedGotoStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 308 ] =  globalIndexCounter; 
     globalIndexCounter = SgConcatenationOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 309 ] =  globalIndexCounter; 
     globalIndexCounter = SgConditionalExp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 310 ] =  globalIndexCounter; 
     globalIndexCounter = SgConjugateOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 311 ] =  globalIndexCounter; 
     globalIndexCounter = SgConstVolatileModifier_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 312 ] =  globalIndexCounter; 
     globalIndexCounter = SgConstructorInitializer_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 313 ] =  globalIndexCounter; 
     globalIndexCounter = SgContainsStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 314 ] =  globalIndexCounter; 
     globalIndexCounter = SgContinueStmt_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 315 ] =  globalIndexCounter; 
     globalIndexCounter = SgCtorInitializerList_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 316 ] =  globalIndexCounter; 
     globalIndexCounter = SgDataStatementGroup_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 317 ] =  globalIndexCounter; 
     globalIndexCounter = SgDataStatementObject_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 318 ] =  globalIndexCounter; 
     globalIndexCounter = SgDataStatementValue_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 319 ] =  globalIndexCounter; 
     globalIndexCounter = SgDeadIfDirectiveStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 320 ] =  globalIndexCounter; 
     globalIndexCounter = SgDeallocateStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 321 ] =  globalIndexCounter; 
     globalIndexCounter = SgDeclarationModifier_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 322 ] =  globalIndexCounter; 
     globalIndexCounter = SgDeclarationStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 323 ] =  globalIndexCounter; 
     globalIndexCounter = SgDefaultOptionStmt_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 324 ] =  globalIndexCounter; 
     globalIndexCounter = SgDefaultSymbol_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 325 ] =  globalIndexCounter; 
     globalIndexCounter = SgDefineDirectiveStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 326 ] =  globalIndexCounter; 
     globalIndexCounter = SgDeleteExp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 327 ] =  globalIndexCounter; 
     globalIndexCounter = SgDerivedTypeStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 328 ] =  globalIndexCounter; 
     globalIndexCounter = SgDesignatedInitializer_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 329 ] =  globalIndexCounter; 
     globalIndexCounter = SgDictionaryComprehension_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 330 ] =  globalIndexCounter; 
     globalIndexCounter = SgDictionaryExp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 331 ] =  globalIndexCounter; 
     globalIndexCounter = SgDimensionObject_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 332 ] =  globalIndexCounter; 
     listOfMemoryPoolSizes [ 333 ] =  globalIndexCounter; 
     globalIndexCounter = SgDirectedGraphEdge_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 334 ] =  globalIndexCounter; 
     listOfMemoryPoolSizes [ 335 ] =  globalIndexCounter; 
     globalIndexCounter = SgDirectory_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 336 ] =  globalIndexCounter; 
     globalIndexCounter = SgDirectoryList_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 337 ] =  globalIndexCounter; 
     globalIndexCounter = SgDivAssignOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 338 ] =  globalIndexCounter; 
     globalIndexCounter = SgDivideOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 339 ] =  globalIndexCounter; 
     globalIndexCounter = SgDoWhileStmt_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 340 ] =  globalIndexCounter; 
     globalIndexCounter = SgDotExp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 341 ] =  globalIndexCounter; 
     globalIndexCounter = SgDotStarOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 342 ] =  globalIndexCounter; 
     globalIndexCounter = SgDoubleVal_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 343 ] =  globalIndexCounter; 
     globalIndexCounter = SgElaboratedTypeModifier_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 344 ] =  globalIndexCounter; 
     globalIndexCounter = SgElseDirectiveStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 345 ] =  globalIndexCounter; 
     globalIndexCounter = SgElseWhereStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 346 ] =  globalIndexCounter; 
     globalIndexCounter = SgElseifDirectiveStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 347 ] =  globalIndexCounter; 
     globalIndexCounter = SgEmptyDirectiveStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 348 ] =  globalIndexCounter; 
     globalIndexCounter = SgEndfileStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 349 ] =  globalIndexCounter; 
     globalIndexCounter = SgEndifDirectiveStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 350 ] =  globalIndexCounter; 
     globalIndexCounter = SgEntryStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 351 ] =  globalIndexCounter; 
     globalIndexCounter = SgEnumDeclaration_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 352 ] =  globalIndexCounter; 
     globalIndexCounter = SgEnumFieldSymbol_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 353 ] =  globalIndexCounter; 
     globalIndexCounter = SgEnumSymbol_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 354 ] =  globalIndexCounter; 
     globalIndexCounter = SgEnumType_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 355 ] =  globalIndexCounter; 
     globalIndexCounter = SgEnumVal_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 356 ] =  globalIndexCounter; 
     globalIndexCounter = SgEqualityOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 357 ] =  globalIndexCounter; 
     globalIndexCounter = SgEquivalenceStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 358 ] =  globalIndexCounter; 
     globalIndexCounter = SgErrorDirectiveStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 359 ] =  globalIndexCounter; 
     globalIndexCounter = SgExecStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 360 ] =  globalIndexCounter; 
     globalIndexCounter = SgExponentiationOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 361 ] =  globalIndexCounter; 
     globalIndexCounter = SgExponentiationAssignOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 362 ] =  globalIndexCounter; 
     globalIndexCounter = SgExprListExp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 363 ] =  globalIndexCounter; 
     globalIndexCounter = SgExprStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 364 ] =  globalIndexCounter; 
     globalIndexCounter = SgExpression_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 365 ] =  globalIndexCounter; 
     globalIndexCounter = SgExpressionRoot_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 366 ] =  globalIndexCounter; 
     globalIndexCounter = SgFile_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 367 ] =  globalIndexCounter; 
     globalIndexCounter = SgFileList_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 368 ] =  globalIndexCounter; 
     globalIndexCounter = SgFloatVal_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 369 ] =  globalIndexCounter; 
     globalIndexCounter = SgFlushStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 370 ] =  globalIndexCounter; 
     globalIndexCounter = SgForAllStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 371 ] =  globalIndexCounter; 
     globalIndexCounter = SgForInitStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 372 ] =  globalIndexCounter; 
     globalIndexCounter = SgForStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 373 ] =  globalIndexCounter; 
     globalIndexCounter = SgFormatItem_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 374 ] =  globalIndexCounter; 
     globalIndexCounter = SgFormatItemList_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 375 ] =  globalIndexCounter; 
     globalIndexCounter = SgFormatStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 376 ] =  globalIndexCounter; 
     globalIndexCounter = SgFortranDo_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 377 ] =  globalIndexCounter; 
     globalIndexCounter = SgFortranIncludeLine_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 378 ] =  globalIndexCounter; 
     globalIndexCounter = SgFortranNonblockedDo_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 379 ] =  globalIndexCounter; 
     globalIndexCounter = SgFuncDecl_attr_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 380 ] =  globalIndexCounter; 
     globalIndexCounter = SgFunctionCallExp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 381 ] =  globalIndexCounter; 
     globalIndexCounter = SgFunctionDeclaration_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 382 ] =  globalIndexCounter; 
     globalIndexCounter = SgFunctionDefinition_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 383 ] =  globalIndexCounter; 
     globalIndexCounter = SgFunctionModifier_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 384 ] =  globalIndexCounter; 
     globalIndexCounter = SgFunctionParameterList_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 385 ] =  globalIndexCounter; 
     globalIndexCounter = SgFunctionParameterTypeList_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 386 ] =  globalIndexCounter; 
     globalIndexCounter = SgFunctionRefExp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 387 ] =  globalIndexCounter; 
     globalIndexCounter = SgFunctionSymbol_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 388 ] =  globalIndexCounter; 
     globalIndexCounter = SgFunctionType_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 389 ] =  globalIndexCounter; 
     globalIndexCounter = SgFunctionTypeSymbol_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 390 ] =  globalIndexCounter; 
     globalIndexCounter = SgFunctionTypeTable_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 391 ] =  globalIndexCounter; 
     globalIndexCounter = SgTypeTable_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 392 ] =  globalIndexCounter; 
     globalIndexCounter = SgGlobal_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 393 ] =  globalIndexCounter; 
     globalIndexCounter = SgGotoStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 394 ] =  globalIndexCounter; 
     globalIndexCounter = SgGraph_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 395 ] =  globalIndexCounter; 
     globalIndexCounter = SgGraphEdge_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 396 ] =  globalIndexCounter; 
     globalIndexCounter = SgGraphEdgeList_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 397 ] =  globalIndexCounter; 
     globalIndexCounter = SgGraphNode_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 398 ] =  globalIndexCounter; 
     globalIndexCounter = SgGraphNodeList_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 399 ] =  globalIndexCounter; 
     globalIndexCounter = SgGreaterOrEqualOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 400 ] =  globalIndexCounter; 
     globalIndexCounter = SgGreaterThanOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 401 ] =  globalIndexCounter; 
     globalIndexCounter = SgIOItemExpression_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 402 ] =  globalIndexCounter; 
     globalIndexCounter = SgIOStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 403 ] =  globalIndexCounter; 
     globalIndexCounter = SgIdentDirectiveStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 404 ] =  globalIndexCounter; 
     globalIndexCounter = SgIfDirectiveStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 405 ] =  globalIndexCounter; 
     globalIndexCounter = SgIfStmt_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 406 ] =  globalIndexCounter; 
     globalIndexCounter = SgIfdefDirectiveStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 407 ] =  globalIndexCounter; 
     globalIndexCounter = SgIfndefDirectiveStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 408 ] =  globalIndexCounter; 
     globalIndexCounter = SgImagPartOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 409 ] =  globalIndexCounter; 
     globalIndexCounter = SgImplicitStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 410 ] =  globalIndexCounter; 
     globalIndexCounter = SgImpliedDo_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 411 ] =  globalIndexCounter; 
     globalIndexCounter = SgImportStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 412 ] =  globalIndexCounter; 
     globalIndexCounter = SgIncidenceDirectedGraph_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 413 ] =  globalIndexCounter; 
     globalIndexCounter = SgIncidenceUndirectedGraph_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 414 ] =  globalIndexCounter; 
     globalIndexCounter = SgIncludeDirectiveStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 415 ] =  globalIndexCounter; 
     globalIndexCounter = SgIncludeNextDirectiveStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 416 ] =  globalIndexCounter; 
     globalIndexCounter = SgInitializedName_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 417 ] =  globalIndexCounter; 
     globalIndexCounter = SgInitializer_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 418 ] =  globalIndexCounter; 
     globalIndexCounter = SgInquireStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 419 ] =  globalIndexCounter; 
     globalIndexCounter = SgIntKeyedBidirectionalGraph_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 420 ] =  globalIndexCounter; 
     globalIndexCounter = SgIntVal_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 421 ] =  globalIndexCounter; 
     globalIndexCounter = SgIntegerDivideOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 422 ] =  globalIndexCounter; 
     globalIndexCounter = SgIntegerDivideAssignOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 423 ] =  globalIndexCounter; 
     globalIndexCounter = SgInterfaceBody_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 424 ] =  globalIndexCounter; 
     globalIndexCounter = SgHeaderFileBody_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 425 ] =  globalIndexCounter; 
     globalIndexCounter = SgInterfaceStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 426 ] =  globalIndexCounter; 
     globalIndexCounter = SgInterfaceSymbol_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 427 ] =  globalIndexCounter; 
     globalIndexCounter = SgIntrinsicSymbol_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 428 ] =  globalIndexCounter; 
     globalIndexCounter = SgIsOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 429 ] =  globalIndexCounter; 
     globalIndexCounter = SgIsNotOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 430 ] =  globalIndexCounter; 
     globalIndexCounter = SgIorAssignOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 431 ] =  globalIndexCounter; 
     globalIndexCounter = SgKeyDatumPair_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 432 ] =  globalIndexCounter; 
     globalIndexCounter = SgCudaKernelExecConfig_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 433 ] =  globalIndexCounter; 
     globalIndexCounter = SgCudaKernelCallExp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 434 ] =  globalIndexCounter; 
     globalIndexCounter = SgLabelRefExp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 435 ] =  globalIndexCounter; 
     globalIndexCounter = SgLabelStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 436 ] =  globalIndexCounter; 
     globalIndexCounter = SgJavaLabelStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 437 ] =  globalIndexCounter; 
     globalIndexCounter = SgLabelSymbol_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 438 ] =  globalIndexCounter; 
     globalIndexCounter = SgJavaLabelSymbol_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 439 ] =  globalIndexCounter; 
     globalIndexCounter = SgLambdaRefExp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 440 ] =  globalIndexCounter; 
     globalIndexCounter = SgLessOrEqualOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 441 ] =  globalIndexCounter; 
     globalIndexCounter = SgLessThanOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 442 ] =  globalIndexCounter; 
     globalIndexCounter = SgLineDirectiveStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 443 ] =  globalIndexCounter; 
     globalIndexCounter = SgLinemarkerDirectiveStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 444 ] =  globalIndexCounter; 
     globalIndexCounter = SgLinkageModifier_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 445 ] =  globalIndexCounter; 
     globalIndexCounter = SgListComprehension_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 446 ] =  globalIndexCounter; 
     globalIndexCounter = SgListExp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 447 ] =  globalIndexCounter; 
     globalIndexCounter = SgLocatedNode_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 448 ] =  globalIndexCounter; 
     globalIndexCounter = SgLocatedNodeSupport_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 449 ] =  globalIndexCounter; 
     globalIndexCounter = SgLongDoubleVal_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 450 ] =  globalIndexCounter; 
     globalIndexCounter = SgLongIntVal_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 451 ] =  globalIndexCounter; 
     globalIndexCounter = SgLongLongIntVal_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 452 ] =  globalIndexCounter; 
     globalIndexCounter = SgLshiftAssignOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 453 ] =  globalIndexCounter; 
     globalIndexCounter = SgLshiftOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 454 ] =  globalIndexCounter; 
     globalIndexCounter = SgMemberFunctionDeclaration_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 455 ] =  globalIndexCounter; 
     globalIndexCounter = SgMemberFunctionRefExp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 456 ] =  globalIndexCounter; 
     globalIndexCounter = SgMemberFunctionSymbol_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 457 ] =  globalIndexCounter; 
     globalIndexCounter = SgMemberFunctionType_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 458 ] =  globalIndexCounter; 
     globalIndexCounter = SgMembershipOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 459 ] =  globalIndexCounter; 
     globalIndexCounter = SgMinusAssignOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 460 ] =  globalIndexCounter; 
     globalIndexCounter = SgMinusMinusOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 461 ] =  globalIndexCounter; 
     globalIndexCounter = SgMinusOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 462 ] =  globalIndexCounter; 
     globalIndexCounter = SgModAssignOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 463 ] =  globalIndexCounter; 
     globalIndexCounter = SgModOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 464 ] =  globalIndexCounter; 
     globalIndexCounter = SgModifier_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 465 ] =  globalIndexCounter; 
     globalIndexCounter = SgModifierNodes_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 466 ] =  globalIndexCounter; 
     globalIndexCounter = SgModifierType_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 467 ] =  globalIndexCounter; 
     globalIndexCounter = SgModuleStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 468 ] =  globalIndexCounter; 
     globalIndexCounter = SgModuleSymbol_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 469 ] =  globalIndexCounter; 
     globalIndexCounter = SgMultAssignOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 470 ] =  globalIndexCounter; 
     globalIndexCounter = SgMultiplyOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 471 ] =  globalIndexCounter; 
     globalIndexCounter = SgName_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 472 ] =  globalIndexCounter; 
     globalIndexCounter = SgNameGroup_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 473 ] =  globalIndexCounter; 
     globalIndexCounter = SgNamedType_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 474 ] =  globalIndexCounter; 
     globalIndexCounter = SgNamelistStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 475 ] =  globalIndexCounter; 
     globalIndexCounter = SgNamespaceAliasDeclarationStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 476 ] =  globalIndexCounter; 
     globalIndexCounter = SgNamespaceDeclarationStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 477 ] =  globalIndexCounter; 
     globalIndexCounter = SgNamespaceDefinitionStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 478 ] =  globalIndexCounter; 
     globalIndexCounter = SgNamespaceSymbol_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 479 ] =  globalIndexCounter; 
     globalIndexCounter = SgNaryOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 480 ] =  globalIndexCounter; 
     globalIndexCounter = SgNaryBooleanOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 481 ] =  globalIndexCounter; 
     globalIndexCounter = SgNaryComparisonOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 482 ] =  globalIndexCounter; 
     globalIndexCounter = SgNewExp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 483 ] =  globalIndexCounter; 
     globalIndexCounter = SgNode_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 484 ] =  globalIndexCounter; 
     globalIndexCounter = SgNotEqualOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 485 ] =  globalIndexCounter; 
     globalIndexCounter = SgNotOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 486 ] =  globalIndexCounter; 
     globalIndexCounter = SgNonMembershipOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 487 ] =  globalIndexCounter; 
     globalIndexCounter = SgNullExpression_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 488 ] =  globalIndexCounter; 
     globalIndexCounter = SgNullStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 489 ] =  globalIndexCounter; 
     globalIndexCounter = SgNullifyStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 490 ] =  globalIndexCounter; 
     globalIndexCounter = SgOmpAtomicStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 491 ] =  globalIndexCounter; 
     globalIndexCounter = SgOmpBarrierStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 492 ] =  globalIndexCounter; 
     globalIndexCounter = SgOmpCriticalStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 493 ] =  globalIndexCounter; 
     globalIndexCounter = SgOmpClauseBodyStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 494 ] =  globalIndexCounter; 
     globalIndexCounter = SgOmpBodyStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 495 ] =  globalIndexCounter; 
     globalIndexCounter = SgOmpDoStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 496 ] =  globalIndexCounter; 
     globalIndexCounter = SgOmpFlushStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 497 ] =  globalIndexCounter; 
     globalIndexCounter = SgOmpForStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 498 ] =  globalIndexCounter; 
     globalIndexCounter = SgOmpMasterStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 499 ] =  globalIndexCounter; 
     globalIndexCounter = SgOmpOrderedStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 500 ] =  globalIndexCounter; 
     globalIndexCounter = SgOmpParallelStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 501 ] =  globalIndexCounter; 
     globalIndexCounter = SgOmpSectionStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 502 ] =  globalIndexCounter; 
     globalIndexCounter = SgOmpSectionsStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 503 ] =  globalIndexCounter; 
     globalIndexCounter = SgOmpSingleStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 504 ] =  globalIndexCounter; 
     globalIndexCounter = SgOmpTaskStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 505 ] =  globalIndexCounter; 
     globalIndexCounter = SgOmpTaskwaitStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 506 ] =  globalIndexCounter; 
     globalIndexCounter = SgOmpThreadprivateStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 507 ] =  globalIndexCounter; 
     globalIndexCounter = SgOmpWorkshareStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 508 ] =  globalIndexCounter; 
     globalIndexCounter = SgOmpClause_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 509 ] =  globalIndexCounter; 
     globalIndexCounter = SgOmpCollapseClause_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 510 ] =  globalIndexCounter; 
     globalIndexCounter = SgOmpCopyinClause_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 511 ] =  globalIndexCounter; 
     globalIndexCounter = SgOmpCopyprivateClause_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 512 ] =  globalIndexCounter; 
     globalIndexCounter = SgOmpDefaultClause_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 513 ] =  globalIndexCounter; 
     globalIndexCounter = SgOmpExpressionClause_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 514 ] =  globalIndexCounter; 
     globalIndexCounter = SgOmpFirstprivateClause_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 515 ] =  globalIndexCounter; 
     globalIndexCounter = SgOmpIfClause_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 516 ] =  globalIndexCounter; 
     globalIndexCounter = SgOmpLastprivateClause_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 517 ] =  globalIndexCounter; 
     globalIndexCounter = SgOmpNowaitClause_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 518 ] =  globalIndexCounter; 
     globalIndexCounter = SgOmpNumThreadsClause_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 519 ] =  globalIndexCounter; 
     globalIndexCounter = SgOmpOrderedClause_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 520 ] =  globalIndexCounter; 
     globalIndexCounter = SgOmpPrivateClause_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 521 ] =  globalIndexCounter; 
     globalIndexCounter = SgOmpReductionClause_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 522 ] =  globalIndexCounter; 
     globalIndexCounter = SgOmpScheduleClause_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 523 ] =  globalIndexCounter; 
     globalIndexCounter = SgOmpSharedClause_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 524 ] =  globalIndexCounter; 
     globalIndexCounter = SgOmpUntiedClause_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 525 ] =  globalIndexCounter; 
     globalIndexCounter = SgOmpVariablesClause_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 526 ] =  globalIndexCounter; 
     globalIndexCounter = SgOpenclAccessModeModifier_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 527 ] =  globalIndexCounter; 
     globalIndexCounter = SgOpenStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 528 ] =  globalIndexCounter; 
     globalIndexCounter = SgOptions_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 529 ] =  globalIndexCounter; 
     globalIndexCounter = SgOrOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 530 ] =  globalIndexCounter; 
     globalIndexCounter = SgParameterStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 531 ] =  globalIndexCounter; 
     globalIndexCounter = SgPartialFunctionModifierType_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 532 ] =  globalIndexCounter; 
     globalIndexCounter = SgPartialFunctionType_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 533 ] =  globalIndexCounter; 
     globalIndexCounter = SgPassStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 534 ] =  globalIndexCounter; 
     globalIndexCounter = SgPlusAssignOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 535 ] =  globalIndexCounter; 
     globalIndexCounter = SgPlusPlusOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 536 ] =  globalIndexCounter; 
     globalIndexCounter = SgPntrArrRefExp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 537 ] =  globalIndexCounter; 
     globalIndexCounter = SgPointerAssignOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 538 ] =  globalIndexCounter; 
     globalIndexCounter = SgPointerDerefExp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 539 ] =  globalIndexCounter; 
     globalIndexCounter = SgPointerMemberType_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 540 ] =  globalIndexCounter; 
     globalIndexCounter = SgPointerType_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 541 ] =  globalIndexCounter; 
     globalIndexCounter = SgPragma_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 542 ] =  globalIndexCounter; 
     globalIndexCounter = SgPragmaDeclaration_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 543 ] =  globalIndexCounter; 
     globalIndexCounter = SgPrintStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 544 ] =  globalIndexCounter; 
     globalIndexCounter = SgProcedureHeaderStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 545 ] =  globalIndexCounter; 
     globalIndexCounter = SgProgramHeaderStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 546 ] =  globalIndexCounter; 
     globalIndexCounter = SgProject_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 547 ] =  globalIndexCounter; 
     globalIndexCounter = SgPseudoDestructorRefExp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 548 ] =  globalIndexCounter; 
     globalIndexCounter = SgPythonGlobalStmt_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 549 ] =  globalIndexCounter; 
     globalIndexCounter = SgPythonPrintStmt_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 550 ] =  globalIndexCounter; 
     globalIndexCounter = SgQualifiedName_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 551 ] =  globalIndexCounter; 
     globalIndexCounter = SgQualifiedNameType_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 552 ] =  globalIndexCounter; 
     globalIndexCounter = SgReadStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 553 ] =  globalIndexCounter; 
     globalIndexCounter = SgRealPartOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 554 ] =  globalIndexCounter; 
     globalIndexCounter = SgRefExp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 555 ] =  globalIndexCounter; 
     globalIndexCounter = SgReferenceType_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 556 ] =  globalIndexCounter; 
     globalIndexCounter = SgRenamePair_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 557 ] =  globalIndexCounter; 
     globalIndexCounter = SgRenameSymbol_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 558 ] =  globalIndexCounter; 
     globalIndexCounter = SgReturnStmt_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 559 ] =  globalIndexCounter; 
     globalIndexCounter = SgRewindStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 560 ] =  globalIndexCounter; 
     globalIndexCounter = SgRshiftAssignOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 561 ] =  globalIndexCounter; 
     globalIndexCounter = SgRshiftOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 562 ] =  globalIndexCounter; 
     globalIndexCounter = SgJavaUnsignedRshiftAssignOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 563 ] =  globalIndexCounter; 
     globalIndexCounter = SgJavaUnsignedRshiftOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 564 ] =  globalIndexCounter; 
     globalIndexCounter = SgScopeOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 565 ] =  globalIndexCounter; 
     globalIndexCounter = SgScopeStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 566 ] =  globalIndexCounter; 
     globalIndexCounter = SgSequenceStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 567 ] =  globalIndexCounter; 
     globalIndexCounter = SgSetComprehension_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 568 ] =  globalIndexCounter; 
     globalIndexCounter = SgShortVal_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 569 ] =  globalIndexCounter; 
     globalIndexCounter = SgSizeOfOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 570 ] =  globalIndexCounter; 
     globalIndexCounter = SgJavaInstanceOfOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 571 ] =  globalIndexCounter; 
     globalIndexCounter = SgSourceFile_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 572 ] =  globalIndexCounter; 
     globalIndexCounter = SgSpawnStmt_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 573 ] =  globalIndexCounter; 
     globalIndexCounter = SgJavaThrowStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 574 ] =  globalIndexCounter; 
     globalIndexCounter = SgJavaForEachStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 575 ] =  globalIndexCounter; 
     globalIndexCounter = SgJavaSynchronizedStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 576 ] =  globalIndexCounter; 
     globalIndexCounter = SgJavaParameterizedType_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 577 ] =  globalIndexCounter; 
     globalIndexCounter = SgSpecialFunctionModifier_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 578 ] =  globalIndexCounter; 
     globalIndexCounter = SgStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 579 ] =  globalIndexCounter; 
     globalIndexCounter = SgStmtDeclarationStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 580 ] =  globalIndexCounter; 
     globalIndexCounter = SgStatementExpression_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 581 ] =  globalIndexCounter; 
     globalIndexCounter = SgStatementFunctionStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 582 ] =  globalIndexCounter; 
     globalIndexCounter = SgStopOrPauseStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 583 ] =  globalIndexCounter; 
     globalIndexCounter = SgStorageModifier_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 584 ] =  globalIndexCounter; 
     globalIndexCounter = SgStringConversion_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 585 ] =  globalIndexCounter; 
     globalIndexCounter = SgStringKeyedBidirectionalGraph_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 586 ] =  globalIndexCounter; 
     globalIndexCounter = SgStringVal_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 587 ] =  globalIndexCounter; 
     globalIndexCounter = SgSubscriptExpression_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 588 ] =  globalIndexCounter; 
     globalIndexCounter = SgSubtractOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 589 ] =  globalIndexCounter; 
     globalIndexCounter = SgSupport_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 590 ] =  globalIndexCounter; 
     globalIndexCounter = SgSwitchStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 591 ] =  globalIndexCounter; 
     globalIndexCounter = SgSymbol_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 592 ] =  globalIndexCounter; 
     globalIndexCounter = SgSymbolTable_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 593 ] =  globalIndexCounter; 
     globalIndexCounter = SgTemplateArgument_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 594 ] =  globalIndexCounter; 
     globalIndexCounter = SgTemplateArgumentList_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 595 ] =  globalIndexCounter; 
     globalIndexCounter = SgTemplateDeclaration_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 596 ] =  globalIndexCounter; 
     globalIndexCounter = SgTemplateClassDeclaration_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 597 ] =  globalIndexCounter; 
     globalIndexCounter = SgTemplateFunctionDeclaration_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 598 ] =  globalIndexCounter; 
     globalIndexCounter = SgTemplateMemberFunctionDeclaration_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 599 ] =  globalIndexCounter; 
     globalIndexCounter = SgTemplateClassDefinition_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 600 ] =  globalIndexCounter; 
     globalIndexCounter = SgTemplateFunctionDefinition_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 601 ] =  globalIndexCounter; 
     globalIndexCounter = SgTemplateInstantiationDecl_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 602 ] =  globalIndexCounter; 
     globalIndexCounter = SgTemplateInstantiationDefn_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 603 ] =  globalIndexCounter; 
     globalIndexCounter = SgTemplateInstantiationDirectiveStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 604 ] =  globalIndexCounter; 
     globalIndexCounter = SgTemplateInstantiationFunctionDecl_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 605 ] =  globalIndexCounter; 
     globalIndexCounter = SgTemplateInstantiationMemberFunctionDecl_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 606 ] =  globalIndexCounter; 
     globalIndexCounter = SgTemplateParameter_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 607 ] =  globalIndexCounter; 
     globalIndexCounter = SgTemplateParameterList_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 608 ] =  globalIndexCounter; 
     globalIndexCounter = SgTemplateSymbol_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 609 ] =  globalIndexCounter; 
     globalIndexCounter = SgTemplateType_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 610 ] =  globalIndexCounter; 
     globalIndexCounter = SgThisExp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 611 ] =  globalIndexCounter; 
     globalIndexCounter = SgSuperExp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 612 ] =  globalIndexCounter; 
     globalIndexCounter = SgThrowOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 613 ] =  globalIndexCounter; 
     globalIndexCounter = SgToken_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 614 ] =  globalIndexCounter; 
     globalIndexCounter = SgTryStmt_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 615 ] =  globalIndexCounter; 
     globalIndexCounter = SgTupleExp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 616 ] =  globalIndexCounter; 
     globalIndexCounter = SgType_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 617 ] =  globalIndexCounter; 
     globalIndexCounter = SgTypeBool_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 618 ] =  globalIndexCounter; 
     globalIndexCounter = SgTypeChar_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 619 ] =  globalIndexCounter; 
     globalIndexCounter = SgTypeComplex_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 620 ] =  globalIndexCounter; 
     globalIndexCounter = SgTypeDefault_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 621 ] =  globalIndexCounter; 
     globalIndexCounter = SgTypeLabel_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 622 ] =  globalIndexCounter; 
     globalIndexCounter = SgTypeDouble_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 623 ] =  globalIndexCounter; 
     globalIndexCounter = SgTypeEllipse_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 624 ] =  globalIndexCounter; 
     globalIndexCounter = SgTypeFloat_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 625 ] =  globalIndexCounter; 
     globalIndexCounter = SgTypeGlobalVoid_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 626 ] =  globalIndexCounter; 
     globalIndexCounter = SgTypeIdOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 627 ] =  globalIndexCounter; 
     globalIndexCounter = SgTypeImaginary_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 628 ] =  globalIndexCounter; 
     globalIndexCounter = SgTypeInt_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 629 ] =  globalIndexCounter; 
     globalIndexCounter = SgTypeLong_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 630 ] =  globalIndexCounter; 
     globalIndexCounter = SgTypeLongDouble_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 631 ] =  globalIndexCounter; 
     globalIndexCounter = SgTypeLongLong_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 632 ] =  globalIndexCounter; 
     globalIndexCounter = SgTypeModifier_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 633 ] =  globalIndexCounter; 
     globalIndexCounter = SgTypeShort_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 634 ] =  globalIndexCounter; 
     globalIndexCounter = SgTypeSignedChar_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 635 ] =  globalIndexCounter; 
     globalIndexCounter = SgTypeSignedInt_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 636 ] =  globalIndexCounter; 
     globalIndexCounter = SgTypeSignedLong_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 637 ] =  globalIndexCounter; 
     globalIndexCounter = SgTypeSignedLongLong_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 638 ] =  globalIndexCounter; 
     globalIndexCounter = SgTypeSignedShort_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 639 ] =  globalIndexCounter; 
     globalIndexCounter = SgTypeString_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 640 ] =  globalIndexCounter; 
     globalIndexCounter = SgTypeUnknown_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 641 ] =  globalIndexCounter; 
     globalIndexCounter = SgTypeUnsignedChar_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 642 ] =  globalIndexCounter; 
     globalIndexCounter = SgTypeUnsignedInt_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 643 ] =  globalIndexCounter; 
     globalIndexCounter = SgTypeUnsignedLong_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 644 ] =  globalIndexCounter; 
     globalIndexCounter = SgTypeUnsignedLongLong_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 645 ] =  globalIndexCounter; 
     globalIndexCounter = SgTypeUnsignedShort_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 646 ] =  globalIndexCounter; 
     globalIndexCounter = SgTypeVoid_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 647 ] =  globalIndexCounter; 
     globalIndexCounter = SgTypeWchar_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 648 ] =  globalIndexCounter; 
     globalIndexCounter = SgTypedefDeclaration_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 649 ] =  globalIndexCounter; 
     globalIndexCounter = SgTypedefSeq_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 650 ] =  globalIndexCounter; 
     globalIndexCounter = SgTypedefSymbol_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 651 ] =  globalIndexCounter; 
     globalIndexCounter = SgTypedefType_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 652 ] =  globalIndexCounter; 
     globalIndexCounter = SgUPC_AccessModifier_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 653 ] =  globalIndexCounter; 
     globalIndexCounter = SgUnaryAddOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 654 ] =  globalIndexCounter; 
     globalIndexCounter = SgUnaryOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 655 ] =  globalIndexCounter; 
     globalIndexCounter = SgUndefDirectiveStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 656 ] =  globalIndexCounter; 
     globalIndexCounter = SgUndirectedGraphEdge_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 657 ] =  globalIndexCounter; 
     globalIndexCounter = SgUnknownArrayOrFunctionReference_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 658 ] =  globalIndexCounter; 
     globalIndexCounter = SgUnknownFile_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 659 ] =  globalIndexCounter; 
     listOfMemoryPoolSizes [ 660 ] =  globalIndexCounter; 
     globalIndexCounter = SgUnparse_Info_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 661 ] =  globalIndexCounter; 
     globalIndexCounter = SgUnsignedCharVal_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 662 ] =  globalIndexCounter; 
     globalIndexCounter = SgUnsignedIntVal_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 663 ] =  globalIndexCounter; 
     globalIndexCounter = SgUnsignedLongLongIntVal_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 664 ] =  globalIndexCounter; 
     globalIndexCounter = SgUnsignedLongVal_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 665 ] =  globalIndexCounter; 
     globalIndexCounter = SgUnsignedShortVal_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 666 ] =  globalIndexCounter; 
     globalIndexCounter = SgUpcBarrierStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 667 ] =  globalIndexCounter; 
     globalIndexCounter = SgUpcBlocksizeofExpression_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 668 ] =  globalIndexCounter; 
     globalIndexCounter = SgUpcElemsizeofExpression_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 669 ] =  globalIndexCounter; 
     globalIndexCounter = SgUpcFenceStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 670 ] =  globalIndexCounter; 
     globalIndexCounter = SgUpcForAllStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 671 ] =  globalIndexCounter; 
     globalIndexCounter = SgUpcLocalsizeofExpression_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 672 ] =  globalIndexCounter; 
     globalIndexCounter = SgUpcMythread_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 673 ] =  globalIndexCounter; 
     globalIndexCounter = SgUpcNotifyStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 674 ] =  globalIndexCounter; 
     globalIndexCounter = SgUpcThreads_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 675 ] =  globalIndexCounter; 
     globalIndexCounter = SgUpcWaitStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 676 ] =  globalIndexCounter; 
     globalIndexCounter = SgUseStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 677 ] =  globalIndexCounter; 
     globalIndexCounter = SgUserDefinedBinaryOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 678 ] =  globalIndexCounter; 
     globalIndexCounter = SgUserDefinedUnaryOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 679 ] =  globalIndexCounter; 
     globalIndexCounter = SgUsingDeclarationStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 680 ] =  globalIndexCounter; 
     globalIndexCounter = SgUsingDirectiveStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 681 ] =  globalIndexCounter; 
     globalIndexCounter = SgValueExp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 682 ] =  globalIndexCounter; 
     globalIndexCounter = SgVarArgCopyOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 683 ] =  globalIndexCounter; 
     globalIndexCounter = SgVarArgEndOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 684 ] =  globalIndexCounter; 
     globalIndexCounter = SgVarArgOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 685 ] =  globalIndexCounter; 
     globalIndexCounter = SgVarArgStartOneOperandOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 686 ] =  globalIndexCounter; 
     globalIndexCounter = SgVarArgStartOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 687 ] =  globalIndexCounter; 
     globalIndexCounter = SgVarRefExp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 688 ] =  globalIndexCounter; 
     globalIndexCounter = SgVariableDeclaration_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 689 ] =  globalIndexCounter; 
     globalIndexCounter = SgVariableDefinition_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 690 ] =  globalIndexCounter; 
     globalIndexCounter = SgVariableSymbol_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 691 ] =  globalIndexCounter; 
     globalIndexCounter = SgVariantExpression_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 692 ] =  globalIndexCounter; 
     globalIndexCounter = SgVariantStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 693 ] =  globalIndexCounter; 
     globalIndexCounter = SgWaitStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 694 ] =  globalIndexCounter; 
     globalIndexCounter = SgWarningDirectiveStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 695 ] =  globalIndexCounter; 
     globalIndexCounter = SgWithStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 696 ] =  globalIndexCounter; 
     globalIndexCounter = SgWcharVal_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 697 ] =  globalIndexCounter; 
     globalIndexCounter = SgWhereStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 698 ] =  globalIndexCounter; 
     globalIndexCounter = SgWhileStmt_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 699 ] =  globalIndexCounter; 
     globalIndexCounter = SgWriteStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 700 ] =  globalIndexCounter; 
     globalIndexCounter = SgXorAssignOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 701 ] =  globalIndexCounter; 
     globalIndexCounter = SgYieldExpression_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 702 ] =  globalIndexCounter; 
     globalIndexCounter = Sg_File_Info_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 703 ] =  globalIndexCounter; 
     globalIndexCounter = SgTypeCAFTeam_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 704 ] =  globalIndexCounter; 
     globalIndexCounter = SgCAFWithTeamStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 705 ] =  globalIndexCounter; 
     globalIndexCounter = SgCAFCoExpression_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 706 ] =  globalIndexCounter; 
     globalIndexCounter = SgCallExpression_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 707 ] =  globalIndexCounter; 
     globalIndexCounter = SgTypeCrayPointer_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 708 ] =  globalIndexCounter; 
     globalIndexCounter = SgJavaImportStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer ( globalIndexCounter ) ; 
     listOfMemoryPoolSizes [ 709 ] =  globalIndexCounter; 
     listOfMemoryPoolSizes [ 710 ] =  globalIndexCounter; 

/* #line 95 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarAST_FileIoSource.code" */

     {
  // DQ (4/22/2006): Added timer information for AST File I/O
     TimingPerformance nested_timer ("AST_FILE_IO::startUp() Build contiguious storage:");

     actualRebuildAst = new AstData(root);
     vectorOfASTs.push_back( actualRebuildAst );

     actualRebuildAst->listOfAccumulatedPoolSizes[0] = listOfMemoryPoolSizes[0];
     for (int i = 0; i < totalNumberOfIRNodes ; ++i )
        {
          actualRebuildAst->listOfAccumulatedPoolSizes[i+1] = listOfMemoryPoolSizes[i+1];
          listOfMemoryPoolSizes[i] = actualRebuildAst->listOfAccumulatedPoolSizes[i+1] - actualRebuildAst->listOfAccumulatedPoolSizes[i];
        }
     
     freepointersOfCurrentAstAreSetToGlobalIndices = true;
    
     REGISTER_ATTRIBUTE_FOR_FILE_IO(AstAttribute) ;
     }

   }


unsigned long
AST_FILE_IO :: getSizeOfMemoryPool( const int position )
   {
   /* JH (01/03/2006): method returns the accumulated pool sizes of the pools that are
      previous to V_position -> i.e. the SgVariant of an IRNode class
   */
      return listOfMemoryPoolSizes [ position ];
   }


unsigned long
AST_FILE_IO :: getSizeOfMemoryPoolUpToAst( AstData *astInPool, const int position )
   {
   /* JH (01/03/2006): method returns the accumulated pool sizes of the pools that are
      previous to V_position -> i.e. the SgVariant of an IRNode class
   */
      unsigned long memoryPoolSize = 0;
      for (int i=0;i < astInPool->get_AstIndex(); ++i)
          {
            memoryPoolSize += vectorOfASTs[i]->getMemoryPoolSize(position);
          }
      return memoryPoolSize;
   }

unsigned long
AST_FILE_IO :: getAccumulatedPoolSizeOfNewAst( const int position )
   {
   /* JH (01/03/2006): method returns the accumulated pool sizes of the pools that are
      previous to V_position -> i.e. the SgVariant of an IRNode class
   */
      return actualRebuildAst->getNumberOfAccumulatedNodes ( position ) ;
   }


unsigned long
AST_FILE_IO :: getAccumulatedPoolSizeOfAst( AstData *astInPool, const int position )
   {
   /* JH (01/03/2006): method returns the accumulated pool sizes of the pools that are
      previous to V_position -> i.e. the SgVariant of an IRNode class
   */
      return astInPool->getNumberOfAccumulatedNodes ( position ) ;
   }


unsigned long
AST_FILE_IO :: getPoolSizeOfNewAst( const int position )
   {
   /* JH (01/03/2006): method returns the accumulated pool sizes of the pools that are
      previous to V_position -> i.e. the SgVariant of an IRNode class
   */
      return actualRebuildAst->getMemoryPoolSize ( position ) ;
   }


unsigned long 
AST_FILE_IO :: getTotalNumberOfNodesOfAstInMemoryPool ( )
   {
   // JH (01/03/2006): returning the sum of all pool sizes; this is used for checking only ...
      return listOfMemoryPoolSizes [ totalNumberOfIRNodes ] ; 
   }


unsigned long 
AST_FILE_IO :: getTotalNumberOfNodesOfNewAst ( )
   {
   // JH (01/03/2006): returning the sum of all pool sizes; this is used for checking only ...
      assert (actualRebuildAst != NULL);
      return actualRebuildAst->getTotalNumberOfASTIRNodes();
   }



unsigned long 
AST_FILE_IO :: linearSearch( unsigned long globalIndex ) 
   {
   /* JH (01/03/2006): linearSearch. This easy implementation just looks at the first index, where the
      getAccumulated pool sizes exceed index.
   */
#if FILE_IO_EXTRA_CHECK 
      // assert ( 0 <= globalIndex ) ;
      assert ( globalIndex < actualRebuildAst->getTotalNumberOfASTIRNodes() ) ;
#endif
      unsigned int actualIRNodeType = 1;
      while ( actualIRNodeType  < actualRebuildAst->getTotalNumberOfASTIRNodes() )
         {
           if ( actualRebuildAst->getNumberOfAccumulatedNodes (actualIRNodeType) <= globalIndex && globalIndex < actualRebuildAst->getNumberOfAccumulatedNodes (actualIRNodeType + 1 ) ) 
              { 
                break ; 
              }
         } 
#if FILE_IO_EXTRA_CHECK
      assert ( 0 < actualIRNodeType ) ;
      assert ( actualIRNodeType < actualRebuildAst->getTotalNumberOfASTIRNodes() ) ;
#endif
      return actualIRNodeType;
   }

                                                                                                                                                                                                                          
                                                                                                                                                                                                                          
unsigned long 
AST_FILE_IO :: binarySearch( unsigned long globalIndex, int start , int end )
   {
   /* JH (01/03/2006): binarySearch: find the SgVariant that corresponds to the index contained in
      the pointer. Therefore, we use the accumulatedPoolSizesOfNewAst and check the ranges
   */
      if ( end - start <= 1 )
         {
           if ( actualRebuildAst->getNumberOfAccumulatedNodes (start) <= globalIndex && globalIndex < actualRebuildAst->getNumberOfAccumulatedNodes (end) ) 
              {
                return start; 
              }
           else
              {
                return end;
              }
         }
      int middle = ( end + start ) / 2 ;
      if (  actualRebuildAst->getNumberOfAccumulatedNodes (middle ) <= globalIndex )
         {
           return binarySearch ( globalIndex , middle , end ) ;
         }
      else
         {
           return binarySearch ( globalIndex, start , middle ) ;
         }
   }

void
AST_FILE_IO :: compressAstInMemoryPool ( ) 
   {
  // DQ (4/22/2006): Added timer information for AST File I/O
     TimingPerformance timer ("AST_FILE_IO::compressAstInMemoryPool():");
 
     assert ( freepointersOfCurrentAstAreSetToGlobalIndices == true );
     assert ( 0 < getTotalNumberOfNodesOfAstInMemoryPool() );
   /* JH (01/03/2006): prepareMemoryPoolWise: method that traverses the storage pools.
      1. For each IRNodesStorageClass the pickOutIRNodeData is called
      2. The static data of the EasyStorage classes is arranged, in order that all static data (of a type) is
         contained in one memory block
      3. For each IRNodesStorageClass the rebuildIRNode is called
      4. The static data of the EasyStorage classes is deleted
   */

      unsigned long sizeOfActualPool = 0 ; 

     AstSpecificDataManagingClassStorageClass staticTemp; 
     staticTemp.pickOutIRNodeData(actualRebuildAst); 
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAccessModifier ) ; 
     std::cout << " SgAccessModifier has size " << sizeOfActualPool << std::endl;
     SgAccessModifierStorageClass* SgAccessModifierStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAccessModifierStorageArray = new SgAccessModifierStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAccessModifier_initializeStorageClassArray (SgAccessModifierStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgActualArgumentExpression ) ; 
     std::cout << " SgActualArgumentExpression has size " << sizeOfActualPool << std::endl;
     SgActualArgumentExpressionStorageClass* SgActualArgumentExpressionStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgActualArgumentExpressionStorageArray = new SgActualArgumentExpressionStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgActualArgumentExpression_initializeStorageClassArray (SgActualArgumentExpressionStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAddOp ) ; 
     std::cout << " SgAddOp has size " << sizeOfActualPool << std::endl;
     SgAddOpStorageClass* SgAddOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAddOpStorageArray = new SgAddOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAddOp_initializeStorageClassArray (SgAddOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAddressOfOp ) ; 
     std::cout << " SgAddressOfOp has size " << sizeOfActualPool << std::endl;
     SgAddressOfOpStorageClass* SgAddressOfOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAddressOfOpStorageArray = new SgAddressOfOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAddressOfOp_initializeStorageClassArray (SgAddressOfOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAggregateInitializer ) ; 
     std::cout << " SgAggregateInitializer has size " << sizeOfActualPool << std::endl;
     SgAggregateInitializerStorageClass* SgAggregateInitializerStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAggregateInitializerStorageArray = new SgAggregateInitializerStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAggregateInitializer_initializeStorageClassArray (SgAggregateInitializerStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAliasSymbol ) ; 
     std::cout << " SgAliasSymbol has size " << sizeOfActualPool << std::endl;
     SgAliasSymbolStorageClass* SgAliasSymbolStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAliasSymbolStorageArray = new SgAliasSymbolStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAliasSymbol_initializeStorageClassArray (SgAliasSymbolStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAllocateStatement ) ; 
     std::cout << " SgAllocateStatement has size " << sizeOfActualPool << std::endl;
     SgAllocateStatementStorageClass* SgAllocateStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAllocateStatementStorageArray = new SgAllocateStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAllocateStatement_initializeStorageClassArray (SgAllocateStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAndAssignOp ) ; 
     std::cout << " SgAndAssignOp has size " << sizeOfActualPool << std::endl;
     SgAndAssignOpStorageClass* SgAndAssignOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAndAssignOpStorageArray = new SgAndAssignOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAndAssignOp_initializeStorageClassArray (SgAndAssignOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAndOp ) ; 
     std::cout << " SgAndOp has size " << sizeOfActualPool << std::endl;
     SgAndOpStorageClass* SgAndOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAndOpStorageArray = new SgAndOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAndOp_initializeStorageClassArray (SgAndOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgArithmeticIfStatement ) ; 
     std::cout << " SgArithmeticIfStatement has size " << sizeOfActualPool << std::endl;
     SgArithmeticIfStatementStorageClass* SgArithmeticIfStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgArithmeticIfStatementStorageArray = new SgArithmeticIfStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgArithmeticIfStatement_initializeStorageClassArray (SgArithmeticIfStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgArrayType ) ; 
     std::cout << " SgArrayType has size " << sizeOfActualPool << std::endl;
     SgArrayTypeStorageClass* SgArrayTypeStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgArrayTypeStorageArray = new SgArrayTypeStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgArrayType_initializeStorageClassArray (SgArrayTypeStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgArrowExp ) ; 
     std::cout << " SgArrowExp has size " << sizeOfActualPool << std::endl;
     SgArrowExpStorageClass* SgArrowExpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgArrowExpStorageArray = new SgArrowExpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgArrowExp_initializeStorageClassArray (SgArrowExpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgArrowStarOp ) ; 
     std::cout << " SgArrowStarOp has size " << sizeOfActualPool << std::endl;
     SgArrowStarOpStorageClass* SgArrowStarOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgArrowStarOpStorageArray = new SgArrowStarOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgArrowStarOp_initializeStorageClassArray (SgArrowStarOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmArmInstruction ) ; 
     std::cout << " SgAsmArmInstruction has size " << sizeOfActualPool << std::endl;
     SgAsmArmInstructionStorageClass* SgAsmArmInstructionStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmArmInstructionStorageArray = new SgAsmArmInstructionStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmArmInstruction_initializeStorageClassArray (SgAsmArmInstructionStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmArmRegisterReferenceExpression ) ; 
     std::cout << " SgAsmArmRegisterReferenceExpression has size " << sizeOfActualPool << std::endl;
     SgAsmArmRegisterReferenceExpressionStorageClass* SgAsmArmRegisterReferenceExpressionStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmArmRegisterReferenceExpressionStorageArray = new SgAsmArmRegisterReferenceExpressionStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmArmRegisterReferenceExpression_initializeStorageClassArray (SgAsmArmRegisterReferenceExpressionStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmBasicString ) ; 
     std::cout << " SgAsmBasicString has size " << sizeOfActualPool << std::endl;
     SgAsmBasicStringStorageClass* SgAsmBasicStringStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmBasicStringStorageArray = new SgAsmBasicStringStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmBasicString_initializeStorageClassArray (SgAsmBasicStringStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmBinaryAdd ) ; 
     std::cout << " SgAsmBinaryAdd has size " << sizeOfActualPool << std::endl;
     SgAsmBinaryAddStorageClass* SgAsmBinaryAddStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmBinaryAddStorageArray = new SgAsmBinaryAddStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmBinaryAdd_initializeStorageClassArray (SgAsmBinaryAddStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmBinaryAddPostupdate ) ; 
     std::cout << " SgAsmBinaryAddPostupdate has size " << sizeOfActualPool << std::endl;
     SgAsmBinaryAddPostupdateStorageClass* SgAsmBinaryAddPostupdateStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmBinaryAddPostupdateStorageArray = new SgAsmBinaryAddPostupdateStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmBinaryAddPostupdate_initializeStorageClassArray (SgAsmBinaryAddPostupdateStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmBinaryAddPreupdate ) ; 
     std::cout << " SgAsmBinaryAddPreupdate has size " << sizeOfActualPool << std::endl;
     SgAsmBinaryAddPreupdateStorageClass* SgAsmBinaryAddPreupdateStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmBinaryAddPreupdateStorageArray = new SgAsmBinaryAddPreupdateStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmBinaryAddPreupdate_initializeStorageClassArray (SgAsmBinaryAddPreupdateStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmBinaryAsr ) ; 
     std::cout << " SgAsmBinaryAsr has size " << sizeOfActualPool << std::endl;
     SgAsmBinaryAsrStorageClass* SgAsmBinaryAsrStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmBinaryAsrStorageArray = new SgAsmBinaryAsrStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmBinaryAsr_initializeStorageClassArray (SgAsmBinaryAsrStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmBinaryDivide ) ; 
     std::cout << " SgAsmBinaryDivide has size " << sizeOfActualPool << std::endl;
     SgAsmBinaryDivideStorageClass* SgAsmBinaryDivideStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmBinaryDivideStorageArray = new SgAsmBinaryDivideStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmBinaryDivide_initializeStorageClassArray (SgAsmBinaryDivideStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmBinaryExpression ) ; 
     std::cout << " SgAsmBinaryExpression has size " << sizeOfActualPool << std::endl;
     SgAsmBinaryExpressionStorageClass* SgAsmBinaryExpressionStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmBinaryExpressionStorageArray = new SgAsmBinaryExpressionStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmBinaryExpression_initializeStorageClassArray (SgAsmBinaryExpressionStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmBinaryLsl ) ; 
     std::cout << " SgAsmBinaryLsl has size " << sizeOfActualPool << std::endl;
     SgAsmBinaryLslStorageClass* SgAsmBinaryLslStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmBinaryLslStorageArray = new SgAsmBinaryLslStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmBinaryLsl_initializeStorageClassArray (SgAsmBinaryLslStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmBinaryLsr ) ; 
     std::cout << " SgAsmBinaryLsr has size " << sizeOfActualPool << std::endl;
     SgAsmBinaryLsrStorageClass* SgAsmBinaryLsrStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmBinaryLsrStorageArray = new SgAsmBinaryLsrStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmBinaryLsr_initializeStorageClassArray (SgAsmBinaryLsrStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmBinaryMod ) ; 
     std::cout << " SgAsmBinaryMod has size " << sizeOfActualPool << std::endl;
     SgAsmBinaryModStorageClass* SgAsmBinaryModStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmBinaryModStorageArray = new SgAsmBinaryModStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmBinaryMod_initializeStorageClassArray (SgAsmBinaryModStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmBinaryMultiply ) ; 
     std::cout << " SgAsmBinaryMultiply has size " << sizeOfActualPool << std::endl;
     SgAsmBinaryMultiplyStorageClass* SgAsmBinaryMultiplyStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmBinaryMultiplyStorageArray = new SgAsmBinaryMultiplyStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmBinaryMultiply_initializeStorageClassArray (SgAsmBinaryMultiplyStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmBinaryRor ) ; 
     std::cout << " SgAsmBinaryRor has size " << sizeOfActualPool << std::endl;
     SgAsmBinaryRorStorageClass* SgAsmBinaryRorStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmBinaryRorStorageArray = new SgAsmBinaryRorStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmBinaryRor_initializeStorageClassArray (SgAsmBinaryRorStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmBinarySubtract ) ; 
     std::cout << " SgAsmBinarySubtract has size " << sizeOfActualPool << std::endl;
     SgAsmBinarySubtractStorageClass* SgAsmBinarySubtractStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmBinarySubtractStorageArray = new SgAsmBinarySubtractStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmBinarySubtract_initializeStorageClassArray (SgAsmBinarySubtractStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmBinarySubtractPostupdate ) ; 
     std::cout << " SgAsmBinarySubtractPostupdate has size " << sizeOfActualPool << std::endl;
     SgAsmBinarySubtractPostupdateStorageClass* SgAsmBinarySubtractPostupdateStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmBinarySubtractPostupdateStorageArray = new SgAsmBinarySubtractPostupdateStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmBinarySubtractPostupdate_initializeStorageClassArray (SgAsmBinarySubtractPostupdateStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmBinarySubtractPreupdate ) ; 
     std::cout << " SgAsmBinarySubtractPreupdate has size " << sizeOfActualPool << std::endl;
     SgAsmBinarySubtractPreupdateStorageClass* SgAsmBinarySubtractPreupdateStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmBinarySubtractPreupdateStorageArray = new SgAsmBinarySubtractPreupdateStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmBinarySubtractPreupdate_initializeStorageClassArray (SgAsmBinarySubtractPreupdateStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmBlock ) ; 
     std::cout << " SgAsmBlock has size " << sizeOfActualPool << std::endl;
     SgAsmBlockStorageClass* SgAsmBlockStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmBlockStorageArray = new SgAsmBlockStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmBlock_initializeStorageClassArray (SgAsmBlockStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmByteValueExpression ) ; 
     std::cout << " SgAsmByteValueExpression has size " << sizeOfActualPool << std::endl;
     SgAsmByteValueExpressionStorageClass* SgAsmByteValueExpressionStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmByteValueExpressionStorageArray = new SgAsmByteValueExpressionStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmByteValueExpression_initializeStorageClassArray (SgAsmByteValueExpressionStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmCoffStrtab ) ; 
     std::cout << " SgAsmCoffStrtab has size " << sizeOfActualPool << std::endl;
     SgAsmCoffStrtabStorageClass* SgAsmCoffStrtabStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCoffStrtabStorageArray = new SgAsmCoffStrtabStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmCoffStrtab_initializeStorageClassArray (SgAsmCoffStrtabStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmCoffSymbol ) ; 
     std::cout << " SgAsmCoffSymbol has size " << sizeOfActualPool << std::endl;
     SgAsmCoffSymbolStorageClass* SgAsmCoffSymbolStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCoffSymbolStorageArray = new SgAsmCoffSymbolStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmCoffSymbol_initializeStorageClassArray (SgAsmCoffSymbolStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmCoffSymbolList ) ; 
     std::cout << " SgAsmCoffSymbolList has size " << sizeOfActualPool << std::endl;
     SgAsmCoffSymbolListStorageClass* SgAsmCoffSymbolListStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCoffSymbolListStorageArray = new SgAsmCoffSymbolListStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmCoffSymbolList_initializeStorageClassArray (SgAsmCoffSymbolListStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmCoffSymbolTable ) ; 
     std::cout << " SgAsmCoffSymbolTable has size " << sizeOfActualPool << std::endl;
     SgAsmCoffSymbolTableStorageClass* SgAsmCoffSymbolTableStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCoffSymbolTableStorageArray = new SgAsmCoffSymbolTableStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmCoffSymbolTable_initializeStorageClassArray (SgAsmCoffSymbolTableStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmCommonSubExpression ) ; 
     std::cout << " SgAsmCommonSubExpression has size " << sizeOfActualPool << std::endl;
     SgAsmCommonSubExpressionStorageClass* SgAsmCommonSubExpressionStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCommonSubExpressionStorageArray = new SgAsmCommonSubExpressionStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmCommonSubExpression_initializeStorageClassArray (SgAsmCommonSubExpressionStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmControlFlagsExpression ) ; 
     std::cout << " SgAsmControlFlagsExpression has size " << sizeOfActualPool << std::endl;
     SgAsmControlFlagsExpressionStorageClass* SgAsmControlFlagsExpressionStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmControlFlagsExpressionStorageArray = new SgAsmControlFlagsExpressionStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmControlFlagsExpression_initializeStorageClassArray (SgAsmControlFlagsExpressionStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDOSExtendedHeader ) ; 
     std::cout << " SgAsmDOSExtendedHeader has size " << sizeOfActualPool << std::endl;
     SgAsmDOSExtendedHeaderStorageClass* SgAsmDOSExtendedHeaderStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDOSExtendedHeaderStorageArray = new SgAsmDOSExtendedHeaderStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDOSExtendedHeader_initializeStorageClassArray (SgAsmDOSExtendedHeaderStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDOSFileHeader ) ; 
     std::cout << " SgAsmDOSFileHeader has size " << sizeOfActualPool << std::endl;
     SgAsmDOSFileHeaderStorageClass* SgAsmDOSFileHeaderStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDOSFileHeaderStorageArray = new SgAsmDOSFileHeaderStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDOSFileHeader_initializeStorageClassArray (SgAsmDOSFileHeaderStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDoubleFloatValueExpression ) ; 
     std::cout << " SgAsmDoubleFloatValueExpression has size " << sizeOfActualPool << std::endl;
     SgAsmDoubleFloatValueExpressionStorageClass* SgAsmDoubleFloatValueExpressionStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDoubleFloatValueExpressionStorageArray = new SgAsmDoubleFloatValueExpressionStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDoubleFloatValueExpression_initializeStorageClassArray (SgAsmDoubleFloatValueExpressionStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDoubleWordValueExpression ) ; 
     std::cout << " SgAsmDoubleWordValueExpression has size " << sizeOfActualPool << std::endl;
     SgAsmDoubleWordValueExpressionStorageClass* SgAsmDoubleWordValueExpressionStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDoubleWordValueExpressionStorageArray = new SgAsmDoubleWordValueExpressionStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDoubleWordValueExpression_initializeStorageClassArray (SgAsmDoubleWordValueExpressionStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDwarfAccessDeclaration ) ; 
     std::cout << " SgAsmDwarfAccessDeclaration has size " << sizeOfActualPool << std::endl;
     SgAsmDwarfAccessDeclarationStorageClass* SgAsmDwarfAccessDeclarationStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfAccessDeclarationStorageArray = new SgAsmDwarfAccessDeclarationStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDwarfAccessDeclaration_initializeStorageClassArray (SgAsmDwarfAccessDeclarationStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDwarfArrayType ) ; 
     std::cout << " SgAsmDwarfArrayType has size " << sizeOfActualPool << std::endl;
     SgAsmDwarfArrayTypeStorageClass* SgAsmDwarfArrayTypeStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfArrayTypeStorageArray = new SgAsmDwarfArrayTypeStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDwarfArrayType_initializeStorageClassArray (SgAsmDwarfArrayTypeStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDwarfBaseType ) ; 
     std::cout << " SgAsmDwarfBaseType has size " << sizeOfActualPool << std::endl;
     SgAsmDwarfBaseTypeStorageClass* SgAsmDwarfBaseTypeStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfBaseTypeStorageArray = new SgAsmDwarfBaseTypeStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDwarfBaseType_initializeStorageClassArray (SgAsmDwarfBaseTypeStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDwarfCatchBlock ) ; 
     std::cout << " SgAsmDwarfCatchBlock has size " << sizeOfActualPool << std::endl;
     SgAsmDwarfCatchBlockStorageClass* SgAsmDwarfCatchBlockStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfCatchBlockStorageArray = new SgAsmDwarfCatchBlockStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDwarfCatchBlock_initializeStorageClassArray (SgAsmDwarfCatchBlockStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDwarfClassTemplate ) ; 
     std::cout << " SgAsmDwarfClassTemplate has size " << sizeOfActualPool << std::endl;
     SgAsmDwarfClassTemplateStorageClass* SgAsmDwarfClassTemplateStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfClassTemplateStorageArray = new SgAsmDwarfClassTemplateStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDwarfClassTemplate_initializeStorageClassArray (SgAsmDwarfClassTemplateStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDwarfClassType ) ; 
     std::cout << " SgAsmDwarfClassType has size " << sizeOfActualPool << std::endl;
     SgAsmDwarfClassTypeStorageClass* SgAsmDwarfClassTypeStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfClassTypeStorageArray = new SgAsmDwarfClassTypeStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDwarfClassType_initializeStorageClassArray (SgAsmDwarfClassTypeStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDwarfCommonBlock ) ; 
     std::cout << " SgAsmDwarfCommonBlock has size " << sizeOfActualPool << std::endl;
     SgAsmDwarfCommonBlockStorageClass* SgAsmDwarfCommonBlockStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfCommonBlockStorageArray = new SgAsmDwarfCommonBlockStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDwarfCommonBlock_initializeStorageClassArray (SgAsmDwarfCommonBlockStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDwarfCommonInclusion ) ; 
     std::cout << " SgAsmDwarfCommonInclusion has size " << sizeOfActualPool << std::endl;
     SgAsmDwarfCommonInclusionStorageClass* SgAsmDwarfCommonInclusionStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfCommonInclusionStorageArray = new SgAsmDwarfCommonInclusionStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDwarfCommonInclusion_initializeStorageClassArray (SgAsmDwarfCommonInclusionStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDwarfCompilationUnit ) ; 
     std::cout << " SgAsmDwarfCompilationUnit has size " << sizeOfActualPool << std::endl;
     SgAsmDwarfCompilationUnitStorageClass* SgAsmDwarfCompilationUnitStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfCompilationUnitStorageArray = new SgAsmDwarfCompilationUnitStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDwarfCompilationUnit_initializeStorageClassArray (SgAsmDwarfCompilationUnitStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDwarfCompilationUnitList ) ; 
     std::cout << " SgAsmDwarfCompilationUnitList has size " << sizeOfActualPool << std::endl;
     SgAsmDwarfCompilationUnitListStorageClass* SgAsmDwarfCompilationUnitListStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfCompilationUnitListStorageArray = new SgAsmDwarfCompilationUnitListStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDwarfCompilationUnitList_initializeStorageClassArray (SgAsmDwarfCompilationUnitListStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDwarfCondition ) ; 
     std::cout << " SgAsmDwarfCondition has size " << sizeOfActualPool << std::endl;
     SgAsmDwarfConditionStorageClass* SgAsmDwarfConditionStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfConditionStorageArray = new SgAsmDwarfConditionStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDwarfCondition_initializeStorageClassArray (SgAsmDwarfConditionStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDwarfConstType ) ; 
     std::cout << " SgAsmDwarfConstType has size " << sizeOfActualPool << std::endl;
     SgAsmDwarfConstTypeStorageClass* SgAsmDwarfConstTypeStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfConstTypeStorageArray = new SgAsmDwarfConstTypeStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDwarfConstType_initializeStorageClassArray (SgAsmDwarfConstTypeStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDwarfConstant ) ; 
     std::cout << " SgAsmDwarfConstant has size " << sizeOfActualPool << std::endl;
     SgAsmDwarfConstantStorageClass* SgAsmDwarfConstantStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfConstantStorageArray = new SgAsmDwarfConstantStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDwarfConstant_initializeStorageClassArray (SgAsmDwarfConstantStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDwarfConstruct ) ; 
     std::cout << " SgAsmDwarfConstruct has size " << sizeOfActualPool << std::endl;
     SgAsmDwarfConstructStorageClass* SgAsmDwarfConstructStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfConstructStorageArray = new SgAsmDwarfConstructStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDwarfConstruct_initializeStorageClassArray (SgAsmDwarfConstructStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDwarfConstructList ) ; 
     std::cout << " SgAsmDwarfConstructList has size " << sizeOfActualPool << std::endl;
     SgAsmDwarfConstructListStorageClass* SgAsmDwarfConstructListStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfConstructListStorageArray = new SgAsmDwarfConstructListStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDwarfConstructList_initializeStorageClassArray (SgAsmDwarfConstructListStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDwarfDwarfProcedure ) ; 
     std::cout << " SgAsmDwarfDwarfProcedure has size " << sizeOfActualPool << std::endl;
     SgAsmDwarfDwarfProcedureStorageClass* SgAsmDwarfDwarfProcedureStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfDwarfProcedureStorageArray = new SgAsmDwarfDwarfProcedureStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDwarfDwarfProcedure_initializeStorageClassArray (SgAsmDwarfDwarfProcedureStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDwarfEntryPoint ) ; 
     std::cout << " SgAsmDwarfEntryPoint has size " << sizeOfActualPool << std::endl;
     SgAsmDwarfEntryPointStorageClass* SgAsmDwarfEntryPointStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfEntryPointStorageArray = new SgAsmDwarfEntryPointStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDwarfEntryPoint_initializeStorageClassArray (SgAsmDwarfEntryPointStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDwarfEnumerationType ) ; 
     std::cout << " SgAsmDwarfEnumerationType has size " << sizeOfActualPool << std::endl;
     SgAsmDwarfEnumerationTypeStorageClass* SgAsmDwarfEnumerationTypeStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfEnumerationTypeStorageArray = new SgAsmDwarfEnumerationTypeStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDwarfEnumerationType_initializeStorageClassArray (SgAsmDwarfEnumerationTypeStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDwarfEnumerator ) ; 
     std::cout << " SgAsmDwarfEnumerator has size " << sizeOfActualPool << std::endl;
     SgAsmDwarfEnumeratorStorageClass* SgAsmDwarfEnumeratorStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfEnumeratorStorageArray = new SgAsmDwarfEnumeratorStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDwarfEnumerator_initializeStorageClassArray (SgAsmDwarfEnumeratorStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDwarfFileType ) ; 
     std::cout << " SgAsmDwarfFileType has size " << sizeOfActualPool << std::endl;
     SgAsmDwarfFileTypeStorageClass* SgAsmDwarfFileTypeStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfFileTypeStorageArray = new SgAsmDwarfFileTypeStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDwarfFileType_initializeStorageClassArray (SgAsmDwarfFileTypeStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDwarfFormalParameter ) ; 
     std::cout << " SgAsmDwarfFormalParameter has size " << sizeOfActualPool << std::endl;
     SgAsmDwarfFormalParameterStorageClass* SgAsmDwarfFormalParameterStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfFormalParameterStorageArray = new SgAsmDwarfFormalParameterStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDwarfFormalParameter_initializeStorageClassArray (SgAsmDwarfFormalParameterStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDwarfFormatLabel ) ; 
     std::cout << " SgAsmDwarfFormatLabel has size " << sizeOfActualPool << std::endl;
     SgAsmDwarfFormatLabelStorageClass* SgAsmDwarfFormatLabelStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfFormatLabelStorageArray = new SgAsmDwarfFormatLabelStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDwarfFormatLabel_initializeStorageClassArray (SgAsmDwarfFormatLabelStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDwarfFriend ) ; 
     std::cout << " SgAsmDwarfFriend has size " << sizeOfActualPool << std::endl;
     SgAsmDwarfFriendStorageClass* SgAsmDwarfFriendStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfFriendStorageArray = new SgAsmDwarfFriendStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDwarfFriend_initializeStorageClassArray (SgAsmDwarfFriendStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDwarfFunctionTemplate ) ; 
     std::cout << " SgAsmDwarfFunctionTemplate has size " << sizeOfActualPool << std::endl;
     SgAsmDwarfFunctionTemplateStorageClass* SgAsmDwarfFunctionTemplateStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfFunctionTemplateStorageArray = new SgAsmDwarfFunctionTemplateStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDwarfFunctionTemplate_initializeStorageClassArray (SgAsmDwarfFunctionTemplateStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDwarfImportedDeclaration ) ; 
     std::cout << " SgAsmDwarfImportedDeclaration has size " << sizeOfActualPool << std::endl;
     SgAsmDwarfImportedDeclarationStorageClass* SgAsmDwarfImportedDeclarationStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfImportedDeclarationStorageArray = new SgAsmDwarfImportedDeclarationStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDwarfImportedDeclaration_initializeStorageClassArray (SgAsmDwarfImportedDeclarationStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDwarfImportedModule ) ; 
     std::cout << " SgAsmDwarfImportedModule has size " << sizeOfActualPool << std::endl;
     SgAsmDwarfImportedModuleStorageClass* SgAsmDwarfImportedModuleStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfImportedModuleStorageArray = new SgAsmDwarfImportedModuleStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDwarfImportedModule_initializeStorageClassArray (SgAsmDwarfImportedModuleStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDwarfImportedUnit ) ; 
     std::cout << " SgAsmDwarfImportedUnit has size " << sizeOfActualPool << std::endl;
     SgAsmDwarfImportedUnitStorageClass* SgAsmDwarfImportedUnitStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfImportedUnitStorageArray = new SgAsmDwarfImportedUnitStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDwarfImportedUnit_initializeStorageClassArray (SgAsmDwarfImportedUnitStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDwarfInformation ) ; 
     std::cout << " SgAsmDwarfInformation has size " << sizeOfActualPool << std::endl;
     SgAsmDwarfInformationStorageClass* SgAsmDwarfInformationStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfInformationStorageArray = new SgAsmDwarfInformationStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDwarfInformation_initializeStorageClassArray (SgAsmDwarfInformationStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDwarfInheritance ) ; 
     std::cout << " SgAsmDwarfInheritance has size " << sizeOfActualPool << std::endl;
     SgAsmDwarfInheritanceStorageClass* SgAsmDwarfInheritanceStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfInheritanceStorageArray = new SgAsmDwarfInheritanceStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDwarfInheritance_initializeStorageClassArray (SgAsmDwarfInheritanceStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDwarfInlinedSubroutine ) ; 
     std::cout << " SgAsmDwarfInlinedSubroutine has size " << sizeOfActualPool << std::endl;
     SgAsmDwarfInlinedSubroutineStorageClass* SgAsmDwarfInlinedSubroutineStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfInlinedSubroutineStorageArray = new SgAsmDwarfInlinedSubroutineStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDwarfInlinedSubroutine_initializeStorageClassArray (SgAsmDwarfInlinedSubroutineStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDwarfInterfaceType ) ; 
     std::cout << " SgAsmDwarfInterfaceType has size " << sizeOfActualPool << std::endl;
     SgAsmDwarfInterfaceTypeStorageClass* SgAsmDwarfInterfaceTypeStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfInterfaceTypeStorageArray = new SgAsmDwarfInterfaceTypeStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDwarfInterfaceType_initializeStorageClassArray (SgAsmDwarfInterfaceTypeStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDwarfLabel ) ; 
     std::cout << " SgAsmDwarfLabel has size " << sizeOfActualPool << std::endl;
     SgAsmDwarfLabelStorageClass* SgAsmDwarfLabelStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfLabelStorageArray = new SgAsmDwarfLabelStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDwarfLabel_initializeStorageClassArray (SgAsmDwarfLabelStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDwarfLexicalBlock ) ; 
     std::cout << " SgAsmDwarfLexicalBlock has size " << sizeOfActualPool << std::endl;
     SgAsmDwarfLexicalBlockStorageClass* SgAsmDwarfLexicalBlockStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfLexicalBlockStorageArray = new SgAsmDwarfLexicalBlockStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDwarfLexicalBlock_initializeStorageClassArray (SgAsmDwarfLexicalBlockStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDwarfLine ) ; 
     std::cout << " SgAsmDwarfLine has size " << sizeOfActualPool << std::endl;
     SgAsmDwarfLineStorageClass* SgAsmDwarfLineStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfLineStorageArray = new SgAsmDwarfLineStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDwarfLine_initializeStorageClassArray (SgAsmDwarfLineStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDwarfLineList ) ; 
     std::cout << " SgAsmDwarfLineList has size " << sizeOfActualPool << std::endl;
     SgAsmDwarfLineListStorageClass* SgAsmDwarfLineListStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfLineListStorageArray = new SgAsmDwarfLineListStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDwarfLineList_initializeStorageClassArray (SgAsmDwarfLineListStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDwarfMacro ) ; 
     std::cout << " SgAsmDwarfMacro has size " << sizeOfActualPool << std::endl;
     SgAsmDwarfMacroStorageClass* SgAsmDwarfMacroStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfMacroStorageArray = new SgAsmDwarfMacroStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDwarfMacro_initializeStorageClassArray (SgAsmDwarfMacroStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDwarfMacroList ) ; 
     std::cout << " SgAsmDwarfMacroList has size " << sizeOfActualPool << std::endl;
     SgAsmDwarfMacroListStorageClass* SgAsmDwarfMacroListStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfMacroListStorageArray = new SgAsmDwarfMacroListStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDwarfMacroList_initializeStorageClassArray (SgAsmDwarfMacroListStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDwarfMember ) ; 
     std::cout << " SgAsmDwarfMember has size " << sizeOfActualPool << std::endl;
     SgAsmDwarfMemberStorageClass* SgAsmDwarfMemberStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfMemberStorageArray = new SgAsmDwarfMemberStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDwarfMember_initializeStorageClassArray (SgAsmDwarfMemberStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDwarfModule ) ; 
     std::cout << " SgAsmDwarfModule has size " << sizeOfActualPool << std::endl;
     SgAsmDwarfModuleStorageClass* SgAsmDwarfModuleStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfModuleStorageArray = new SgAsmDwarfModuleStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDwarfModule_initializeStorageClassArray (SgAsmDwarfModuleStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDwarfMutableType ) ; 
     std::cout << " SgAsmDwarfMutableType has size " << sizeOfActualPool << std::endl;
     SgAsmDwarfMutableTypeStorageClass* SgAsmDwarfMutableTypeStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfMutableTypeStorageArray = new SgAsmDwarfMutableTypeStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDwarfMutableType_initializeStorageClassArray (SgAsmDwarfMutableTypeStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDwarfNamelist ) ; 
     std::cout << " SgAsmDwarfNamelist has size " << sizeOfActualPool << std::endl;
     SgAsmDwarfNamelistStorageClass* SgAsmDwarfNamelistStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfNamelistStorageArray = new SgAsmDwarfNamelistStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDwarfNamelist_initializeStorageClassArray (SgAsmDwarfNamelistStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDwarfNamelistItem ) ; 
     std::cout << " SgAsmDwarfNamelistItem has size " << sizeOfActualPool << std::endl;
     SgAsmDwarfNamelistItemStorageClass* SgAsmDwarfNamelistItemStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfNamelistItemStorageArray = new SgAsmDwarfNamelistItemStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDwarfNamelistItem_initializeStorageClassArray (SgAsmDwarfNamelistItemStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDwarfNamespace ) ; 
     std::cout << " SgAsmDwarfNamespace has size " << sizeOfActualPool << std::endl;
     SgAsmDwarfNamespaceStorageClass* SgAsmDwarfNamespaceStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfNamespaceStorageArray = new SgAsmDwarfNamespaceStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDwarfNamespace_initializeStorageClassArray (SgAsmDwarfNamespaceStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDwarfPackedType ) ; 
     std::cout << " SgAsmDwarfPackedType has size " << sizeOfActualPool << std::endl;
     SgAsmDwarfPackedTypeStorageClass* SgAsmDwarfPackedTypeStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfPackedTypeStorageArray = new SgAsmDwarfPackedTypeStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDwarfPackedType_initializeStorageClassArray (SgAsmDwarfPackedTypeStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDwarfPartialUnit ) ; 
     std::cout << " SgAsmDwarfPartialUnit has size " << sizeOfActualPool << std::endl;
     SgAsmDwarfPartialUnitStorageClass* SgAsmDwarfPartialUnitStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfPartialUnitStorageArray = new SgAsmDwarfPartialUnitStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDwarfPartialUnit_initializeStorageClassArray (SgAsmDwarfPartialUnitStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDwarfPointerType ) ; 
     std::cout << " SgAsmDwarfPointerType has size " << sizeOfActualPool << std::endl;
     SgAsmDwarfPointerTypeStorageClass* SgAsmDwarfPointerTypeStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfPointerTypeStorageArray = new SgAsmDwarfPointerTypeStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDwarfPointerType_initializeStorageClassArray (SgAsmDwarfPointerTypeStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDwarfPtrToMemberType ) ; 
     std::cout << " SgAsmDwarfPtrToMemberType has size " << sizeOfActualPool << std::endl;
     SgAsmDwarfPtrToMemberTypeStorageClass* SgAsmDwarfPtrToMemberTypeStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfPtrToMemberTypeStorageArray = new SgAsmDwarfPtrToMemberTypeStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDwarfPtrToMemberType_initializeStorageClassArray (SgAsmDwarfPtrToMemberTypeStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDwarfReferenceType ) ; 
     std::cout << " SgAsmDwarfReferenceType has size " << sizeOfActualPool << std::endl;
     SgAsmDwarfReferenceTypeStorageClass* SgAsmDwarfReferenceTypeStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfReferenceTypeStorageArray = new SgAsmDwarfReferenceTypeStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDwarfReferenceType_initializeStorageClassArray (SgAsmDwarfReferenceTypeStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDwarfRestrictType ) ; 
     std::cout << " SgAsmDwarfRestrictType has size " << sizeOfActualPool << std::endl;
     SgAsmDwarfRestrictTypeStorageClass* SgAsmDwarfRestrictTypeStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfRestrictTypeStorageArray = new SgAsmDwarfRestrictTypeStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDwarfRestrictType_initializeStorageClassArray (SgAsmDwarfRestrictTypeStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDwarfSetType ) ; 
     std::cout << " SgAsmDwarfSetType has size " << sizeOfActualPool << std::endl;
     SgAsmDwarfSetTypeStorageClass* SgAsmDwarfSetTypeStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfSetTypeStorageArray = new SgAsmDwarfSetTypeStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDwarfSetType_initializeStorageClassArray (SgAsmDwarfSetTypeStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDwarfSharedType ) ; 
     std::cout << " SgAsmDwarfSharedType has size " << sizeOfActualPool << std::endl;
     SgAsmDwarfSharedTypeStorageClass* SgAsmDwarfSharedTypeStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfSharedTypeStorageArray = new SgAsmDwarfSharedTypeStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDwarfSharedType_initializeStorageClassArray (SgAsmDwarfSharedTypeStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDwarfStringType ) ; 
     std::cout << " SgAsmDwarfStringType has size " << sizeOfActualPool << std::endl;
     SgAsmDwarfStringTypeStorageClass* SgAsmDwarfStringTypeStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfStringTypeStorageArray = new SgAsmDwarfStringTypeStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDwarfStringType_initializeStorageClassArray (SgAsmDwarfStringTypeStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDwarfStructureType ) ; 
     std::cout << " SgAsmDwarfStructureType has size " << sizeOfActualPool << std::endl;
     SgAsmDwarfStructureTypeStorageClass* SgAsmDwarfStructureTypeStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfStructureTypeStorageArray = new SgAsmDwarfStructureTypeStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDwarfStructureType_initializeStorageClassArray (SgAsmDwarfStructureTypeStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDwarfSubprogram ) ; 
     std::cout << " SgAsmDwarfSubprogram has size " << sizeOfActualPool << std::endl;
     SgAsmDwarfSubprogramStorageClass* SgAsmDwarfSubprogramStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfSubprogramStorageArray = new SgAsmDwarfSubprogramStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDwarfSubprogram_initializeStorageClassArray (SgAsmDwarfSubprogramStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDwarfSubrangeType ) ; 
     std::cout << " SgAsmDwarfSubrangeType has size " << sizeOfActualPool << std::endl;
     SgAsmDwarfSubrangeTypeStorageClass* SgAsmDwarfSubrangeTypeStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfSubrangeTypeStorageArray = new SgAsmDwarfSubrangeTypeStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDwarfSubrangeType_initializeStorageClassArray (SgAsmDwarfSubrangeTypeStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDwarfSubroutineType ) ; 
     std::cout << " SgAsmDwarfSubroutineType has size " << sizeOfActualPool << std::endl;
     SgAsmDwarfSubroutineTypeStorageClass* SgAsmDwarfSubroutineTypeStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfSubroutineTypeStorageArray = new SgAsmDwarfSubroutineTypeStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDwarfSubroutineType_initializeStorageClassArray (SgAsmDwarfSubroutineTypeStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDwarfTemplateTypeParameter ) ; 
     std::cout << " SgAsmDwarfTemplateTypeParameter has size " << sizeOfActualPool << std::endl;
     SgAsmDwarfTemplateTypeParameterStorageClass* SgAsmDwarfTemplateTypeParameterStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfTemplateTypeParameterStorageArray = new SgAsmDwarfTemplateTypeParameterStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDwarfTemplateTypeParameter_initializeStorageClassArray (SgAsmDwarfTemplateTypeParameterStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDwarfTemplateValueParameter ) ; 
     std::cout << " SgAsmDwarfTemplateValueParameter has size " << sizeOfActualPool << std::endl;
     SgAsmDwarfTemplateValueParameterStorageClass* SgAsmDwarfTemplateValueParameterStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfTemplateValueParameterStorageArray = new SgAsmDwarfTemplateValueParameterStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDwarfTemplateValueParameter_initializeStorageClassArray (SgAsmDwarfTemplateValueParameterStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDwarfThrownType ) ; 
     std::cout << " SgAsmDwarfThrownType has size " << sizeOfActualPool << std::endl;
     SgAsmDwarfThrownTypeStorageClass* SgAsmDwarfThrownTypeStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfThrownTypeStorageArray = new SgAsmDwarfThrownTypeStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDwarfThrownType_initializeStorageClassArray (SgAsmDwarfThrownTypeStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDwarfTryBlock ) ; 
     std::cout << " SgAsmDwarfTryBlock has size " << sizeOfActualPool << std::endl;
     SgAsmDwarfTryBlockStorageClass* SgAsmDwarfTryBlockStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfTryBlockStorageArray = new SgAsmDwarfTryBlockStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDwarfTryBlock_initializeStorageClassArray (SgAsmDwarfTryBlockStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDwarfTypedef ) ; 
     std::cout << " SgAsmDwarfTypedef has size " << sizeOfActualPool << std::endl;
     SgAsmDwarfTypedefStorageClass* SgAsmDwarfTypedefStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfTypedefStorageArray = new SgAsmDwarfTypedefStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDwarfTypedef_initializeStorageClassArray (SgAsmDwarfTypedefStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDwarfUnionType ) ; 
     std::cout << " SgAsmDwarfUnionType has size " << sizeOfActualPool << std::endl;
     SgAsmDwarfUnionTypeStorageClass* SgAsmDwarfUnionTypeStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfUnionTypeStorageArray = new SgAsmDwarfUnionTypeStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDwarfUnionType_initializeStorageClassArray (SgAsmDwarfUnionTypeStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDwarfUnknownConstruct ) ; 
     std::cout << " SgAsmDwarfUnknownConstruct has size " << sizeOfActualPool << std::endl;
     SgAsmDwarfUnknownConstructStorageClass* SgAsmDwarfUnknownConstructStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfUnknownConstructStorageArray = new SgAsmDwarfUnknownConstructStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDwarfUnknownConstruct_initializeStorageClassArray (SgAsmDwarfUnknownConstructStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDwarfUnspecifiedParameters ) ; 
     std::cout << " SgAsmDwarfUnspecifiedParameters has size " << sizeOfActualPool << std::endl;
     SgAsmDwarfUnspecifiedParametersStorageClass* SgAsmDwarfUnspecifiedParametersStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfUnspecifiedParametersStorageArray = new SgAsmDwarfUnspecifiedParametersStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDwarfUnspecifiedParameters_initializeStorageClassArray (SgAsmDwarfUnspecifiedParametersStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDwarfUnspecifiedType ) ; 
     std::cout << " SgAsmDwarfUnspecifiedType has size " << sizeOfActualPool << std::endl;
     SgAsmDwarfUnspecifiedTypeStorageClass* SgAsmDwarfUnspecifiedTypeStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfUnspecifiedTypeStorageArray = new SgAsmDwarfUnspecifiedTypeStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDwarfUnspecifiedType_initializeStorageClassArray (SgAsmDwarfUnspecifiedTypeStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDwarfUpcRelaxedType ) ; 
     std::cout << " SgAsmDwarfUpcRelaxedType has size " << sizeOfActualPool << std::endl;
     SgAsmDwarfUpcRelaxedTypeStorageClass* SgAsmDwarfUpcRelaxedTypeStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfUpcRelaxedTypeStorageArray = new SgAsmDwarfUpcRelaxedTypeStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDwarfUpcRelaxedType_initializeStorageClassArray (SgAsmDwarfUpcRelaxedTypeStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDwarfUpcSharedType ) ; 
     std::cout << " SgAsmDwarfUpcSharedType has size " << sizeOfActualPool << std::endl;
     SgAsmDwarfUpcSharedTypeStorageClass* SgAsmDwarfUpcSharedTypeStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfUpcSharedTypeStorageArray = new SgAsmDwarfUpcSharedTypeStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDwarfUpcSharedType_initializeStorageClassArray (SgAsmDwarfUpcSharedTypeStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDwarfUpcStrictType ) ; 
     std::cout << " SgAsmDwarfUpcStrictType has size " << sizeOfActualPool << std::endl;
     SgAsmDwarfUpcStrictTypeStorageClass* SgAsmDwarfUpcStrictTypeStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfUpcStrictTypeStorageArray = new SgAsmDwarfUpcStrictTypeStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDwarfUpcStrictType_initializeStorageClassArray (SgAsmDwarfUpcStrictTypeStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDwarfVariable ) ; 
     std::cout << " SgAsmDwarfVariable has size " << sizeOfActualPool << std::endl;
     SgAsmDwarfVariableStorageClass* SgAsmDwarfVariableStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfVariableStorageArray = new SgAsmDwarfVariableStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDwarfVariable_initializeStorageClassArray (SgAsmDwarfVariableStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDwarfVariant ) ; 
     std::cout << " SgAsmDwarfVariant has size " << sizeOfActualPool << std::endl;
     SgAsmDwarfVariantStorageClass* SgAsmDwarfVariantStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfVariantStorageArray = new SgAsmDwarfVariantStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDwarfVariant_initializeStorageClassArray (SgAsmDwarfVariantStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDwarfVariantPart ) ; 
     std::cout << " SgAsmDwarfVariantPart has size " << sizeOfActualPool << std::endl;
     SgAsmDwarfVariantPartStorageClass* SgAsmDwarfVariantPartStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfVariantPartStorageArray = new SgAsmDwarfVariantPartStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDwarfVariantPart_initializeStorageClassArray (SgAsmDwarfVariantPartStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDwarfVolatileType ) ; 
     std::cout << " SgAsmDwarfVolatileType has size " << sizeOfActualPool << std::endl;
     SgAsmDwarfVolatileTypeStorageClass* SgAsmDwarfVolatileTypeStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfVolatileTypeStorageArray = new SgAsmDwarfVolatileTypeStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDwarfVolatileType_initializeStorageClassArray (SgAsmDwarfVolatileTypeStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmDwarfWithStmt ) ; 
     std::cout << " SgAsmDwarfWithStmt has size " << sizeOfActualPool << std::endl;
     SgAsmDwarfWithStmtStorageClass* SgAsmDwarfWithStmtStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfWithStmtStorageArray = new SgAsmDwarfWithStmtStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmDwarfWithStmt_initializeStorageClassArray (SgAsmDwarfWithStmtStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmElfDynamicEntry ) ; 
     std::cout << " SgAsmElfDynamicEntry has size " << sizeOfActualPool << std::endl;
     SgAsmElfDynamicEntryStorageClass* SgAsmElfDynamicEntryStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfDynamicEntryStorageArray = new SgAsmElfDynamicEntryStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmElfDynamicEntry_initializeStorageClassArray (SgAsmElfDynamicEntryStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmElfDynamicEntryList ) ; 
     std::cout << " SgAsmElfDynamicEntryList has size " << sizeOfActualPool << std::endl;
     SgAsmElfDynamicEntryListStorageClass* SgAsmElfDynamicEntryListStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfDynamicEntryListStorageArray = new SgAsmElfDynamicEntryListStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmElfDynamicEntryList_initializeStorageClassArray (SgAsmElfDynamicEntryListStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmElfDynamicSection ) ; 
     std::cout << " SgAsmElfDynamicSection has size " << sizeOfActualPool << std::endl;
     SgAsmElfDynamicSectionStorageClass* SgAsmElfDynamicSectionStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfDynamicSectionStorageArray = new SgAsmElfDynamicSectionStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmElfDynamicSection_initializeStorageClassArray (SgAsmElfDynamicSectionStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmElfEHFrameEntryCI ) ; 
     std::cout << " SgAsmElfEHFrameEntryCI has size " << sizeOfActualPool << std::endl;
     SgAsmElfEHFrameEntryCIStorageClass* SgAsmElfEHFrameEntryCIStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfEHFrameEntryCIStorageArray = new SgAsmElfEHFrameEntryCIStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmElfEHFrameEntryCI_initializeStorageClassArray (SgAsmElfEHFrameEntryCIStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmElfEHFrameEntryCIList ) ; 
     std::cout << " SgAsmElfEHFrameEntryCIList has size " << sizeOfActualPool << std::endl;
     SgAsmElfEHFrameEntryCIListStorageClass* SgAsmElfEHFrameEntryCIListStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfEHFrameEntryCIListStorageArray = new SgAsmElfEHFrameEntryCIListStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmElfEHFrameEntryCIList_initializeStorageClassArray (SgAsmElfEHFrameEntryCIListStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmElfEHFrameEntryFD ) ; 
     std::cout << " SgAsmElfEHFrameEntryFD has size " << sizeOfActualPool << std::endl;
     SgAsmElfEHFrameEntryFDStorageClass* SgAsmElfEHFrameEntryFDStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfEHFrameEntryFDStorageArray = new SgAsmElfEHFrameEntryFDStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmElfEHFrameEntryFD_initializeStorageClassArray (SgAsmElfEHFrameEntryFDStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmElfEHFrameEntryFDList ) ; 
     std::cout << " SgAsmElfEHFrameEntryFDList has size " << sizeOfActualPool << std::endl;
     SgAsmElfEHFrameEntryFDListStorageClass* SgAsmElfEHFrameEntryFDListStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfEHFrameEntryFDListStorageArray = new SgAsmElfEHFrameEntryFDListStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmElfEHFrameEntryFDList_initializeStorageClassArray (SgAsmElfEHFrameEntryFDListStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmElfEHFrameSection ) ; 
     std::cout << " SgAsmElfEHFrameSection has size " << sizeOfActualPool << std::endl;
     SgAsmElfEHFrameSectionStorageClass* SgAsmElfEHFrameSectionStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfEHFrameSectionStorageArray = new SgAsmElfEHFrameSectionStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmElfEHFrameSection_initializeStorageClassArray (SgAsmElfEHFrameSectionStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmElfFileHeader ) ; 
     std::cout << " SgAsmElfFileHeader has size " << sizeOfActualPool << std::endl;
     SgAsmElfFileHeaderStorageClass* SgAsmElfFileHeaderStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfFileHeaderStorageArray = new SgAsmElfFileHeaderStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmElfFileHeader_initializeStorageClassArray (SgAsmElfFileHeaderStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmElfNoteEntry ) ; 
     std::cout << " SgAsmElfNoteEntry has size " << sizeOfActualPool << std::endl;
     SgAsmElfNoteEntryStorageClass* SgAsmElfNoteEntryStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfNoteEntryStorageArray = new SgAsmElfNoteEntryStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmElfNoteEntry_initializeStorageClassArray (SgAsmElfNoteEntryStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmElfNoteEntryList ) ; 
     std::cout << " SgAsmElfNoteEntryList has size " << sizeOfActualPool << std::endl;
     SgAsmElfNoteEntryListStorageClass* SgAsmElfNoteEntryListStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfNoteEntryListStorageArray = new SgAsmElfNoteEntryListStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmElfNoteEntryList_initializeStorageClassArray (SgAsmElfNoteEntryListStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmElfNoteSection ) ; 
     std::cout << " SgAsmElfNoteSection has size " << sizeOfActualPool << std::endl;
     SgAsmElfNoteSectionStorageClass* SgAsmElfNoteSectionStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfNoteSectionStorageArray = new SgAsmElfNoteSectionStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmElfNoteSection_initializeStorageClassArray (SgAsmElfNoteSectionStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmElfRelocEntry ) ; 
     std::cout << " SgAsmElfRelocEntry has size " << sizeOfActualPool << std::endl;
     SgAsmElfRelocEntryStorageClass* SgAsmElfRelocEntryStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfRelocEntryStorageArray = new SgAsmElfRelocEntryStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmElfRelocEntry_initializeStorageClassArray (SgAsmElfRelocEntryStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmElfRelocEntryList ) ; 
     std::cout << " SgAsmElfRelocEntryList has size " << sizeOfActualPool << std::endl;
     SgAsmElfRelocEntryListStorageClass* SgAsmElfRelocEntryListStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfRelocEntryListStorageArray = new SgAsmElfRelocEntryListStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmElfRelocEntryList_initializeStorageClassArray (SgAsmElfRelocEntryListStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmElfRelocSection ) ; 
     std::cout << " SgAsmElfRelocSection has size " << sizeOfActualPool << std::endl;
     SgAsmElfRelocSectionStorageClass* SgAsmElfRelocSectionStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfRelocSectionStorageArray = new SgAsmElfRelocSectionStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmElfRelocSection_initializeStorageClassArray (SgAsmElfRelocSectionStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmElfSection ) ; 
     std::cout << " SgAsmElfSection has size " << sizeOfActualPool << std::endl;
     SgAsmElfSectionStorageClass* SgAsmElfSectionStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfSectionStorageArray = new SgAsmElfSectionStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmElfSection_initializeStorageClassArray (SgAsmElfSectionStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmElfSectionTable ) ; 
     std::cout << " SgAsmElfSectionTable has size " << sizeOfActualPool << std::endl;
     SgAsmElfSectionTableStorageClass* SgAsmElfSectionTableStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfSectionTableStorageArray = new SgAsmElfSectionTableStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmElfSectionTable_initializeStorageClassArray (SgAsmElfSectionTableStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmElfSectionTableEntry ) ; 
     std::cout << " SgAsmElfSectionTableEntry has size " << sizeOfActualPool << std::endl;
     SgAsmElfSectionTableEntryStorageClass* SgAsmElfSectionTableEntryStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfSectionTableEntryStorageArray = new SgAsmElfSectionTableEntryStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmElfSectionTableEntry_initializeStorageClassArray (SgAsmElfSectionTableEntryStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmElfSegmentTable ) ; 
     std::cout << " SgAsmElfSegmentTable has size " << sizeOfActualPool << std::endl;
     SgAsmElfSegmentTableStorageClass* SgAsmElfSegmentTableStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfSegmentTableStorageArray = new SgAsmElfSegmentTableStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmElfSegmentTable_initializeStorageClassArray (SgAsmElfSegmentTableStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmElfSegmentTableEntry ) ; 
     std::cout << " SgAsmElfSegmentTableEntry has size " << sizeOfActualPool << std::endl;
     SgAsmElfSegmentTableEntryStorageClass* SgAsmElfSegmentTableEntryStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfSegmentTableEntryStorageArray = new SgAsmElfSegmentTableEntryStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmElfSegmentTableEntry_initializeStorageClassArray (SgAsmElfSegmentTableEntryStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmElfSegmentTableEntryList ) ; 
     std::cout << " SgAsmElfSegmentTableEntryList has size " << sizeOfActualPool << std::endl;
     SgAsmElfSegmentTableEntryListStorageClass* SgAsmElfSegmentTableEntryListStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfSegmentTableEntryListStorageArray = new SgAsmElfSegmentTableEntryListStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmElfSegmentTableEntryList_initializeStorageClassArray (SgAsmElfSegmentTableEntryListStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmElfStringSection ) ; 
     std::cout << " SgAsmElfStringSection has size " << sizeOfActualPool << std::endl;
     SgAsmElfStringSectionStorageClass* SgAsmElfStringSectionStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfStringSectionStorageArray = new SgAsmElfStringSectionStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmElfStringSection_initializeStorageClassArray (SgAsmElfStringSectionStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmElfStrtab ) ; 
     std::cout << " SgAsmElfStrtab has size " << sizeOfActualPool << std::endl;
     SgAsmElfStrtabStorageClass* SgAsmElfStrtabStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfStrtabStorageArray = new SgAsmElfStrtabStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmElfStrtab_initializeStorageClassArray (SgAsmElfStrtabStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmElfSymbol ) ; 
     std::cout << " SgAsmElfSymbol has size " << sizeOfActualPool << std::endl;
     SgAsmElfSymbolStorageClass* SgAsmElfSymbolStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfSymbolStorageArray = new SgAsmElfSymbolStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmElfSymbol_initializeStorageClassArray (SgAsmElfSymbolStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmElfSymbolList ) ; 
     std::cout << " SgAsmElfSymbolList has size " << sizeOfActualPool << std::endl;
     SgAsmElfSymbolListStorageClass* SgAsmElfSymbolListStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfSymbolListStorageArray = new SgAsmElfSymbolListStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmElfSymbolList_initializeStorageClassArray (SgAsmElfSymbolListStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmElfSymbolSection ) ; 
     std::cout << " SgAsmElfSymbolSection has size " << sizeOfActualPool << std::endl;
     SgAsmElfSymbolSectionStorageClass* SgAsmElfSymbolSectionStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfSymbolSectionStorageArray = new SgAsmElfSymbolSectionStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmElfSymbolSection_initializeStorageClassArray (SgAsmElfSymbolSectionStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmElfSymverDefinedAux ) ; 
     std::cout << " SgAsmElfSymverDefinedAux has size " << sizeOfActualPool << std::endl;
     SgAsmElfSymverDefinedAuxStorageClass* SgAsmElfSymverDefinedAuxStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfSymverDefinedAuxStorageArray = new SgAsmElfSymverDefinedAuxStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmElfSymverDefinedAux_initializeStorageClassArray (SgAsmElfSymverDefinedAuxStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmElfSymverDefinedAuxList ) ; 
     std::cout << " SgAsmElfSymverDefinedAuxList has size " << sizeOfActualPool << std::endl;
     SgAsmElfSymverDefinedAuxListStorageClass* SgAsmElfSymverDefinedAuxListStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfSymverDefinedAuxListStorageArray = new SgAsmElfSymverDefinedAuxListStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmElfSymverDefinedAuxList_initializeStorageClassArray (SgAsmElfSymverDefinedAuxListStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmElfSymverDefinedEntry ) ; 
     std::cout << " SgAsmElfSymverDefinedEntry has size " << sizeOfActualPool << std::endl;
     SgAsmElfSymverDefinedEntryStorageClass* SgAsmElfSymverDefinedEntryStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfSymverDefinedEntryStorageArray = new SgAsmElfSymverDefinedEntryStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmElfSymverDefinedEntry_initializeStorageClassArray (SgAsmElfSymverDefinedEntryStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmElfSymverDefinedEntryList ) ; 
     std::cout << " SgAsmElfSymverDefinedEntryList has size " << sizeOfActualPool << std::endl;
     SgAsmElfSymverDefinedEntryListStorageClass* SgAsmElfSymverDefinedEntryListStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfSymverDefinedEntryListStorageArray = new SgAsmElfSymverDefinedEntryListStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmElfSymverDefinedEntryList_initializeStorageClassArray (SgAsmElfSymverDefinedEntryListStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmElfSymverDefinedSection ) ; 
     std::cout << " SgAsmElfSymverDefinedSection has size " << sizeOfActualPool << std::endl;
     SgAsmElfSymverDefinedSectionStorageClass* SgAsmElfSymverDefinedSectionStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfSymverDefinedSectionStorageArray = new SgAsmElfSymverDefinedSectionStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmElfSymverDefinedSection_initializeStorageClassArray (SgAsmElfSymverDefinedSectionStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmElfSymverEntry ) ; 
     std::cout << " SgAsmElfSymverEntry has size " << sizeOfActualPool << std::endl;
     SgAsmElfSymverEntryStorageClass* SgAsmElfSymverEntryStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfSymverEntryStorageArray = new SgAsmElfSymverEntryStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmElfSymverEntry_initializeStorageClassArray (SgAsmElfSymverEntryStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmElfSymverEntryList ) ; 
     std::cout << " SgAsmElfSymverEntryList has size " << sizeOfActualPool << std::endl;
     SgAsmElfSymverEntryListStorageClass* SgAsmElfSymverEntryListStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfSymverEntryListStorageArray = new SgAsmElfSymverEntryListStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmElfSymverEntryList_initializeStorageClassArray (SgAsmElfSymverEntryListStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmElfSymverNeededAux ) ; 
     std::cout << " SgAsmElfSymverNeededAux has size " << sizeOfActualPool << std::endl;
     SgAsmElfSymverNeededAuxStorageClass* SgAsmElfSymverNeededAuxStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfSymverNeededAuxStorageArray = new SgAsmElfSymverNeededAuxStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmElfSymverNeededAux_initializeStorageClassArray (SgAsmElfSymverNeededAuxStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmElfSymverNeededAuxList ) ; 
     std::cout << " SgAsmElfSymverNeededAuxList has size " << sizeOfActualPool << std::endl;
     SgAsmElfSymverNeededAuxListStorageClass* SgAsmElfSymverNeededAuxListStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfSymverNeededAuxListStorageArray = new SgAsmElfSymverNeededAuxListStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmElfSymverNeededAuxList_initializeStorageClassArray (SgAsmElfSymverNeededAuxListStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmElfSymverNeededEntry ) ; 
     std::cout << " SgAsmElfSymverNeededEntry has size " << sizeOfActualPool << std::endl;
     SgAsmElfSymverNeededEntryStorageClass* SgAsmElfSymverNeededEntryStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfSymverNeededEntryStorageArray = new SgAsmElfSymverNeededEntryStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmElfSymverNeededEntry_initializeStorageClassArray (SgAsmElfSymverNeededEntryStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmElfSymverNeededEntryList ) ; 
     std::cout << " SgAsmElfSymverNeededEntryList has size " << sizeOfActualPool << std::endl;
     SgAsmElfSymverNeededEntryListStorageClass* SgAsmElfSymverNeededEntryListStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfSymverNeededEntryListStorageArray = new SgAsmElfSymverNeededEntryListStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmElfSymverNeededEntryList_initializeStorageClassArray (SgAsmElfSymverNeededEntryListStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmElfSymverNeededSection ) ; 
     std::cout << " SgAsmElfSymverNeededSection has size " << sizeOfActualPool << std::endl;
     SgAsmElfSymverNeededSectionStorageClass* SgAsmElfSymverNeededSectionStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfSymverNeededSectionStorageArray = new SgAsmElfSymverNeededSectionStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmElfSymverNeededSection_initializeStorageClassArray (SgAsmElfSymverNeededSectionStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmElfSymverSection ) ; 
     std::cout << " SgAsmElfSymverSection has size " << sizeOfActualPool << std::endl;
     SgAsmElfSymverSectionStorageClass* SgAsmElfSymverSectionStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfSymverSectionStorageArray = new SgAsmElfSymverSectionStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmElfSymverSection_initializeStorageClassArray (SgAsmElfSymverSectionStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmExecutableFileFormat ) ; 
     std::cout << " SgAsmExecutableFileFormat has size " << sizeOfActualPool << std::endl;
     SgAsmExecutableFileFormatStorageClass* SgAsmExecutableFileFormatStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmExecutableFileFormatStorageArray = new SgAsmExecutableFileFormatStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmExecutableFileFormat_initializeStorageClassArray (SgAsmExecutableFileFormatStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmExprListExp ) ; 
     std::cout << " SgAsmExprListExp has size " << sizeOfActualPool << std::endl;
     SgAsmExprListExpStorageClass* SgAsmExprListExpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmExprListExpStorageArray = new SgAsmExprListExpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmExprListExp_initializeStorageClassArray (SgAsmExprListExpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmExpression ) ; 
     std::cout << " SgAsmExpression has size " << sizeOfActualPool << std::endl;
     SgAsmExpressionStorageClass* SgAsmExpressionStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmExpressionStorageArray = new SgAsmExpressionStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmExpression_initializeStorageClassArray (SgAsmExpressionStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmFunction ) ; 
     std::cout << " SgAsmFunction has size " << sizeOfActualPool << std::endl;
     SgAsmFunctionStorageClass* SgAsmFunctionStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmFunctionStorageArray = new SgAsmFunctionStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmFunction_initializeStorageClassArray (SgAsmFunctionStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmGenericDLL ) ; 
     std::cout << " SgAsmGenericDLL has size " << sizeOfActualPool << std::endl;
     SgAsmGenericDLLStorageClass* SgAsmGenericDLLStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmGenericDLLStorageArray = new SgAsmGenericDLLStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmGenericDLL_initializeStorageClassArray (SgAsmGenericDLLStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmGenericDLLList ) ; 
     std::cout << " SgAsmGenericDLLList has size " << sizeOfActualPool << std::endl;
     SgAsmGenericDLLListStorageClass* SgAsmGenericDLLListStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmGenericDLLListStorageArray = new SgAsmGenericDLLListStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmGenericDLLList_initializeStorageClassArray (SgAsmGenericDLLListStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmGenericFile ) ; 
     std::cout << " SgAsmGenericFile has size " << sizeOfActualPool << std::endl;
     SgAsmGenericFileStorageClass* SgAsmGenericFileStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmGenericFileStorageArray = new SgAsmGenericFileStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmGenericFile_initializeStorageClassArray (SgAsmGenericFileStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmGenericFileList ) ; 
     std::cout << " SgAsmGenericFileList has size " << sizeOfActualPool << std::endl;
     SgAsmGenericFileListStorageClass* SgAsmGenericFileListStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmGenericFileListStorageArray = new SgAsmGenericFileListStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmGenericFileList_initializeStorageClassArray (SgAsmGenericFileListStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmGenericFormat ) ; 
     std::cout << " SgAsmGenericFormat has size " << sizeOfActualPool << std::endl;
     SgAsmGenericFormatStorageClass* SgAsmGenericFormatStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmGenericFormatStorageArray = new SgAsmGenericFormatStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmGenericFormat_initializeStorageClassArray (SgAsmGenericFormatStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmGenericHeader ) ; 
     std::cout << " SgAsmGenericHeader has size " << sizeOfActualPool << std::endl;
     SgAsmGenericHeaderStorageClass* SgAsmGenericHeaderStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmGenericHeaderStorageArray = new SgAsmGenericHeaderStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmGenericHeader_initializeStorageClassArray (SgAsmGenericHeaderStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmGenericHeaderList ) ; 
     std::cout << " SgAsmGenericHeaderList has size " << sizeOfActualPool << std::endl;
     SgAsmGenericHeaderListStorageClass* SgAsmGenericHeaderListStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmGenericHeaderListStorageArray = new SgAsmGenericHeaderListStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmGenericHeaderList_initializeStorageClassArray (SgAsmGenericHeaderListStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmGenericSection ) ; 
     std::cout << " SgAsmGenericSection has size " << sizeOfActualPool << std::endl;
     SgAsmGenericSectionStorageClass* SgAsmGenericSectionStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmGenericSectionStorageArray = new SgAsmGenericSectionStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmGenericSection_initializeStorageClassArray (SgAsmGenericSectionStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmGenericSectionList ) ; 
     std::cout << " SgAsmGenericSectionList has size " << sizeOfActualPool << std::endl;
     SgAsmGenericSectionListStorageClass* SgAsmGenericSectionListStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmGenericSectionListStorageArray = new SgAsmGenericSectionListStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmGenericSectionList_initializeStorageClassArray (SgAsmGenericSectionListStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmGenericString ) ; 
     std::cout << " SgAsmGenericString has size " << sizeOfActualPool << std::endl;
     SgAsmGenericStringStorageClass* SgAsmGenericStringStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmGenericStringStorageArray = new SgAsmGenericStringStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmGenericString_initializeStorageClassArray (SgAsmGenericStringStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmGenericStrtab ) ; 
     std::cout << " SgAsmGenericStrtab has size " << sizeOfActualPool << std::endl;
     SgAsmGenericStrtabStorageClass* SgAsmGenericStrtabStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmGenericStrtabStorageArray = new SgAsmGenericStrtabStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmGenericStrtab_initializeStorageClassArray (SgAsmGenericStrtabStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmGenericSymbol ) ; 
     std::cout << " SgAsmGenericSymbol has size " << sizeOfActualPool << std::endl;
     SgAsmGenericSymbolStorageClass* SgAsmGenericSymbolStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmGenericSymbolStorageArray = new SgAsmGenericSymbolStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmGenericSymbol_initializeStorageClassArray (SgAsmGenericSymbolStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmGenericSymbolList ) ; 
     std::cout << " SgAsmGenericSymbolList has size " << sizeOfActualPool << std::endl;
     SgAsmGenericSymbolListStorageClass* SgAsmGenericSymbolListStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmGenericSymbolListStorageArray = new SgAsmGenericSymbolListStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmGenericSymbolList_initializeStorageClassArray (SgAsmGenericSymbolListStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmInstruction ) ; 
     std::cout << " SgAsmInstruction has size " << sizeOfActualPool << std::endl;
     SgAsmInstructionStorageClass* SgAsmInstructionStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmInstructionStorageArray = new SgAsmInstructionStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmInstruction_initializeStorageClassArray (SgAsmInstructionStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmIntegerValueExpression ) ; 
     std::cout << " SgAsmIntegerValueExpression has size " << sizeOfActualPool << std::endl;
     SgAsmIntegerValueExpressionStorageClass* SgAsmIntegerValueExpressionStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmIntegerValueExpressionStorageArray = new SgAsmIntegerValueExpressionStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmIntegerValueExpression_initializeStorageClassArray (SgAsmIntegerValueExpressionStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmInterpretation ) ; 
     std::cout << " SgAsmInterpretation has size " << sizeOfActualPool << std::endl;
     SgAsmInterpretationStorageClass* SgAsmInterpretationStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmInterpretationStorageArray = new SgAsmInterpretationStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmInterpretation_initializeStorageClassArray (SgAsmInterpretationStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmInterpretationList ) ; 
     std::cout << " SgAsmInterpretationList has size " << sizeOfActualPool << std::endl;
     SgAsmInterpretationListStorageClass* SgAsmInterpretationListStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmInterpretationListStorageArray = new SgAsmInterpretationListStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmInterpretationList_initializeStorageClassArray (SgAsmInterpretationListStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmLEEntryPoint ) ; 
     std::cout << " SgAsmLEEntryPoint has size " << sizeOfActualPool << std::endl;
     SgAsmLEEntryPointStorageClass* SgAsmLEEntryPointStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmLEEntryPointStorageArray = new SgAsmLEEntryPointStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmLEEntryPoint_initializeStorageClassArray (SgAsmLEEntryPointStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmLEEntryTable ) ; 
     std::cout << " SgAsmLEEntryTable has size " << sizeOfActualPool << std::endl;
     SgAsmLEEntryTableStorageClass* SgAsmLEEntryTableStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmLEEntryTableStorageArray = new SgAsmLEEntryTableStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmLEEntryTable_initializeStorageClassArray (SgAsmLEEntryTableStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmLEFileHeader ) ; 
     std::cout << " SgAsmLEFileHeader has size " << sizeOfActualPool << std::endl;
     SgAsmLEFileHeaderStorageClass* SgAsmLEFileHeaderStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmLEFileHeaderStorageArray = new SgAsmLEFileHeaderStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmLEFileHeader_initializeStorageClassArray (SgAsmLEFileHeaderStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmLENameTable ) ; 
     std::cout << " SgAsmLENameTable has size " << sizeOfActualPool << std::endl;
     SgAsmLENameTableStorageClass* SgAsmLENameTableStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmLENameTableStorageArray = new SgAsmLENameTableStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmLENameTable_initializeStorageClassArray (SgAsmLENameTableStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmLEPageTable ) ; 
     std::cout << " SgAsmLEPageTable has size " << sizeOfActualPool << std::endl;
     SgAsmLEPageTableStorageClass* SgAsmLEPageTableStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmLEPageTableStorageArray = new SgAsmLEPageTableStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmLEPageTable_initializeStorageClassArray (SgAsmLEPageTableStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmLEPageTableEntry ) ; 
     std::cout << " SgAsmLEPageTableEntry has size " << sizeOfActualPool << std::endl;
     SgAsmLEPageTableEntryStorageClass* SgAsmLEPageTableEntryStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmLEPageTableEntryStorageArray = new SgAsmLEPageTableEntryStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmLEPageTableEntry_initializeStorageClassArray (SgAsmLEPageTableEntryStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmLERelocTable ) ; 
     std::cout << " SgAsmLERelocTable has size " << sizeOfActualPool << std::endl;
     SgAsmLERelocTableStorageClass* SgAsmLERelocTableStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmLERelocTableStorageArray = new SgAsmLERelocTableStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmLERelocTable_initializeStorageClassArray (SgAsmLERelocTableStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmLESection ) ; 
     std::cout << " SgAsmLESection has size " << sizeOfActualPool << std::endl;
     SgAsmLESectionStorageClass* SgAsmLESectionStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmLESectionStorageArray = new SgAsmLESectionStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmLESection_initializeStorageClassArray (SgAsmLESectionStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmLESectionTable ) ; 
     std::cout << " SgAsmLESectionTable has size " << sizeOfActualPool << std::endl;
     SgAsmLESectionTableStorageClass* SgAsmLESectionTableStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmLESectionTableStorageArray = new SgAsmLESectionTableStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmLESectionTable_initializeStorageClassArray (SgAsmLESectionTableStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmLESectionTableEntry ) ; 
     std::cout << " SgAsmLESectionTableEntry has size " << sizeOfActualPool << std::endl;
     SgAsmLESectionTableEntryStorageClass* SgAsmLESectionTableEntryStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmLESectionTableEntryStorageArray = new SgAsmLESectionTableEntryStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmLESectionTableEntry_initializeStorageClassArray (SgAsmLESectionTableEntryStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmMemoryReferenceExpression ) ; 
     std::cout << " SgAsmMemoryReferenceExpression has size " << sizeOfActualPool << std::endl;
     SgAsmMemoryReferenceExpressionStorageClass* SgAsmMemoryReferenceExpressionStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmMemoryReferenceExpressionStorageArray = new SgAsmMemoryReferenceExpressionStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmMemoryReferenceExpression_initializeStorageClassArray (SgAsmMemoryReferenceExpressionStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmNEEntryPoint ) ; 
     std::cout << " SgAsmNEEntryPoint has size " << sizeOfActualPool << std::endl;
     SgAsmNEEntryPointStorageClass* SgAsmNEEntryPointStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmNEEntryPointStorageArray = new SgAsmNEEntryPointStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmNEEntryPoint_initializeStorageClassArray (SgAsmNEEntryPointStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmNEEntryTable ) ; 
     std::cout << " SgAsmNEEntryTable has size " << sizeOfActualPool << std::endl;
     SgAsmNEEntryTableStorageClass* SgAsmNEEntryTableStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmNEEntryTableStorageArray = new SgAsmNEEntryTableStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmNEEntryTable_initializeStorageClassArray (SgAsmNEEntryTableStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmNEFileHeader ) ; 
     std::cout << " SgAsmNEFileHeader has size " << sizeOfActualPool << std::endl;
     SgAsmNEFileHeaderStorageClass* SgAsmNEFileHeaderStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmNEFileHeaderStorageArray = new SgAsmNEFileHeaderStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmNEFileHeader_initializeStorageClassArray (SgAsmNEFileHeaderStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmNEModuleTable ) ; 
     std::cout << " SgAsmNEModuleTable has size " << sizeOfActualPool << std::endl;
     SgAsmNEModuleTableStorageClass* SgAsmNEModuleTableStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmNEModuleTableStorageArray = new SgAsmNEModuleTableStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmNEModuleTable_initializeStorageClassArray (SgAsmNEModuleTableStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmNENameTable ) ; 
     std::cout << " SgAsmNENameTable has size " << sizeOfActualPool << std::endl;
     SgAsmNENameTableStorageClass* SgAsmNENameTableStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmNENameTableStorageArray = new SgAsmNENameTableStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmNENameTable_initializeStorageClassArray (SgAsmNENameTableStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmNERelocEntry ) ; 
     std::cout << " SgAsmNERelocEntry has size " << sizeOfActualPool << std::endl;
     SgAsmNERelocEntryStorageClass* SgAsmNERelocEntryStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmNERelocEntryStorageArray = new SgAsmNERelocEntryStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmNERelocEntry_initializeStorageClassArray (SgAsmNERelocEntryStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmNERelocTable ) ; 
     std::cout << " SgAsmNERelocTable has size " << sizeOfActualPool << std::endl;
     SgAsmNERelocTableStorageClass* SgAsmNERelocTableStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmNERelocTableStorageArray = new SgAsmNERelocTableStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmNERelocTable_initializeStorageClassArray (SgAsmNERelocTableStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmNESection ) ; 
     std::cout << " SgAsmNESection has size " << sizeOfActualPool << std::endl;
     SgAsmNESectionStorageClass* SgAsmNESectionStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmNESectionStorageArray = new SgAsmNESectionStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmNESection_initializeStorageClassArray (SgAsmNESectionStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmNESectionTable ) ; 
     std::cout << " SgAsmNESectionTable has size " << sizeOfActualPool << std::endl;
     SgAsmNESectionTableStorageClass* SgAsmNESectionTableStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmNESectionTableStorageArray = new SgAsmNESectionTableStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmNESectionTable_initializeStorageClassArray (SgAsmNESectionTableStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmNESectionTableEntry ) ; 
     std::cout << " SgAsmNESectionTableEntry has size " << sizeOfActualPool << std::endl;
     SgAsmNESectionTableEntryStorageClass* SgAsmNESectionTableEntryStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmNESectionTableEntryStorageArray = new SgAsmNESectionTableEntryStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmNESectionTableEntry_initializeStorageClassArray (SgAsmNESectionTableEntryStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmNEStringTable ) ; 
     std::cout << " SgAsmNEStringTable has size " << sizeOfActualPool << std::endl;
     SgAsmNEStringTableStorageClass* SgAsmNEStringTableStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmNEStringTableStorageArray = new SgAsmNEStringTableStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmNEStringTable_initializeStorageClassArray (SgAsmNEStringTableStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmNode ) ; 
     std::cout << " SgAsmNode has size " << sizeOfActualPool << std::endl;
     SgAsmNodeStorageClass* SgAsmNodeStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmNodeStorageArray = new SgAsmNodeStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmNode_initializeStorageClassArray (SgAsmNodeStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmOp ) ; 
     std::cout << " SgAsmOp has size " << sizeOfActualPool << std::endl;
     SgAsmOpStorageClass* SgAsmOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmOpStorageArray = new SgAsmOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmOp_initializeStorageClassArray (SgAsmOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmOperandList ) ; 
     std::cout << " SgAsmOperandList has size " << sizeOfActualPool << std::endl;
     SgAsmOperandListStorageClass* SgAsmOperandListStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmOperandListStorageArray = new SgAsmOperandListStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmOperandList_initializeStorageClassArray (SgAsmOperandListStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmPEExportDirectory ) ; 
     std::cout << " SgAsmPEExportDirectory has size " << sizeOfActualPool << std::endl;
     SgAsmPEExportDirectoryStorageClass* SgAsmPEExportDirectoryStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmPEExportDirectoryStorageArray = new SgAsmPEExportDirectoryStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmPEExportDirectory_initializeStorageClassArray (SgAsmPEExportDirectoryStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmPEExportEntry ) ; 
     std::cout << " SgAsmPEExportEntry has size " << sizeOfActualPool << std::endl;
     SgAsmPEExportEntryStorageClass* SgAsmPEExportEntryStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmPEExportEntryStorageArray = new SgAsmPEExportEntryStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmPEExportEntry_initializeStorageClassArray (SgAsmPEExportEntryStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmPEExportEntryList ) ; 
     std::cout << " SgAsmPEExportEntryList has size " << sizeOfActualPool << std::endl;
     SgAsmPEExportEntryListStorageClass* SgAsmPEExportEntryListStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmPEExportEntryListStorageArray = new SgAsmPEExportEntryListStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmPEExportEntryList_initializeStorageClassArray (SgAsmPEExportEntryListStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmPEExportSection ) ; 
     std::cout << " SgAsmPEExportSection has size " << sizeOfActualPool << std::endl;
     SgAsmPEExportSectionStorageClass* SgAsmPEExportSectionStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmPEExportSectionStorageArray = new SgAsmPEExportSectionStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmPEExportSection_initializeStorageClassArray (SgAsmPEExportSectionStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmPEFileHeader ) ; 
     std::cout << " SgAsmPEFileHeader has size " << sizeOfActualPool << std::endl;
     SgAsmPEFileHeaderStorageClass* SgAsmPEFileHeaderStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmPEFileHeaderStorageArray = new SgAsmPEFileHeaderStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmPEFileHeader_initializeStorageClassArray (SgAsmPEFileHeaderStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmPEImportDirectory ) ; 
     std::cout << " SgAsmPEImportDirectory has size " << sizeOfActualPool << std::endl;
     SgAsmPEImportDirectoryStorageClass* SgAsmPEImportDirectoryStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmPEImportDirectoryStorageArray = new SgAsmPEImportDirectoryStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmPEImportDirectory_initializeStorageClassArray (SgAsmPEImportDirectoryStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmPEImportDirectoryList ) ; 
     std::cout << " SgAsmPEImportDirectoryList has size " << sizeOfActualPool << std::endl;
     SgAsmPEImportDirectoryListStorageClass* SgAsmPEImportDirectoryListStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmPEImportDirectoryListStorageArray = new SgAsmPEImportDirectoryListStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmPEImportDirectoryList_initializeStorageClassArray (SgAsmPEImportDirectoryListStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmPEImportItem ) ; 
     std::cout << " SgAsmPEImportItem has size " << sizeOfActualPool << std::endl;
     SgAsmPEImportItemStorageClass* SgAsmPEImportItemStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmPEImportItemStorageArray = new SgAsmPEImportItemStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmPEImportItem_initializeStorageClassArray (SgAsmPEImportItemStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmPEImportItemList ) ; 
     std::cout << " SgAsmPEImportItemList has size " << sizeOfActualPool << std::endl;
     SgAsmPEImportItemListStorageClass* SgAsmPEImportItemListStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmPEImportItemListStorageArray = new SgAsmPEImportItemListStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmPEImportItemList_initializeStorageClassArray (SgAsmPEImportItemListStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmPEImportSection ) ; 
     std::cout << " SgAsmPEImportSection has size " << sizeOfActualPool << std::endl;
     SgAsmPEImportSectionStorageClass* SgAsmPEImportSectionStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmPEImportSectionStorageArray = new SgAsmPEImportSectionStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmPEImportSection_initializeStorageClassArray (SgAsmPEImportSectionStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmPERVASizePair ) ; 
     std::cout << " SgAsmPERVASizePair has size " << sizeOfActualPool << std::endl;
     SgAsmPERVASizePairStorageClass* SgAsmPERVASizePairStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmPERVASizePairStorageArray = new SgAsmPERVASizePairStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmPERVASizePair_initializeStorageClassArray (SgAsmPERVASizePairStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmPERVASizePairList ) ; 
     std::cout << " SgAsmPERVASizePairList has size " << sizeOfActualPool << std::endl;
     SgAsmPERVASizePairListStorageClass* SgAsmPERVASizePairListStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmPERVASizePairListStorageArray = new SgAsmPERVASizePairListStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmPERVASizePairList_initializeStorageClassArray (SgAsmPERVASizePairListStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmPESection ) ; 
     std::cout << " SgAsmPESection has size " << sizeOfActualPool << std::endl;
     SgAsmPESectionStorageClass* SgAsmPESectionStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmPESectionStorageArray = new SgAsmPESectionStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmPESection_initializeStorageClassArray (SgAsmPESectionStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmPESectionTable ) ; 
     std::cout << " SgAsmPESectionTable has size " << sizeOfActualPool << std::endl;
     SgAsmPESectionTableStorageClass* SgAsmPESectionTableStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmPESectionTableStorageArray = new SgAsmPESectionTableStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmPESectionTable_initializeStorageClassArray (SgAsmPESectionTableStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmPESectionTableEntry ) ; 
     std::cout << " SgAsmPESectionTableEntry has size " << sizeOfActualPool << std::endl;
     SgAsmPESectionTableEntryStorageClass* SgAsmPESectionTableEntryStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmPESectionTableEntryStorageArray = new SgAsmPESectionTableEntryStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmPESectionTableEntry_initializeStorageClassArray (SgAsmPESectionTableEntryStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmPEStringSection ) ; 
     std::cout << " SgAsmPEStringSection has size " << sizeOfActualPool << std::endl;
     SgAsmPEStringSectionStorageClass* SgAsmPEStringSectionStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmPEStringSectionStorageArray = new SgAsmPEStringSectionStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmPEStringSection_initializeStorageClassArray (SgAsmPEStringSectionStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmPowerpcInstruction ) ; 
     std::cout << " SgAsmPowerpcInstruction has size " << sizeOfActualPool << std::endl;
     SgAsmPowerpcInstructionStorageClass* SgAsmPowerpcInstructionStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmPowerpcInstructionStorageArray = new SgAsmPowerpcInstructionStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmPowerpcInstruction_initializeStorageClassArray (SgAsmPowerpcInstructionStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmPowerpcRegisterReferenceExpression ) ; 
     std::cout << " SgAsmPowerpcRegisterReferenceExpression has size " << sizeOfActualPool << std::endl;
     SgAsmPowerpcRegisterReferenceExpressionStorageClass* SgAsmPowerpcRegisterReferenceExpressionStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmPowerpcRegisterReferenceExpressionStorageArray = new SgAsmPowerpcRegisterReferenceExpressionStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmPowerpcRegisterReferenceExpression_initializeStorageClassArray (SgAsmPowerpcRegisterReferenceExpressionStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmQuadWordValueExpression ) ; 
     std::cout << " SgAsmQuadWordValueExpression has size " << sizeOfActualPool << std::endl;
     SgAsmQuadWordValueExpressionStorageClass* SgAsmQuadWordValueExpressionStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmQuadWordValueExpressionStorageArray = new SgAsmQuadWordValueExpressionStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmQuadWordValueExpression_initializeStorageClassArray (SgAsmQuadWordValueExpressionStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmRegisterReferenceExpression ) ; 
     std::cout << " SgAsmRegisterReferenceExpression has size " << sizeOfActualPool << std::endl;
     SgAsmRegisterReferenceExpressionStorageClass* SgAsmRegisterReferenceExpressionStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmRegisterReferenceExpressionStorageArray = new SgAsmRegisterReferenceExpressionStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmRegisterReferenceExpression_initializeStorageClassArray (SgAsmRegisterReferenceExpressionStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmSingleFloatValueExpression ) ; 
     std::cout << " SgAsmSingleFloatValueExpression has size " << sizeOfActualPool << std::endl;
     SgAsmSingleFloatValueExpressionStorageClass* SgAsmSingleFloatValueExpressionStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmSingleFloatValueExpressionStorageArray = new SgAsmSingleFloatValueExpressionStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmSingleFloatValueExpression_initializeStorageClassArray (SgAsmSingleFloatValueExpressionStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmStatement ) ; 
     std::cout << " SgAsmStatement has size " << sizeOfActualPool << std::endl;
     SgAsmStatementStorageClass* SgAsmStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmStatementStorageArray = new SgAsmStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmStatement_initializeStorageClassArray (SgAsmStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmStaticData ) ; 
     std::cout << " SgAsmStaticData has size " << sizeOfActualPool << std::endl;
     SgAsmStaticDataStorageClass* SgAsmStaticDataStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmStaticDataStorageArray = new SgAsmStaticDataStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmStaticData_initializeStorageClassArray (SgAsmStaticDataStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmStmt ) ; 
     std::cout << " SgAsmStmt has size " << sizeOfActualPool << std::endl;
     SgAsmStmtStorageClass* SgAsmStmtStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmStmtStorageArray = new SgAsmStmtStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmStmt_initializeStorageClassArray (SgAsmStmtStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmStoredString ) ; 
     std::cout << " SgAsmStoredString has size " << sizeOfActualPool << std::endl;
     SgAsmStoredStringStorageClass* SgAsmStoredStringStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmStoredStringStorageArray = new SgAsmStoredStringStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmStoredString_initializeStorageClassArray (SgAsmStoredStringStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmStringStorage ) ; 
     std::cout << " SgAsmStringStorage has size " << sizeOfActualPool << std::endl;
     SgAsmStringStorageStorageClass* SgAsmStringStorageStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmStringStorageStorageArray = new SgAsmStringStorageStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmStringStorage_initializeStorageClassArray (SgAsmStringStorageStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmType ) ; 
     std::cout << " SgAsmType has size " << sizeOfActualPool << std::endl;
     SgAsmTypeStorageClass* SgAsmTypeStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmTypeStorageArray = new SgAsmTypeStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmType_initializeStorageClassArray (SgAsmTypeStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmType128bitFloat ) ; 
     std::cout << " SgAsmType128bitFloat has size " << sizeOfActualPool << std::endl;
     SgAsmType128bitFloatStorageClass* SgAsmType128bitFloatStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmType128bitFloatStorageArray = new SgAsmType128bitFloatStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmType128bitFloat_initializeStorageClassArray (SgAsmType128bitFloatStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmType80bitFloat ) ; 
     std::cout << " SgAsmType80bitFloat has size " << sizeOfActualPool << std::endl;
     SgAsmType80bitFloatStorageClass* SgAsmType80bitFloatStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmType80bitFloatStorageArray = new SgAsmType80bitFloatStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmType80bitFloat_initializeStorageClassArray (SgAsmType80bitFloatStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmTypeByte ) ; 
     std::cout << " SgAsmTypeByte has size " << sizeOfActualPool << std::endl;
     SgAsmTypeByteStorageClass* SgAsmTypeByteStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmTypeByteStorageArray = new SgAsmTypeByteStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmTypeByte_initializeStorageClassArray (SgAsmTypeByteStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmTypeDoubleFloat ) ; 
     std::cout << " SgAsmTypeDoubleFloat has size " << sizeOfActualPool << std::endl;
     SgAsmTypeDoubleFloatStorageClass* SgAsmTypeDoubleFloatStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmTypeDoubleFloatStorageArray = new SgAsmTypeDoubleFloatStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmTypeDoubleFloat_initializeStorageClassArray (SgAsmTypeDoubleFloatStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmTypeDoubleQuadWord ) ; 
     std::cout << " SgAsmTypeDoubleQuadWord has size " << sizeOfActualPool << std::endl;
     SgAsmTypeDoubleQuadWordStorageClass* SgAsmTypeDoubleQuadWordStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmTypeDoubleQuadWordStorageArray = new SgAsmTypeDoubleQuadWordStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmTypeDoubleQuadWord_initializeStorageClassArray (SgAsmTypeDoubleQuadWordStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmTypeDoubleWord ) ; 
     std::cout << " SgAsmTypeDoubleWord has size " << sizeOfActualPool << std::endl;
     SgAsmTypeDoubleWordStorageClass* SgAsmTypeDoubleWordStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmTypeDoubleWordStorageArray = new SgAsmTypeDoubleWordStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmTypeDoubleWord_initializeStorageClassArray (SgAsmTypeDoubleWordStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmTypeQuadWord ) ; 
     std::cout << " SgAsmTypeQuadWord has size " << sizeOfActualPool << std::endl;
     SgAsmTypeQuadWordStorageClass* SgAsmTypeQuadWordStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmTypeQuadWordStorageArray = new SgAsmTypeQuadWordStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmTypeQuadWord_initializeStorageClassArray (SgAsmTypeQuadWordStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmTypeSingleFloat ) ; 
     std::cout << " SgAsmTypeSingleFloat has size " << sizeOfActualPool << std::endl;
     SgAsmTypeSingleFloatStorageClass* SgAsmTypeSingleFloatStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmTypeSingleFloatStorageArray = new SgAsmTypeSingleFloatStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmTypeSingleFloat_initializeStorageClassArray (SgAsmTypeSingleFloatStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmTypeVector ) ; 
     std::cout << " SgAsmTypeVector has size " << sizeOfActualPool << std::endl;
     SgAsmTypeVectorStorageClass* SgAsmTypeVectorStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmTypeVectorStorageArray = new SgAsmTypeVectorStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmTypeVector_initializeStorageClassArray (SgAsmTypeVectorStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmTypeWord ) ; 
     std::cout << " SgAsmTypeWord has size " << sizeOfActualPool << std::endl;
     SgAsmTypeWordStorageClass* SgAsmTypeWordStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmTypeWordStorageArray = new SgAsmTypeWordStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmTypeWord_initializeStorageClassArray (SgAsmTypeWordStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmUnaryArmSpecialRegisterList ) ; 
     std::cout << " SgAsmUnaryArmSpecialRegisterList has size " << sizeOfActualPool << std::endl;
     SgAsmUnaryArmSpecialRegisterListStorageClass* SgAsmUnaryArmSpecialRegisterListStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmUnaryArmSpecialRegisterListStorageArray = new SgAsmUnaryArmSpecialRegisterListStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmUnaryArmSpecialRegisterList_initializeStorageClassArray (SgAsmUnaryArmSpecialRegisterListStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmUnaryExpression ) ; 
     std::cout << " SgAsmUnaryExpression has size " << sizeOfActualPool << std::endl;
     SgAsmUnaryExpressionStorageClass* SgAsmUnaryExpressionStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmUnaryExpressionStorageArray = new SgAsmUnaryExpressionStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmUnaryExpression_initializeStorageClassArray (SgAsmUnaryExpressionStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmUnaryMinus ) ; 
     std::cout << " SgAsmUnaryMinus has size " << sizeOfActualPool << std::endl;
     SgAsmUnaryMinusStorageClass* SgAsmUnaryMinusStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmUnaryMinusStorageArray = new SgAsmUnaryMinusStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmUnaryMinus_initializeStorageClassArray (SgAsmUnaryMinusStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmUnaryPlus ) ; 
     std::cout << " SgAsmUnaryPlus has size " << sizeOfActualPool << std::endl;
     SgAsmUnaryPlusStorageClass* SgAsmUnaryPlusStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmUnaryPlusStorageArray = new SgAsmUnaryPlusStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmUnaryPlus_initializeStorageClassArray (SgAsmUnaryPlusStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmUnaryRrx ) ; 
     std::cout << " SgAsmUnaryRrx has size " << sizeOfActualPool << std::endl;
     SgAsmUnaryRrxStorageClass* SgAsmUnaryRrxStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmUnaryRrxStorageArray = new SgAsmUnaryRrxStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmUnaryRrx_initializeStorageClassArray (SgAsmUnaryRrxStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmValueExpression ) ; 
     std::cout << " SgAsmValueExpression has size " << sizeOfActualPool << std::endl;
     SgAsmValueExpressionStorageClass* SgAsmValueExpressionStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmValueExpressionStorageArray = new SgAsmValueExpressionStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmValueExpression_initializeStorageClassArray (SgAsmValueExpressionStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmVectorValueExpression ) ; 
     std::cout << " SgAsmVectorValueExpression has size " << sizeOfActualPool << std::endl;
     SgAsmVectorValueExpressionStorageClass* SgAsmVectorValueExpressionStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmVectorValueExpressionStorageArray = new SgAsmVectorValueExpressionStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmVectorValueExpression_initializeStorageClassArray (SgAsmVectorValueExpressionStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmWordValueExpression ) ; 
     std::cout << " SgAsmWordValueExpression has size " << sizeOfActualPool << std::endl;
     SgAsmWordValueExpressionStorageClass* SgAsmWordValueExpressionStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmWordValueExpressionStorageArray = new SgAsmWordValueExpressionStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmWordValueExpression_initializeStorageClassArray (SgAsmWordValueExpressionStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmx86Instruction ) ; 
     std::cout << " SgAsmx86Instruction has size " << sizeOfActualPool << std::endl;
     SgAsmx86InstructionStorageClass* SgAsmx86InstructionStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmx86InstructionStorageArray = new SgAsmx86InstructionStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmx86Instruction_initializeStorageClassArray (SgAsmx86InstructionStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmx86RegisterReferenceExpression ) ; 
     std::cout << " SgAsmx86RegisterReferenceExpression has size " << sizeOfActualPool << std::endl;
     SgAsmx86RegisterReferenceExpressionStorageClass* SgAsmx86RegisterReferenceExpressionStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmx86RegisterReferenceExpressionStorageArray = new SgAsmx86RegisterReferenceExpressionStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmx86RegisterReferenceExpression_initializeStorageClassArray (SgAsmx86RegisterReferenceExpressionStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmBinaryAddressSymbol ) ; 
     std::cout << " SgAsmBinaryAddressSymbol has size " << sizeOfActualPool << std::endl;
     SgAsmBinaryAddressSymbolStorageClass* SgAsmBinaryAddressSymbolStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmBinaryAddressSymbolStorageArray = new SgAsmBinaryAddressSymbolStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmBinaryAddressSymbol_initializeStorageClassArray (SgAsmBinaryAddressSymbolStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsmBinaryDataSymbol ) ; 
     std::cout << " SgAsmBinaryDataSymbol has size " << sizeOfActualPool << std::endl;
     SgAsmBinaryDataSymbolStorageClass* SgAsmBinaryDataSymbolStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmBinaryDataSymbolStorageArray = new SgAsmBinaryDataSymbolStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsmBinaryDataSymbol_initializeStorageClassArray (SgAsmBinaryDataSymbolStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAssertStmt ) ; 
     std::cout << " SgAssertStmt has size " << sizeOfActualPool << std::endl;
     SgAssertStmtStorageClass* SgAssertStmtStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAssertStmtStorageArray = new SgAssertStmtStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAssertStmt_initializeStorageClassArray (SgAssertStmtStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAssignInitializer ) ; 
     std::cout << " SgAssignInitializer has size " << sizeOfActualPool << std::endl;
     SgAssignInitializerStorageClass* SgAssignInitializerStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAssignInitializerStorageArray = new SgAssignInitializerStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAssignInitializer_initializeStorageClassArray (SgAssignInitializerStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAssignOp ) ; 
     std::cout << " SgAssignOp has size " << sizeOfActualPool << std::endl;
     SgAssignOpStorageClass* SgAssignOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAssignOpStorageArray = new SgAssignOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAssignOp_initializeStorageClassArray (SgAssignOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAssignStatement ) ; 
     std::cout << " SgAssignStatement has size " << sizeOfActualPool << std::endl;
     SgAssignStatementStorageClass* SgAssignStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAssignStatementStorageArray = new SgAssignStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAssignStatement_initializeStorageClassArray (SgAssignStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAssignedGotoStatement ) ; 
     std::cout << " SgAssignedGotoStatement has size " << sizeOfActualPool << std::endl;
     SgAssignedGotoStatementStorageClass* SgAssignedGotoStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAssignedGotoStatementStorageArray = new SgAssignedGotoStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAssignedGotoStatement_initializeStorageClassArray (SgAssignedGotoStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAssociateStatement ) ; 
     std::cout << " SgAssociateStatement has size " << sizeOfActualPool << std::endl;
     SgAssociateStatementStorageClass* SgAssociateStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAssociateStatementStorageArray = new SgAssociateStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAssociateStatement_initializeStorageClassArray (SgAssociateStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAsteriskShapeExp ) ; 
     std::cout << " SgAsteriskShapeExp has size " << sizeOfActualPool << std::endl;
     SgAsteriskShapeExpStorageClass* SgAsteriskShapeExpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsteriskShapeExpStorageArray = new SgAsteriskShapeExpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAsteriskShapeExp_initializeStorageClassArray (SgAsteriskShapeExpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAttribute ) ; 
     std::cout << " SgAttribute has size " << sizeOfActualPool << std::endl;
     SgAttributeStorageClass* SgAttributeStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAttributeStorageArray = new SgAttributeStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAttribute_initializeStorageClassArray (SgAttributeStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgAttributeSpecificationStatement ) ; 
     std::cout << " SgAttributeSpecificationStatement has size " << sizeOfActualPool << std::endl;
     SgAttributeSpecificationStatementStorageClass* SgAttributeSpecificationStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAttributeSpecificationStatementStorageArray = new SgAttributeSpecificationStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgAttributeSpecificationStatement_initializeStorageClassArray (SgAttributeSpecificationStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgBackspaceStatement ) ; 
     std::cout << " SgBackspaceStatement has size " << sizeOfActualPool << std::endl;
     SgBackspaceStatementStorageClass* SgBackspaceStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgBackspaceStatementStorageArray = new SgBackspaceStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgBackspaceStatement_initializeStorageClassArray (SgBackspaceStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgBaseClass ) ; 
     std::cout << " SgBaseClass has size " << sizeOfActualPool << std::endl;
     SgBaseClassStorageClass* SgBaseClassStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgBaseClassStorageArray = new SgBaseClassStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgBaseClass_initializeStorageClassArray (SgBaseClassStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgExpBaseClass ) ; 
     std::cout << " SgExpBaseClass has size " << sizeOfActualPool << std::endl;
     SgExpBaseClassStorageClass* SgExpBaseClassStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgExpBaseClassStorageArray = new SgExpBaseClassStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgExpBaseClass_initializeStorageClassArray (SgExpBaseClassStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgBaseClassModifier ) ; 
     std::cout << " SgBaseClassModifier has size " << sizeOfActualPool << std::endl;
     SgBaseClassModifierStorageClass* SgBaseClassModifierStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgBaseClassModifierStorageArray = new SgBaseClassModifierStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgBaseClassModifier_initializeStorageClassArray (SgBaseClassModifierStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgBasicBlock ) ; 
     std::cout << " SgBasicBlock has size " << sizeOfActualPool << std::endl;
     SgBasicBlockStorageClass* SgBasicBlockStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgBasicBlockStorageArray = new SgBasicBlockStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgBasicBlock_initializeStorageClassArray (SgBasicBlockStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgBidirectionalGraph ) ; 
     std::cout << " SgBidirectionalGraph has size " << sizeOfActualPool << std::endl;
     SgBidirectionalGraphStorageClass* SgBidirectionalGraphStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgBidirectionalGraphStorageArray = new SgBidirectionalGraphStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgBidirectionalGraph_initializeStorageClassArray (SgBidirectionalGraphStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgBinaryComposite ) ; 
     std::cout << " SgBinaryComposite has size " << sizeOfActualPool << std::endl;
     SgBinaryCompositeStorageClass* SgBinaryCompositeStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgBinaryCompositeStorageArray = new SgBinaryCompositeStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgBinaryComposite_initializeStorageClassArray (SgBinaryCompositeStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgBinaryOp ) ; 
     std::cout << " SgBinaryOp has size " << sizeOfActualPool << std::endl;
     SgBinaryOpStorageClass* SgBinaryOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgBinaryOpStorageArray = new SgBinaryOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgBinaryOp_initializeStorageClassArray (SgBinaryOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgBitAndOp ) ; 
     std::cout << " SgBitAndOp has size " << sizeOfActualPool << std::endl;
     SgBitAndOpStorageClass* SgBitAndOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgBitAndOpStorageArray = new SgBitAndOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgBitAndOp_initializeStorageClassArray (SgBitAndOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgBitAttribute ) ; 
     std::cout << " SgBitAttribute has size " << sizeOfActualPool << std::endl;
     SgBitAttributeStorageClass* SgBitAttributeStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgBitAttributeStorageArray = new SgBitAttributeStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgBitAttribute_initializeStorageClassArray (SgBitAttributeStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgBitComplementOp ) ; 
     std::cout << " SgBitComplementOp has size " << sizeOfActualPool << std::endl;
     SgBitComplementOpStorageClass* SgBitComplementOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgBitComplementOpStorageArray = new SgBitComplementOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgBitComplementOp_initializeStorageClassArray (SgBitComplementOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgBitOrOp ) ; 
     std::cout << " SgBitOrOp has size " << sizeOfActualPool << std::endl;
     SgBitOrOpStorageClass* SgBitOrOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgBitOrOpStorageArray = new SgBitOrOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgBitOrOp_initializeStorageClassArray (SgBitOrOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgBitXorOp ) ; 
     std::cout << " SgBitXorOp has size " << sizeOfActualPool << std::endl;
     SgBitXorOpStorageClass* SgBitXorOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgBitXorOpStorageArray = new SgBitXorOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgBitXorOp_initializeStorageClassArray (SgBitXorOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgBlockDataStatement ) ; 
     std::cout << " SgBlockDataStatement has size " << sizeOfActualPool << std::endl;
     SgBlockDataStatementStorageClass* SgBlockDataStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgBlockDataStatementStorageArray = new SgBlockDataStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgBlockDataStatement_initializeStorageClassArray (SgBlockDataStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgBoolValExp ) ; 
     std::cout << " SgBoolValExp has size " << sizeOfActualPool << std::endl;
     SgBoolValExpStorageClass* SgBoolValExpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgBoolValExpStorageArray = new SgBoolValExpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgBoolValExp_initializeStorageClassArray (SgBoolValExpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgBreakStmt ) ; 
     std::cout << " SgBreakStmt has size " << sizeOfActualPool << std::endl;
     SgBreakStmtStorageClass* SgBreakStmtStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgBreakStmtStorageArray = new SgBreakStmtStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgBreakStmt_initializeStorageClassArray (SgBreakStmtStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgC_PreprocessorDirectiveStatement ) ; 
     std::cout << " SgC_PreprocessorDirectiveStatement has size " << sizeOfActualPool << std::endl;
     SgC_PreprocessorDirectiveStatementStorageClass* SgC_PreprocessorDirectiveStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgC_PreprocessorDirectiveStatementStorageArray = new SgC_PreprocessorDirectiveStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgC_PreprocessorDirectiveStatement_initializeStorageClassArray (SgC_PreprocessorDirectiveStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgCaseOptionStmt ) ; 
     std::cout << " SgCaseOptionStmt has size " << sizeOfActualPool << std::endl;
     SgCaseOptionStmtStorageClass* SgCaseOptionStmtStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgCaseOptionStmtStorageArray = new SgCaseOptionStmtStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgCaseOptionStmt_initializeStorageClassArray (SgCaseOptionStmtStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgCastExp ) ; 
     std::cout << " SgCastExp has size " << sizeOfActualPool << std::endl;
     SgCastExpStorageClass* SgCastExpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgCastExpStorageArray = new SgCastExpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgCastExp_initializeStorageClassArray (SgCastExpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgCatchOptionStmt ) ; 
     std::cout << " SgCatchOptionStmt has size " << sizeOfActualPool << std::endl;
     SgCatchOptionStmtStorageClass* SgCatchOptionStmtStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgCatchOptionStmtStorageArray = new SgCatchOptionStmtStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgCatchOptionStmt_initializeStorageClassArray (SgCatchOptionStmtStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgCatchStatementSeq ) ; 
     std::cout << " SgCatchStatementSeq has size " << sizeOfActualPool << std::endl;
     SgCatchStatementSeqStorageClass* SgCatchStatementSeqStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgCatchStatementSeqStorageArray = new SgCatchStatementSeqStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgCatchStatementSeq_initializeStorageClassArray (SgCatchStatementSeqStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgCharVal ) ; 
     std::cout << " SgCharVal has size " << sizeOfActualPool << std::endl;
     SgCharValStorageClass* SgCharValStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgCharValStorageArray = new SgCharValStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgCharVal_initializeStorageClassArray (SgCharValStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgClassDecl_attr ) ; 
     std::cout << " SgClassDecl_attr has size " << sizeOfActualPool << std::endl;
     SgClassDecl_attrStorageClass* SgClassDecl_attrStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgClassDecl_attrStorageArray = new SgClassDecl_attrStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgClassDecl_attr_initializeStorageClassArray (SgClassDecl_attrStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgClassDeclaration ) ; 
     std::cout << " SgClassDeclaration has size " << sizeOfActualPool << std::endl;
     SgClassDeclarationStorageClass* SgClassDeclarationStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgClassDeclarationStorageArray = new SgClassDeclarationStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgClassDeclaration_initializeStorageClassArray (SgClassDeclarationStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgClassDefinition ) ; 
     std::cout << " SgClassDefinition has size " << sizeOfActualPool << std::endl;
     SgClassDefinitionStorageClass* SgClassDefinitionStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgClassDefinitionStorageArray = new SgClassDefinitionStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgClassDefinition_initializeStorageClassArray (SgClassDefinitionStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgClassNameRefExp ) ; 
     std::cout << " SgClassNameRefExp has size " << sizeOfActualPool << std::endl;
     SgClassNameRefExpStorageClass* SgClassNameRefExpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgClassNameRefExpStorageArray = new SgClassNameRefExpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgClassNameRefExp_initializeStorageClassArray (SgClassNameRefExpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgClassSymbol ) ; 
     std::cout << " SgClassSymbol has size " << sizeOfActualPool << std::endl;
     SgClassSymbolStorageClass* SgClassSymbolStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgClassSymbolStorageArray = new SgClassSymbolStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgClassSymbol_initializeStorageClassArray (SgClassSymbolStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgClassType ) ; 
     std::cout << " SgClassType has size " << sizeOfActualPool << std::endl;
     SgClassTypeStorageClass* SgClassTypeStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgClassTypeStorageArray = new SgClassTypeStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgClassType_initializeStorageClassArray (SgClassTypeStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgClinkageDeclarationStatement ) ; 
     std::cout << " SgClinkageDeclarationStatement has size " << sizeOfActualPool << std::endl;
     SgClinkageDeclarationStatementStorageClass* SgClinkageDeclarationStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgClinkageDeclarationStatementStorageArray = new SgClinkageDeclarationStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgClinkageDeclarationStatement_initializeStorageClassArray (SgClinkageDeclarationStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgClinkageEndStatement ) ; 
     std::cout << " SgClinkageEndStatement has size " << sizeOfActualPool << std::endl;
     SgClinkageEndStatementStorageClass* SgClinkageEndStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgClinkageEndStatementStorageArray = new SgClinkageEndStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgClinkageEndStatement_initializeStorageClassArray (SgClinkageEndStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgClinkageStartStatement ) ; 
     std::cout << " SgClinkageStartStatement has size " << sizeOfActualPool << std::endl;
     SgClinkageStartStatementStorageClass* SgClinkageStartStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgClinkageStartStatementStorageArray = new SgClinkageStartStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgClinkageStartStatement_initializeStorageClassArray (SgClinkageStartStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgCloseStatement ) ; 
     std::cout << " SgCloseStatement has size " << sizeOfActualPool << std::endl;
     SgCloseStatementStorageClass* SgCloseStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgCloseStatementStorageArray = new SgCloseStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgCloseStatement_initializeStorageClassArray (SgCloseStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgColonShapeExp ) ; 
     std::cout << " SgColonShapeExp has size " << sizeOfActualPool << std::endl;
     SgColonShapeExpStorageClass* SgColonShapeExpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgColonShapeExpStorageArray = new SgColonShapeExpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgColonShapeExp_initializeStorageClassArray (SgColonShapeExpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgCommaOpExp ) ; 
     std::cout << " SgCommaOpExp has size " << sizeOfActualPool << std::endl;
     SgCommaOpExpStorageClass* SgCommaOpExpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgCommaOpExpStorageArray = new SgCommaOpExpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgCommaOpExp_initializeStorageClassArray (SgCommaOpExpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgCommonBlock ) ; 
     std::cout << " SgCommonBlock has size " << sizeOfActualPool << std::endl;
     SgCommonBlockStorageClass* SgCommonBlockStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgCommonBlockStorageArray = new SgCommonBlockStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgCommonBlock_initializeStorageClassArray (SgCommonBlockStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgCommonBlockObject ) ; 
     std::cout << " SgCommonBlockObject has size " << sizeOfActualPool << std::endl;
     SgCommonBlockObjectStorageClass* SgCommonBlockObjectStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgCommonBlockObjectStorageArray = new SgCommonBlockObjectStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgCommonBlockObject_initializeStorageClassArray (SgCommonBlockObjectStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgCommonSymbol ) ; 
     std::cout << " SgCommonSymbol has size " << sizeOfActualPool << std::endl;
     SgCommonSymbolStorageClass* SgCommonSymbolStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgCommonSymbolStorageArray = new SgCommonSymbolStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgCommonSymbol_initializeStorageClassArray (SgCommonSymbolStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgComplexVal ) ; 
     std::cout << " SgComplexVal has size " << sizeOfActualPool << std::endl;
     SgComplexValStorageClass* SgComplexValStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgComplexValStorageArray = new SgComplexValStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgComplexVal_initializeStorageClassArray (SgComplexValStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgComprehension ) ; 
     std::cout << " SgComprehension has size " << sizeOfActualPool << std::endl;
     SgComprehensionStorageClass* SgComprehensionStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgComprehensionStorageArray = new SgComprehensionStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgComprehension_initializeStorageClassArray (SgComprehensionStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgCompoundAssignOp ) ; 
     std::cout << " SgCompoundAssignOp has size " << sizeOfActualPool << std::endl;
     SgCompoundAssignOpStorageClass* SgCompoundAssignOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgCompoundAssignOpStorageArray = new SgCompoundAssignOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgCompoundAssignOp_initializeStorageClassArray (SgCompoundAssignOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgCompoundInitializer ) ; 
     std::cout << " SgCompoundInitializer has size " << sizeOfActualPool << std::endl;
     SgCompoundInitializerStorageClass* SgCompoundInitializerStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgCompoundInitializerStorageArray = new SgCompoundInitializerStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgCompoundInitializer_initializeStorageClassArray (SgCompoundInitializerStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgComputedGotoStatement ) ; 
     std::cout << " SgComputedGotoStatement has size " << sizeOfActualPool << std::endl;
     SgComputedGotoStatementStorageClass* SgComputedGotoStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgComputedGotoStatementStorageArray = new SgComputedGotoStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgComputedGotoStatement_initializeStorageClassArray (SgComputedGotoStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgConcatenationOp ) ; 
     std::cout << " SgConcatenationOp has size " << sizeOfActualPool << std::endl;
     SgConcatenationOpStorageClass* SgConcatenationOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgConcatenationOpStorageArray = new SgConcatenationOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgConcatenationOp_initializeStorageClassArray (SgConcatenationOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgConditionalExp ) ; 
     std::cout << " SgConditionalExp has size " << sizeOfActualPool << std::endl;
     SgConditionalExpStorageClass* SgConditionalExpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgConditionalExpStorageArray = new SgConditionalExpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgConditionalExp_initializeStorageClassArray (SgConditionalExpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgConjugateOp ) ; 
     std::cout << " SgConjugateOp has size " << sizeOfActualPool << std::endl;
     SgConjugateOpStorageClass* SgConjugateOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgConjugateOpStorageArray = new SgConjugateOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgConjugateOp_initializeStorageClassArray (SgConjugateOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgConstVolatileModifier ) ; 
     std::cout << " SgConstVolatileModifier has size " << sizeOfActualPool << std::endl;
     SgConstVolatileModifierStorageClass* SgConstVolatileModifierStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgConstVolatileModifierStorageArray = new SgConstVolatileModifierStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgConstVolatileModifier_initializeStorageClassArray (SgConstVolatileModifierStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgConstructorInitializer ) ; 
     std::cout << " SgConstructorInitializer has size " << sizeOfActualPool << std::endl;
     SgConstructorInitializerStorageClass* SgConstructorInitializerStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgConstructorInitializerStorageArray = new SgConstructorInitializerStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgConstructorInitializer_initializeStorageClassArray (SgConstructorInitializerStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgContainsStatement ) ; 
     std::cout << " SgContainsStatement has size " << sizeOfActualPool << std::endl;
     SgContainsStatementStorageClass* SgContainsStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgContainsStatementStorageArray = new SgContainsStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgContainsStatement_initializeStorageClassArray (SgContainsStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgContinueStmt ) ; 
     std::cout << " SgContinueStmt has size " << sizeOfActualPool << std::endl;
     SgContinueStmtStorageClass* SgContinueStmtStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgContinueStmtStorageArray = new SgContinueStmtStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgContinueStmt_initializeStorageClassArray (SgContinueStmtStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgCtorInitializerList ) ; 
     std::cout << " SgCtorInitializerList has size " << sizeOfActualPool << std::endl;
     SgCtorInitializerListStorageClass* SgCtorInitializerListStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgCtorInitializerListStorageArray = new SgCtorInitializerListStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgCtorInitializerList_initializeStorageClassArray (SgCtorInitializerListStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgDataStatementGroup ) ; 
     std::cout << " SgDataStatementGroup has size " << sizeOfActualPool << std::endl;
     SgDataStatementGroupStorageClass* SgDataStatementGroupStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgDataStatementGroupStorageArray = new SgDataStatementGroupStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgDataStatementGroup_initializeStorageClassArray (SgDataStatementGroupStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgDataStatementObject ) ; 
     std::cout << " SgDataStatementObject has size " << sizeOfActualPool << std::endl;
     SgDataStatementObjectStorageClass* SgDataStatementObjectStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgDataStatementObjectStorageArray = new SgDataStatementObjectStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgDataStatementObject_initializeStorageClassArray (SgDataStatementObjectStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgDataStatementValue ) ; 
     std::cout << " SgDataStatementValue has size " << sizeOfActualPool << std::endl;
     SgDataStatementValueStorageClass* SgDataStatementValueStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgDataStatementValueStorageArray = new SgDataStatementValueStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgDataStatementValue_initializeStorageClassArray (SgDataStatementValueStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgDeadIfDirectiveStatement ) ; 
     std::cout << " SgDeadIfDirectiveStatement has size " << sizeOfActualPool << std::endl;
     SgDeadIfDirectiveStatementStorageClass* SgDeadIfDirectiveStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgDeadIfDirectiveStatementStorageArray = new SgDeadIfDirectiveStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgDeadIfDirectiveStatement_initializeStorageClassArray (SgDeadIfDirectiveStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgDeallocateStatement ) ; 
     std::cout << " SgDeallocateStatement has size " << sizeOfActualPool << std::endl;
     SgDeallocateStatementStorageClass* SgDeallocateStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgDeallocateStatementStorageArray = new SgDeallocateStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgDeallocateStatement_initializeStorageClassArray (SgDeallocateStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgDeclarationModifier ) ; 
     std::cout << " SgDeclarationModifier has size " << sizeOfActualPool << std::endl;
     SgDeclarationModifierStorageClass* SgDeclarationModifierStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgDeclarationModifierStorageArray = new SgDeclarationModifierStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgDeclarationModifier_initializeStorageClassArray (SgDeclarationModifierStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgDeclarationStatement ) ; 
     std::cout << " SgDeclarationStatement has size " << sizeOfActualPool << std::endl;
     SgDeclarationStatementStorageClass* SgDeclarationStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgDeclarationStatementStorageArray = new SgDeclarationStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgDeclarationStatement_initializeStorageClassArray (SgDeclarationStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgDefaultOptionStmt ) ; 
     std::cout << " SgDefaultOptionStmt has size " << sizeOfActualPool << std::endl;
     SgDefaultOptionStmtStorageClass* SgDefaultOptionStmtStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgDefaultOptionStmtStorageArray = new SgDefaultOptionStmtStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgDefaultOptionStmt_initializeStorageClassArray (SgDefaultOptionStmtStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgDefaultSymbol ) ; 
     std::cout << " SgDefaultSymbol has size " << sizeOfActualPool << std::endl;
     SgDefaultSymbolStorageClass* SgDefaultSymbolStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgDefaultSymbolStorageArray = new SgDefaultSymbolStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgDefaultSymbol_initializeStorageClassArray (SgDefaultSymbolStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgDefineDirectiveStatement ) ; 
     std::cout << " SgDefineDirectiveStatement has size " << sizeOfActualPool << std::endl;
     SgDefineDirectiveStatementStorageClass* SgDefineDirectiveStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgDefineDirectiveStatementStorageArray = new SgDefineDirectiveStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgDefineDirectiveStatement_initializeStorageClassArray (SgDefineDirectiveStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgDeleteExp ) ; 
     std::cout << " SgDeleteExp has size " << sizeOfActualPool << std::endl;
     SgDeleteExpStorageClass* SgDeleteExpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgDeleteExpStorageArray = new SgDeleteExpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgDeleteExp_initializeStorageClassArray (SgDeleteExpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgDerivedTypeStatement ) ; 
     std::cout << " SgDerivedTypeStatement has size " << sizeOfActualPool << std::endl;
     SgDerivedTypeStatementStorageClass* SgDerivedTypeStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgDerivedTypeStatementStorageArray = new SgDerivedTypeStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgDerivedTypeStatement_initializeStorageClassArray (SgDerivedTypeStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgDesignatedInitializer ) ; 
     std::cout << " SgDesignatedInitializer has size " << sizeOfActualPool << std::endl;
     SgDesignatedInitializerStorageClass* SgDesignatedInitializerStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgDesignatedInitializerStorageArray = new SgDesignatedInitializerStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgDesignatedInitializer_initializeStorageClassArray (SgDesignatedInitializerStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgDictionaryComprehension ) ; 
     std::cout << " SgDictionaryComprehension has size " << sizeOfActualPool << std::endl;
     SgDictionaryComprehensionStorageClass* SgDictionaryComprehensionStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgDictionaryComprehensionStorageArray = new SgDictionaryComprehensionStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgDictionaryComprehension_initializeStorageClassArray (SgDictionaryComprehensionStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgDictionaryExp ) ; 
     std::cout << " SgDictionaryExp has size " << sizeOfActualPool << std::endl;
     SgDictionaryExpStorageClass* SgDictionaryExpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgDictionaryExpStorageArray = new SgDictionaryExpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgDictionaryExp_initializeStorageClassArray (SgDictionaryExpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgDimensionObject ) ; 
     std::cout << " SgDimensionObject has size " << sizeOfActualPool << std::endl;
     SgDimensionObjectStorageClass* SgDimensionObjectStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgDimensionObjectStorageArray = new SgDimensionObjectStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgDimensionObject_initializeStorageClassArray (SgDimensionObjectStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgDirectedGraphEdge ) ; 
     std::cout << " SgDirectedGraphEdge has size " << sizeOfActualPool << std::endl;
     SgDirectedGraphEdgeStorageClass* SgDirectedGraphEdgeStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgDirectedGraphEdgeStorageArray = new SgDirectedGraphEdgeStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgDirectedGraphEdge_initializeStorageClassArray (SgDirectedGraphEdgeStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgDirectory ) ; 
     std::cout << " SgDirectory has size " << sizeOfActualPool << std::endl;
     SgDirectoryStorageClass* SgDirectoryStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgDirectoryStorageArray = new SgDirectoryStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgDirectory_initializeStorageClassArray (SgDirectoryStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgDirectoryList ) ; 
     std::cout << " SgDirectoryList has size " << sizeOfActualPool << std::endl;
     SgDirectoryListStorageClass* SgDirectoryListStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgDirectoryListStorageArray = new SgDirectoryListStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgDirectoryList_initializeStorageClassArray (SgDirectoryListStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgDivAssignOp ) ; 
     std::cout << " SgDivAssignOp has size " << sizeOfActualPool << std::endl;
     SgDivAssignOpStorageClass* SgDivAssignOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgDivAssignOpStorageArray = new SgDivAssignOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgDivAssignOp_initializeStorageClassArray (SgDivAssignOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgDivideOp ) ; 
     std::cout << " SgDivideOp has size " << sizeOfActualPool << std::endl;
     SgDivideOpStorageClass* SgDivideOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgDivideOpStorageArray = new SgDivideOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgDivideOp_initializeStorageClassArray (SgDivideOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgDoWhileStmt ) ; 
     std::cout << " SgDoWhileStmt has size " << sizeOfActualPool << std::endl;
     SgDoWhileStmtStorageClass* SgDoWhileStmtStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgDoWhileStmtStorageArray = new SgDoWhileStmtStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgDoWhileStmt_initializeStorageClassArray (SgDoWhileStmtStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgDotExp ) ; 
     std::cout << " SgDotExp has size " << sizeOfActualPool << std::endl;
     SgDotExpStorageClass* SgDotExpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgDotExpStorageArray = new SgDotExpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgDotExp_initializeStorageClassArray (SgDotExpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgDotStarOp ) ; 
     std::cout << " SgDotStarOp has size " << sizeOfActualPool << std::endl;
     SgDotStarOpStorageClass* SgDotStarOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgDotStarOpStorageArray = new SgDotStarOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgDotStarOp_initializeStorageClassArray (SgDotStarOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgDoubleVal ) ; 
     std::cout << " SgDoubleVal has size " << sizeOfActualPool << std::endl;
     SgDoubleValStorageClass* SgDoubleValStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgDoubleValStorageArray = new SgDoubleValStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgDoubleVal_initializeStorageClassArray (SgDoubleValStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgElaboratedTypeModifier ) ; 
     std::cout << " SgElaboratedTypeModifier has size " << sizeOfActualPool << std::endl;
     SgElaboratedTypeModifierStorageClass* SgElaboratedTypeModifierStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgElaboratedTypeModifierStorageArray = new SgElaboratedTypeModifierStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgElaboratedTypeModifier_initializeStorageClassArray (SgElaboratedTypeModifierStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgElseDirectiveStatement ) ; 
     std::cout << " SgElseDirectiveStatement has size " << sizeOfActualPool << std::endl;
     SgElseDirectiveStatementStorageClass* SgElseDirectiveStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgElseDirectiveStatementStorageArray = new SgElseDirectiveStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgElseDirectiveStatement_initializeStorageClassArray (SgElseDirectiveStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgElseWhereStatement ) ; 
     std::cout << " SgElseWhereStatement has size " << sizeOfActualPool << std::endl;
     SgElseWhereStatementStorageClass* SgElseWhereStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgElseWhereStatementStorageArray = new SgElseWhereStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgElseWhereStatement_initializeStorageClassArray (SgElseWhereStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgElseifDirectiveStatement ) ; 
     std::cout << " SgElseifDirectiveStatement has size " << sizeOfActualPool << std::endl;
     SgElseifDirectiveStatementStorageClass* SgElseifDirectiveStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgElseifDirectiveStatementStorageArray = new SgElseifDirectiveStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgElseifDirectiveStatement_initializeStorageClassArray (SgElseifDirectiveStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgEmptyDirectiveStatement ) ; 
     std::cout << " SgEmptyDirectiveStatement has size " << sizeOfActualPool << std::endl;
     SgEmptyDirectiveStatementStorageClass* SgEmptyDirectiveStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgEmptyDirectiveStatementStorageArray = new SgEmptyDirectiveStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgEmptyDirectiveStatement_initializeStorageClassArray (SgEmptyDirectiveStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgEndfileStatement ) ; 
     std::cout << " SgEndfileStatement has size " << sizeOfActualPool << std::endl;
     SgEndfileStatementStorageClass* SgEndfileStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgEndfileStatementStorageArray = new SgEndfileStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgEndfileStatement_initializeStorageClassArray (SgEndfileStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgEndifDirectiveStatement ) ; 
     std::cout << " SgEndifDirectiveStatement has size " << sizeOfActualPool << std::endl;
     SgEndifDirectiveStatementStorageClass* SgEndifDirectiveStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgEndifDirectiveStatementStorageArray = new SgEndifDirectiveStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgEndifDirectiveStatement_initializeStorageClassArray (SgEndifDirectiveStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgEntryStatement ) ; 
     std::cout << " SgEntryStatement has size " << sizeOfActualPool << std::endl;
     SgEntryStatementStorageClass* SgEntryStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgEntryStatementStorageArray = new SgEntryStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgEntryStatement_initializeStorageClassArray (SgEntryStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgEnumDeclaration ) ; 
     std::cout << " SgEnumDeclaration has size " << sizeOfActualPool << std::endl;
     SgEnumDeclarationStorageClass* SgEnumDeclarationStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgEnumDeclarationStorageArray = new SgEnumDeclarationStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgEnumDeclaration_initializeStorageClassArray (SgEnumDeclarationStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgEnumFieldSymbol ) ; 
     std::cout << " SgEnumFieldSymbol has size " << sizeOfActualPool << std::endl;
     SgEnumFieldSymbolStorageClass* SgEnumFieldSymbolStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgEnumFieldSymbolStorageArray = new SgEnumFieldSymbolStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgEnumFieldSymbol_initializeStorageClassArray (SgEnumFieldSymbolStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgEnumSymbol ) ; 
     std::cout << " SgEnumSymbol has size " << sizeOfActualPool << std::endl;
     SgEnumSymbolStorageClass* SgEnumSymbolStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgEnumSymbolStorageArray = new SgEnumSymbolStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgEnumSymbol_initializeStorageClassArray (SgEnumSymbolStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgEnumType ) ; 
     std::cout << " SgEnumType has size " << sizeOfActualPool << std::endl;
     SgEnumTypeStorageClass* SgEnumTypeStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgEnumTypeStorageArray = new SgEnumTypeStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgEnumType_initializeStorageClassArray (SgEnumTypeStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgEnumVal ) ; 
     std::cout << " SgEnumVal has size " << sizeOfActualPool << std::endl;
     SgEnumValStorageClass* SgEnumValStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgEnumValStorageArray = new SgEnumValStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgEnumVal_initializeStorageClassArray (SgEnumValStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgEqualityOp ) ; 
     std::cout << " SgEqualityOp has size " << sizeOfActualPool << std::endl;
     SgEqualityOpStorageClass* SgEqualityOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgEqualityOpStorageArray = new SgEqualityOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgEqualityOp_initializeStorageClassArray (SgEqualityOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgEquivalenceStatement ) ; 
     std::cout << " SgEquivalenceStatement has size " << sizeOfActualPool << std::endl;
     SgEquivalenceStatementStorageClass* SgEquivalenceStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgEquivalenceStatementStorageArray = new SgEquivalenceStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgEquivalenceStatement_initializeStorageClassArray (SgEquivalenceStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgErrorDirectiveStatement ) ; 
     std::cout << " SgErrorDirectiveStatement has size " << sizeOfActualPool << std::endl;
     SgErrorDirectiveStatementStorageClass* SgErrorDirectiveStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgErrorDirectiveStatementStorageArray = new SgErrorDirectiveStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgErrorDirectiveStatement_initializeStorageClassArray (SgErrorDirectiveStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgExecStatement ) ; 
     std::cout << " SgExecStatement has size " << sizeOfActualPool << std::endl;
     SgExecStatementStorageClass* SgExecStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgExecStatementStorageArray = new SgExecStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgExecStatement_initializeStorageClassArray (SgExecStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgExponentiationOp ) ; 
     std::cout << " SgExponentiationOp has size " << sizeOfActualPool << std::endl;
     SgExponentiationOpStorageClass* SgExponentiationOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgExponentiationOpStorageArray = new SgExponentiationOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgExponentiationOp_initializeStorageClassArray (SgExponentiationOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgExponentiationAssignOp ) ; 
     std::cout << " SgExponentiationAssignOp has size " << sizeOfActualPool << std::endl;
     SgExponentiationAssignOpStorageClass* SgExponentiationAssignOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgExponentiationAssignOpStorageArray = new SgExponentiationAssignOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgExponentiationAssignOp_initializeStorageClassArray (SgExponentiationAssignOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgExprListExp ) ; 
     std::cout << " SgExprListExp has size " << sizeOfActualPool << std::endl;
     SgExprListExpStorageClass* SgExprListExpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgExprListExpStorageArray = new SgExprListExpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgExprListExp_initializeStorageClassArray (SgExprListExpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgExprStatement ) ; 
     std::cout << " SgExprStatement has size " << sizeOfActualPool << std::endl;
     SgExprStatementStorageClass* SgExprStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgExprStatementStorageArray = new SgExprStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgExprStatement_initializeStorageClassArray (SgExprStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgExpression ) ; 
     std::cout << " SgExpression has size " << sizeOfActualPool << std::endl;
     SgExpressionStorageClass* SgExpressionStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgExpressionStorageArray = new SgExpressionStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgExpression_initializeStorageClassArray (SgExpressionStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgExpressionRoot ) ; 
     std::cout << " SgExpressionRoot has size " << sizeOfActualPool << std::endl;
     SgExpressionRootStorageClass* SgExpressionRootStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgExpressionRootStorageArray = new SgExpressionRootStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgExpressionRoot_initializeStorageClassArray (SgExpressionRootStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgFile ) ; 
     std::cout << " SgFile has size " << sizeOfActualPool << std::endl;
     SgFileStorageClass* SgFileStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgFileStorageArray = new SgFileStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgFile_initializeStorageClassArray (SgFileStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgFileList ) ; 
     std::cout << " SgFileList has size " << sizeOfActualPool << std::endl;
     SgFileListStorageClass* SgFileListStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgFileListStorageArray = new SgFileListStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgFileList_initializeStorageClassArray (SgFileListStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgFloatVal ) ; 
     std::cout << " SgFloatVal has size " << sizeOfActualPool << std::endl;
     SgFloatValStorageClass* SgFloatValStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgFloatValStorageArray = new SgFloatValStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgFloatVal_initializeStorageClassArray (SgFloatValStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgFlushStatement ) ; 
     std::cout << " SgFlushStatement has size " << sizeOfActualPool << std::endl;
     SgFlushStatementStorageClass* SgFlushStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgFlushStatementStorageArray = new SgFlushStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgFlushStatement_initializeStorageClassArray (SgFlushStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgForAllStatement ) ; 
     std::cout << " SgForAllStatement has size " << sizeOfActualPool << std::endl;
     SgForAllStatementStorageClass* SgForAllStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgForAllStatementStorageArray = new SgForAllStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgForAllStatement_initializeStorageClassArray (SgForAllStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgForInitStatement ) ; 
     std::cout << " SgForInitStatement has size " << sizeOfActualPool << std::endl;
     SgForInitStatementStorageClass* SgForInitStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgForInitStatementStorageArray = new SgForInitStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgForInitStatement_initializeStorageClassArray (SgForInitStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgForStatement ) ; 
     std::cout << " SgForStatement has size " << sizeOfActualPool << std::endl;
     SgForStatementStorageClass* SgForStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgForStatementStorageArray = new SgForStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgForStatement_initializeStorageClassArray (SgForStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgFormatItem ) ; 
     std::cout << " SgFormatItem has size " << sizeOfActualPool << std::endl;
     SgFormatItemStorageClass* SgFormatItemStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgFormatItemStorageArray = new SgFormatItemStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgFormatItem_initializeStorageClassArray (SgFormatItemStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgFormatItemList ) ; 
     std::cout << " SgFormatItemList has size " << sizeOfActualPool << std::endl;
     SgFormatItemListStorageClass* SgFormatItemListStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgFormatItemListStorageArray = new SgFormatItemListStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgFormatItemList_initializeStorageClassArray (SgFormatItemListStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgFormatStatement ) ; 
     std::cout << " SgFormatStatement has size " << sizeOfActualPool << std::endl;
     SgFormatStatementStorageClass* SgFormatStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgFormatStatementStorageArray = new SgFormatStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgFormatStatement_initializeStorageClassArray (SgFormatStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgFortranDo ) ; 
     std::cout << " SgFortranDo has size " << sizeOfActualPool << std::endl;
     SgFortranDoStorageClass* SgFortranDoStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgFortranDoStorageArray = new SgFortranDoStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgFortranDo_initializeStorageClassArray (SgFortranDoStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgFortranIncludeLine ) ; 
     std::cout << " SgFortranIncludeLine has size " << sizeOfActualPool << std::endl;
     SgFortranIncludeLineStorageClass* SgFortranIncludeLineStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgFortranIncludeLineStorageArray = new SgFortranIncludeLineStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgFortranIncludeLine_initializeStorageClassArray (SgFortranIncludeLineStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgFortranNonblockedDo ) ; 
     std::cout << " SgFortranNonblockedDo has size " << sizeOfActualPool << std::endl;
     SgFortranNonblockedDoStorageClass* SgFortranNonblockedDoStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgFortranNonblockedDoStorageArray = new SgFortranNonblockedDoStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgFortranNonblockedDo_initializeStorageClassArray (SgFortranNonblockedDoStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgFuncDecl_attr ) ; 
     std::cout << " SgFuncDecl_attr has size " << sizeOfActualPool << std::endl;
     SgFuncDecl_attrStorageClass* SgFuncDecl_attrStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgFuncDecl_attrStorageArray = new SgFuncDecl_attrStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgFuncDecl_attr_initializeStorageClassArray (SgFuncDecl_attrStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgFunctionCallExp ) ; 
     std::cout << " SgFunctionCallExp has size " << sizeOfActualPool << std::endl;
     SgFunctionCallExpStorageClass* SgFunctionCallExpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgFunctionCallExpStorageArray = new SgFunctionCallExpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgFunctionCallExp_initializeStorageClassArray (SgFunctionCallExpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgFunctionDeclaration ) ; 
     std::cout << " SgFunctionDeclaration has size " << sizeOfActualPool << std::endl;
     SgFunctionDeclarationStorageClass* SgFunctionDeclarationStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgFunctionDeclarationStorageArray = new SgFunctionDeclarationStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgFunctionDeclaration_initializeStorageClassArray (SgFunctionDeclarationStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgFunctionDefinition ) ; 
     std::cout << " SgFunctionDefinition has size " << sizeOfActualPool << std::endl;
     SgFunctionDefinitionStorageClass* SgFunctionDefinitionStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgFunctionDefinitionStorageArray = new SgFunctionDefinitionStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgFunctionDefinition_initializeStorageClassArray (SgFunctionDefinitionStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgFunctionModifier ) ; 
     std::cout << " SgFunctionModifier has size " << sizeOfActualPool << std::endl;
     SgFunctionModifierStorageClass* SgFunctionModifierStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgFunctionModifierStorageArray = new SgFunctionModifierStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgFunctionModifier_initializeStorageClassArray (SgFunctionModifierStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgFunctionParameterList ) ; 
     std::cout << " SgFunctionParameterList has size " << sizeOfActualPool << std::endl;
     SgFunctionParameterListStorageClass* SgFunctionParameterListStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgFunctionParameterListStorageArray = new SgFunctionParameterListStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgFunctionParameterList_initializeStorageClassArray (SgFunctionParameterListStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgFunctionParameterTypeList ) ; 
     std::cout << " SgFunctionParameterTypeList has size " << sizeOfActualPool << std::endl;
     SgFunctionParameterTypeListStorageClass* SgFunctionParameterTypeListStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgFunctionParameterTypeListStorageArray = new SgFunctionParameterTypeListStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgFunctionParameterTypeList_initializeStorageClassArray (SgFunctionParameterTypeListStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgFunctionRefExp ) ; 
     std::cout << " SgFunctionRefExp has size " << sizeOfActualPool << std::endl;
     SgFunctionRefExpStorageClass* SgFunctionRefExpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgFunctionRefExpStorageArray = new SgFunctionRefExpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgFunctionRefExp_initializeStorageClassArray (SgFunctionRefExpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgFunctionSymbol ) ; 
     std::cout << " SgFunctionSymbol has size " << sizeOfActualPool << std::endl;
     SgFunctionSymbolStorageClass* SgFunctionSymbolStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgFunctionSymbolStorageArray = new SgFunctionSymbolStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgFunctionSymbol_initializeStorageClassArray (SgFunctionSymbolStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgFunctionType ) ; 
     std::cout << " SgFunctionType has size " << sizeOfActualPool << std::endl;
     SgFunctionTypeStorageClass* SgFunctionTypeStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgFunctionTypeStorageArray = new SgFunctionTypeStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgFunctionType_initializeStorageClassArray (SgFunctionTypeStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgFunctionTypeSymbol ) ; 
     std::cout << " SgFunctionTypeSymbol has size " << sizeOfActualPool << std::endl;
     SgFunctionTypeSymbolStorageClass* SgFunctionTypeSymbolStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgFunctionTypeSymbolStorageArray = new SgFunctionTypeSymbolStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgFunctionTypeSymbol_initializeStorageClassArray (SgFunctionTypeSymbolStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgFunctionTypeTable ) ; 
     std::cout << " SgFunctionTypeTable has size " << sizeOfActualPool << std::endl;
     SgFunctionTypeTableStorageClass* SgFunctionTypeTableStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgFunctionTypeTableStorageArray = new SgFunctionTypeTableStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgFunctionTypeTable_initializeStorageClassArray (SgFunctionTypeTableStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgTypeTable ) ; 
     std::cout << " SgTypeTable has size " << sizeOfActualPool << std::endl;
     SgTypeTableStorageClass* SgTypeTableStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeTableStorageArray = new SgTypeTableStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgTypeTable_initializeStorageClassArray (SgTypeTableStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgGlobal ) ; 
     std::cout << " SgGlobal has size " << sizeOfActualPool << std::endl;
     SgGlobalStorageClass* SgGlobalStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgGlobalStorageArray = new SgGlobalStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgGlobal_initializeStorageClassArray (SgGlobalStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgGotoStatement ) ; 
     std::cout << " SgGotoStatement has size " << sizeOfActualPool << std::endl;
     SgGotoStatementStorageClass* SgGotoStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgGotoStatementStorageArray = new SgGotoStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgGotoStatement_initializeStorageClassArray (SgGotoStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgGraph ) ; 
     std::cout << " SgGraph has size " << sizeOfActualPool << std::endl;
     SgGraphStorageClass* SgGraphStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgGraphStorageArray = new SgGraphStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgGraph_initializeStorageClassArray (SgGraphStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgGraphEdge ) ; 
     std::cout << " SgGraphEdge has size " << sizeOfActualPool << std::endl;
     SgGraphEdgeStorageClass* SgGraphEdgeStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgGraphEdgeStorageArray = new SgGraphEdgeStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgGraphEdge_initializeStorageClassArray (SgGraphEdgeStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgGraphEdgeList ) ; 
     std::cout << " SgGraphEdgeList has size " << sizeOfActualPool << std::endl;
     SgGraphEdgeListStorageClass* SgGraphEdgeListStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgGraphEdgeListStorageArray = new SgGraphEdgeListStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgGraphEdgeList_initializeStorageClassArray (SgGraphEdgeListStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgGraphNode ) ; 
     std::cout << " SgGraphNode has size " << sizeOfActualPool << std::endl;
     SgGraphNodeStorageClass* SgGraphNodeStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgGraphNodeStorageArray = new SgGraphNodeStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgGraphNode_initializeStorageClassArray (SgGraphNodeStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgGraphNodeList ) ; 
     std::cout << " SgGraphNodeList has size " << sizeOfActualPool << std::endl;
     SgGraphNodeListStorageClass* SgGraphNodeListStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgGraphNodeListStorageArray = new SgGraphNodeListStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgGraphNodeList_initializeStorageClassArray (SgGraphNodeListStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgGreaterOrEqualOp ) ; 
     std::cout << " SgGreaterOrEqualOp has size " << sizeOfActualPool << std::endl;
     SgGreaterOrEqualOpStorageClass* SgGreaterOrEqualOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgGreaterOrEqualOpStorageArray = new SgGreaterOrEqualOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgGreaterOrEqualOp_initializeStorageClassArray (SgGreaterOrEqualOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgGreaterThanOp ) ; 
     std::cout << " SgGreaterThanOp has size " << sizeOfActualPool << std::endl;
     SgGreaterThanOpStorageClass* SgGreaterThanOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgGreaterThanOpStorageArray = new SgGreaterThanOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgGreaterThanOp_initializeStorageClassArray (SgGreaterThanOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgIOItemExpression ) ; 
     std::cout << " SgIOItemExpression has size " << sizeOfActualPool << std::endl;
     SgIOItemExpressionStorageClass* SgIOItemExpressionStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgIOItemExpressionStorageArray = new SgIOItemExpressionStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgIOItemExpression_initializeStorageClassArray (SgIOItemExpressionStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgIOStatement ) ; 
     std::cout << " SgIOStatement has size " << sizeOfActualPool << std::endl;
     SgIOStatementStorageClass* SgIOStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgIOStatementStorageArray = new SgIOStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgIOStatement_initializeStorageClassArray (SgIOStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgIdentDirectiveStatement ) ; 
     std::cout << " SgIdentDirectiveStatement has size " << sizeOfActualPool << std::endl;
     SgIdentDirectiveStatementStorageClass* SgIdentDirectiveStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgIdentDirectiveStatementStorageArray = new SgIdentDirectiveStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgIdentDirectiveStatement_initializeStorageClassArray (SgIdentDirectiveStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgIfDirectiveStatement ) ; 
     std::cout << " SgIfDirectiveStatement has size " << sizeOfActualPool << std::endl;
     SgIfDirectiveStatementStorageClass* SgIfDirectiveStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgIfDirectiveStatementStorageArray = new SgIfDirectiveStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgIfDirectiveStatement_initializeStorageClassArray (SgIfDirectiveStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgIfStmt ) ; 
     std::cout << " SgIfStmt has size " << sizeOfActualPool << std::endl;
     SgIfStmtStorageClass* SgIfStmtStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgIfStmtStorageArray = new SgIfStmtStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgIfStmt_initializeStorageClassArray (SgIfStmtStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgIfdefDirectiveStatement ) ; 
     std::cout << " SgIfdefDirectiveStatement has size " << sizeOfActualPool << std::endl;
     SgIfdefDirectiveStatementStorageClass* SgIfdefDirectiveStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgIfdefDirectiveStatementStorageArray = new SgIfdefDirectiveStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgIfdefDirectiveStatement_initializeStorageClassArray (SgIfdefDirectiveStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgIfndefDirectiveStatement ) ; 
     std::cout << " SgIfndefDirectiveStatement has size " << sizeOfActualPool << std::endl;
     SgIfndefDirectiveStatementStorageClass* SgIfndefDirectiveStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgIfndefDirectiveStatementStorageArray = new SgIfndefDirectiveStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgIfndefDirectiveStatement_initializeStorageClassArray (SgIfndefDirectiveStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgImagPartOp ) ; 
     std::cout << " SgImagPartOp has size " << sizeOfActualPool << std::endl;
     SgImagPartOpStorageClass* SgImagPartOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgImagPartOpStorageArray = new SgImagPartOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgImagPartOp_initializeStorageClassArray (SgImagPartOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgImplicitStatement ) ; 
     std::cout << " SgImplicitStatement has size " << sizeOfActualPool << std::endl;
     SgImplicitStatementStorageClass* SgImplicitStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgImplicitStatementStorageArray = new SgImplicitStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgImplicitStatement_initializeStorageClassArray (SgImplicitStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgImpliedDo ) ; 
     std::cout << " SgImpliedDo has size " << sizeOfActualPool << std::endl;
     SgImpliedDoStorageClass* SgImpliedDoStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgImpliedDoStorageArray = new SgImpliedDoStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgImpliedDo_initializeStorageClassArray (SgImpliedDoStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgImportStatement ) ; 
     std::cout << " SgImportStatement has size " << sizeOfActualPool << std::endl;
     SgImportStatementStorageClass* SgImportStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgImportStatementStorageArray = new SgImportStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgImportStatement_initializeStorageClassArray (SgImportStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgIncidenceDirectedGraph ) ; 
     std::cout << " SgIncidenceDirectedGraph has size " << sizeOfActualPool << std::endl;
     SgIncidenceDirectedGraphStorageClass* SgIncidenceDirectedGraphStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgIncidenceDirectedGraphStorageArray = new SgIncidenceDirectedGraphStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgIncidenceDirectedGraph_initializeStorageClassArray (SgIncidenceDirectedGraphStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgIncidenceUndirectedGraph ) ; 
     std::cout << " SgIncidenceUndirectedGraph has size " << sizeOfActualPool << std::endl;
     SgIncidenceUndirectedGraphStorageClass* SgIncidenceUndirectedGraphStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgIncidenceUndirectedGraphStorageArray = new SgIncidenceUndirectedGraphStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgIncidenceUndirectedGraph_initializeStorageClassArray (SgIncidenceUndirectedGraphStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgIncludeDirectiveStatement ) ; 
     std::cout << " SgIncludeDirectiveStatement has size " << sizeOfActualPool << std::endl;
     SgIncludeDirectiveStatementStorageClass* SgIncludeDirectiveStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgIncludeDirectiveStatementStorageArray = new SgIncludeDirectiveStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgIncludeDirectiveStatement_initializeStorageClassArray (SgIncludeDirectiveStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgIncludeNextDirectiveStatement ) ; 
     std::cout << " SgIncludeNextDirectiveStatement has size " << sizeOfActualPool << std::endl;
     SgIncludeNextDirectiveStatementStorageClass* SgIncludeNextDirectiveStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgIncludeNextDirectiveStatementStorageArray = new SgIncludeNextDirectiveStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgIncludeNextDirectiveStatement_initializeStorageClassArray (SgIncludeNextDirectiveStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgInitializedName ) ; 
     std::cout << " SgInitializedName has size " << sizeOfActualPool << std::endl;
     SgInitializedNameStorageClass* SgInitializedNameStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgInitializedNameStorageArray = new SgInitializedNameStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgInitializedName_initializeStorageClassArray (SgInitializedNameStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgInitializer ) ; 
     std::cout << " SgInitializer has size " << sizeOfActualPool << std::endl;
     SgInitializerStorageClass* SgInitializerStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgInitializerStorageArray = new SgInitializerStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgInitializer_initializeStorageClassArray (SgInitializerStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgInquireStatement ) ; 
     std::cout << " SgInquireStatement has size " << sizeOfActualPool << std::endl;
     SgInquireStatementStorageClass* SgInquireStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgInquireStatementStorageArray = new SgInquireStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgInquireStatement_initializeStorageClassArray (SgInquireStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgIntKeyedBidirectionalGraph ) ; 
     std::cout << " SgIntKeyedBidirectionalGraph has size " << sizeOfActualPool << std::endl;
     SgIntKeyedBidirectionalGraphStorageClass* SgIntKeyedBidirectionalGraphStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgIntKeyedBidirectionalGraphStorageArray = new SgIntKeyedBidirectionalGraphStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgIntKeyedBidirectionalGraph_initializeStorageClassArray (SgIntKeyedBidirectionalGraphStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgIntVal ) ; 
     std::cout << " SgIntVal has size " << sizeOfActualPool << std::endl;
     SgIntValStorageClass* SgIntValStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgIntValStorageArray = new SgIntValStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgIntVal_initializeStorageClassArray (SgIntValStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgIntegerDivideOp ) ; 
     std::cout << " SgIntegerDivideOp has size " << sizeOfActualPool << std::endl;
     SgIntegerDivideOpStorageClass* SgIntegerDivideOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgIntegerDivideOpStorageArray = new SgIntegerDivideOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgIntegerDivideOp_initializeStorageClassArray (SgIntegerDivideOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgIntegerDivideAssignOp ) ; 
     std::cout << " SgIntegerDivideAssignOp has size " << sizeOfActualPool << std::endl;
     SgIntegerDivideAssignOpStorageClass* SgIntegerDivideAssignOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgIntegerDivideAssignOpStorageArray = new SgIntegerDivideAssignOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgIntegerDivideAssignOp_initializeStorageClassArray (SgIntegerDivideAssignOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgInterfaceBody ) ; 
     std::cout << " SgInterfaceBody has size " << sizeOfActualPool << std::endl;
     SgInterfaceBodyStorageClass* SgInterfaceBodyStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgInterfaceBodyStorageArray = new SgInterfaceBodyStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgInterfaceBody_initializeStorageClassArray (SgInterfaceBodyStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgHeaderFileBody ) ; 
     std::cout << " SgHeaderFileBody has size " << sizeOfActualPool << std::endl;
     SgHeaderFileBodyStorageClass* SgHeaderFileBodyStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgHeaderFileBodyStorageArray = new SgHeaderFileBodyStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgHeaderFileBody_initializeStorageClassArray (SgHeaderFileBodyStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgInterfaceStatement ) ; 
     std::cout << " SgInterfaceStatement has size " << sizeOfActualPool << std::endl;
     SgInterfaceStatementStorageClass* SgInterfaceStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgInterfaceStatementStorageArray = new SgInterfaceStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgInterfaceStatement_initializeStorageClassArray (SgInterfaceStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgInterfaceSymbol ) ; 
     std::cout << " SgInterfaceSymbol has size " << sizeOfActualPool << std::endl;
     SgInterfaceSymbolStorageClass* SgInterfaceSymbolStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgInterfaceSymbolStorageArray = new SgInterfaceSymbolStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgInterfaceSymbol_initializeStorageClassArray (SgInterfaceSymbolStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgIntrinsicSymbol ) ; 
     std::cout << " SgIntrinsicSymbol has size " << sizeOfActualPool << std::endl;
     SgIntrinsicSymbolStorageClass* SgIntrinsicSymbolStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgIntrinsicSymbolStorageArray = new SgIntrinsicSymbolStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgIntrinsicSymbol_initializeStorageClassArray (SgIntrinsicSymbolStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgIsOp ) ; 
     std::cout << " SgIsOp has size " << sizeOfActualPool << std::endl;
     SgIsOpStorageClass* SgIsOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgIsOpStorageArray = new SgIsOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgIsOp_initializeStorageClassArray (SgIsOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgIsNotOp ) ; 
     std::cout << " SgIsNotOp has size " << sizeOfActualPool << std::endl;
     SgIsNotOpStorageClass* SgIsNotOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgIsNotOpStorageArray = new SgIsNotOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgIsNotOp_initializeStorageClassArray (SgIsNotOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgIorAssignOp ) ; 
     std::cout << " SgIorAssignOp has size " << sizeOfActualPool << std::endl;
     SgIorAssignOpStorageClass* SgIorAssignOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgIorAssignOpStorageArray = new SgIorAssignOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgIorAssignOp_initializeStorageClassArray (SgIorAssignOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgKeyDatumPair ) ; 
     std::cout << " SgKeyDatumPair has size " << sizeOfActualPool << std::endl;
     SgKeyDatumPairStorageClass* SgKeyDatumPairStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgKeyDatumPairStorageArray = new SgKeyDatumPairStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgKeyDatumPair_initializeStorageClassArray (SgKeyDatumPairStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgCudaKernelExecConfig ) ; 
     std::cout << " SgCudaKernelExecConfig has size " << sizeOfActualPool << std::endl;
     SgCudaKernelExecConfigStorageClass* SgCudaKernelExecConfigStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgCudaKernelExecConfigStorageArray = new SgCudaKernelExecConfigStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgCudaKernelExecConfig_initializeStorageClassArray (SgCudaKernelExecConfigStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgCudaKernelCallExp ) ; 
     std::cout << " SgCudaKernelCallExp has size " << sizeOfActualPool << std::endl;
     SgCudaKernelCallExpStorageClass* SgCudaKernelCallExpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgCudaKernelCallExpStorageArray = new SgCudaKernelCallExpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgCudaKernelCallExp_initializeStorageClassArray (SgCudaKernelCallExpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgLabelRefExp ) ; 
     std::cout << " SgLabelRefExp has size " << sizeOfActualPool << std::endl;
     SgLabelRefExpStorageClass* SgLabelRefExpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgLabelRefExpStorageArray = new SgLabelRefExpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgLabelRefExp_initializeStorageClassArray (SgLabelRefExpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgLabelStatement ) ; 
     std::cout << " SgLabelStatement has size " << sizeOfActualPool << std::endl;
     SgLabelStatementStorageClass* SgLabelStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgLabelStatementStorageArray = new SgLabelStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgLabelStatement_initializeStorageClassArray (SgLabelStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgJavaLabelStatement ) ; 
     std::cout << " SgJavaLabelStatement has size " << sizeOfActualPool << std::endl;
     SgJavaLabelStatementStorageClass* SgJavaLabelStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgJavaLabelStatementStorageArray = new SgJavaLabelStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgJavaLabelStatement_initializeStorageClassArray (SgJavaLabelStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgLabelSymbol ) ; 
     std::cout << " SgLabelSymbol has size " << sizeOfActualPool << std::endl;
     SgLabelSymbolStorageClass* SgLabelSymbolStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgLabelSymbolStorageArray = new SgLabelSymbolStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgLabelSymbol_initializeStorageClassArray (SgLabelSymbolStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgJavaLabelSymbol ) ; 
     std::cout << " SgJavaLabelSymbol has size " << sizeOfActualPool << std::endl;
     SgJavaLabelSymbolStorageClass* SgJavaLabelSymbolStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgJavaLabelSymbolStorageArray = new SgJavaLabelSymbolStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgJavaLabelSymbol_initializeStorageClassArray (SgJavaLabelSymbolStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgLambdaRefExp ) ; 
     std::cout << " SgLambdaRefExp has size " << sizeOfActualPool << std::endl;
     SgLambdaRefExpStorageClass* SgLambdaRefExpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgLambdaRefExpStorageArray = new SgLambdaRefExpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgLambdaRefExp_initializeStorageClassArray (SgLambdaRefExpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgLessOrEqualOp ) ; 
     std::cout << " SgLessOrEqualOp has size " << sizeOfActualPool << std::endl;
     SgLessOrEqualOpStorageClass* SgLessOrEqualOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgLessOrEqualOpStorageArray = new SgLessOrEqualOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgLessOrEqualOp_initializeStorageClassArray (SgLessOrEqualOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgLessThanOp ) ; 
     std::cout << " SgLessThanOp has size " << sizeOfActualPool << std::endl;
     SgLessThanOpStorageClass* SgLessThanOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgLessThanOpStorageArray = new SgLessThanOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgLessThanOp_initializeStorageClassArray (SgLessThanOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgLineDirectiveStatement ) ; 
     std::cout << " SgLineDirectiveStatement has size " << sizeOfActualPool << std::endl;
     SgLineDirectiveStatementStorageClass* SgLineDirectiveStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgLineDirectiveStatementStorageArray = new SgLineDirectiveStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgLineDirectiveStatement_initializeStorageClassArray (SgLineDirectiveStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgLinemarkerDirectiveStatement ) ; 
     std::cout << " SgLinemarkerDirectiveStatement has size " << sizeOfActualPool << std::endl;
     SgLinemarkerDirectiveStatementStorageClass* SgLinemarkerDirectiveStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgLinemarkerDirectiveStatementStorageArray = new SgLinemarkerDirectiveStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgLinemarkerDirectiveStatement_initializeStorageClassArray (SgLinemarkerDirectiveStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgLinkageModifier ) ; 
     std::cout << " SgLinkageModifier has size " << sizeOfActualPool << std::endl;
     SgLinkageModifierStorageClass* SgLinkageModifierStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgLinkageModifierStorageArray = new SgLinkageModifierStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgLinkageModifier_initializeStorageClassArray (SgLinkageModifierStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgListComprehension ) ; 
     std::cout << " SgListComprehension has size " << sizeOfActualPool << std::endl;
     SgListComprehensionStorageClass* SgListComprehensionStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgListComprehensionStorageArray = new SgListComprehensionStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgListComprehension_initializeStorageClassArray (SgListComprehensionStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgListExp ) ; 
     std::cout << " SgListExp has size " << sizeOfActualPool << std::endl;
     SgListExpStorageClass* SgListExpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgListExpStorageArray = new SgListExpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgListExp_initializeStorageClassArray (SgListExpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgLocatedNode ) ; 
     std::cout << " SgLocatedNode has size " << sizeOfActualPool << std::endl;
     SgLocatedNodeStorageClass* SgLocatedNodeStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgLocatedNodeStorageArray = new SgLocatedNodeStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgLocatedNode_initializeStorageClassArray (SgLocatedNodeStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgLocatedNodeSupport ) ; 
     std::cout << " SgLocatedNodeSupport has size " << sizeOfActualPool << std::endl;
     SgLocatedNodeSupportStorageClass* SgLocatedNodeSupportStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgLocatedNodeSupportStorageArray = new SgLocatedNodeSupportStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgLocatedNodeSupport_initializeStorageClassArray (SgLocatedNodeSupportStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgLongDoubleVal ) ; 
     std::cout << " SgLongDoubleVal has size " << sizeOfActualPool << std::endl;
     SgLongDoubleValStorageClass* SgLongDoubleValStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgLongDoubleValStorageArray = new SgLongDoubleValStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgLongDoubleVal_initializeStorageClassArray (SgLongDoubleValStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgLongIntVal ) ; 
     std::cout << " SgLongIntVal has size " << sizeOfActualPool << std::endl;
     SgLongIntValStorageClass* SgLongIntValStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgLongIntValStorageArray = new SgLongIntValStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgLongIntVal_initializeStorageClassArray (SgLongIntValStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgLongLongIntVal ) ; 
     std::cout << " SgLongLongIntVal has size " << sizeOfActualPool << std::endl;
     SgLongLongIntValStorageClass* SgLongLongIntValStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgLongLongIntValStorageArray = new SgLongLongIntValStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgLongLongIntVal_initializeStorageClassArray (SgLongLongIntValStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgLshiftAssignOp ) ; 
     std::cout << " SgLshiftAssignOp has size " << sizeOfActualPool << std::endl;
     SgLshiftAssignOpStorageClass* SgLshiftAssignOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgLshiftAssignOpStorageArray = new SgLshiftAssignOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgLshiftAssignOp_initializeStorageClassArray (SgLshiftAssignOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgLshiftOp ) ; 
     std::cout << " SgLshiftOp has size " << sizeOfActualPool << std::endl;
     SgLshiftOpStorageClass* SgLshiftOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgLshiftOpStorageArray = new SgLshiftOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgLshiftOp_initializeStorageClassArray (SgLshiftOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgMemberFunctionDeclaration ) ; 
     std::cout << " SgMemberFunctionDeclaration has size " << sizeOfActualPool << std::endl;
     SgMemberFunctionDeclarationStorageClass* SgMemberFunctionDeclarationStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgMemberFunctionDeclarationStorageArray = new SgMemberFunctionDeclarationStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgMemberFunctionDeclaration_initializeStorageClassArray (SgMemberFunctionDeclarationStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgMemberFunctionRefExp ) ; 
     std::cout << " SgMemberFunctionRefExp has size " << sizeOfActualPool << std::endl;
     SgMemberFunctionRefExpStorageClass* SgMemberFunctionRefExpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgMemberFunctionRefExpStorageArray = new SgMemberFunctionRefExpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgMemberFunctionRefExp_initializeStorageClassArray (SgMemberFunctionRefExpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgMemberFunctionSymbol ) ; 
     std::cout << " SgMemberFunctionSymbol has size " << sizeOfActualPool << std::endl;
     SgMemberFunctionSymbolStorageClass* SgMemberFunctionSymbolStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgMemberFunctionSymbolStorageArray = new SgMemberFunctionSymbolStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgMemberFunctionSymbol_initializeStorageClassArray (SgMemberFunctionSymbolStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgMemberFunctionType ) ; 
     std::cout << " SgMemberFunctionType has size " << sizeOfActualPool << std::endl;
     SgMemberFunctionTypeStorageClass* SgMemberFunctionTypeStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgMemberFunctionTypeStorageArray = new SgMemberFunctionTypeStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgMemberFunctionType_initializeStorageClassArray (SgMemberFunctionTypeStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgMembershipOp ) ; 
     std::cout << " SgMembershipOp has size " << sizeOfActualPool << std::endl;
     SgMembershipOpStorageClass* SgMembershipOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgMembershipOpStorageArray = new SgMembershipOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgMembershipOp_initializeStorageClassArray (SgMembershipOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgMinusAssignOp ) ; 
     std::cout << " SgMinusAssignOp has size " << sizeOfActualPool << std::endl;
     SgMinusAssignOpStorageClass* SgMinusAssignOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgMinusAssignOpStorageArray = new SgMinusAssignOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgMinusAssignOp_initializeStorageClassArray (SgMinusAssignOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgMinusMinusOp ) ; 
     std::cout << " SgMinusMinusOp has size " << sizeOfActualPool << std::endl;
     SgMinusMinusOpStorageClass* SgMinusMinusOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgMinusMinusOpStorageArray = new SgMinusMinusOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgMinusMinusOp_initializeStorageClassArray (SgMinusMinusOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgMinusOp ) ; 
     std::cout << " SgMinusOp has size " << sizeOfActualPool << std::endl;
     SgMinusOpStorageClass* SgMinusOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgMinusOpStorageArray = new SgMinusOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgMinusOp_initializeStorageClassArray (SgMinusOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgModAssignOp ) ; 
     std::cout << " SgModAssignOp has size " << sizeOfActualPool << std::endl;
     SgModAssignOpStorageClass* SgModAssignOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgModAssignOpStorageArray = new SgModAssignOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgModAssignOp_initializeStorageClassArray (SgModAssignOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgModOp ) ; 
     std::cout << " SgModOp has size " << sizeOfActualPool << std::endl;
     SgModOpStorageClass* SgModOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgModOpStorageArray = new SgModOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgModOp_initializeStorageClassArray (SgModOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgModifier ) ; 
     std::cout << " SgModifier has size " << sizeOfActualPool << std::endl;
     SgModifierStorageClass* SgModifierStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgModifierStorageArray = new SgModifierStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgModifier_initializeStorageClassArray (SgModifierStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgModifierNodes ) ; 
     std::cout << " SgModifierNodes has size " << sizeOfActualPool << std::endl;
     SgModifierNodesStorageClass* SgModifierNodesStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgModifierNodesStorageArray = new SgModifierNodesStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgModifierNodes_initializeStorageClassArray (SgModifierNodesStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgModifierType ) ; 
     std::cout << " SgModifierType has size " << sizeOfActualPool << std::endl;
     SgModifierTypeStorageClass* SgModifierTypeStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgModifierTypeStorageArray = new SgModifierTypeStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgModifierType_initializeStorageClassArray (SgModifierTypeStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgModuleStatement ) ; 
     std::cout << " SgModuleStatement has size " << sizeOfActualPool << std::endl;
     SgModuleStatementStorageClass* SgModuleStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgModuleStatementStorageArray = new SgModuleStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgModuleStatement_initializeStorageClassArray (SgModuleStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgModuleSymbol ) ; 
     std::cout << " SgModuleSymbol has size " << sizeOfActualPool << std::endl;
     SgModuleSymbolStorageClass* SgModuleSymbolStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgModuleSymbolStorageArray = new SgModuleSymbolStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgModuleSymbol_initializeStorageClassArray (SgModuleSymbolStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgMultAssignOp ) ; 
     std::cout << " SgMultAssignOp has size " << sizeOfActualPool << std::endl;
     SgMultAssignOpStorageClass* SgMultAssignOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgMultAssignOpStorageArray = new SgMultAssignOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgMultAssignOp_initializeStorageClassArray (SgMultAssignOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgMultiplyOp ) ; 
     std::cout << " SgMultiplyOp has size " << sizeOfActualPool << std::endl;
     SgMultiplyOpStorageClass* SgMultiplyOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgMultiplyOpStorageArray = new SgMultiplyOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgMultiplyOp_initializeStorageClassArray (SgMultiplyOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgName ) ; 
     std::cout << " SgName has size " << sizeOfActualPool << std::endl;
     SgNameStorageClass* SgNameStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgNameStorageArray = new SgNameStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgName_initializeStorageClassArray (SgNameStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgNameGroup ) ; 
     std::cout << " SgNameGroup has size " << sizeOfActualPool << std::endl;
     SgNameGroupStorageClass* SgNameGroupStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgNameGroupStorageArray = new SgNameGroupStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgNameGroup_initializeStorageClassArray (SgNameGroupStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgNamedType ) ; 
     std::cout << " SgNamedType has size " << sizeOfActualPool << std::endl;
     SgNamedTypeStorageClass* SgNamedTypeStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgNamedTypeStorageArray = new SgNamedTypeStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgNamedType_initializeStorageClassArray (SgNamedTypeStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgNamelistStatement ) ; 
     std::cout << " SgNamelistStatement has size " << sizeOfActualPool << std::endl;
     SgNamelistStatementStorageClass* SgNamelistStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgNamelistStatementStorageArray = new SgNamelistStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgNamelistStatement_initializeStorageClassArray (SgNamelistStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgNamespaceAliasDeclarationStatement ) ; 
     std::cout << " SgNamespaceAliasDeclarationStatement has size " << sizeOfActualPool << std::endl;
     SgNamespaceAliasDeclarationStatementStorageClass* SgNamespaceAliasDeclarationStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgNamespaceAliasDeclarationStatementStorageArray = new SgNamespaceAliasDeclarationStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgNamespaceAliasDeclarationStatement_initializeStorageClassArray (SgNamespaceAliasDeclarationStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgNamespaceDeclarationStatement ) ; 
     std::cout << " SgNamespaceDeclarationStatement has size " << sizeOfActualPool << std::endl;
     SgNamespaceDeclarationStatementStorageClass* SgNamespaceDeclarationStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgNamespaceDeclarationStatementStorageArray = new SgNamespaceDeclarationStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgNamespaceDeclarationStatement_initializeStorageClassArray (SgNamespaceDeclarationStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgNamespaceDefinitionStatement ) ; 
     std::cout << " SgNamespaceDefinitionStatement has size " << sizeOfActualPool << std::endl;
     SgNamespaceDefinitionStatementStorageClass* SgNamespaceDefinitionStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgNamespaceDefinitionStatementStorageArray = new SgNamespaceDefinitionStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgNamespaceDefinitionStatement_initializeStorageClassArray (SgNamespaceDefinitionStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgNamespaceSymbol ) ; 
     std::cout << " SgNamespaceSymbol has size " << sizeOfActualPool << std::endl;
     SgNamespaceSymbolStorageClass* SgNamespaceSymbolStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgNamespaceSymbolStorageArray = new SgNamespaceSymbolStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgNamespaceSymbol_initializeStorageClassArray (SgNamespaceSymbolStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgNaryOp ) ; 
     std::cout << " SgNaryOp has size " << sizeOfActualPool << std::endl;
     SgNaryOpStorageClass* SgNaryOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgNaryOpStorageArray = new SgNaryOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgNaryOp_initializeStorageClassArray (SgNaryOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgNaryBooleanOp ) ; 
     std::cout << " SgNaryBooleanOp has size " << sizeOfActualPool << std::endl;
     SgNaryBooleanOpStorageClass* SgNaryBooleanOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgNaryBooleanOpStorageArray = new SgNaryBooleanOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgNaryBooleanOp_initializeStorageClassArray (SgNaryBooleanOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgNaryComparisonOp ) ; 
     std::cout << " SgNaryComparisonOp has size " << sizeOfActualPool << std::endl;
     SgNaryComparisonOpStorageClass* SgNaryComparisonOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgNaryComparisonOpStorageArray = new SgNaryComparisonOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgNaryComparisonOp_initializeStorageClassArray (SgNaryComparisonOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgNewExp ) ; 
     std::cout << " SgNewExp has size " << sizeOfActualPool << std::endl;
     SgNewExpStorageClass* SgNewExpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgNewExpStorageArray = new SgNewExpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgNewExp_initializeStorageClassArray (SgNewExpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgNode ) ; 
     std::cout << " SgNode has size " << sizeOfActualPool << std::endl;
     SgNodeStorageClass* SgNodeStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgNodeStorageArray = new SgNodeStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgNode_initializeStorageClassArray (SgNodeStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgNotEqualOp ) ; 
     std::cout << " SgNotEqualOp has size " << sizeOfActualPool << std::endl;
     SgNotEqualOpStorageClass* SgNotEqualOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgNotEqualOpStorageArray = new SgNotEqualOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgNotEqualOp_initializeStorageClassArray (SgNotEqualOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgNotOp ) ; 
     std::cout << " SgNotOp has size " << sizeOfActualPool << std::endl;
     SgNotOpStorageClass* SgNotOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgNotOpStorageArray = new SgNotOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgNotOp_initializeStorageClassArray (SgNotOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgNonMembershipOp ) ; 
     std::cout << " SgNonMembershipOp has size " << sizeOfActualPool << std::endl;
     SgNonMembershipOpStorageClass* SgNonMembershipOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgNonMembershipOpStorageArray = new SgNonMembershipOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgNonMembershipOp_initializeStorageClassArray (SgNonMembershipOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgNullExpression ) ; 
     std::cout << " SgNullExpression has size " << sizeOfActualPool << std::endl;
     SgNullExpressionStorageClass* SgNullExpressionStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgNullExpressionStorageArray = new SgNullExpressionStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgNullExpression_initializeStorageClassArray (SgNullExpressionStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgNullStatement ) ; 
     std::cout << " SgNullStatement has size " << sizeOfActualPool << std::endl;
     SgNullStatementStorageClass* SgNullStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgNullStatementStorageArray = new SgNullStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgNullStatement_initializeStorageClassArray (SgNullStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgNullifyStatement ) ; 
     std::cout << " SgNullifyStatement has size " << sizeOfActualPool << std::endl;
     SgNullifyStatementStorageClass* SgNullifyStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgNullifyStatementStorageArray = new SgNullifyStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgNullifyStatement_initializeStorageClassArray (SgNullifyStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgOmpAtomicStatement ) ; 
     std::cout << " SgOmpAtomicStatement has size " << sizeOfActualPool << std::endl;
     SgOmpAtomicStatementStorageClass* SgOmpAtomicStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpAtomicStatementStorageArray = new SgOmpAtomicStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgOmpAtomicStatement_initializeStorageClassArray (SgOmpAtomicStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgOmpBarrierStatement ) ; 
     std::cout << " SgOmpBarrierStatement has size " << sizeOfActualPool << std::endl;
     SgOmpBarrierStatementStorageClass* SgOmpBarrierStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpBarrierStatementStorageArray = new SgOmpBarrierStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgOmpBarrierStatement_initializeStorageClassArray (SgOmpBarrierStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgOmpCriticalStatement ) ; 
     std::cout << " SgOmpCriticalStatement has size " << sizeOfActualPool << std::endl;
     SgOmpCriticalStatementStorageClass* SgOmpCriticalStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpCriticalStatementStorageArray = new SgOmpCriticalStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgOmpCriticalStatement_initializeStorageClassArray (SgOmpCriticalStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgOmpClauseBodyStatement ) ; 
     std::cout << " SgOmpClauseBodyStatement has size " << sizeOfActualPool << std::endl;
     SgOmpClauseBodyStatementStorageClass* SgOmpClauseBodyStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpClauseBodyStatementStorageArray = new SgOmpClauseBodyStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgOmpClauseBodyStatement_initializeStorageClassArray (SgOmpClauseBodyStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgOmpBodyStatement ) ; 
     std::cout << " SgOmpBodyStatement has size " << sizeOfActualPool << std::endl;
     SgOmpBodyStatementStorageClass* SgOmpBodyStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpBodyStatementStorageArray = new SgOmpBodyStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgOmpBodyStatement_initializeStorageClassArray (SgOmpBodyStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgOmpDoStatement ) ; 
     std::cout << " SgOmpDoStatement has size " << sizeOfActualPool << std::endl;
     SgOmpDoStatementStorageClass* SgOmpDoStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpDoStatementStorageArray = new SgOmpDoStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgOmpDoStatement_initializeStorageClassArray (SgOmpDoStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgOmpFlushStatement ) ; 
     std::cout << " SgOmpFlushStatement has size " << sizeOfActualPool << std::endl;
     SgOmpFlushStatementStorageClass* SgOmpFlushStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpFlushStatementStorageArray = new SgOmpFlushStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgOmpFlushStatement_initializeStorageClassArray (SgOmpFlushStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgOmpForStatement ) ; 
     std::cout << " SgOmpForStatement has size " << sizeOfActualPool << std::endl;
     SgOmpForStatementStorageClass* SgOmpForStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpForStatementStorageArray = new SgOmpForStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgOmpForStatement_initializeStorageClassArray (SgOmpForStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgOmpMasterStatement ) ; 
     std::cout << " SgOmpMasterStatement has size " << sizeOfActualPool << std::endl;
     SgOmpMasterStatementStorageClass* SgOmpMasterStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpMasterStatementStorageArray = new SgOmpMasterStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgOmpMasterStatement_initializeStorageClassArray (SgOmpMasterStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgOmpOrderedStatement ) ; 
     std::cout << " SgOmpOrderedStatement has size " << sizeOfActualPool << std::endl;
     SgOmpOrderedStatementStorageClass* SgOmpOrderedStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpOrderedStatementStorageArray = new SgOmpOrderedStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgOmpOrderedStatement_initializeStorageClassArray (SgOmpOrderedStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgOmpParallelStatement ) ; 
     std::cout << " SgOmpParallelStatement has size " << sizeOfActualPool << std::endl;
     SgOmpParallelStatementStorageClass* SgOmpParallelStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpParallelStatementStorageArray = new SgOmpParallelStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgOmpParallelStatement_initializeStorageClassArray (SgOmpParallelStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgOmpSectionStatement ) ; 
     std::cout << " SgOmpSectionStatement has size " << sizeOfActualPool << std::endl;
     SgOmpSectionStatementStorageClass* SgOmpSectionStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpSectionStatementStorageArray = new SgOmpSectionStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgOmpSectionStatement_initializeStorageClassArray (SgOmpSectionStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgOmpSectionsStatement ) ; 
     std::cout << " SgOmpSectionsStatement has size " << sizeOfActualPool << std::endl;
     SgOmpSectionsStatementStorageClass* SgOmpSectionsStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpSectionsStatementStorageArray = new SgOmpSectionsStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgOmpSectionsStatement_initializeStorageClassArray (SgOmpSectionsStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgOmpSingleStatement ) ; 
     std::cout << " SgOmpSingleStatement has size " << sizeOfActualPool << std::endl;
     SgOmpSingleStatementStorageClass* SgOmpSingleStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpSingleStatementStorageArray = new SgOmpSingleStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgOmpSingleStatement_initializeStorageClassArray (SgOmpSingleStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgOmpTaskStatement ) ; 
     std::cout << " SgOmpTaskStatement has size " << sizeOfActualPool << std::endl;
     SgOmpTaskStatementStorageClass* SgOmpTaskStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpTaskStatementStorageArray = new SgOmpTaskStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgOmpTaskStatement_initializeStorageClassArray (SgOmpTaskStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgOmpTaskwaitStatement ) ; 
     std::cout << " SgOmpTaskwaitStatement has size " << sizeOfActualPool << std::endl;
     SgOmpTaskwaitStatementStorageClass* SgOmpTaskwaitStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpTaskwaitStatementStorageArray = new SgOmpTaskwaitStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgOmpTaskwaitStatement_initializeStorageClassArray (SgOmpTaskwaitStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgOmpThreadprivateStatement ) ; 
     std::cout << " SgOmpThreadprivateStatement has size " << sizeOfActualPool << std::endl;
     SgOmpThreadprivateStatementStorageClass* SgOmpThreadprivateStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpThreadprivateStatementStorageArray = new SgOmpThreadprivateStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgOmpThreadprivateStatement_initializeStorageClassArray (SgOmpThreadprivateStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgOmpWorkshareStatement ) ; 
     std::cout << " SgOmpWorkshareStatement has size " << sizeOfActualPool << std::endl;
     SgOmpWorkshareStatementStorageClass* SgOmpWorkshareStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpWorkshareStatementStorageArray = new SgOmpWorkshareStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgOmpWorkshareStatement_initializeStorageClassArray (SgOmpWorkshareStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgOmpClause ) ; 
     std::cout << " SgOmpClause has size " << sizeOfActualPool << std::endl;
     SgOmpClauseStorageClass* SgOmpClauseStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpClauseStorageArray = new SgOmpClauseStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgOmpClause_initializeStorageClassArray (SgOmpClauseStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgOmpCollapseClause ) ; 
     std::cout << " SgOmpCollapseClause has size " << sizeOfActualPool << std::endl;
     SgOmpCollapseClauseStorageClass* SgOmpCollapseClauseStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpCollapseClauseStorageArray = new SgOmpCollapseClauseStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgOmpCollapseClause_initializeStorageClassArray (SgOmpCollapseClauseStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgOmpCopyinClause ) ; 
     std::cout << " SgOmpCopyinClause has size " << sizeOfActualPool << std::endl;
     SgOmpCopyinClauseStorageClass* SgOmpCopyinClauseStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpCopyinClauseStorageArray = new SgOmpCopyinClauseStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgOmpCopyinClause_initializeStorageClassArray (SgOmpCopyinClauseStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgOmpCopyprivateClause ) ; 
     std::cout << " SgOmpCopyprivateClause has size " << sizeOfActualPool << std::endl;
     SgOmpCopyprivateClauseStorageClass* SgOmpCopyprivateClauseStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpCopyprivateClauseStorageArray = new SgOmpCopyprivateClauseStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgOmpCopyprivateClause_initializeStorageClassArray (SgOmpCopyprivateClauseStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgOmpDefaultClause ) ; 
     std::cout << " SgOmpDefaultClause has size " << sizeOfActualPool << std::endl;
     SgOmpDefaultClauseStorageClass* SgOmpDefaultClauseStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpDefaultClauseStorageArray = new SgOmpDefaultClauseStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgOmpDefaultClause_initializeStorageClassArray (SgOmpDefaultClauseStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgOmpExpressionClause ) ; 
     std::cout << " SgOmpExpressionClause has size " << sizeOfActualPool << std::endl;
     SgOmpExpressionClauseStorageClass* SgOmpExpressionClauseStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpExpressionClauseStorageArray = new SgOmpExpressionClauseStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgOmpExpressionClause_initializeStorageClassArray (SgOmpExpressionClauseStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgOmpFirstprivateClause ) ; 
     std::cout << " SgOmpFirstprivateClause has size " << sizeOfActualPool << std::endl;
     SgOmpFirstprivateClauseStorageClass* SgOmpFirstprivateClauseStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpFirstprivateClauseStorageArray = new SgOmpFirstprivateClauseStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgOmpFirstprivateClause_initializeStorageClassArray (SgOmpFirstprivateClauseStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgOmpIfClause ) ; 
     std::cout << " SgOmpIfClause has size " << sizeOfActualPool << std::endl;
     SgOmpIfClauseStorageClass* SgOmpIfClauseStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpIfClauseStorageArray = new SgOmpIfClauseStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgOmpIfClause_initializeStorageClassArray (SgOmpIfClauseStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgOmpLastprivateClause ) ; 
     std::cout << " SgOmpLastprivateClause has size " << sizeOfActualPool << std::endl;
     SgOmpLastprivateClauseStorageClass* SgOmpLastprivateClauseStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpLastprivateClauseStorageArray = new SgOmpLastprivateClauseStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgOmpLastprivateClause_initializeStorageClassArray (SgOmpLastprivateClauseStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgOmpNowaitClause ) ; 
     std::cout << " SgOmpNowaitClause has size " << sizeOfActualPool << std::endl;
     SgOmpNowaitClauseStorageClass* SgOmpNowaitClauseStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpNowaitClauseStorageArray = new SgOmpNowaitClauseStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgOmpNowaitClause_initializeStorageClassArray (SgOmpNowaitClauseStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgOmpNumThreadsClause ) ; 
     std::cout << " SgOmpNumThreadsClause has size " << sizeOfActualPool << std::endl;
     SgOmpNumThreadsClauseStorageClass* SgOmpNumThreadsClauseStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpNumThreadsClauseStorageArray = new SgOmpNumThreadsClauseStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgOmpNumThreadsClause_initializeStorageClassArray (SgOmpNumThreadsClauseStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgOmpOrderedClause ) ; 
     std::cout << " SgOmpOrderedClause has size " << sizeOfActualPool << std::endl;
     SgOmpOrderedClauseStorageClass* SgOmpOrderedClauseStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpOrderedClauseStorageArray = new SgOmpOrderedClauseStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgOmpOrderedClause_initializeStorageClassArray (SgOmpOrderedClauseStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgOmpPrivateClause ) ; 
     std::cout << " SgOmpPrivateClause has size " << sizeOfActualPool << std::endl;
     SgOmpPrivateClauseStorageClass* SgOmpPrivateClauseStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpPrivateClauseStorageArray = new SgOmpPrivateClauseStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgOmpPrivateClause_initializeStorageClassArray (SgOmpPrivateClauseStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgOmpReductionClause ) ; 
     std::cout << " SgOmpReductionClause has size " << sizeOfActualPool << std::endl;
     SgOmpReductionClauseStorageClass* SgOmpReductionClauseStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpReductionClauseStorageArray = new SgOmpReductionClauseStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgOmpReductionClause_initializeStorageClassArray (SgOmpReductionClauseStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgOmpScheduleClause ) ; 
     std::cout << " SgOmpScheduleClause has size " << sizeOfActualPool << std::endl;
     SgOmpScheduleClauseStorageClass* SgOmpScheduleClauseStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpScheduleClauseStorageArray = new SgOmpScheduleClauseStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgOmpScheduleClause_initializeStorageClassArray (SgOmpScheduleClauseStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgOmpSharedClause ) ; 
     std::cout << " SgOmpSharedClause has size " << sizeOfActualPool << std::endl;
     SgOmpSharedClauseStorageClass* SgOmpSharedClauseStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpSharedClauseStorageArray = new SgOmpSharedClauseStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgOmpSharedClause_initializeStorageClassArray (SgOmpSharedClauseStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgOmpUntiedClause ) ; 
     std::cout << " SgOmpUntiedClause has size " << sizeOfActualPool << std::endl;
     SgOmpUntiedClauseStorageClass* SgOmpUntiedClauseStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpUntiedClauseStorageArray = new SgOmpUntiedClauseStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgOmpUntiedClause_initializeStorageClassArray (SgOmpUntiedClauseStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgOmpVariablesClause ) ; 
     std::cout << " SgOmpVariablesClause has size " << sizeOfActualPool << std::endl;
     SgOmpVariablesClauseStorageClass* SgOmpVariablesClauseStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpVariablesClauseStorageArray = new SgOmpVariablesClauseStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgOmpVariablesClause_initializeStorageClassArray (SgOmpVariablesClauseStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgOpenclAccessModeModifier ) ; 
     std::cout << " SgOpenclAccessModeModifier has size " << sizeOfActualPool << std::endl;
     SgOpenclAccessModeModifierStorageClass* SgOpenclAccessModeModifierStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOpenclAccessModeModifierStorageArray = new SgOpenclAccessModeModifierStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgOpenclAccessModeModifier_initializeStorageClassArray (SgOpenclAccessModeModifierStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgOpenStatement ) ; 
     std::cout << " SgOpenStatement has size " << sizeOfActualPool << std::endl;
     SgOpenStatementStorageClass* SgOpenStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOpenStatementStorageArray = new SgOpenStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgOpenStatement_initializeStorageClassArray (SgOpenStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgOptions ) ; 
     std::cout << " SgOptions has size " << sizeOfActualPool << std::endl;
     SgOptionsStorageClass* SgOptionsStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOptionsStorageArray = new SgOptionsStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgOptions_initializeStorageClassArray (SgOptionsStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgOrOp ) ; 
     std::cout << " SgOrOp has size " << sizeOfActualPool << std::endl;
     SgOrOpStorageClass* SgOrOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOrOpStorageArray = new SgOrOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgOrOp_initializeStorageClassArray (SgOrOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgParameterStatement ) ; 
     std::cout << " SgParameterStatement has size " << sizeOfActualPool << std::endl;
     SgParameterStatementStorageClass* SgParameterStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgParameterStatementStorageArray = new SgParameterStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgParameterStatement_initializeStorageClassArray (SgParameterStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgPartialFunctionModifierType ) ; 
     std::cout << " SgPartialFunctionModifierType has size " << sizeOfActualPool << std::endl;
     SgPartialFunctionModifierTypeStorageClass* SgPartialFunctionModifierTypeStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgPartialFunctionModifierTypeStorageArray = new SgPartialFunctionModifierTypeStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgPartialFunctionModifierType_initializeStorageClassArray (SgPartialFunctionModifierTypeStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgPartialFunctionType ) ; 
     std::cout << " SgPartialFunctionType has size " << sizeOfActualPool << std::endl;
     SgPartialFunctionTypeStorageClass* SgPartialFunctionTypeStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgPartialFunctionTypeStorageArray = new SgPartialFunctionTypeStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgPartialFunctionType_initializeStorageClassArray (SgPartialFunctionTypeStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgPassStatement ) ; 
     std::cout << " SgPassStatement has size " << sizeOfActualPool << std::endl;
     SgPassStatementStorageClass* SgPassStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgPassStatementStorageArray = new SgPassStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgPassStatement_initializeStorageClassArray (SgPassStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgPlusAssignOp ) ; 
     std::cout << " SgPlusAssignOp has size " << sizeOfActualPool << std::endl;
     SgPlusAssignOpStorageClass* SgPlusAssignOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgPlusAssignOpStorageArray = new SgPlusAssignOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgPlusAssignOp_initializeStorageClassArray (SgPlusAssignOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgPlusPlusOp ) ; 
     std::cout << " SgPlusPlusOp has size " << sizeOfActualPool << std::endl;
     SgPlusPlusOpStorageClass* SgPlusPlusOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgPlusPlusOpStorageArray = new SgPlusPlusOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgPlusPlusOp_initializeStorageClassArray (SgPlusPlusOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgPntrArrRefExp ) ; 
     std::cout << " SgPntrArrRefExp has size " << sizeOfActualPool << std::endl;
     SgPntrArrRefExpStorageClass* SgPntrArrRefExpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgPntrArrRefExpStorageArray = new SgPntrArrRefExpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgPntrArrRefExp_initializeStorageClassArray (SgPntrArrRefExpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgPointerAssignOp ) ; 
     std::cout << " SgPointerAssignOp has size " << sizeOfActualPool << std::endl;
     SgPointerAssignOpStorageClass* SgPointerAssignOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgPointerAssignOpStorageArray = new SgPointerAssignOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgPointerAssignOp_initializeStorageClassArray (SgPointerAssignOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgPointerDerefExp ) ; 
     std::cout << " SgPointerDerefExp has size " << sizeOfActualPool << std::endl;
     SgPointerDerefExpStorageClass* SgPointerDerefExpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgPointerDerefExpStorageArray = new SgPointerDerefExpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgPointerDerefExp_initializeStorageClassArray (SgPointerDerefExpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgPointerMemberType ) ; 
     std::cout << " SgPointerMemberType has size " << sizeOfActualPool << std::endl;
     SgPointerMemberTypeStorageClass* SgPointerMemberTypeStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgPointerMemberTypeStorageArray = new SgPointerMemberTypeStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgPointerMemberType_initializeStorageClassArray (SgPointerMemberTypeStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgPointerType ) ; 
     std::cout << " SgPointerType has size " << sizeOfActualPool << std::endl;
     SgPointerTypeStorageClass* SgPointerTypeStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgPointerTypeStorageArray = new SgPointerTypeStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgPointerType_initializeStorageClassArray (SgPointerTypeStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgPragma ) ; 
     std::cout << " SgPragma has size " << sizeOfActualPool << std::endl;
     SgPragmaStorageClass* SgPragmaStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgPragmaStorageArray = new SgPragmaStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgPragma_initializeStorageClassArray (SgPragmaStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgPragmaDeclaration ) ; 
     std::cout << " SgPragmaDeclaration has size " << sizeOfActualPool << std::endl;
     SgPragmaDeclarationStorageClass* SgPragmaDeclarationStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgPragmaDeclarationStorageArray = new SgPragmaDeclarationStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgPragmaDeclaration_initializeStorageClassArray (SgPragmaDeclarationStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgPrintStatement ) ; 
     std::cout << " SgPrintStatement has size " << sizeOfActualPool << std::endl;
     SgPrintStatementStorageClass* SgPrintStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgPrintStatementStorageArray = new SgPrintStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgPrintStatement_initializeStorageClassArray (SgPrintStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgProcedureHeaderStatement ) ; 
     std::cout << " SgProcedureHeaderStatement has size " << sizeOfActualPool << std::endl;
     SgProcedureHeaderStatementStorageClass* SgProcedureHeaderStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgProcedureHeaderStatementStorageArray = new SgProcedureHeaderStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgProcedureHeaderStatement_initializeStorageClassArray (SgProcedureHeaderStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgProgramHeaderStatement ) ; 
     std::cout << " SgProgramHeaderStatement has size " << sizeOfActualPool << std::endl;
     SgProgramHeaderStatementStorageClass* SgProgramHeaderStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgProgramHeaderStatementStorageArray = new SgProgramHeaderStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgProgramHeaderStatement_initializeStorageClassArray (SgProgramHeaderStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgProject ) ; 
     std::cout << " SgProject has size " << sizeOfActualPool << std::endl;
     SgProjectStorageClass* SgProjectStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgProjectStorageArray = new SgProjectStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgProject_initializeStorageClassArray (SgProjectStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgPseudoDestructorRefExp ) ; 
     std::cout << " SgPseudoDestructorRefExp has size " << sizeOfActualPool << std::endl;
     SgPseudoDestructorRefExpStorageClass* SgPseudoDestructorRefExpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgPseudoDestructorRefExpStorageArray = new SgPseudoDestructorRefExpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgPseudoDestructorRefExp_initializeStorageClassArray (SgPseudoDestructorRefExpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgPythonGlobalStmt ) ; 
     std::cout << " SgPythonGlobalStmt has size " << sizeOfActualPool << std::endl;
     SgPythonGlobalStmtStorageClass* SgPythonGlobalStmtStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgPythonGlobalStmtStorageArray = new SgPythonGlobalStmtStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgPythonGlobalStmt_initializeStorageClassArray (SgPythonGlobalStmtStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgPythonPrintStmt ) ; 
     std::cout << " SgPythonPrintStmt has size " << sizeOfActualPool << std::endl;
     SgPythonPrintStmtStorageClass* SgPythonPrintStmtStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgPythonPrintStmtStorageArray = new SgPythonPrintStmtStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgPythonPrintStmt_initializeStorageClassArray (SgPythonPrintStmtStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgQualifiedName ) ; 
     std::cout << " SgQualifiedName has size " << sizeOfActualPool << std::endl;
     SgQualifiedNameStorageClass* SgQualifiedNameStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgQualifiedNameStorageArray = new SgQualifiedNameStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgQualifiedName_initializeStorageClassArray (SgQualifiedNameStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgQualifiedNameType ) ; 
     std::cout << " SgQualifiedNameType has size " << sizeOfActualPool << std::endl;
     SgQualifiedNameTypeStorageClass* SgQualifiedNameTypeStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgQualifiedNameTypeStorageArray = new SgQualifiedNameTypeStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgQualifiedNameType_initializeStorageClassArray (SgQualifiedNameTypeStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgReadStatement ) ; 
     std::cout << " SgReadStatement has size " << sizeOfActualPool << std::endl;
     SgReadStatementStorageClass* SgReadStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgReadStatementStorageArray = new SgReadStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgReadStatement_initializeStorageClassArray (SgReadStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgRealPartOp ) ; 
     std::cout << " SgRealPartOp has size " << sizeOfActualPool << std::endl;
     SgRealPartOpStorageClass* SgRealPartOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgRealPartOpStorageArray = new SgRealPartOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgRealPartOp_initializeStorageClassArray (SgRealPartOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgRefExp ) ; 
     std::cout << " SgRefExp has size " << sizeOfActualPool << std::endl;
     SgRefExpStorageClass* SgRefExpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgRefExpStorageArray = new SgRefExpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgRefExp_initializeStorageClassArray (SgRefExpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgReferenceType ) ; 
     std::cout << " SgReferenceType has size " << sizeOfActualPool << std::endl;
     SgReferenceTypeStorageClass* SgReferenceTypeStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgReferenceTypeStorageArray = new SgReferenceTypeStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgReferenceType_initializeStorageClassArray (SgReferenceTypeStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgRenamePair ) ; 
     std::cout << " SgRenamePair has size " << sizeOfActualPool << std::endl;
     SgRenamePairStorageClass* SgRenamePairStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgRenamePairStorageArray = new SgRenamePairStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgRenamePair_initializeStorageClassArray (SgRenamePairStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgRenameSymbol ) ; 
     std::cout << " SgRenameSymbol has size " << sizeOfActualPool << std::endl;
     SgRenameSymbolStorageClass* SgRenameSymbolStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgRenameSymbolStorageArray = new SgRenameSymbolStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgRenameSymbol_initializeStorageClassArray (SgRenameSymbolStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgReturnStmt ) ; 
     std::cout << " SgReturnStmt has size " << sizeOfActualPool << std::endl;
     SgReturnStmtStorageClass* SgReturnStmtStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgReturnStmtStorageArray = new SgReturnStmtStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgReturnStmt_initializeStorageClassArray (SgReturnStmtStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgRewindStatement ) ; 
     std::cout << " SgRewindStatement has size " << sizeOfActualPool << std::endl;
     SgRewindStatementStorageClass* SgRewindStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgRewindStatementStorageArray = new SgRewindStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgRewindStatement_initializeStorageClassArray (SgRewindStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgRshiftAssignOp ) ; 
     std::cout << " SgRshiftAssignOp has size " << sizeOfActualPool << std::endl;
     SgRshiftAssignOpStorageClass* SgRshiftAssignOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgRshiftAssignOpStorageArray = new SgRshiftAssignOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgRshiftAssignOp_initializeStorageClassArray (SgRshiftAssignOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgRshiftOp ) ; 
     std::cout << " SgRshiftOp has size " << sizeOfActualPool << std::endl;
     SgRshiftOpStorageClass* SgRshiftOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgRshiftOpStorageArray = new SgRshiftOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgRshiftOp_initializeStorageClassArray (SgRshiftOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgJavaUnsignedRshiftAssignOp ) ; 
     std::cout << " SgJavaUnsignedRshiftAssignOp has size " << sizeOfActualPool << std::endl;
     SgJavaUnsignedRshiftAssignOpStorageClass* SgJavaUnsignedRshiftAssignOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgJavaUnsignedRshiftAssignOpStorageArray = new SgJavaUnsignedRshiftAssignOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgJavaUnsignedRshiftAssignOp_initializeStorageClassArray (SgJavaUnsignedRshiftAssignOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgJavaUnsignedRshiftOp ) ; 
     std::cout << " SgJavaUnsignedRshiftOp has size " << sizeOfActualPool << std::endl;
     SgJavaUnsignedRshiftOpStorageClass* SgJavaUnsignedRshiftOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgJavaUnsignedRshiftOpStorageArray = new SgJavaUnsignedRshiftOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgJavaUnsignedRshiftOp_initializeStorageClassArray (SgJavaUnsignedRshiftOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgScopeOp ) ; 
     std::cout << " SgScopeOp has size " << sizeOfActualPool << std::endl;
     SgScopeOpStorageClass* SgScopeOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgScopeOpStorageArray = new SgScopeOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgScopeOp_initializeStorageClassArray (SgScopeOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgScopeStatement ) ; 
     std::cout << " SgScopeStatement has size " << sizeOfActualPool << std::endl;
     SgScopeStatementStorageClass* SgScopeStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgScopeStatementStorageArray = new SgScopeStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgScopeStatement_initializeStorageClassArray (SgScopeStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgSequenceStatement ) ; 
     std::cout << " SgSequenceStatement has size " << sizeOfActualPool << std::endl;
     SgSequenceStatementStorageClass* SgSequenceStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgSequenceStatementStorageArray = new SgSequenceStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgSequenceStatement_initializeStorageClassArray (SgSequenceStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgSetComprehension ) ; 
     std::cout << " SgSetComprehension has size " << sizeOfActualPool << std::endl;
     SgSetComprehensionStorageClass* SgSetComprehensionStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgSetComprehensionStorageArray = new SgSetComprehensionStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgSetComprehension_initializeStorageClassArray (SgSetComprehensionStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgShortVal ) ; 
     std::cout << " SgShortVal has size " << sizeOfActualPool << std::endl;
     SgShortValStorageClass* SgShortValStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgShortValStorageArray = new SgShortValStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgShortVal_initializeStorageClassArray (SgShortValStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgSizeOfOp ) ; 
     std::cout << " SgSizeOfOp has size " << sizeOfActualPool << std::endl;
     SgSizeOfOpStorageClass* SgSizeOfOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgSizeOfOpStorageArray = new SgSizeOfOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgSizeOfOp_initializeStorageClassArray (SgSizeOfOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgJavaInstanceOfOp ) ; 
     std::cout << " SgJavaInstanceOfOp has size " << sizeOfActualPool << std::endl;
     SgJavaInstanceOfOpStorageClass* SgJavaInstanceOfOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgJavaInstanceOfOpStorageArray = new SgJavaInstanceOfOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgJavaInstanceOfOp_initializeStorageClassArray (SgJavaInstanceOfOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgSourceFile ) ; 
     std::cout << " SgSourceFile has size " << sizeOfActualPool << std::endl;
     SgSourceFileStorageClass* SgSourceFileStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgSourceFileStorageArray = new SgSourceFileStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgSourceFile_initializeStorageClassArray (SgSourceFileStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgSpawnStmt ) ; 
     std::cout << " SgSpawnStmt has size " << sizeOfActualPool << std::endl;
     SgSpawnStmtStorageClass* SgSpawnStmtStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgSpawnStmtStorageArray = new SgSpawnStmtStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgSpawnStmt_initializeStorageClassArray (SgSpawnStmtStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgJavaThrowStatement ) ; 
     std::cout << " SgJavaThrowStatement has size " << sizeOfActualPool << std::endl;
     SgJavaThrowStatementStorageClass* SgJavaThrowStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgJavaThrowStatementStorageArray = new SgJavaThrowStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgJavaThrowStatement_initializeStorageClassArray (SgJavaThrowStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgJavaForEachStatement ) ; 
     std::cout << " SgJavaForEachStatement has size " << sizeOfActualPool << std::endl;
     SgJavaForEachStatementStorageClass* SgJavaForEachStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgJavaForEachStatementStorageArray = new SgJavaForEachStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgJavaForEachStatement_initializeStorageClassArray (SgJavaForEachStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgJavaSynchronizedStatement ) ; 
     std::cout << " SgJavaSynchronizedStatement has size " << sizeOfActualPool << std::endl;
     SgJavaSynchronizedStatementStorageClass* SgJavaSynchronizedStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgJavaSynchronizedStatementStorageArray = new SgJavaSynchronizedStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgJavaSynchronizedStatement_initializeStorageClassArray (SgJavaSynchronizedStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgJavaParameterizedType ) ; 
     std::cout << " SgJavaParameterizedType has size " << sizeOfActualPool << std::endl;
     SgJavaParameterizedTypeStorageClass* SgJavaParameterizedTypeStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgJavaParameterizedTypeStorageArray = new SgJavaParameterizedTypeStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgJavaParameterizedType_initializeStorageClassArray (SgJavaParameterizedTypeStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgSpecialFunctionModifier ) ; 
     std::cout << " SgSpecialFunctionModifier has size " << sizeOfActualPool << std::endl;
     SgSpecialFunctionModifierStorageClass* SgSpecialFunctionModifierStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgSpecialFunctionModifierStorageArray = new SgSpecialFunctionModifierStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgSpecialFunctionModifier_initializeStorageClassArray (SgSpecialFunctionModifierStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgStatement ) ; 
     std::cout << " SgStatement has size " << sizeOfActualPool << std::endl;
     SgStatementStorageClass* SgStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgStatementStorageArray = new SgStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgStatement_initializeStorageClassArray (SgStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgStmtDeclarationStatement ) ; 
     std::cout << " SgStmtDeclarationStatement has size " << sizeOfActualPool << std::endl;
     SgStmtDeclarationStatementStorageClass* SgStmtDeclarationStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgStmtDeclarationStatementStorageArray = new SgStmtDeclarationStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgStmtDeclarationStatement_initializeStorageClassArray (SgStmtDeclarationStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgStatementExpression ) ; 
     std::cout << " SgStatementExpression has size " << sizeOfActualPool << std::endl;
     SgStatementExpressionStorageClass* SgStatementExpressionStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgStatementExpressionStorageArray = new SgStatementExpressionStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgStatementExpression_initializeStorageClassArray (SgStatementExpressionStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgStatementFunctionStatement ) ; 
     std::cout << " SgStatementFunctionStatement has size " << sizeOfActualPool << std::endl;
     SgStatementFunctionStatementStorageClass* SgStatementFunctionStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgStatementFunctionStatementStorageArray = new SgStatementFunctionStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgStatementFunctionStatement_initializeStorageClassArray (SgStatementFunctionStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgStopOrPauseStatement ) ; 
     std::cout << " SgStopOrPauseStatement has size " << sizeOfActualPool << std::endl;
     SgStopOrPauseStatementStorageClass* SgStopOrPauseStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgStopOrPauseStatementStorageArray = new SgStopOrPauseStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgStopOrPauseStatement_initializeStorageClassArray (SgStopOrPauseStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgStorageModifier ) ; 
     std::cout << " SgStorageModifier has size " << sizeOfActualPool << std::endl;
     SgStorageModifierStorageClass* SgStorageModifierStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgStorageModifierStorageArray = new SgStorageModifierStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgStorageModifier_initializeStorageClassArray (SgStorageModifierStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgStringConversion ) ; 
     std::cout << " SgStringConversion has size " << sizeOfActualPool << std::endl;
     SgStringConversionStorageClass* SgStringConversionStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgStringConversionStorageArray = new SgStringConversionStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgStringConversion_initializeStorageClassArray (SgStringConversionStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgStringKeyedBidirectionalGraph ) ; 
     std::cout << " SgStringKeyedBidirectionalGraph has size " << sizeOfActualPool << std::endl;
     SgStringKeyedBidirectionalGraphStorageClass* SgStringKeyedBidirectionalGraphStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgStringKeyedBidirectionalGraphStorageArray = new SgStringKeyedBidirectionalGraphStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgStringKeyedBidirectionalGraph_initializeStorageClassArray (SgStringKeyedBidirectionalGraphStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgStringVal ) ; 
     std::cout << " SgStringVal has size " << sizeOfActualPool << std::endl;
     SgStringValStorageClass* SgStringValStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgStringValStorageArray = new SgStringValStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgStringVal_initializeStorageClassArray (SgStringValStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgSubscriptExpression ) ; 
     std::cout << " SgSubscriptExpression has size " << sizeOfActualPool << std::endl;
     SgSubscriptExpressionStorageClass* SgSubscriptExpressionStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgSubscriptExpressionStorageArray = new SgSubscriptExpressionStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgSubscriptExpression_initializeStorageClassArray (SgSubscriptExpressionStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgSubtractOp ) ; 
     std::cout << " SgSubtractOp has size " << sizeOfActualPool << std::endl;
     SgSubtractOpStorageClass* SgSubtractOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgSubtractOpStorageArray = new SgSubtractOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgSubtractOp_initializeStorageClassArray (SgSubtractOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgSupport ) ; 
     std::cout << " SgSupport has size " << sizeOfActualPool << std::endl;
     SgSupportStorageClass* SgSupportStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgSupportStorageArray = new SgSupportStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgSupport_initializeStorageClassArray (SgSupportStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgSwitchStatement ) ; 
     std::cout << " SgSwitchStatement has size " << sizeOfActualPool << std::endl;
     SgSwitchStatementStorageClass* SgSwitchStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgSwitchStatementStorageArray = new SgSwitchStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgSwitchStatement_initializeStorageClassArray (SgSwitchStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgSymbolTable ) ; 
     std::cout << " SgSymbolTable has size " << sizeOfActualPool << std::endl;
     SgSymbolTableStorageClass* SgSymbolTableStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgSymbolTableStorageArray = new SgSymbolTableStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgSymbolTable_initializeStorageClassArray (SgSymbolTableStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgTemplateArgument ) ; 
     std::cout << " SgTemplateArgument has size " << sizeOfActualPool << std::endl;
     SgTemplateArgumentStorageClass* SgTemplateArgumentStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTemplateArgumentStorageArray = new SgTemplateArgumentStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgTemplateArgument_initializeStorageClassArray (SgTemplateArgumentStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgTemplateArgumentList ) ; 
     std::cout << " SgTemplateArgumentList has size " << sizeOfActualPool << std::endl;
     SgTemplateArgumentListStorageClass* SgTemplateArgumentListStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTemplateArgumentListStorageArray = new SgTemplateArgumentListStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgTemplateArgumentList_initializeStorageClassArray (SgTemplateArgumentListStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgTemplateDeclaration ) ; 
     std::cout << " SgTemplateDeclaration has size " << sizeOfActualPool << std::endl;
     SgTemplateDeclarationStorageClass* SgTemplateDeclarationStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTemplateDeclarationStorageArray = new SgTemplateDeclarationStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgTemplateDeclaration_initializeStorageClassArray (SgTemplateDeclarationStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgTemplateClassDeclaration ) ; 
     std::cout << " SgTemplateClassDeclaration has size " << sizeOfActualPool << std::endl;
     SgTemplateClassDeclarationStorageClass* SgTemplateClassDeclarationStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTemplateClassDeclarationStorageArray = new SgTemplateClassDeclarationStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgTemplateClassDeclaration_initializeStorageClassArray (SgTemplateClassDeclarationStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgTemplateFunctionDeclaration ) ; 
     std::cout << " SgTemplateFunctionDeclaration has size " << sizeOfActualPool << std::endl;
     SgTemplateFunctionDeclarationStorageClass* SgTemplateFunctionDeclarationStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTemplateFunctionDeclarationStorageArray = new SgTemplateFunctionDeclarationStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgTemplateFunctionDeclaration_initializeStorageClassArray (SgTemplateFunctionDeclarationStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgTemplateMemberFunctionDeclaration ) ; 
     std::cout << " SgTemplateMemberFunctionDeclaration has size " << sizeOfActualPool << std::endl;
     SgTemplateMemberFunctionDeclarationStorageClass* SgTemplateMemberFunctionDeclarationStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTemplateMemberFunctionDeclarationStorageArray = new SgTemplateMemberFunctionDeclarationStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgTemplateMemberFunctionDeclaration_initializeStorageClassArray (SgTemplateMemberFunctionDeclarationStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgTemplateClassDefinition ) ; 
     std::cout << " SgTemplateClassDefinition has size " << sizeOfActualPool << std::endl;
     SgTemplateClassDefinitionStorageClass* SgTemplateClassDefinitionStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTemplateClassDefinitionStorageArray = new SgTemplateClassDefinitionStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgTemplateClassDefinition_initializeStorageClassArray (SgTemplateClassDefinitionStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgTemplateFunctionDefinition ) ; 
     std::cout << " SgTemplateFunctionDefinition has size " << sizeOfActualPool << std::endl;
     SgTemplateFunctionDefinitionStorageClass* SgTemplateFunctionDefinitionStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTemplateFunctionDefinitionStorageArray = new SgTemplateFunctionDefinitionStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgTemplateFunctionDefinition_initializeStorageClassArray (SgTemplateFunctionDefinitionStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgTemplateInstantiationDecl ) ; 
     std::cout << " SgTemplateInstantiationDecl has size " << sizeOfActualPool << std::endl;
     SgTemplateInstantiationDeclStorageClass* SgTemplateInstantiationDeclStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTemplateInstantiationDeclStorageArray = new SgTemplateInstantiationDeclStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgTemplateInstantiationDecl_initializeStorageClassArray (SgTemplateInstantiationDeclStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgTemplateInstantiationDefn ) ; 
     std::cout << " SgTemplateInstantiationDefn has size " << sizeOfActualPool << std::endl;
     SgTemplateInstantiationDefnStorageClass* SgTemplateInstantiationDefnStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTemplateInstantiationDefnStorageArray = new SgTemplateInstantiationDefnStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgTemplateInstantiationDefn_initializeStorageClassArray (SgTemplateInstantiationDefnStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgTemplateInstantiationDirectiveStatement ) ; 
     std::cout << " SgTemplateInstantiationDirectiveStatement has size " << sizeOfActualPool << std::endl;
     SgTemplateInstantiationDirectiveStatementStorageClass* SgTemplateInstantiationDirectiveStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTemplateInstantiationDirectiveStatementStorageArray = new SgTemplateInstantiationDirectiveStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgTemplateInstantiationDirectiveStatement_initializeStorageClassArray (SgTemplateInstantiationDirectiveStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgTemplateInstantiationFunctionDecl ) ; 
     std::cout << " SgTemplateInstantiationFunctionDecl has size " << sizeOfActualPool << std::endl;
     SgTemplateInstantiationFunctionDeclStorageClass* SgTemplateInstantiationFunctionDeclStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTemplateInstantiationFunctionDeclStorageArray = new SgTemplateInstantiationFunctionDeclStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgTemplateInstantiationFunctionDecl_initializeStorageClassArray (SgTemplateInstantiationFunctionDeclStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgTemplateInstantiationMemberFunctionDecl ) ; 
     std::cout << " SgTemplateInstantiationMemberFunctionDecl has size " << sizeOfActualPool << std::endl;
     SgTemplateInstantiationMemberFunctionDeclStorageClass* SgTemplateInstantiationMemberFunctionDeclStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTemplateInstantiationMemberFunctionDeclStorageArray = new SgTemplateInstantiationMemberFunctionDeclStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgTemplateInstantiationMemberFunctionDecl_initializeStorageClassArray (SgTemplateInstantiationMemberFunctionDeclStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgTemplateParameter ) ; 
     std::cout << " SgTemplateParameter has size " << sizeOfActualPool << std::endl;
     SgTemplateParameterStorageClass* SgTemplateParameterStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTemplateParameterStorageArray = new SgTemplateParameterStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgTemplateParameter_initializeStorageClassArray (SgTemplateParameterStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgTemplateParameterList ) ; 
     std::cout << " SgTemplateParameterList has size " << sizeOfActualPool << std::endl;
     SgTemplateParameterListStorageClass* SgTemplateParameterListStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTemplateParameterListStorageArray = new SgTemplateParameterListStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgTemplateParameterList_initializeStorageClassArray (SgTemplateParameterListStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgTemplateSymbol ) ; 
     std::cout << " SgTemplateSymbol has size " << sizeOfActualPool << std::endl;
     SgTemplateSymbolStorageClass* SgTemplateSymbolStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTemplateSymbolStorageArray = new SgTemplateSymbolStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgTemplateSymbol_initializeStorageClassArray (SgTemplateSymbolStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgTemplateType ) ; 
     std::cout << " SgTemplateType has size " << sizeOfActualPool << std::endl;
     SgTemplateTypeStorageClass* SgTemplateTypeStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTemplateTypeStorageArray = new SgTemplateTypeStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgTemplateType_initializeStorageClassArray (SgTemplateTypeStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgThisExp ) ; 
     std::cout << " SgThisExp has size " << sizeOfActualPool << std::endl;
     SgThisExpStorageClass* SgThisExpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgThisExpStorageArray = new SgThisExpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgThisExp_initializeStorageClassArray (SgThisExpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgSuperExp ) ; 
     std::cout << " SgSuperExp has size " << sizeOfActualPool << std::endl;
     SgSuperExpStorageClass* SgSuperExpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgSuperExpStorageArray = new SgSuperExpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgSuperExp_initializeStorageClassArray (SgSuperExpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgThrowOp ) ; 
     std::cout << " SgThrowOp has size " << sizeOfActualPool << std::endl;
     SgThrowOpStorageClass* SgThrowOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgThrowOpStorageArray = new SgThrowOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgThrowOp_initializeStorageClassArray (SgThrowOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgToken ) ; 
     std::cout << " SgToken has size " << sizeOfActualPool << std::endl;
     SgTokenStorageClass* SgTokenStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTokenStorageArray = new SgTokenStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgToken_initializeStorageClassArray (SgTokenStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgTryStmt ) ; 
     std::cout << " SgTryStmt has size " << sizeOfActualPool << std::endl;
     SgTryStmtStorageClass* SgTryStmtStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTryStmtStorageArray = new SgTryStmtStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgTryStmt_initializeStorageClassArray (SgTryStmtStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgTupleExp ) ; 
     std::cout << " SgTupleExp has size " << sizeOfActualPool << std::endl;
     SgTupleExpStorageClass* SgTupleExpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTupleExpStorageArray = new SgTupleExpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgTupleExp_initializeStorageClassArray (SgTupleExpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgType ) ; 
     std::cout << " SgType has size " << sizeOfActualPool << std::endl;
     SgTypeStorageClass* SgTypeStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeStorageArray = new SgTypeStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgType_initializeStorageClassArray (SgTypeStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgTypeBool ) ; 
     std::cout << " SgTypeBool has size " << sizeOfActualPool << std::endl;
     SgTypeBoolStorageClass* SgTypeBoolStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeBoolStorageArray = new SgTypeBoolStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgTypeBool_initializeStorageClassArray (SgTypeBoolStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgTypeChar ) ; 
     std::cout << " SgTypeChar has size " << sizeOfActualPool << std::endl;
     SgTypeCharStorageClass* SgTypeCharStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeCharStorageArray = new SgTypeCharStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgTypeChar_initializeStorageClassArray (SgTypeCharStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgTypeComplex ) ; 
     std::cout << " SgTypeComplex has size " << sizeOfActualPool << std::endl;
     SgTypeComplexStorageClass* SgTypeComplexStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeComplexStorageArray = new SgTypeComplexStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgTypeComplex_initializeStorageClassArray (SgTypeComplexStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgTypeDefault ) ; 
     std::cout << " SgTypeDefault has size " << sizeOfActualPool << std::endl;
     SgTypeDefaultStorageClass* SgTypeDefaultStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeDefaultStorageArray = new SgTypeDefaultStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgTypeDefault_initializeStorageClassArray (SgTypeDefaultStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgTypeLabel ) ; 
     std::cout << " SgTypeLabel has size " << sizeOfActualPool << std::endl;
     SgTypeLabelStorageClass* SgTypeLabelStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeLabelStorageArray = new SgTypeLabelStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgTypeLabel_initializeStorageClassArray (SgTypeLabelStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgTypeDouble ) ; 
     std::cout << " SgTypeDouble has size " << sizeOfActualPool << std::endl;
     SgTypeDoubleStorageClass* SgTypeDoubleStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeDoubleStorageArray = new SgTypeDoubleStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgTypeDouble_initializeStorageClassArray (SgTypeDoubleStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgTypeEllipse ) ; 
     std::cout << " SgTypeEllipse has size " << sizeOfActualPool << std::endl;
     SgTypeEllipseStorageClass* SgTypeEllipseStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeEllipseStorageArray = new SgTypeEllipseStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgTypeEllipse_initializeStorageClassArray (SgTypeEllipseStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgTypeFloat ) ; 
     std::cout << " SgTypeFloat has size " << sizeOfActualPool << std::endl;
     SgTypeFloatStorageClass* SgTypeFloatStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeFloatStorageArray = new SgTypeFloatStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgTypeFloat_initializeStorageClassArray (SgTypeFloatStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgTypeGlobalVoid ) ; 
     std::cout << " SgTypeGlobalVoid has size " << sizeOfActualPool << std::endl;
     SgTypeGlobalVoidStorageClass* SgTypeGlobalVoidStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeGlobalVoidStorageArray = new SgTypeGlobalVoidStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgTypeGlobalVoid_initializeStorageClassArray (SgTypeGlobalVoidStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgTypeIdOp ) ; 
     std::cout << " SgTypeIdOp has size " << sizeOfActualPool << std::endl;
     SgTypeIdOpStorageClass* SgTypeIdOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeIdOpStorageArray = new SgTypeIdOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgTypeIdOp_initializeStorageClassArray (SgTypeIdOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgTypeImaginary ) ; 
     std::cout << " SgTypeImaginary has size " << sizeOfActualPool << std::endl;
     SgTypeImaginaryStorageClass* SgTypeImaginaryStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeImaginaryStorageArray = new SgTypeImaginaryStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgTypeImaginary_initializeStorageClassArray (SgTypeImaginaryStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgTypeInt ) ; 
     std::cout << " SgTypeInt has size " << sizeOfActualPool << std::endl;
     SgTypeIntStorageClass* SgTypeIntStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeIntStorageArray = new SgTypeIntStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgTypeInt_initializeStorageClassArray (SgTypeIntStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgTypeLong ) ; 
     std::cout << " SgTypeLong has size " << sizeOfActualPool << std::endl;
     SgTypeLongStorageClass* SgTypeLongStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeLongStorageArray = new SgTypeLongStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgTypeLong_initializeStorageClassArray (SgTypeLongStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgTypeLongDouble ) ; 
     std::cout << " SgTypeLongDouble has size " << sizeOfActualPool << std::endl;
     SgTypeLongDoubleStorageClass* SgTypeLongDoubleStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeLongDoubleStorageArray = new SgTypeLongDoubleStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgTypeLongDouble_initializeStorageClassArray (SgTypeLongDoubleStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgTypeLongLong ) ; 
     std::cout << " SgTypeLongLong has size " << sizeOfActualPool << std::endl;
     SgTypeLongLongStorageClass* SgTypeLongLongStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeLongLongStorageArray = new SgTypeLongLongStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgTypeLongLong_initializeStorageClassArray (SgTypeLongLongStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgTypeModifier ) ; 
     std::cout << " SgTypeModifier has size " << sizeOfActualPool << std::endl;
     SgTypeModifierStorageClass* SgTypeModifierStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeModifierStorageArray = new SgTypeModifierStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgTypeModifier_initializeStorageClassArray (SgTypeModifierStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgTypeShort ) ; 
     std::cout << " SgTypeShort has size " << sizeOfActualPool << std::endl;
     SgTypeShortStorageClass* SgTypeShortStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeShortStorageArray = new SgTypeShortStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgTypeShort_initializeStorageClassArray (SgTypeShortStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgTypeSignedChar ) ; 
     std::cout << " SgTypeSignedChar has size " << sizeOfActualPool << std::endl;
     SgTypeSignedCharStorageClass* SgTypeSignedCharStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeSignedCharStorageArray = new SgTypeSignedCharStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgTypeSignedChar_initializeStorageClassArray (SgTypeSignedCharStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgTypeSignedInt ) ; 
     std::cout << " SgTypeSignedInt has size " << sizeOfActualPool << std::endl;
     SgTypeSignedIntStorageClass* SgTypeSignedIntStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeSignedIntStorageArray = new SgTypeSignedIntStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgTypeSignedInt_initializeStorageClassArray (SgTypeSignedIntStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgTypeSignedLong ) ; 
     std::cout << " SgTypeSignedLong has size " << sizeOfActualPool << std::endl;
     SgTypeSignedLongStorageClass* SgTypeSignedLongStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeSignedLongStorageArray = new SgTypeSignedLongStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgTypeSignedLong_initializeStorageClassArray (SgTypeSignedLongStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgTypeSignedLongLong ) ; 
     std::cout << " SgTypeSignedLongLong has size " << sizeOfActualPool << std::endl;
     SgTypeSignedLongLongStorageClass* SgTypeSignedLongLongStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeSignedLongLongStorageArray = new SgTypeSignedLongLongStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgTypeSignedLongLong_initializeStorageClassArray (SgTypeSignedLongLongStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgTypeSignedShort ) ; 
     std::cout << " SgTypeSignedShort has size " << sizeOfActualPool << std::endl;
     SgTypeSignedShortStorageClass* SgTypeSignedShortStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeSignedShortStorageArray = new SgTypeSignedShortStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgTypeSignedShort_initializeStorageClassArray (SgTypeSignedShortStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgTypeString ) ; 
     std::cout << " SgTypeString has size " << sizeOfActualPool << std::endl;
     SgTypeStringStorageClass* SgTypeStringStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeStringStorageArray = new SgTypeStringStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgTypeString_initializeStorageClassArray (SgTypeStringStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgTypeUnknown ) ; 
     std::cout << " SgTypeUnknown has size " << sizeOfActualPool << std::endl;
     SgTypeUnknownStorageClass* SgTypeUnknownStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeUnknownStorageArray = new SgTypeUnknownStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgTypeUnknown_initializeStorageClassArray (SgTypeUnknownStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgTypeUnsignedChar ) ; 
     std::cout << " SgTypeUnsignedChar has size " << sizeOfActualPool << std::endl;
     SgTypeUnsignedCharStorageClass* SgTypeUnsignedCharStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeUnsignedCharStorageArray = new SgTypeUnsignedCharStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgTypeUnsignedChar_initializeStorageClassArray (SgTypeUnsignedCharStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgTypeUnsignedInt ) ; 
     std::cout << " SgTypeUnsignedInt has size " << sizeOfActualPool << std::endl;
     SgTypeUnsignedIntStorageClass* SgTypeUnsignedIntStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeUnsignedIntStorageArray = new SgTypeUnsignedIntStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgTypeUnsignedInt_initializeStorageClassArray (SgTypeUnsignedIntStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgTypeUnsignedLong ) ; 
     std::cout << " SgTypeUnsignedLong has size " << sizeOfActualPool << std::endl;
     SgTypeUnsignedLongStorageClass* SgTypeUnsignedLongStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeUnsignedLongStorageArray = new SgTypeUnsignedLongStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgTypeUnsignedLong_initializeStorageClassArray (SgTypeUnsignedLongStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgTypeUnsignedLongLong ) ; 
     std::cout << " SgTypeUnsignedLongLong has size " << sizeOfActualPool << std::endl;
     SgTypeUnsignedLongLongStorageClass* SgTypeUnsignedLongLongStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeUnsignedLongLongStorageArray = new SgTypeUnsignedLongLongStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgTypeUnsignedLongLong_initializeStorageClassArray (SgTypeUnsignedLongLongStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgTypeUnsignedShort ) ; 
     std::cout << " SgTypeUnsignedShort has size " << sizeOfActualPool << std::endl;
     SgTypeUnsignedShortStorageClass* SgTypeUnsignedShortStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeUnsignedShortStorageArray = new SgTypeUnsignedShortStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgTypeUnsignedShort_initializeStorageClassArray (SgTypeUnsignedShortStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgTypeVoid ) ; 
     std::cout << " SgTypeVoid has size " << sizeOfActualPool << std::endl;
     SgTypeVoidStorageClass* SgTypeVoidStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeVoidStorageArray = new SgTypeVoidStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgTypeVoid_initializeStorageClassArray (SgTypeVoidStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgTypeWchar ) ; 
     std::cout << " SgTypeWchar has size " << sizeOfActualPool << std::endl;
     SgTypeWcharStorageClass* SgTypeWcharStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeWcharStorageArray = new SgTypeWcharStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgTypeWchar_initializeStorageClassArray (SgTypeWcharStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgTypedefDeclaration ) ; 
     std::cout << " SgTypedefDeclaration has size " << sizeOfActualPool << std::endl;
     SgTypedefDeclarationStorageClass* SgTypedefDeclarationStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypedefDeclarationStorageArray = new SgTypedefDeclarationStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgTypedefDeclaration_initializeStorageClassArray (SgTypedefDeclarationStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgTypedefSeq ) ; 
     std::cout << " SgTypedefSeq has size " << sizeOfActualPool << std::endl;
     SgTypedefSeqStorageClass* SgTypedefSeqStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypedefSeqStorageArray = new SgTypedefSeqStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgTypedefSeq_initializeStorageClassArray (SgTypedefSeqStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgTypedefSymbol ) ; 
     std::cout << " SgTypedefSymbol has size " << sizeOfActualPool << std::endl;
     SgTypedefSymbolStorageClass* SgTypedefSymbolStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypedefSymbolStorageArray = new SgTypedefSymbolStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgTypedefSymbol_initializeStorageClassArray (SgTypedefSymbolStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgTypedefType ) ; 
     std::cout << " SgTypedefType has size " << sizeOfActualPool << std::endl;
     SgTypedefTypeStorageClass* SgTypedefTypeStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypedefTypeStorageArray = new SgTypedefTypeStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgTypedefType_initializeStorageClassArray (SgTypedefTypeStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgUPC_AccessModifier ) ; 
     std::cout << " SgUPC_AccessModifier has size " << sizeOfActualPool << std::endl;
     SgUPC_AccessModifierStorageClass* SgUPC_AccessModifierStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgUPC_AccessModifierStorageArray = new SgUPC_AccessModifierStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgUPC_AccessModifier_initializeStorageClassArray (SgUPC_AccessModifierStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgUnaryAddOp ) ; 
     std::cout << " SgUnaryAddOp has size " << sizeOfActualPool << std::endl;
     SgUnaryAddOpStorageClass* SgUnaryAddOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgUnaryAddOpStorageArray = new SgUnaryAddOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgUnaryAddOp_initializeStorageClassArray (SgUnaryAddOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgUnaryOp ) ; 
     std::cout << " SgUnaryOp has size " << sizeOfActualPool << std::endl;
     SgUnaryOpStorageClass* SgUnaryOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgUnaryOpStorageArray = new SgUnaryOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgUnaryOp_initializeStorageClassArray (SgUnaryOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgUndefDirectiveStatement ) ; 
     std::cout << " SgUndefDirectiveStatement has size " << sizeOfActualPool << std::endl;
     SgUndefDirectiveStatementStorageClass* SgUndefDirectiveStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgUndefDirectiveStatementStorageArray = new SgUndefDirectiveStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgUndefDirectiveStatement_initializeStorageClassArray (SgUndefDirectiveStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgUndirectedGraphEdge ) ; 
     std::cout << " SgUndirectedGraphEdge has size " << sizeOfActualPool << std::endl;
     SgUndirectedGraphEdgeStorageClass* SgUndirectedGraphEdgeStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgUndirectedGraphEdgeStorageArray = new SgUndirectedGraphEdgeStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgUndirectedGraphEdge_initializeStorageClassArray (SgUndirectedGraphEdgeStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgUnknownArrayOrFunctionReference ) ; 
     std::cout << " SgUnknownArrayOrFunctionReference has size " << sizeOfActualPool << std::endl;
     SgUnknownArrayOrFunctionReferenceStorageClass* SgUnknownArrayOrFunctionReferenceStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgUnknownArrayOrFunctionReferenceStorageArray = new SgUnknownArrayOrFunctionReferenceStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgUnknownArrayOrFunctionReference_initializeStorageClassArray (SgUnknownArrayOrFunctionReferenceStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgUnknownFile ) ; 
     std::cout << " SgUnknownFile has size " << sizeOfActualPool << std::endl;
     SgUnknownFileStorageClass* SgUnknownFileStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgUnknownFileStorageArray = new SgUnknownFileStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgUnknownFile_initializeStorageClassArray (SgUnknownFileStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgUnparse_Info ) ; 
     std::cout << " SgUnparse_Info has size " << sizeOfActualPool << std::endl;
     SgUnparse_InfoStorageClass* SgUnparse_InfoStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgUnparse_InfoStorageArray = new SgUnparse_InfoStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgUnparse_Info_initializeStorageClassArray (SgUnparse_InfoStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgUnsignedCharVal ) ; 
     std::cout << " SgUnsignedCharVal has size " << sizeOfActualPool << std::endl;
     SgUnsignedCharValStorageClass* SgUnsignedCharValStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgUnsignedCharValStorageArray = new SgUnsignedCharValStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgUnsignedCharVal_initializeStorageClassArray (SgUnsignedCharValStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgUnsignedIntVal ) ; 
     std::cout << " SgUnsignedIntVal has size " << sizeOfActualPool << std::endl;
     SgUnsignedIntValStorageClass* SgUnsignedIntValStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgUnsignedIntValStorageArray = new SgUnsignedIntValStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgUnsignedIntVal_initializeStorageClassArray (SgUnsignedIntValStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgUnsignedLongLongIntVal ) ; 
     std::cout << " SgUnsignedLongLongIntVal has size " << sizeOfActualPool << std::endl;
     SgUnsignedLongLongIntValStorageClass* SgUnsignedLongLongIntValStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgUnsignedLongLongIntValStorageArray = new SgUnsignedLongLongIntValStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgUnsignedLongLongIntVal_initializeStorageClassArray (SgUnsignedLongLongIntValStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgUnsignedLongVal ) ; 
     std::cout << " SgUnsignedLongVal has size " << sizeOfActualPool << std::endl;
     SgUnsignedLongValStorageClass* SgUnsignedLongValStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgUnsignedLongValStorageArray = new SgUnsignedLongValStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgUnsignedLongVal_initializeStorageClassArray (SgUnsignedLongValStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgUnsignedShortVal ) ; 
     std::cout << " SgUnsignedShortVal has size " << sizeOfActualPool << std::endl;
     SgUnsignedShortValStorageClass* SgUnsignedShortValStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgUnsignedShortValStorageArray = new SgUnsignedShortValStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgUnsignedShortVal_initializeStorageClassArray (SgUnsignedShortValStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgUpcBarrierStatement ) ; 
     std::cout << " SgUpcBarrierStatement has size " << sizeOfActualPool << std::endl;
     SgUpcBarrierStatementStorageClass* SgUpcBarrierStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgUpcBarrierStatementStorageArray = new SgUpcBarrierStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgUpcBarrierStatement_initializeStorageClassArray (SgUpcBarrierStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgUpcBlocksizeofExpression ) ; 
     std::cout << " SgUpcBlocksizeofExpression has size " << sizeOfActualPool << std::endl;
     SgUpcBlocksizeofExpressionStorageClass* SgUpcBlocksizeofExpressionStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgUpcBlocksizeofExpressionStorageArray = new SgUpcBlocksizeofExpressionStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgUpcBlocksizeofExpression_initializeStorageClassArray (SgUpcBlocksizeofExpressionStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgUpcElemsizeofExpression ) ; 
     std::cout << " SgUpcElemsizeofExpression has size " << sizeOfActualPool << std::endl;
     SgUpcElemsizeofExpressionStorageClass* SgUpcElemsizeofExpressionStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgUpcElemsizeofExpressionStorageArray = new SgUpcElemsizeofExpressionStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgUpcElemsizeofExpression_initializeStorageClassArray (SgUpcElemsizeofExpressionStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgUpcFenceStatement ) ; 
     std::cout << " SgUpcFenceStatement has size " << sizeOfActualPool << std::endl;
     SgUpcFenceStatementStorageClass* SgUpcFenceStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgUpcFenceStatementStorageArray = new SgUpcFenceStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgUpcFenceStatement_initializeStorageClassArray (SgUpcFenceStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgUpcForAllStatement ) ; 
     std::cout << " SgUpcForAllStatement has size " << sizeOfActualPool << std::endl;
     SgUpcForAllStatementStorageClass* SgUpcForAllStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgUpcForAllStatementStorageArray = new SgUpcForAllStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgUpcForAllStatement_initializeStorageClassArray (SgUpcForAllStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgUpcLocalsizeofExpression ) ; 
     std::cout << " SgUpcLocalsizeofExpression has size " << sizeOfActualPool << std::endl;
     SgUpcLocalsizeofExpressionStorageClass* SgUpcLocalsizeofExpressionStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgUpcLocalsizeofExpressionStorageArray = new SgUpcLocalsizeofExpressionStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgUpcLocalsizeofExpression_initializeStorageClassArray (SgUpcLocalsizeofExpressionStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgUpcMythread ) ; 
     std::cout << " SgUpcMythread has size " << sizeOfActualPool << std::endl;
     SgUpcMythreadStorageClass* SgUpcMythreadStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgUpcMythreadStorageArray = new SgUpcMythreadStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgUpcMythread_initializeStorageClassArray (SgUpcMythreadStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgUpcNotifyStatement ) ; 
     std::cout << " SgUpcNotifyStatement has size " << sizeOfActualPool << std::endl;
     SgUpcNotifyStatementStorageClass* SgUpcNotifyStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgUpcNotifyStatementStorageArray = new SgUpcNotifyStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgUpcNotifyStatement_initializeStorageClassArray (SgUpcNotifyStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgUpcThreads ) ; 
     std::cout << " SgUpcThreads has size " << sizeOfActualPool << std::endl;
     SgUpcThreadsStorageClass* SgUpcThreadsStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgUpcThreadsStorageArray = new SgUpcThreadsStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgUpcThreads_initializeStorageClassArray (SgUpcThreadsStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgUpcWaitStatement ) ; 
     std::cout << " SgUpcWaitStatement has size " << sizeOfActualPool << std::endl;
     SgUpcWaitStatementStorageClass* SgUpcWaitStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgUpcWaitStatementStorageArray = new SgUpcWaitStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgUpcWaitStatement_initializeStorageClassArray (SgUpcWaitStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgUseStatement ) ; 
     std::cout << " SgUseStatement has size " << sizeOfActualPool << std::endl;
     SgUseStatementStorageClass* SgUseStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgUseStatementStorageArray = new SgUseStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgUseStatement_initializeStorageClassArray (SgUseStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgUserDefinedBinaryOp ) ; 
     std::cout << " SgUserDefinedBinaryOp has size " << sizeOfActualPool << std::endl;
     SgUserDefinedBinaryOpStorageClass* SgUserDefinedBinaryOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgUserDefinedBinaryOpStorageArray = new SgUserDefinedBinaryOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgUserDefinedBinaryOp_initializeStorageClassArray (SgUserDefinedBinaryOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgUserDefinedUnaryOp ) ; 
     std::cout << " SgUserDefinedUnaryOp has size " << sizeOfActualPool << std::endl;
     SgUserDefinedUnaryOpStorageClass* SgUserDefinedUnaryOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgUserDefinedUnaryOpStorageArray = new SgUserDefinedUnaryOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgUserDefinedUnaryOp_initializeStorageClassArray (SgUserDefinedUnaryOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgUsingDeclarationStatement ) ; 
     std::cout << " SgUsingDeclarationStatement has size " << sizeOfActualPool << std::endl;
     SgUsingDeclarationStatementStorageClass* SgUsingDeclarationStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgUsingDeclarationStatementStorageArray = new SgUsingDeclarationStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgUsingDeclarationStatement_initializeStorageClassArray (SgUsingDeclarationStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgUsingDirectiveStatement ) ; 
     std::cout << " SgUsingDirectiveStatement has size " << sizeOfActualPool << std::endl;
     SgUsingDirectiveStatementStorageClass* SgUsingDirectiveStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgUsingDirectiveStatementStorageArray = new SgUsingDirectiveStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgUsingDirectiveStatement_initializeStorageClassArray (SgUsingDirectiveStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgValueExp ) ; 
     std::cout << " SgValueExp has size " << sizeOfActualPool << std::endl;
     SgValueExpStorageClass* SgValueExpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgValueExpStorageArray = new SgValueExpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgValueExp_initializeStorageClassArray (SgValueExpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgVarArgCopyOp ) ; 
     std::cout << " SgVarArgCopyOp has size " << sizeOfActualPool << std::endl;
     SgVarArgCopyOpStorageClass* SgVarArgCopyOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgVarArgCopyOpStorageArray = new SgVarArgCopyOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgVarArgCopyOp_initializeStorageClassArray (SgVarArgCopyOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgVarArgEndOp ) ; 
     std::cout << " SgVarArgEndOp has size " << sizeOfActualPool << std::endl;
     SgVarArgEndOpStorageClass* SgVarArgEndOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgVarArgEndOpStorageArray = new SgVarArgEndOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgVarArgEndOp_initializeStorageClassArray (SgVarArgEndOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgVarArgOp ) ; 
     std::cout << " SgVarArgOp has size " << sizeOfActualPool << std::endl;
     SgVarArgOpStorageClass* SgVarArgOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgVarArgOpStorageArray = new SgVarArgOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgVarArgOp_initializeStorageClassArray (SgVarArgOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgVarArgStartOneOperandOp ) ; 
     std::cout << " SgVarArgStartOneOperandOp has size " << sizeOfActualPool << std::endl;
     SgVarArgStartOneOperandOpStorageClass* SgVarArgStartOneOperandOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgVarArgStartOneOperandOpStorageArray = new SgVarArgStartOneOperandOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgVarArgStartOneOperandOp_initializeStorageClassArray (SgVarArgStartOneOperandOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgVarArgStartOp ) ; 
     std::cout << " SgVarArgStartOp has size " << sizeOfActualPool << std::endl;
     SgVarArgStartOpStorageClass* SgVarArgStartOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgVarArgStartOpStorageArray = new SgVarArgStartOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgVarArgStartOp_initializeStorageClassArray (SgVarArgStartOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgVarRefExp ) ; 
     std::cout << " SgVarRefExp has size " << sizeOfActualPool << std::endl;
     SgVarRefExpStorageClass* SgVarRefExpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgVarRefExpStorageArray = new SgVarRefExpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgVarRefExp_initializeStorageClassArray (SgVarRefExpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgVariableDeclaration ) ; 
     std::cout << " SgVariableDeclaration has size " << sizeOfActualPool << std::endl;
     SgVariableDeclarationStorageClass* SgVariableDeclarationStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgVariableDeclarationStorageArray = new SgVariableDeclarationStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgVariableDeclaration_initializeStorageClassArray (SgVariableDeclarationStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgVariableDefinition ) ; 
     std::cout << " SgVariableDefinition has size " << sizeOfActualPool << std::endl;
     SgVariableDefinitionStorageClass* SgVariableDefinitionStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgVariableDefinitionStorageArray = new SgVariableDefinitionStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgVariableDefinition_initializeStorageClassArray (SgVariableDefinitionStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgVariableSymbol ) ; 
     std::cout << " SgVariableSymbol has size " << sizeOfActualPool << std::endl;
     SgVariableSymbolStorageClass* SgVariableSymbolStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgVariableSymbolStorageArray = new SgVariableSymbolStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgVariableSymbol_initializeStorageClassArray (SgVariableSymbolStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgVariantExpression ) ; 
     std::cout << " SgVariantExpression has size " << sizeOfActualPool << std::endl;
     SgVariantExpressionStorageClass* SgVariantExpressionStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgVariantExpressionStorageArray = new SgVariantExpressionStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgVariantExpression_initializeStorageClassArray (SgVariantExpressionStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgVariantStatement ) ; 
     std::cout << " SgVariantStatement has size " << sizeOfActualPool << std::endl;
     SgVariantStatementStorageClass* SgVariantStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgVariantStatementStorageArray = new SgVariantStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgVariantStatement_initializeStorageClassArray (SgVariantStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgWaitStatement ) ; 
     std::cout << " SgWaitStatement has size " << sizeOfActualPool << std::endl;
     SgWaitStatementStorageClass* SgWaitStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgWaitStatementStorageArray = new SgWaitStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgWaitStatement_initializeStorageClassArray (SgWaitStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgWarningDirectiveStatement ) ; 
     std::cout << " SgWarningDirectiveStatement has size " << sizeOfActualPool << std::endl;
     SgWarningDirectiveStatementStorageClass* SgWarningDirectiveStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgWarningDirectiveStatementStorageArray = new SgWarningDirectiveStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgWarningDirectiveStatement_initializeStorageClassArray (SgWarningDirectiveStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgWithStatement ) ; 
     std::cout << " SgWithStatement has size " << sizeOfActualPool << std::endl;
     SgWithStatementStorageClass* SgWithStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgWithStatementStorageArray = new SgWithStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgWithStatement_initializeStorageClassArray (SgWithStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgWcharVal ) ; 
     std::cout << " SgWcharVal has size " << sizeOfActualPool << std::endl;
     SgWcharValStorageClass* SgWcharValStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgWcharValStorageArray = new SgWcharValStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgWcharVal_initializeStorageClassArray (SgWcharValStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgWhereStatement ) ; 
     std::cout << " SgWhereStatement has size " << sizeOfActualPool << std::endl;
     SgWhereStatementStorageClass* SgWhereStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgWhereStatementStorageArray = new SgWhereStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgWhereStatement_initializeStorageClassArray (SgWhereStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgWhileStmt ) ; 
     std::cout << " SgWhileStmt has size " << sizeOfActualPool << std::endl;
     SgWhileStmtStorageClass* SgWhileStmtStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgWhileStmtStorageArray = new SgWhileStmtStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgWhileStmt_initializeStorageClassArray (SgWhileStmtStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgWriteStatement ) ; 
     std::cout << " SgWriteStatement has size " << sizeOfActualPool << std::endl;
     SgWriteStatementStorageClass* SgWriteStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgWriteStatementStorageArray = new SgWriteStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgWriteStatement_initializeStorageClassArray (SgWriteStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgXorAssignOp ) ; 
     std::cout << " SgXorAssignOp has size " << sizeOfActualPool << std::endl;
     SgXorAssignOpStorageClass* SgXorAssignOpStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgXorAssignOpStorageArray = new SgXorAssignOpStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgXorAssignOp_initializeStorageClassArray (SgXorAssignOpStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgYieldExpression ) ; 
     std::cout << " SgYieldExpression has size " << sizeOfActualPool << std::endl;
     SgYieldExpressionStorageClass* SgYieldExpressionStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgYieldExpressionStorageArray = new SgYieldExpressionStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgYieldExpression_initializeStorageClassArray (SgYieldExpressionStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_Sg_File_Info ) ; 
     std::cout << " Sg_File_Info has size " << sizeOfActualPool << std::endl;
     Sg_File_InfoStorageClass* Sg_File_InfoStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          Sg_File_InfoStorageArray = new Sg_File_InfoStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = Sg_File_Info_initializeStorageClassArray (Sg_File_InfoStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgTypeCAFTeam ) ; 
     std::cout << " SgTypeCAFTeam has size " << sizeOfActualPool << std::endl;
     SgTypeCAFTeamStorageClass* SgTypeCAFTeamStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeCAFTeamStorageArray = new SgTypeCAFTeamStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgTypeCAFTeam_initializeStorageClassArray (SgTypeCAFTeamStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgCAFWithTeamStatement ) ; 
     std::cout << " SgCAFWithTeamStatement has size " << sizeOfActualPool << std::endl;
     SgCAFWithTeamStatementStorageClass* SgCAFWithTeamStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgCAFWithTeamStatementStorageArray = new SgCAFWithTeamStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgCAFWithTeamStatement_initializeStorageClassArray (SgCAFWithTeamStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgCAFCoExpression ) ; 
     std::cout << " SgCAFCoExpression has size " << sizeOfActualPool << std::endl;
     SgCAFCoExpressionStorageClass* SgCAFCoExpressionStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgCAFCoExpressionStorageArray = new SgCAFCoExpressionStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgCAFCoExpression_initializeStorageClassArray (SgCAFCoExpressionStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgCallExpression ) ; 
     std::cout << " SgCallExpression has size " << sizeOfActualPool << std::endl;
     SgCallExpressionStorageClass* SgCallExpressionStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgCallExpressionStorageArray = new SgCallExpressionStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgCallExpression_initializeStorageClassArray (SgCallExpressionStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgTypeCrayPointer ) ; 
     std::cout << " SgTypeCrayPointer has size " << sizeOfActualPool << std::endl;
     SgTypeCrayPointerStorageClass* SgTypeCrayPointerStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeCrayPointerStorageArray = new SgTypeCrayPointerStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgTypeCrayPointer_initializeStorageClassArray (SgTypeCrayPointerStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     sizeOfActualPool = getSizeOfMemoryPool (V_SgJavaImportStatement ) ; 
     std::cout << " SgJavaImportStatement has size " << sizeOfActualPool << std::endl;
     SgJavaImportStatementStorageClass* SgJavaImportStatementStorageArray = NULL; 
     if ( 0 < sizeOfActualPool ) 
        {  
          SgJavaImportStatementStorageArray = new SgJavaImportStatementStorageClass[sizeOfActualPool] ; 
          unsigned long storageClassIndex = SgJavaImportStatement_initializeStorageClassArray (SgJavaImportStatementStorageArray); ;
          assert ( storageClassIndex == sizeOfActualPool ); 
        }  
     clearAllMemoryPools();
     AstSpecificDataManagingClassStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock (); 
     actualRebuildAst = new AstSpecificDataManagingClass(staticTemp); 
     actualRebuildAst->setStaticDataMembersOfIRNodes(); 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAccessModifier ) ;
     std::cout << " SgAccessModifier has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAccessModifier ( SgAccessModifierStorageArray[i] ) ; 
              }
          delete [] SgAccessModifierStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgActualArgumentExpression ) ;
     std::cout << " SgActualArgumentExpression has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgActualArgumentExpressionStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgActualArgumentExpression ( SgActualArgumentExpressionStorageArray[i] ) ; 
              }
          delete [] SgActualArgumentExpressionStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAddOp ) ;
     std::cout << " SgAddOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAddOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAddOp ( SgAddOpStorageArray[i] ) ; 
              }
          delete [] SgAddOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAddressOfOp ) ;
     std::cout << " SgAddressOfOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAddressOfOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAddressOfOp ( SgAddressOfOpStorageArray[i] ) ; 
              }
          delete [] SgAddressOfOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAggregateInitializer ) ;
     std::cout << " SgAggregateInitializer has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAggregateInitializerStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAggregateInitializer ( SgAggregateInitializerStorageArray[i] ) ; 
              }
          delete [] SgAggregateInitializerStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAliasSymbol ) ;
     std::cout << " SgAliasSymbol has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAliasSymbolStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAliasSymbol ( SgAliasSymbolStorageArray[i] ) ; 
              }
          delete [] SgAliasSymbolStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAllocateStatement ) ;
     std::cout << " SgAllocateStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAllocateStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAllocateStatement ( SgAllocateStatementStorageArray[i] ) ; 
              }
          delete [] SgAllocateStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAndAssignOp ) ;
     std::cout << " SgAndAssignOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAndAssignOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAndAssignOp ( SgAndAssignOpStorageArray[i] ) ; 
              }
          delete [] SgAndAssignOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAndOp ) ;
     std::cout << " SgAndOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAndOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAndOp ( SgAndOpStorageArray[i] ) ; 
              }
          delete [] SgAndOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgArithmeticIfStatement ) ;
     std::cout << " SgArithmeticIfStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgArithmeticIfStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgArithmeticIfStatement ( SgArithmeticIfStatementStorageArray[i] ) ; 
              }
          delete [] SgArithmeticIfStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgArrayType ) ;
     std::cout << " SgArrayType has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgArrayTypeStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgArrayType ( SgArrayTypeStorageArray[i] ) ; 
              }
          delete [] SgArrayTypeStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgArrowExp ) ;
     std::cout << " SgArrowExp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgArrowExpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgArrowExp ( SgArrowExpStorageArray[i] ) ; 
              }
          delete [] SgArrowExpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgArrowStarOp ) ;
     std::cout << " SgArrowStarOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgArrowStarOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgArrowStarOp ( SgArrowStarOpStorageArray[i] ) ; 
              }
          delete [] SgArrowStarOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmArmInstruction ) ;
     std::cout << " SgAsmArmInstruction has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmArmInstructionStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmArmInstruction ( SgAsmArmInstructionStorageArray[i] ) ; 
              }
          delete [] SgAsmArmInstructionStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmArmRegisterReferenceExpression ) ;
     std::cout << " SgAsmArmRegisterReferenceExpression has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmArmRegisterReferenceExpressionStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmArmRegisterReferenceExpression ( SgAsmArmRegisterReferenceExpressionStorageArray[i] ) ; 
              }
          delete [] SgAsmArmRegisterReferenceExpressionStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmBasicString ) ;
     std::cout << " SgAsmBasicString has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmBasicStringStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmBasicString ( SgAsmBasicStringStorageArray[i] ) ; 
              }
          delete [] SgAsmBasicStringStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmBinaryAdd ) ;
     std::cout << " SgAsmBinaryAdd has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmBinaryAddStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmBinaryAdd ( SgAsmBinaryAddStorageArray[i] ) ; 
              }
          delete [] SgAsmBinaryAddStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmBinaryAddPostupdate ) ;
     std::cout << " SgAsmBinaryAddPostupdate has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmBinaryAddPostupdateStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmBinaryAddPostupdate ( SgAsmBinaryAddPostupdateStorageArray[i] ) ; 
              }
          delete [] SgAsmBinaryAddPostupdateStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmBinaryAddPreupdate ) ;
     std::cout << " SgAsmBinaryAddPreupdate has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmBinaryAddPreupdateStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmBinaryAddPreupdate ( SgAsmBinaryAddPreupdateStorageArray[i] ) ; 
              }
          delete [] SgAsmBinaryAddPreupdateStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmBinaryAsr ) ;
     std::cout << " SgAsmBinaryAsr has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmBinaryAsrStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmBinaryAsr ( SgAsmBinaryAsrStorageArray[i] ) ; 
              }
          delete [] SgAsmBinaryAsrStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmBinaryDivide ) ;
     std::cout << " SgAsmBinaryDivide has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmBinaryDivideStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmBinaryDivide ( SgAsmBinaryDivideStorageArray[i] ) ; 
              }
          delete [] SgAsmBinaryDivideStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmBinaryExpression ) ;
     std::cout << " SgAsmBinaryExpression has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmBinaryExpressionStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmBinaryExpression ( SgAsmBinaryExpressionStorageArray[i] ) ; 
              }
          delete [] SgAsmBinaryExpressionStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmBinaryLsl ) ;
     std::cout << " SgAsmBinaryLsl has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmBinaryLslStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmBinaryLsl ( SgAsmBinaryLslStorageArray[i] ) ; 
              }
          delete [] SgAsmBinaryLslStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmBinaryLsr ) ;
     std::cout << " SgAsmBinaryLsr has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmBinaryLsrStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmBinaryLsr ( SgAsmBinaryLsrStorageArray[i] ) ; 
              }
          delete [] SgAsmBinaryLsrStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmBinaryMod ) ;
     std::cout << " SgAsmBinaryMod has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmBinaryModStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmBinaryMod ( SgAsmBinaryModStorageArray[i] ) ; 
              }
          delete [] SgAsmBinaryModStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmBinaryMultiply ) ;
     std::cout << " SgAsmBinaryMultiply has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmBinaryMultiplyStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmBinaryMultiply ( SgAsmBinaryMultiplyStorageArray[i] ) ; 
              }
          delete [] SgAsmBinaryMultiplyStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmBinaryRor ) ;
     std::cout << " SgAsmBinaryRor has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmBinaryRorStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmBinaryRor ( SgAsmBinaryRorStorageArray[i] ) ; 
              }
          delete [] SgAsmBinaryRorStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmBinarySubtract ) ;
     std::cout << " SgAsmBinarySubtract has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmBinarySubtractStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmBinarySubtract ( SgAsmBinarySubtractStorageArray[i] ) ; 
              }
          delete [] SgAsmBinarySubtractStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmBinarySubtractPostupdate ) ;
     std::cout << " SgAsmBinarySubtractPostupdate has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmBinarySubtractPostupdateStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmBinarySubtractPostupdate ( SgAsmBinarySubtractPostupdateStorageArray[i] ) ; 
              }
          delete [] SgAsmBinarySubtractPostupdateStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmBinarySubtractPreupdate ) ;
     std::cout << " SgAsmBinarySubtractPreupdate has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmBinarySubtractPreupdateStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmBinarySubtractPreupdate ( SgAsmBinarySubtractPreupdateStorageArray[i] ) ; 
              }
          delete [] SgAsmBinarySubtractPreupdateStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmBlock ) ;
     std::cout << " SgAsmBlock has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmBlockStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmBlock ( SgAsmBlockStorageArray[i] ) ; 
              }
          delete [] SgAsmBlockStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmByteValueExpression ) ;
     std::cout << " SgAsmByteValueExpression has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmByteValueExpressionStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmByteValueExpression ( SgAsmByteValueExpressionStorageArray[i] ) ; 
              }
          delete [] SgAsmByteValueExpressionStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmCoffStrtab ) ;
     std::cout << " SgAsmCoffStrtab has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmCoffStrtabStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmCoffStrtab ( SgAsmCoffStrtabStorageArray[i] ) ; 
              }
          delete [] SgAsmCoffStrtabStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmCoffSymbol ) ;
     std::cout << " SgAsmCoffSymbol has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmCoffSymbolStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmCoffSymbol ( SgAsmCoffSymbolStorageArray[i] ) ; 
              }
          delete [] SgAsmCoffSymbolStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmCoffSymbolList ) ;
     std::cout << " SgAsmCoffSymbolList has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmCoffSymbolListStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmCoffSymbolList ( SgAsmCoffSymbolListStorageArray[i] ) ; 
              }
          delete [] SgAsmCoffSymbolListStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmCoffSymbolTable ) ;
     std::cout << " SgAsmCoffSymbolTable has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmCoffSymbolTableStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmCoffSymbolTable ( SgAsmCoffSymbolTableStorageArray[i] ) ; 
              }
          delete [] SgAsmCoffSymbolTableStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmCommonSubExpression ) ;
     std::cout << " SgAsmCommonSubExpression has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmCommonSubExpressionStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmCommonSubExpression ( SgAsmCommonSubExpressionStorageArray[i] ) ; 
              }
          delete [] SgAsmCommonSubExpressionStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmControlFlagsExpression ) ;
     std::cout << " SgAsmControlFlagsExpression has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmControlFlagsExpressionStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmControlFlagsExpression ( SgAsmControlFlagsExpressionStorageArray[i] ) ; 
              }
          delete [] SgAsmControlFlagsExpressionStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDOSExtendedHeader ) ;
     std::cout << " SgAsmDOSExtendedHeader has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDOSExtendedHeaderStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDOSExtendedHeader ( SgAsmDOSExtendedHeaderStorageArray[i] ) ; 
              }
          delete [] SgAsmDOSExtendedHeaderStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDOSFileHeader ) ;
     std::cout << " SgAsmDOSFileHeader has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDOSFileHeaderStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDOSFileHeader ( SgAsmDOSFileHeaderStorageArray[i] ) ; 
              }
          delete [] SgAsmDOSFileHeaderStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDoubleFloatValueExpression ) ;
     std::cout << " SgAsmDoubleFloatValueExpression has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDoubleFloatValueExpressionStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDoubleFloatValueExpression ( SgAsmDoubleFloatValueExpressionStorageArray[i] ) ; 
              }
          delete [] SgAsmDoubleFloatValueExpressionStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDoubleWordValueExpression ) ;
     std::cout << " SgAsmDoubleWordValueExpression has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDoubleWordValueExpressionStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDoubleWordValueExpression ( SgAsmDoubleWordValueExpressionStorageArray[i] ) ; 
              }
          delete [] SgAsmDoubleWordValueExpressionStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDwarfAccessDeclaration ) ;
     std::cout << " SgAsmDwarfAccessDeclaration has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDwarfAccessDeclarationStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDwarfAccessDeclaration ( SgAsmDwarfAccessDeclarationStorageArray[i] ) ; 
              }
          delete [] SgAsmDwarfAccessDeclarationStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDwarfArrayType ) ;
     std::cout << " SgAsmDwarfArrayType has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDwarfArrayTypeStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDwarfArrayType ( SgAsmDwarfArrayTypeStorageArray[i] ) ; 
              }
          delete [] SgAsmDwarfArrayTypeStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDwarfBaseType ) ;
     std::cout << " SgAsmDwarfBaseType has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDwarfBaseTypeStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDwarfBaseType ( SgAsmDwarfBaseTypeStorageArray[i] ) ; 
              }
          delete [] SgAsmDwarfBaseTypeStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDwarfCatchBlock ) ;
     std::cout << " SgAsmDwarfCatchBlock has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDwarfCatchBlockStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDwarfCatchBlock ( SgAsmDwarfCatchBlockStorageArray[i] ) ; 
              }
          delete [] SgAsmDwarfCatchBlockStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDwarfClassTemplate ) ;
     std::cout << " SgAsmDwarfClassTemplate has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDwarfClassTemplateStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDwarfClassTemplate ( SgAsmDwarfClassTemplateStorageArray[i] ) ; 
              }
          delete [] SgAsmDwarfClassTemplateStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDwarfClassType ) ;
     std::cout << " SgAsmDwarfClassType has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDwarfClassTypeStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDwarfClassType ( SgAsmDwarfClassTypeStorageArray[i] ) ; 
              }
          delete [] SgAsmDwarfClassTypeStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDwarfCommonBlock ) ;
     std::cout << " SgAsmDwarfCommonBlock has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDwarfCommonBlockStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDwarfCommonBlock ( SgAsmDwarfCommonBlockStorageArray[i] ) ; 
              }
          delete [] SgAsmDwarfCommonBlockStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDwarfCommonInclusion ) ;
     std::cout << " SgAsmDwarfCommonInclusion has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDwarfCommonInclusionStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDwarfCommonInclusion ( SgAsmDwarfCommonInclusionStorageArray[i] ) ; 
              }
          delete [] SgAsmDwarfCommonInclusionStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDwarfCompilationUnit ) ;
     std::cout << " SgAsmDwarfCompilationUnit has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDwarfCompilationUnitStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDwarfCompilationUnit ( SgAsmDwarfCompilationUnitStorageArray[i] ) ; 
              }
          delete [] SgAsmDwarfCompilationUnitStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDwarfCompilationUnitList ) ;
     std::cout << " SgAsmDwarfCompilationUnitList has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDwarfCompilationUnitListStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDwarfCompilationUnitList ( SgAsmDwarfCompilationUnitListStorageArray[i] ) ; 
              }
          delete [] SgAsmDwarfCompilationUnitListStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDwarfCondition ) ;
     std::cout << " SgAsmDwarfCondition has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDwarfConditionStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDwarfCondition ( SgAsmDwarfConditionStorageArray[i] ) ; 
              }
          delete [] SgAsmDwarfConditionStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDwarfConstType ) ;
     std::cout << " SgAsmDwarfConstType has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDwarfConstTypeStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDwarfConstType ( SgAsmDwarfConstTypeStorageArray[i] ) ; 
              }
          delete [] SgAsmDwarfConstTypeStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDwarfConstant ) ;
     std::cout << " SgAsmDwarfConstant has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDwarfConstantStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDwarfConstant ( SgAsmDwarfConstantStorageArray[i] ) ; 
              }
          delete [] SgAsmDwarfConstantStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDwarfConstruct ) ;
     std::cout << " SgAsmDwarfConstruct has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDwarfConstructStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDwarfConstruct ( SgAsmDwarfConstructStorageArray[i] ) ; 
              }
          delete [] SgAsmDwarfConstructStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDwarfConstructList ) ;
     std::cout << " SgAsmDwarfConstructList has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDwarfConstructListStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDwarfConstructList ( SgAsmDwarfConstructListStorageArray[i] ) ; 
              }
          delete [] SgAsmDwarfConstructListStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDwarfDwarfProcedure ) ;
     std::cout << " SgAsmDwarfDwarfProcedure has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDwarfDwarfProcedureStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDwarfDwarfProcedure ( SgAsmDwarfDwarfProcedureStorageArray[i] ) ; 
              }
          delete [] SgAsmDwarfDwarfProcedureStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDwarfEntryPoint ) ;
     std::cout << " SgAsmDwarfEntryPoint has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDwarfEntryPointStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDwarfEntryPoint ( SgAsmDwarfEntryPointStorageArray[i] ) ; 
              }
          delete [] SgAsmDwarfEntryPointStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDwarfEnumerationType ) ;
     std::cout << " SgAsmDwarfEnumerationType has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDwarfEnumerationTypeStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDwarfEnumerationType ( SgAsmDwarfEnumerationTypeStorageArray[i] ) ; 
              }
          delete [] SgAsmDwarfEnumerationTypeStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDwarfEnumerator ) ;
     std::cout << " SgAsmDwarfEnumerator has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDwarfEnumeratorStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDwarfEnumerator ( SgAsmDwarfEnumeratorStorageArray[i] ) ; 
              }
          delete [] SgAsmDwarfEnumeratorStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDwarfFileType ) ;
     std::cout << " SgAsmDwarfFileType has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDwarfFileTypeStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDwarfFileType ( SgAsmDwarfFileTypeStorageArray[i] ) ; 
              }
          delete [] SgAsmDwarfFileTypeStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDwarfFormalParameter ) ;
     std::cout << " SgAsmDwarfFormalParameter has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDwarfFormalParameterStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDwarfFormalParameter ( SgAsmDwarfFormalParameterStorageArray[i] ) ; 
              }
          delete [] SgAsmDwarfFormalParameterStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDwarfFormatLabel ) ;
     std::cout << " SgAsmDwarfFormatLabel has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDwarfFormatLabelStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDwarfFormatLabel ( SgAsmDwarfFormatLabelStorageArray[i] ) ; 
              }
          delete [] SgAsmDwarfFormatLabelStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDwarfFriend ) ;
     std::cout << " SgAsmDwarfFriend has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDwarfFriendStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDwarfFriend ( SgAsmDwarfFriendStorageArray[i] ) ; 
              }
          delete [] SgAsmDwarfFriendStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDwarfFunctionTemplate ) ;
     std::cout << " SgAsmDwarfFunctionTemplate has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDwarfFunctionTemplateStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDwarfFunctionTemplate ( SgAsmDwarfFunctionTemplateStorageArray[i] ) ; 
              }
          delete [] SgAsmDwarfFunctionTemplateStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDwarfImportedDeclaration ) ;
     std::cout << " SgAsmDwarfImportedDeclaration has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDwarfImportedDeclarationStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDwarfImportedDeclaration ( SgAsmDwarfImportedDeclarationStorageArray[i] ) ; 
              }
          delete [] SgAsmDwarfImportedDeclarationStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDwarfImportedModule ) ;
     std::cout << " SgAsmDwarfImportedModule has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDwarfImportedModuleStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDwarfImportedModule ( SgAsmDwarfImportedModuleStorageArray[i] ) ; 
              }
          delete [] SgAsmDwarfImportedModuleStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDwarfImportedUnit ) ;
     std::cout << " SgAsmDwarfImportedUnit has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDwarfImportedUnitStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDwarfImportedUnit ( SgAsmDwarfImportedUnitStorageArray[i] ) ; 
              }
          delete [] SgAsmDwarfImportedUnitStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDwarfInformation ) ;
     std::cout << " SgAsmDwarfInformation has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDwarfInformationStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDwarfInformation ( SgAsmDwarfInformationStorageArray[i] ) ; 
              }
          delete [] SgAsmDwarfInformationStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDwarfInheritance ) ;
     std::cout << " SgAsmDwarfInheritance has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDwarfInheritanceStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDwarfInheritance ( SgAsmDwarfInheritanceStorageArray[i] ) ; 
              }
          delete [] SgAsmDwarfInheritanceStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDwarfInlinedSubroutine ) ;
     std::cout << " SgAsmDwarfInlinedSubroutine has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDwarfInlinedSubroutineStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDwarfInlinedSubroutine ( SgAsmDwarfInlinedSubroutineStorageArray[i] ) ; 
              }
          delete [] SgAsmDwarfInlinedSubroutineStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDwarfInterfaceType ) ;
     std::cout << " SgAsmDwarfInterfaceType has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDwarfInterfaceTypeStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDwarfInterfaceType ( SgAsmDwarfInterfaceTypeStorageArray[i] ) ; 
              }
          delete [] SgAsmDwarfInterfaceTypeStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDwarfLabel ) ;
     std::cout << " SgAsmDwarfLabel has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDwarfLabelStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDwarfLabel ( SgAsmDwarfLabelStorageArray[i] ) ; 
              }
          delete [] SgAsmDwarfLabelStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDwarfLexicalBlock ) ;
     std::cout << " SgAsmDwarfLexicalBlock has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDwarfLexicalBlockStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDwarfLexicalBlock ( SgAsmDwarfLexicalBlockStorageArray[i] ) ; 
              }
          delete [] SgAsmDwarfLexicalBlockStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDwarfLine ) ;
     std::cout << " SgAsmDwarfLine has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDwarfLineStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDwarfLine ( SgAsmDwarfLineStorageArray[i] ) ; 
              }
          delete [] SgAsmDwarfLineStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDwarfLineList ) ;
     std::cout << " SgAsmDwarfLineList has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDwarfLineListStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDwarfLineList ( SgAsmDwarfLineListStorageArray[i] ) ; 
              }
          delete [] SgAsmDwarfLineListStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDwarfMacro ) ;
     std::cout << " SgAsmDwarfMacro has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDwarfMacroStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDwarfMacro ( SgAsmDwarfMacroStorageArray[i] ) ; 
              }
          delete [] SgAsmDwarfMacroStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDwarfMacroList ) ;
     std::cout << " SgAsmDwarfMacroList has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDwarfMacroListStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDwarfMacroList ( SgAsmDwarfMacroListStorageArray[i] ) ; 
              }
          delete [] SgAsmDwarfMacroListStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDwarfMember ) ;
     std::cout << " SgAsmDwarfMember has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDwarfMemberStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDwarfMember ( SgAsmDwarfMemberStorageArray[i] ) ; 
              }
          delete [] SgAsmDwarfMemberStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDwarfModule ) ;
     std::cout << " SgAsmDwarfModule has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDwarfModuleStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDwarfModule ( SgAsmDwarfModuleStorageArray[i] ) ; 
              }
          delete [] SgAsmDwarfModuleStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDwarfMutableType ) ;
     std::cout << " SgAsmDwarfMutableType has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDwarfMutableTypeStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDwarfMutableType ( SgAsmDwarfMutableTypeStorageArray[i] ) ; 
              }
          delete [] SgAsmDwarfMutableTypeStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDwarfNamelist ) ;
     std::cout << " SgAsmDwarfNamelist has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDwarfNamelistStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDwarfNamelist ( SgAsmDwarfNamelistStorageArray[i] ) ; 
              }
          delete [] SgAsmDwarfNamelistStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDwarfNamelistItem ) ;
     std::cout << " SgAsmDwarfNamelistItem has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDwarfNamelistItemStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDwarfNamelistItem ( SgAsmDwarfNamelistItemStorageArray[i] ) ; 
              }
          delete [] SgAsmDwarfNamelistItemStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDwarfNamespace ) ;
     std::cout << " SgAsmDwarfNamespace has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDwarfNamespaceStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDwarfNamespace ( SgAsmDwarfNamespaceStorageArray[i] ) ; 
              }
          delete [] SgAsmDwarfNamespaceStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDwarfPackedType ) ;
     std::cout << " SgAsmDwarfPackedType has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDwarfPackedTypeStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDwarfPackedType ( SgAsmDwarfPackedTypeStorageArray[i] ) ; 
              }
          delete [] SgAsmDwarfPackedTypeStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDwarfPartialUnit ) ;
     std::cout << " SgAsmDwarfPartialUnit has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDwarfPartialUnitStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDwarfPartialUnit ( SgAsmDwarfPartialUnitStorageArray[i] ) ; 
              }
          delete [] SgAsmDwarfPartialUnitStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDwarfPointerType ) ;
     std::cout << " SgAsmDwarfPointerType has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDwarfPointerTypeStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDwarfPointerType ( SgAsmDwarfPointerTypeStorageArray[i] ) ; 
              }
          delete [] SgAsmDwarfPointerTypeStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDwarfPtrToMemberType ) ;
     std::cout << " SgAsmDwarfPtrToMemberType has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDwarfPtrToMemberTypeStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDwarfPtrToMemberType ( SgAsmDwarfPtrToMemberTypeStorageArray[i] ) ; 
              }
          delete [] SgAsmDwarfPtrToMemberTypeStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDwarfReferenceType ) ;
     std::cout << " SgAsmDwarfReferenceType has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDwarfReferenceTypeStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDwarfReferenceType ( SgAsmDwarfReferenceTypeStorageArray[i] ) ; 
              }
          delete [] SgAsmDwarfReferenceTypeStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDwarfRestrictType ) ;
     std::cout << " SgAsmDwarfRestrictType has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDwarfRestrictTypeStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDwarfRestrictType ( SgAsmDwarfRestrictTypeStorageArray[i] ) ; 
              }
          delete [] SgAsmDwarfRestrictTypeStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDwarfSetType ) ;
     std::cout << " SgAsmDwarfSetType has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDwarfSetTypeStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDwarfSetType ( SgAsmDwarfSetTypeStorageArray[i] ) ; 
              }
          delete [] SgAsmDwarfSetTypeStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDwarfSharedType ) ;
     std::cout << " SgAsmDwarfSharedType has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDwarfSharedTypeStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDwarfSharedType ( SgAsmDwarfSharedTypeStorageArray[i] ) ; 
              }
          delete [] SgAsmDwarfSharedTypeStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDwarfStringType ) ;
     std::cout << " SgAsmDwarfStringType has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDwarfStringTypeStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDwarfStringType ( SgAsmDwarfStringTypeStorageArray[i] ) ; 
              }
          delete [] SgAsmDwarfStringTypeStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDwarfStructureType ) ;
     std::cout << " SgAsmDwarfStructureType has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDwarfStructureTypeStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDwarfStructureType ( SgAsmDwarfStructureTypeStorageArray[i] ) ; 
              }
          delete [] SgAsmDwarfStructureTypeStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDwarfSubprogram ) ;
     std::cout << " SgAsmDwarfSubprogram has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDwarfSubprogramStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDwarfSubprogram ( SgAsmDwarfSubprogramStorageArray[i] ) ; 
              }
          delete [] SgAsmDwarfSubprogramStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDwarfSubrangeType ) ;
     std::cout << " SgAsmDwarfSubrangeType has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDwarfSubrangeTypeStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDwarfSubrangeType ( SgAsmDwarfSubrangeTypeStorageArray[i] ) ; 
              }
          delete [] SgAsmDwarfSubrangeTypeStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDwarfSubroutineType ) ;
     std::cout << " SgAsmDwarfSubroutineType has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDwarfSubroutineTypeStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDwarfSubroutineType ( SgAsmDwarfSubroutineTypeStorageArray[i] ) ; 
              }
          delete [] SgAsmDwarfSubroutineTypeStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDwarfTemplateTypeParameter ) ;
     std::cout << " SgAsmDwarfTemplateTypeParameter has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDwarfTemplateTypeParameterStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDwarfTemplateTypeParameter ( SgAsmDwarfTemplateTypeParameterStorageArray[i] ) ; 
              }
          delete [] SgAsmDwarfTemplateTypeParameterStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDwarfTemplateValueParameter ) ;
     std::cout << " SgAsmDwarfTemplateValueParameter has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDwarfTemplateValueParameterStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDwarfTemplateValueParameter ( SgAsmDwarfTemplateValueParameterStorageArray[i] ) ; 
              }
          delete [] SgAsmDwarfTemplateValueParameterStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDwarfThrownType ) ;
     std::cout << " SgAsmDwarfThrownType has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDwarfThrownTypeStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDwarfThrownType ( SgAsmDwarfThrownTypeStorageArray[i] ) ; 
              }
          delete [] SgAsmDwarfThrownTypeStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDwarfTryBlock ) ;
     std::cout << " SgAsmDwarfTryBlock has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDwarfTryBlockStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDwarfTryBlock ( SgAsmDwarfTryBlockStorageArray[i] ) ; 
              }
          delete [] SgAsmDwarfTryBlockStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDwarfTypedef ) ;
     std::cout << " SgAsmDwarfTypedef has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDwarfTypedefStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDwarfTypedef ( SgAsmDwarfTypedefStorageArray[i] ) ; 
              }
          delete [] SgAsmDwarfTypedefStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDwarfUnionType ) ;
     std::cout << " SgAsmDwarfUnionType has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDwarfUnionTypeStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDwarfUnionType ( SgAsmDwarfUnionTypeStorageArray[i] ) ; 
              }
          delete [] SgAsmDwarfUnionTypeStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDwarfUnknownConstruct ) ;
     std::cout << " SgAsmDwarfUnknownConstruct has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDwarfUnknownConstructStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDwarfUnknownConstruct ( SgAsmDwarfUnknownConstructStorageArray[i] ) ; 
              }
          delete [] SgAsmDwarfUnknownConstructStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDwarfUnspecifiedParameters ) ;
     std::cout << " SgAsmDwarfUnspecifiedParameters has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDwarfUnspecifiedParametersStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDwarfUnspecifiedParameters ( SgAsmDwarfUnspecifiedParametersStorageArray[i] ) ; 
              }
          delete [] SgAsmDwarfUnspecifiedParametersStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDwarfUnspecifiedType ) ;
     std::cout << " SgAsmDwarfUnspecifiedType has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDwarfUnspecifiedTypeStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDwarfUnspecifiedType ( SgAsmDwarfUnspecifiedTypeStorageArray[i] ) ; 
              }
          delete [] SgAsmDwarfUnspecifiedTypeStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDwarfUpcRelaxedType ) ;
     std::cout << " SgAsmDwarfUpcRelaxedType has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDwarfUpcRelaxedTypeStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDwarfUpcRelaxedType ( SgAsmDwarfUpcRelaxedTypeStorageArray[i] ) ; 
              }
          delete [] SgAsmDwarfUpcRelaxedTypeStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDwarfUpcSharedType ) ;
     std::cout << " SgAsmDwarfUpcSharedType has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDwarfUpcSharedTypeStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDwarfUpcSharedType ( SgAsmDwarfUpcSharedTypeStorageArray[i] ) ; 
              }
          delete [] SgAsmDwarfUpcSharedTypeStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDwarfUpcStrictType ) ;
     std::cout << " SgAsmDwarfUpcStrictType has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDwarfUpcStrictTypeStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDwarfUpcStrictType ( SgAsmDwarfUpcStrictTypeStorageArray[i] ) ; 
              }
          delete [] SgAsmDwarfUpcStrictTypeStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDwarfVariable ) ;
     std::cout << " SgAsmDwarfVariable has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDwarfVariableStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDwarfVariable ( SgAsmDwarfVariableStorageArray[i] ) ; 
              }
          delete [] SgAsmDwarfVariableStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDwarfVariant ) ;
     std::cout << " SgAsmDwarfVariant has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDwarfVariantStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDwarfVariant ( SgAsmDwarfVariantStorageArray[i] ) ; 
              }
          delete [] SgAsmDwarfVariantStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDwarfVariantPart ) ;
     std::cout << " SgAsmDwarfVariantPart has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDwarfVariantPartStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDwarfVariantPart ( SgAsmDwarfVariantPartStorageArray[i] ) ; 
              }
          delete [] SgAsmDwarfVariantPartStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDwarfVolatileType ) ;
     std::cout << " SgAsmDwarfVolatileType has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDwarfVolatileTypeStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDwarfVolatileType ( SgAsmDwarfVolatileTypeStorageArray[i] ) ; 
              }
          delete [] SgAsmDwarfVolatileTypeStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmDwarfWithStmt ) ;
     std::cout << " SgAsmDwarfWithStmt has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmDwarfWithStmtStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmDwarfWithStmt ( SgAsmDwarfWithStmtStorageArray[i] ) ; 
              }
          delete [] SgAsmDwarfWithStmtStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmElfDynamicEntry ) ;
     std::cout << " SgAsmElfDynamicEntry has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmElfDynamicEntryStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmElfDynamicEntry ( SgAsmElfDynamicEntryStorageArray[i] ) ; 
              }
          delete [] SgAsmElfDynamicEntryStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmElfDynamicEntryList ) ;
     std::cout << " SgAsmElfDynamicEntryList has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmElfDynamicEntryListStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmElfDynamicEntryList ( SgAsmElfDynamicEntryListStorageArray[i] ) ; 
              }
          delete [] SgAsmElfDynamicEntryListStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmElfDynamicSection ) ;
     std::cout << " SgAsmElfDynamicSection has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmElfDynamicSectionStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmElfDynamicSection ( SgAsmElfDynamicSectionStorageArray[i] ) ; 
              }
          delete [] SgAsmElfDynamicSectionStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmElfEHFrameEntryCI ) ;
     std::cout << " SgAsmElfEHFrameEntryCI has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmElfEHFrameEntryCIStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmElfEHFrameEntryCI ( SgAsmElfEHFrameEntryCIStorageArray[i] ) ; 
              }
          delete [] SgAsmElfEHFrameEntryCIStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmElfEHFrameEntryCIList ) ;
     std::cout << " SgAsmElfEHFrameEntryCIList has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmElfEHFrameEntryCIListStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmElfEHFrameEntryCIList ( SgAsmElfEHFrameEntryCIListStorageArray[i] ) ; 
              }
          delete [] SgAsmElfEHFrameEntryCIListStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmElfEHFrameEntryFD ) ;
     std::cout << " SgAsmElfEHFrameEntryFD has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmElfEHFrameEntryFDStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmElfEHFrameEntryFD ( SgAsmElfEHFrameEntryFDStorageArray[i] ) ; 
              }
          delete [] SgAsmElfEHFrameEntryFDStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmElfEHFrameEntryFDList ) ;
     std::cout << " SgAsmElfEHFrameEntryFDList has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmElfEHFrameEntryFDListStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmElfEHFrameEntryFDList ( SgAsmElfEHFrameEntryFDListStorageArray[i] ) ; 
              }
          delete [] SgAsmElfEHFrameEntryFDListStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmElfEHFrameSection ) ;
     std::cout << " SgAsmElfEHFrameSection has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmElfEHFrameSectionStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmElfEHFrameSection ( SgAsmElfEHFrameSectionStorageArray[i] ) ; 
              }
          delete [] SgAsmElfEHFrameSectionStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmElfFileHeader ) ;
     std::cout << " SgAsmElfFileHeader has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmElfFileHeaderStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmElfFileHeader ( SgAsmElfFileHeaderStorageArray[i] ) ; 
              }
          delete [] SgAsmElfFileHeaderStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmElfNoteEntry ) ;
     std::cout << " SgAsmElfNoteEntry has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmElfNoteEntryStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmElfNoteEntry ( SgAsmElfNoteEntryStorageArray[i] ) ; 
              }
          delete [] SgAsmElfNoteEntryStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmElfNoteEntryList ) ;
     std::cout << " SgAsmElfNoteEntryList has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmElfNoteEntryListStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmElfNoteEntryList ( SgAsmElfNoteEntryListStorageArray[i] ) ; 
              }
          delete [] SgAsmElfNoteEntryListStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmElfNoteSection ) ;
     std::cout << " SgAsmElfNoteSection has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmElfNoteSectionStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmElfNoteSection ( SgAsmElfNoteSectionStorageArray[i] ) ; 
              }
          delete [] SgAsmElfNoteSectionStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmElfRelocEntry ) ;
     std::cout << " SgAsmElfRelocEntry has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmElfRelocEntryStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmElfRelocEntry ( SgAsmElfRelocEntryStorageArray[i] ) ; 
              }
          delete [] SgAsmElfRelocEntryStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmElfRelocEntryList ) ;
     std::cout << " SgAsmElfRelocEntryList has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmElfRelocEntryListStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmElfRelocEntryList ( SgAsmElfRelocEntryListStorageArray[i] ) ; 
              }
          delete [] SgAsmElfRelocEntryListStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmElfRelocSection ) ;
     std::cout << " SgAsmElfRelocSection has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmElfRelocSectionStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmElfRelocSection ( SgAsmElfRelocSectionStorageArray[i] ) ; 
              }
          delete [] SgAsmElfRelocSectionStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmElfSection ) ;
     std::cout << " SgAsmElfSection has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmElfSectionStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmElfSection ( SgAsmElfSectionStorageArray[i] ) ; 
              }
          delete [] SgAsmElfSectionStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmElfSectionTable ) ;
     std::cout << " SgAsmElfSectionTable has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmElfSectionTableStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmElfSectionTable ( SgAsmElfSectionTableStorageArray[i] ) ; 
              }
          delete [] SgAsmElfSectionTableStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmElfSectionTableEntry ) ;
     std::cout << " SgAsmElfSectionTableEntry has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmElfSectionTableEntryStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmElfSectionTableEntry ( SgAsmElfSectionTableEntryStorageArray[i] ) ; 
              }
          delete [] SgAsmElfSectionTableEntryStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmElfSegmentTable ) ;
     std::cout << " SgAsmElfSegmentTable has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmElfSegmentTableStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmElfSegmentTable ( SgAsmElfSegmentTableStorageArray[i] ) ; 
              }
          delete [] SgAsmElfSegmentTableStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmElfSegmentTableEntry ) ;
     std::cout << " SgAsmElfSegmentTableEntry has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmElfSegmentTableEntryStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmElfSegmentTableEntry ( SgAsmElfSegmentTableEntryStorageArray[i] ) ; 
              }
          delete [] SgAsmElfSegmentTableEntryStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmElfSegmentTableEntryList ) ;
     std::cout << " SgAsmElfSegmentTableEntryList has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmElfSegmentTableEntryListStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmElfSegmentTableEntryList ( SgAsmElfSegmentTableEntryListStorageArray[i] ) ; 
              }
          delete [] SgAsmElfSegmentTableEntryListStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmElfStringSection ) ;
     std::cout << " SgAsmElfStringSection has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmElfStringSectionStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmElfStringSection ( SgAsmElfStringSectionStorageArray[i] ) ; 
              }
          delete [] SgAsmElfStringSectionStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmElfStrtab ) ;
     std::cout << " SgAsmElfStrtab has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmElfStrtabStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmElfStrtab ( SgAsmElfStrtabStorageArray[i] ) ; 
              }
          delete [] SgAsmElfStrtabStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmElfSymbol ) ;
     std::cout << " SgAsmElfSymbol has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmElfSymbolStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmElfSymbol ( SgAsmElfSymbolStorageArray[i] ) ; 
              }
          delete [] SgAsmElfSymbolStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmElfSymbolList ) ;
     std::cout << " SgAsmElfSymbolList has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmElfSymbolListStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmElfSymbolList ( SgAsmElfSymbolListStorageArray[i] ) ; 
              }
          delete [] SgAsmElfSymbolListStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmElfSymbolSection ) ;
     std::cout << " SgAsmElfSymbolSection has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmElfSymbolSectionStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmElfSymbolSection ( SgAsmElfSymbolSectionStorageArray[i] ) ; 
              }
          delete [] SgAsmElfSymbolSectionStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmElfSymverDefinedAux ) ;
     std::cout << " SgAsmElfSymverDefinedAux has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmElfSymverDefinedAuxStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmElfSymverDefinedAux ( SgAsmElfSymverDefinedAuxStorageArray[i] ) ; 
              }
          delete [] SgAsmElfSymverDefinedAuxStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmElfSymverDefinedAuxList ) ;
     std::cout << " SgAsmElfSymverDefinedAuxList has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmElfSymverDefinedAuxListStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmElfSymverDefinedAuxList ( SgAsmElfSymverDefinedAuxListStorageArray[i] ) ; 
              }
          delete [] SgAsmElfSymverDefinedAuxListStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmElfSymverDefinedEntry ) ;
     std::cout << " SgAsmElfSymverDefinedEntry has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmElfSymverDefinedEntryStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmElfSymverDefinedEntry ( SgAsmElfSymverDefinedEntryStorageArray[i] ) ; 
              }
          delete [] SgAsmElfSymverDefinedEntryStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmElfSymverDefinedEntryList ) ;
     std::cout << " SgAsmElfSymverDefinedEntryList has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmElfSymverDefinedEntryListStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmElfSymverDefinedEntryList ( SgAsmElfSymverDefinedEntryListStorageArray[i] ) ; 
              }
          delete [] SgAsmElfSymverDefinedEntryListStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmElfSymverDefinedSection ) ;
     std::cout << " SgAsmElfSymverDefinedSection has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmElfSymverDefinedSectionStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmElfSymverDefinedSection ( SgAsmElfSymverDefinedSectionStorageArray[i] ) ; 
              }
          delete [] SgAsmElfSymverDefinedSectionStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmElfSymverEntry ) ;
     std::cout << " SgAsmElfSymverEntry has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmElfSymverEntryStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmElfSymverEntry ( SgAsmElfSymverEntryStorageArray[i] ) ; 
              }
          delete [] SgAsmElfSymverEntryStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmElfSymverEntryList ) ;
     std::cout << " SgAsmElfSymverEntryList has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmElfSymverEntryListStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmElfSymverEntryList ( SgAsmElfSymverEntryListStorageArray[i] ) ; 
              }
          delete [] SgAsmElfSymverEntryListStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmElfSymverNeededAux ) ;
     std::cout << " SgAsmElfSymverNeededAux has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmElfSymverNeededAuxStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmElfSymverNeededAux ( SgAsmElfSymverNeededAuxStorageArray[i] ) ; 
              }
          delete [] SgAsmElfSymverNeededAuxStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmElfSymverNeededAuxList ) ;
     std::cout << " SgAsmElfSymverNeededAuxList has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmElfSymverNeededAuxListStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmElfSymverNeededAuxList ( SgAsmElfSymverNeededAuxListStorageArray[i] ) ; 
              }
          delete [] SgAsmElfSymverNeededAuxListStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmElfSymverNeededEntry ) ;
     std::cout << " SgAsmElfSymverNeededEntry has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmElfSymverNeededEntryStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmElfSymverNeededEntry ( SgAsmElfSymverNeededEntryStorageArray[i] ) ; 
              }
          delete [] SgAsmElfSymverNeededEntryStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmElfSymverNeededEntryList ) ;
     std::cout << " SgAsmElfSymverNeededEntryList has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmElfSymverNeededEntryListStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmElfSymverNeededEntryList ( SgAsmElfSymverNeededEntryListStorageArray[i] ) ; 
              }
          delete [] SgAsmElfSymverNeededEntryListStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmElfSymverNeededSection ) ;
     std::cout << " SgAsmElfSymverNeededSection has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmElfSymverNeededSectionStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmElfSymverNeededSection ( SgAsmElfSymverNeededSectionStorageArray[i] ) ; 
              }
          delete [] SgAsmElfSymverNeededSectionStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmElfSymverSection ) ;
     std::cout << " SgAsmElfSymverSection has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmElfSymverSectionStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmElfSymverSection ( SgAsmElfSymverSectionStorageArray[i] ) ; 
              }
          delete [] SgAsmElfSymverSectionStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmExecutableFileFormat ) ;
     std::cout << " SgAsmExecutableFileFormat has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmExecutableFileFormatStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmExecutableFileFormat ( SgAsmExecutableFileFormatStorageArray[i] ) ; 
              }
          delete [] SgAsmExecutableFileFormatStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmExprListExp ) ;
     std::cout << " SgAsmExprListExp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmExprListExpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmExprListExp ( SgAsmExprListExpStorageArray[i] ) ; 
              }
          delete [] SgAsmExprListExpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmExpression ) ;
     std::cout << " SgAsmExpression has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmExpressionStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmExpression ( SgAsmExpressionStorageArray[i] ) ; 
              }
          delete [] SgAsmExpressionStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmFunction ) ;
     std::cout << " SgAsmFunction has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmFunctionStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmFunction ( SgAsmFunctionStorageArray[i] ) ; 
              }
          delete [] SgAsmFunctionStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmGenericDLL ) ;
     std::cout << " SgAsmGenericDLL has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmGenericDLLStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmGenericDLL ( SgAsmGenericDLLStorageArray[i] ) ; 
              }
          delete [] SgAsmGenericDLLStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmGenericDLLList ) ;
     std::cout << " SgAsmGenericDLLList has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmGenericDLLListStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmGenericDLLList ( SgAsmGenericDLLListStorageArray[i] ) ; 
              }
          delete [] SgAsmGenericDLLListStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmGenericFile ) ;
     std::cout << " SgAsmGenericFile has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmGenericFileStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmGenericFile ( SgAsmGenericFileStorageArray[i] ) ; 
              }
          delete [] SgAsmGenericFileStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmGenericFileList ) ;
     std::cout << " SgAsmGenericFileList has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmGenericFileListStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmGenericFileList ( SgAsmGenericFileListStorageArray[i] ) ; 
              }
          delete [] SgAsmGenericFileListStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmGenericFormat ) ;
     std::cout << " SgAsmGenericFormat has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmGenericFormatStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmGenericFormat ( SgAsmGenericFormatStorageArray[i] ) ; 
              }
          delete [] SgAsmGenericFormatStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmGenericHeader ) ;
     std::cout << " SgAsmGenericHeader has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmGenericHeaderStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmGenericHeader ( SgAsmGenericHeaderStorageArray[i] ) ; 
              }
          delete [] SgAsmGenericHeaderStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmGenericHeaderList ) ;
     std::cout << " SgAsmGenericHeaderList has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmGenericHeaderListStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmGenericHeaderList ( SgAsmGenericHeaderListStorageArray[i] ) ; 
              }
          delete [] SgAsmGenericHeaderListStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmGenericSection ) ;
     std::cout << " SgAsmGenericSection has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmGenericSectionStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmGenericSection ( SgAsmGenericSectionStorageArray[i] ) ; 
              }
          delete [] SgAsmGenericSectionStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmGenericSectionList ) ;
     std::cout << " SgAsmGenericSectionList has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmGenericSectionListStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmGenericSectionList ( SgAsmGenericSectionListStorageArray[i] ) ; 
              }
          delete [] SgAsmGenericSectionListStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmGenericString ) ;
     std::cout << " SgAsmGenericString has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmGenericStringStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmGenericString ( SgAsmGenericStringStorageArray[i] ) ; 
              }
          delete [] SgAsmGenericStringStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmGenericStrtab ) ;
     std::cout << " SgAsmGenericStrtab has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmGenericStrtabStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmGenericStrtab ( SgAsmGenericStrtabStorageArray[i] ) ; 
              }
          delete [] SgAsmGenericStrtabStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmGenericSymbol ) ;
     std::cout << " SgAsmGenericSymbol has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmGenericSymbolStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmGenericSymbol ( SgAsmGenericSymbolStorageArray[i] ) ; 
              }
          delete [] SgAsmGenericSymbolStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmGenericSymbolList ) ;
     std::cout << " SgAsmGenericSymbolList has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmGenericSymbolListStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmGenericSymbolList ( SgAsmGenericSymbolListStorageArray[i] ) ; 
              }
          delete [] SgAsmGenericSymbolListStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmInstruction ) ;
     std::cout << " SgAsmInstruction has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmInstructionStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmInstruction ( SgAsmInstructionStorageArray[i] ) ; 
              }
          delete [] SgAsmInstructionStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmIntegerValueExpression ) ;
     std::cout << " SgAsmIntegerValueExpression has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmIntegerValueExpressionStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmIntegerValueExpression ( SgAsmIntegerValueExpressionStorageArray[i] ) ; 
              }
          delete [] SgAsmIntegerValueExpressionStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmInterpretation ) ;
     std::cout << " SgAsmInterpretation has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmInterpretationStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmInterpretation ( SgAsmInterpretationStorageArray[i] ) ; 
              }
          delete [] SgAsmInterpretationStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmInterpretationList ) ;
     std::cout << " SgAsmInterpretationList has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmInterpretationListStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmInterpretationList ( SgAsmInterpretationListStorageArray[i] ) ; 
              }
          delete [] SgAsmInterpretationListStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmLEEntryPoint ) ;
     std::cout << " SgAsmLEEntryPoint has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmLEEntryPointStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmLEEntryPoint ( SgAsmLEEntryPointStorageArray[i] ) ; 
              }
          delete [] SgAsmLEEntryPointStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmLEEntryTable ) ;
     std::cout << " SgAsmLEEntryTable has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmLEEntryTableStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmLEEntryTable ( SgAsmLEEntryTableStorageArray[i] ) ; 
              }
          delete [] SgAsmLEEntryTableStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmLEFileHeader ) ;
     std::cout << " SgAsmLEFileHeader has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmLEFileHeaderStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmLEFileHeader ( SgAsmLEFileHeaderStorageArray[i] ) ; 
              }
          delete [] SgAsmLEFileHeaderStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmLENameTable ) ;
     std::cout << " SgAsmLENameTable has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmLENameTableStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmLENameTable ( SgAsmLENameTableStorageArray[i] ) ; 
              }
          delete [] SgAsmLENameTableStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmLEPageTable ) ;
     std::cout << " SgAsmLEPageTable has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmLEPageTableStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmLEPageTable ( SgAsmLEPageTableStorageArray[i] ) ; 
              }
          delete [] SgAsmLEPageTableStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmLEPageTableEntry ) ;
     std::cout << " SgAsmLEPageTableEntry has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmLEPageTableEntryStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmLEPageTableEntry ( SgAsmLEPageTableEntryStorageArray[i] ) ; 
              }
          delete [] SgAsmLEPageTableEntryStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmLERelocTable ) ;
     std::cout << " SgAsmLERelocTable has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmLERelocTableStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmLERelocTable ( SgAsmLERelocTableStorageArray[i] ) ; 
              }
          delete [] SgAsmLERelocTableStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmLESection ) ;
     std::cout << " SgAsmLESection has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmLESectionStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmLESection ( SgAsmLESectionStorageArray[i] ) ; 
              }
          delete [] SgAsmLESectionStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmLESectionTable ) ;
     std::cout << " SgAsmLESectionTable has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmLESectionTableStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmLESectionTable ( SgAsmLESectionTableStorageArray[i] ) ; 
              }
          delete [] SgAsmLESectionTableStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmLESectionTableEntry ) ;
     std::cout << " SgAsmLESectionTableEntry has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmLESectionTableEntryStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmLESectionTableEntry ( SgAsmLESectionTableEntryStorageArray[i] ) ; 
              }
          delete [] SgAsmLESectionTableEntryStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmMemoryReferenceExpression ) ;
     std::cout << " SgAsmMemoryReferenceExpression has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmMemoryReferenceExpressionStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmMemoryReferenceExpression ( SgAsmMemoryReferenceExpressionStorageArray[i] ) ; 
              }
          delete [] SgAsmMemoryReferenceExpressionStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmNEEntryPoint ) ;
     std::cout << " SgAsmNEEntryPoint has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmNEEntryPointStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmNEEntryPoint ( SgAsmNEEntryPointStorageArray[i] ) ; 
              }
          delete [] SgAsmNEEntryPointStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmNEEntryTable ) ;
     std::cout << " SgAsmNEEntryTable has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmNEEntryTableStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmNEEntryTable ( SgAsmNEEntryTableStorageArray[i] ) ; 
              }
          delete [] SgAsmNEEntryTableStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmNEFileHeader ) ;
     std::cout << " SgAsmNEFileHeader has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmNEFileHeaderStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmNEFileHeader ( SgAsmNEFileHeaderStorageArray[i] ) ; 
              }
          delete [] SgAsmNEFileHeaderStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmNEModuleTable ) ;
     std::cout << " SgAsmNEModuleTable has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmNEModuleTableStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmNEModuleTable ( SgAsmNEModuleTableStorageArray[i] ) ; 
              }
          delete [] SgAsmNEModuleTableStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmNENameTable ) ;
     std::cout << " SgAsmNENameTable has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmNENameTableStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmNENameTable ( SgAsmNENameTableStorageArray[i] ) ; 
              }
          delete [] SgAsmNENameTableStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmNERelocEntry ) ;
     std::cout << " SgAsmNERelocEntry has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmNERelocEntryStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmNERelocEntry ( SgAsmNERelocEntryStorageArray[i] ) ; 
              }
          delete [] SgAsmNERelocEntryStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmNERelocTable ) ;
     std::cout << " SgAsmNERelocTable has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmNERelocTableStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmNERelocTable ( SgAsmNERelocTableStorageArray[i] ) ; 
              }
          delete [] SgAsmNERelocTableStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmNESection ) ;
     std::cout << " SgAsmNESection has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmNESectionStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmNESection ( SgAsmNESectionStorageArray[i] ) ; 
              }
          delete [] SgAsmNESectionStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmNESectionTable ) ;
     std::cout << " SgAsmNESectionTable has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmNESectionTableStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmNESectionTable ( SgAsmNESectionTableStorageArray[i] ) ; 
              }
          delete [] SgAsmNESectionTableStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmNESectionTableEntry ) ;
     std::cout << " SgAsmNESectionTableEntry has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmNESectionTableEntryStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmNESectionTableEntry ( SgAsmNESectionTableEntryStorageArray[i] ) ; 
              }
          delete [] SgAsmNESectionTableEntryStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmNEStringTable ) ;
     std::cout << " SgAsmNEStringTable has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmNEStringTableStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmNEStringTable ( SgAsmNEStringTableStorageArray[i] ) ; 
              }
          delete [] SgAsmNEStringTableStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmNode ) ;
     std::cout << " SgAsmNode has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmNodeStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmNode ( SgAsmNodeStorageArray[i] ) ; 
              }
          delete [] SgAsmNodeStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmOp ) ;
     std::cout << " SgAsmOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmOp ( SgAsmOpStorageArray[i] ) ; 
              }
          delete [] SgAsmOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmOperandList ) ;
     std::cout << " SgAsmOperandList has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmOperandListStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmOperandList ( SgAsmOperandListStorageArray[i] ) ; 
              }
          delete [] SgAsmOperandListStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmPEExportDirectory ) ;
     std::cout << " SgAsmPEExportDirectory has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmPEExportDirectoryStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmPEExportDirectory ( SgAsmPEExportDirectoryStorageArray[i] ) ; 
              }
          delete [] SgAsmPEExportDirectoryStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmPEExportEntry ) ;
     std::cout << " SgAsmPEExportEntry has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmPEExportEntryStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmPEExportEntry ( SgAsmPEExportEntryStorageArray[i] ) ; 
              }
          delete [] SgAsmPEExportEntryStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmPEExportEntryList ) ;
     std::cout << " SgAsmPEExportEntryList has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmPEExportEntryListStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmPEExportEntryList ( SgAsmPEExportEntryListStorageArray[i] ) ; 
              }
          delete [] SgAsmPEExportEntryListStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmPEExportSection ) ;
     std::cout << " SgAsmPEExportSection has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmPEExportSectionStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmPEExportSection ( SgAsmPEExportSectionStorageArray[i] ) ; 
              }
          delete [] SgAsmPEExportSectionStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmPEFileHeader ) ;
     std::cout << " SgAsmPEFileHeader has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmPEFileHeaderStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmPEFileHeader ( SgAsmPEFileHeaderStorageArray[i] ) ; 
              }
          delete [] SgAsmPEFileHeaderStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmPEImportDirectory ) ;
     std::cout << " SgAsmPEImportDirectory has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmPEImportDirectoryStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmPEImportDirectory ( SgAsmPEImportDirectoryStorageArray[i] ) ; 
              }
          delete [] SgAsmPEImportDirectoryStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmPEImportDirectoryList ) ;
     std::cout << " SgAsmPEImportDirectoryList has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmPEImportDirectoryListStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmPEImportDirectoryList ( SgAsmPEImportDirectoryListStorageArray[i] ) ; 
              }
          delete [] SgAsmPEImportDirectoryListStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmPEImportItem ) ;
     std::cout << " SgAsmPEImportItem has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmPEImportItemStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmPEImportItem ( SgAsmPEImportItemStorageArray[i] ) ; 
              }
          delete [] SgAsmPEImportItemStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmPEImportItemList ) ;
     std::cout << " SgAsmPEImportItemList has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmPEImportItemListStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmPEImportItemList ( SgAsmPEImportItemListStorageArray[i] ) ; 
              }
          delete [] SgAsmPEImportItemListStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmPEImportSection ) ;
     std::cout << " SgAsmPEImportSection has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmPEImportSectionStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmPEImportSection ( SgAsmPEImportSectionStorageArray[i] ) ; 
              }
          delete [] SgAsmPEImportSectionStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmPERVASizePair ) ;
     std::cout << " SgAsmPERVASizePair has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmPERVASizePairStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmPERVASizePair ( SgAsmPERVASizePairStorageArray[i] ) ; 
              }
          delete [] SgAsmPERVASizePairStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmPERVASizePairList ) ;
     std::cout << " SgAsmPERVASizePairList has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmPERVASizePairListStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmPERVASizePairList ( SgAsmPERVASizePairListStorageArray[i] ) ; 
              }
          delete [] SgAsmPERVASizePairListStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmPESection ) ;
     std::cout << " SgAsmPESection has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmPESectionStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmPESection ( SgAsmPESectionStorageArray[i] ) ; 
              }
          delete [] SgAsmPESectionStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmPESectionTable ) ;
     std::cout << " SgAsmPESectionTable has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmPESectionTableStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmPESectionTable ( SgAsmPESectionTableStorageArray[i] ) ; 
              }
          delete [] SgAsmPESectionTableStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmPESectionTableEntry ) ;
     std::cout << " SgAsmPESectionTableEntry has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmPESectionTableEntryStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmPESectionTableEntry ( SgAsmPESectionTableEntryStorageArray[i] ) ; 
              }
          delete [] SgAsmPESectionTableEntryStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmPEStringSection ) ;
     std::cout << " SgAsmPEStringSection has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmPEStringSectionStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmPEStringSection ( SgAsmPEStringSectionStorageArray[i] ) ; 
              }
          delete [] SgAsmPEStringSectionStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmPowerpcInstruction ) ;
     std::cout << " SgAsmPowerpcInstruction has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmPowerpcInstructionStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmPowerpcInstruction ( SgAsmPowerpcInstructionStorageArray[i] ) ; 
              }
          delete [] SgAsmPowerpcInstructionStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmPowerpcRegisterReferenceExpression ) ;
     std::cout << " SgAsmPowerpcRegisterReferenceExpression has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmPowerpcRegisterReferenceExpressionStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmPowerpcRegisterReferenceExpression ( SgAsmPowerpcRegisterReferenceExpressionStorageArray[i] ) ; 
              }
          delete [] SgAsmPowerpcRegisterReferenceExpressionStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmQuadWordValueExpression ) ;
     std::cout << " SgAsmQuadWordValueExpression has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmQuadWordValueExpressionStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmQuadWordValueExpression ( SgAsmQuadWordValueExpressionStorageArray[i] ) ; 
              }
          delete [] SgAsmQuadWordValueExpressionStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmRegisterReferenceExpression ) ;
     std::cout << " SgAsmRegisterReferenceExpression has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmRegisterReferenceExpressionStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmRegisterReferenceExpression ( SgAsmRegisterReferenceExpressionStorageArray[i] ) ; 
              }
          delete [] SgAsmRegisterReferenceExpressionStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmSingleFloatValueExpression ) ;
     std::cout << " SgAsmSingleFloatValueExpression has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmSingleFloatValueExpressionStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmSingleFloatValueExpression ( SgAsmSingleFloatValueExpressionStorageArray[i] ) ; 
              }
          delete [] SgAsmSingleFloatValueExpressionStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmStatement ) ;
     std::cout << " SgAsmStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmStatement ( SgAsmStatementStorageArray[i] ) ; 
              }
          delete [] SgAsmStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmStaticData ) ;
     std::cout << " SgAsmStaticData has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmStaticDataStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmStaticData ( SgAsmStaticDataStorageArray[i] ) ; 
              }
          delete [] SgAsmStaticDataStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmStmt ) ;
     std::cout << " SgAsmStmt has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmStmtStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmStmt ( SgAsmStmtStorageArray[i] ) ; 
              }
          delete [] SgAsmStmtStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmStoredString ) ;
     std::cout << " SgAsmStoredString has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmStoredStringStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmStoredString ( SgAsmStoredStringStorageArray[i] ) ; 
              }
          delete [] SgAsmStoredStringStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmStringStorage ) ;
     std::cout << " SgAsmStringStorage has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmStringStorageStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmStringStorage ( SgAsmStringStorageStorageArray[i] ) ; 
              }
          delete [] SgAsmStringStorageStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmType ) ;
     std::cout << " SgAsmType has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmTypeStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmType ( SgAsmTypeStorageArray[i] ) ; 
              }
          delete [] SgAsmTypeStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmType128bitFloat ) ;
     std::cout << " SgAsmType128bitFloat has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmType128bitFloatStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmType128bitFloat ( SgAsmType128bitFloatStorageArray[i] ) ; 
              }
          delete [] SgAsmType128bitFloatStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmType80bitFloat ) ;
     std::cout << " SgAsmType80bitFloat has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmType80bitFloatStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmType80bitFloat ( SgAsmType80bitFloatStorageArray[i] ) ; 
              }
          delete [] SgAsmType80bitFloatStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmTypeByte ) ;
     std::cout << " SgAsmTypeByte has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmTypeByteStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmTypeByte ( SgAsmTypeByteStorageArray[i] ) ; 
              }
          delete [] SgAsmTypeByteStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmTypeDoubleFloat ) ;
     std::cout << " SgAsmTypeDoubleFloat has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmTypeDoubleFloatStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmTypeDoubleFloat ( SgAsmTypeDoubleFloatStorageArray[i] ) ; 
              }
          delete [] SgAsmTypeDoubleFloatStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmTypeDoubleQuadWord ) ;
     std::cout << " SgAsmTypeDoubleQuadWord has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmTypeDoubleQuadWordStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmTypeDoubleQuadWord ( SgAsmTypeDoubleQuadWordStorageArray[i] ) ; 
              }
          delete [] SgAsmTypeDoubleQuadWordStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmTypeDoubleWord ) ;
     std::cout << " SgAsmTypeDoubleWord has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmTypeDoubleWordStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmTypeDoubleWord ( SgAsmTypeDoubleWordStorageArray[i] ) ; 
              }
          delete [] SgAsmTypeDoubleWordStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmTypeQuadWord ) ;
     std::cout << " SgAsmTypeQuadWord has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmTypeQuadWordStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmTypeQuadWord ( SgAsmTypeQuadWordStorageArray[i] ) ; 
              }
          delete [] SgAsmTypeQuadWordStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmTypeSingleFloat ) ;
     std::cout << " SgAsmTypeSingleFloat has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmTypeSingleFloatStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmTypeSingleFloat ( SgAsmTypeSingleFloatStorageArray[i] ) ; 
              }
          delete [] SgAsmTypeSingleFloatStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmTypeVector ) ;
     std::cout << " SgAsmTypeVector has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmTypeVectorStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmTypeVector ( SgAsmTypeVectorStorageArray[i] ) ; 
              }
          delete [] SgAsmTypeVectorStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmTypeWord ) ;
     std::cout << " SgAsmTypeWord has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmTypeWordStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmTypeWord ( SgAsmTypeWordStorageArray[i] ) ; 
              }
          delete [] SgAsmTypeWordStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmUnaryArmSpecialRegisterList ) ;
     std::cout << " SgAsmUnaryArmSpecialRegisterList has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmUnaryArmSpecialRegisterListStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmUnaryArmSpecialRegisterList ( SgAsmUnaryArmSpecialRegisterListStorageArray[i] ) ; 
              }
          delete [] SgAsmUnaryArmSpecialRegisterListStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmUnaryExpression ) ;
     std::cout << " SgAsmUnaryExpression has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmUnaryExpressionStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmUnaryExpression ( SgAsmUnaryExpressionStorageArray[i] ) ; 
              }
          delete [] SgAsmUnaryExpressionStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmUnaryMinus ) ;
     std::cout << " SgAsmUnaryMinus has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmUnaryMinusStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmUnaryMinus ( SgAsmUnaryMinusStorageArray[i] ) ; 
              }
          delete [] SgAsmUnaryMinusStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmUnaryPlus ) ;
     std::cout << " SgAsmUnaryPlus has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmUnaryPlusStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmUnaryPlus ( SgAsmUnaryPlusStorageArray[i] ) ; 
              }
          delete [] SgAsmUnaryPlusStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmUnaryRrx ) ;
     std::cout << " SgAsmUnaryRrx has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmUnaryRrxStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmUnaryRrx ( SgAsmUnaryRrxStorageArray[i] ) ; 
              }
          delete [] SgAsmUnaryRrxStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmValueExpression ) ;
     std::cout << " SgAsmValueExpression has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmValueExpressionStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmValueExpression ( SgAsmValueExpressionStorageArray[i] ) ; 
              }
          delete [] SgAsmValueExpressionStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmVectorValueExpression ) ;
     std::cout << " SgAsmVectorValueExpression has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmVectorValueExpressionStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmVectorValueExpression ( SgAsmVectorValueExpressionStorageArray[i] ) ; 
              }
          delete [] SgAsmVectorValueExpressionStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmWordValueExpression ) ;
     std::cout << " SgAsmWordValueExpression has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmWordValueExpressionStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmWordValueExpression ( SgAsmWordValueExpressionStorageArray[i] ) ; 
              }
          delete [] SgAsmWordValueExpressionStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmx86Instruction ) ;
     std::cout << " SgAsmx86Instruction has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmx86InstructionStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmx86Instruction ( SgAsmx86InstructionStorageArray[i] ) ; 
              }
          delete [] SgAsmx86InstructionStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmx86RegisterReferenceExpression ) ;
     std::cout << " SgAsmx86RegisterReferenceExpression has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmx86RegisterReferenceExpressionStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmx86RegisterReferenceExpression ( SgAsmx86RegisterReferenceExpressionStorageArray[i] ) ; 
              }
          delete [] SgAsmx86RegisterReferenceExpressionStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmBinaryAddressSymbol ) ;
     std::cout << " SgAsmBinaryAddressSymbol has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmBinaryAddressSymbolStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmBinaryAddressSymbol ( SgAsmBinaryAddressSymbolStorageArray[i] ) ; 
              }
          delete [] SgAsmBinaryAddressSymbolStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsmBinaryDataSymbol ) ;
     std::cout << " SgAsmBinaryDataSymbol has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsmBinaryDataSymbolStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsmBinaryDataSymbol ( SgAsmBinaryDataSymbolStorageArray[i] ) ; 
              }
          delete [] SgAsmBinaryDataSymbolStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAssertStmt ) ;
     std::cout << " SgAssertStmt has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAssertStmtStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAssertStmt ( SgAssertStmtStorageArray[i] ) ; 
              }
          delete [] SgAssertStmtStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAssignInitializer ) ;
     std::cout << " SgAssignInitializer has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAssignInitializerStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAssignInitializer ( SgAssignInitializerStorageArray[i] ) ; 
              }
          delete [] SgAssignInitializerStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAssignOp ) ;
     std::cout << " SgAssignOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAssignOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAssignOp ( SgAssignOpStorageArray[i] ) ; 
              }
          delete [] SgAssignOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAssignStatement ) ;
     std::cout << " SgAssignStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAssignStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAssignStatement ( SgAssignStatementStorageArray[i] ) ; 
              }
          delete [] SgAssignStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAssignedGotoStatement ) ;
     std::cout << " SgAssignedGotoStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAssignedGotoStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAssignedGotoStatement ( SgAssignedGotoStatementStorageArray[i] ) ; 
              }
          delete [] SgAssignedGotoStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAssociateStatement ) ;
     std::cout << " SgAssociateStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAssociateStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAssociateStatement ( SgAssociateStatementStorageArray[i] ) ; 
              }
          delete [] SgAssociateStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAsteriskShapeExp ) ;
     std::cout << " SgAsteriskShapeExp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAsteriskShapeExpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAsteriskShapeExp ( SgAsteriskShapeExpStorageArray[i] ) ; 
              }
          delete [] SgAsteriskShapeExpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAttribute ) ;
     std::cout << " SgAttribute has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAttributeStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAttribute ( SgAttributeStorageArray[i] ) ; 
              }
          delete [] SgAttributeStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgAttributeSpecificationStatement ) ;
     std::cout << " SgAttributeSpecificationStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgAttributeSpecificationStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgAttributeSpecificationStatement ( SgAttributeSpecificationStatementStorageArray[i] ) ; 
              }
          delete [] SgAttributeSpecificationStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgBackspaceStatement ) ;
     std::cout << " SgBackspaceStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgBackspaceStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgBackspaceStatement ( SgBackspaceStatementStorageArray[i] ) ; 
              }
          delete [] SgBackspaceStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgBaseClass ) ;
     std::cout << " SgBaseClass has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgBaseClass ( SgBaseClassStorageArray[i] ) ; 
              }
          delete [] SgBaseClassStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgExpBaseClass ) ;
     std::cout << " SgExpBaseClass has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgExpBaseClass ( SgExpBaseClassStorageArray[i] ) ; 
              }
          delete [] SgExpBaseClassStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgBaseClassModifier ) ;
     std::cout << " SgBaseClassModifier has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgBaseClassModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgBaseClassModifier ( SgBaseClassModifierStorageArray[i] ) ; 
              }
          delete [] SgBaseClassModifierStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgBasicBlock ) ;
     std::cout << " SgBasicBlock has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgBasicBlockStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgBasicBlock ( SgBasicBlockStorageArray[i] ) ; 
              }
          delete [] SgBasicBlockStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgBidirectionalGraph ) ;
     std::cout << " SgBidirectionalGraph has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgBidirectionalGraphStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgBidirectionalGraph ( SgBidirectionalGraphStorageArray[i] ) ; 
              }
          delete [] SgBidirectionalGraphStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgBinaryComposite ) ;
     std::cout << " SgBinaryComposite has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgBinaryCompositeStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgBinaryComposite ( SgBinaryCompositeStorageArray[i] ) ; 
              }
          delete [] SgBinaryCompositeStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgBinaryOp ) ;
     std::cout << " SgBinaryOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgBinaryOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgBinaryOp ( SgBinaryOpStorageArray[i] ) ; 
              }
          delete [] SgBinaryOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgBitAndOp ) ;
     std::cout << " SgBitAndOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgBitAndOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgBitAndOp ( SgBitAndOpStorageArray[i] ) ; 
              }
          delete [] SgBitAndOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgBitAttribute ) ;
     std::cout << " SgBitAttribute has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgBitAttributeStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgBitAttribute ( SgBitAttributeStorageArray[i] ) ; 
              }
          delete [] SgBitAttributeStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgBitComplementOp ) ;
     std::cout << " SgBitComplementOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgBitComplementOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgBitComplementOp ( SgBitComplementOpStorageArray[i] ) ; 
              }
          delete [] SgBitComplementOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgBitOrOp ) ;
     std::cout << " SgBitOrOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgBitOrOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgBitOrOp ( SgBitOrOpStorageArray[i] ) ; 
              }
          delete [] SgBitOrOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgBitXorOp ) ;
     std::cout << " SgBitXorOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgBitXorOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgBitXorOp ( SgBitXorOpStorageArray[i] ) ; 
              }
          delete [] SgBitXorOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgBlockDataStatement ) ;
     std::cout << " SgBlockDataStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgBlockDataStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgBlockDataStatement ( SgBlockDataStatementStorageArray[i] ) ; 
              }
          delete [] SgBlockDataStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgBoolValExp ) ;
     std::cout << " SgBoolValExp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgBoolValExpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgBoolValExp ( SgBoolValExpStorageArray[i] ) ; 
              }
          delete [] SgBoolValExpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgBreakStmt ) ;
     std::cout << " SgBreakStmt has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgBreakStmtStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgBreakStmt ( SgBreakStmtStorageArray[i] ) ; 
              }
          delete [] SgBreakStmtStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgC_PreprocessorDirectiveStatement ) ;
     std::cout << " SgC_PreprocessorDirectiveStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgC_PreprocessorDirectiveStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgC_PreprocessorDirectiveStatement ( SgC_PreprocessorDirectiveStatementStorageArray[i] ) ; 
              }
          delete [] SgC_PreprocessorDirectiveStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgCaseOptionStmt ) ;
     std::cout << " SgCaseOptionStmt has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgCaseOptionStmtStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgCaseOptionStmt ( SgCaseOptionStmtStorageArray[i] ) ; 
              }
          delete [] SgCaseOptionStmtStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgCastExp ) ;
     std::cout << " SgCastExp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgCastExpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgCastExp ( SgCastExpStorageArray[i] ) ; 
              }
          delete [] SgCastExpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgCatchOptionStmt ) ;
     std::cout << " SgCatchOptionStmt has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgCatchOptionStmtStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgCatchOptionStmt ( SgCatchOptionStmtStorageArray[i] ) ; 
              }
          delete [] SgCatchOptionStmtStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgCatchStatementSeq ) ;
     std::cout << " SgCatchStatementSeq has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgCatchStatementSeqStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgCatchStatementSeq ( SgCatchStatementSeqStorageArray[i] ) ; 
              }
          delete [] SgCatchStatementSeqStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgCharVal ) ;
     std::cout << " SgCharVal has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgCharValStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgCharVal ( SgCharValStorageArray[i] ) ; 
              }
          delete [] SgCharValStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgClassDecl_attr ) ;
     std::cout << " SgClassDecl_attr has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgClassDecl_attrStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgClassDecl_attr ( SgClassDecl_attrStorageArray[i] ) ; 
              }
          delete [] SgClassDecl_attrStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgClassDeclaration ) ;
     std::cout << " SgClassDeclaration has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgClassDeclarationStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgClassDeclaration ( SgClassDeclarationStorageArray[i] ) ; 
              }
          delete [] SgClassDeclarationStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgClassDefinition ) ;
     std::cout << " SgClassDefinition has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgClassDefinitionStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgClassDefinition ( SgClassDefinitionStorageArray[i] ) ; 
              }
          delete [] SgClassDefinitionStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgClassNameRefExp ) ;
     std::cout << " SgClassNameRefExp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgClassNameRefExpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgClassNameRefExp ( SgClassNameRefExpStorageArray[i] ) ; 
              }
          delete [] SgClassNameRefExpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgClassSymbol ) ;
     std::cout << " SgClassSymbol has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgClassSymbolStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgClassSymbol ( SgClassSymbolStorageArray[i] ) ; 
              }
          delete [] SgClassSymbolStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgClassType ) ;
     std::cout << " SgClassType has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgClassTypeStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgClassType ( SgClassTypeStorageArray[i] ) ; 
              }
          delete [] SgClassTypeStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgClinkageDeclarationStatement ) ;
     std::cout << " SgClinkageDeclarationStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgClinkageDeclarationStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgClinkageDeclarationStatement ( SgClinkageDeclarationStatementStorageArray[i] ) ; 
              }
          delete [] SgClinkageDeclarationStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgClinkageEndStatement ) ;
     std::cout << " SgClinkageEndStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgClinkageEndStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgClinkageEndStatement ( SgClinkageEndStatementStorageArray[i] ) ; 
              }
          delete [] SgClinkageEndStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgClinkageStartStatement ) ;
     std::cout << " SgClinkageStartStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgClinkageStartStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgClinkageStartStatement ( SgClinkageStartStatementStorageArray[i] ) ; 
              }
          delete [] SgClinkageStartStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgCloseStatement ) ;
     std::cout << " SgCloseStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgCloseStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgCloseStatement ( SgCloseStatementStorageArray[i] ) ; 
              }
          delete [] SgCloseStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgColonShapeExp ) ;
     std::cout << " SgColonShapeExp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgColonShapeExpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgColonShapeExp ( SgColonShapeExpStorageArray[i] ) ; 
              }
          delete [] SgColonShapeExpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgCommaOpExp ) ;
     std::cout << " SgCommaOpExp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgCommaOpExpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgCommaOpExp ( SgCommaOpExpStorageArray[i] ) ; 
              }
          delete [] SgCommaOpExpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgCommonBlock ) ;
     std::cout << " SgCommonBlock has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgCommonBlockStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgCommonBlock ( SgCommonBlockStorageArray[i] ) ; 
              }
          delete [] SgCommonBlockStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgCommonBlockObject ) ;
     std::cout << " SgCommonBlockObject has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgCommonBlockObjectStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgCommonBlockObject ( SgCommonBlockObjectStorageArray[i] ) ; 
              }
          delete [] SgCommonBlockObjectStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgCommonSymbol ) ;
     std::cout << " SgCommonSymbol has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgCommonSymbolStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgCommonSymbol ( SgCommonSymbolStorageArray[i] ) ; 
              }
          delete [] SgCommonSymbolStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgComplexVal ) ;
     std::cout << " SgComplexVal has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgComplexValStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgComplexVal ( SgComplexValStorageArray[i] ) ; 
              }
          delete [] SgComplexValStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgComprehension ) ;
     std::cout << " SgComprehension has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgComprehensionStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgComprehension ( SgComprehensionStorageArray[i] ) ; 
              }
          delete [] SgComprehensionStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgCompoundAssignOp ) ;
     std::cout << " SgCompoundAssignOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgCompoundAssignOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgCompoundAssignOp ( SgCompoundAssignOpStorageArray[i] ) ; 
              }
          delete [] SgCompoundAssignOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgCompoundInitializer ) ;
     std::cout << " SgCompoundInitializer has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgCompoundInitializerStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgCompoundInitializer ( SgCompoundInitializerStorageArray[i] ) ; 
              }
          delete [] SgCompoundInitializerStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgComputedGotoStatement ) ;
     std::cout << " SgComputedGotoStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgComputedGotoStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgComputedGotoStatement ( SgComputedGotoStatementStorageArray[i] ) ; 
              }
          delete [] SgComputedGotoStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgConcatenationOp ) ;
     std::cout << " SgConcatenationOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgConcatenationOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgConcatenationOp ( SgConcatenationOpStorageArray[i] ) ; 
              }
          delete [] SgConcatenationOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgConditionalExp ) ;
     std::cout << " SgConditionalExp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgConditionalExpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgConditionalExp ( SgConditionalExpStorageArray[i] ) ; 
              }
          delete [] SgConditionalExpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgConjugateOp ) ;
     std::cout << " SgConjugateOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgConjugateOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgConjugateOp ( SgConjugateOpStorageArray[i] ) ; 
              }
          delete [] SgConjugateOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgConstVolatileModifier ) ;
     std::cout << " SgConstVolatileModifier has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgConstVolatileModifier ( SgConstVolatileModifierStorageArray[i] ) ; 
              }
          delete [] SgConstVolatileModifierStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgConstructorInitializer ) ;
     std::cout << " SgConstructorInitializer has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgConstructorInitializerStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgConstructorInitializer ( SgConstructorInitializerStorageArray[i] ) ; 
              }
          delete [] SgConstructorInitializerStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgContainsStatement ) ;
     std::cout << " SgContainsStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgContainsStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgContainsStatement ( SgContainsStatementStorageArray[i] ) ; 
              }
          delete [] SgContainsStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgContinueStmt ) ;
     std::cout << " SgContinueStmt has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgContinueStmtStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgContinueStmt ( SgContinueStmtStorageArray[i] ) ; 
              }
          delete [] SgContinueStmtStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgCtorInitializerList ) ;
     std::cout << " SgCtorInitializerList has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgCtorInitializerListStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgCtorInitializerList ( SgCtorInitializerListStorageArray[i] ) ; 
              }
          delete [] SgCtorInitializerListStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgDataStatementGroup ) ;
     std::cout << " SgDataStatementGroup has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgDataStatementGroupStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgDataStatementGroup ( SgDataStatementGroupStorageArray[i] ) ; 
              }
          delete [] SgDataStatementGroupStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgDataStatementObject ) ;
     std::cout << " SgDataStatementObject has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgDataStatementObject ( SgDataStatementObjectStorageArray[i] ) ; 
              }
          delete [] SgDataStatementObjectStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgDataStatementValue ) ;
     std::cout << " SgDataStatementValue has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgDataStatementValue ( SgDataStatementValueStorageArray[i] ) ; 
              }
          delete [] SgDataStatementValueStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgDeadIfDirectiveStatement ) ;
     std::cout << " SgDeadIfDirectiveStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgDeadIfDirectiveStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgDeadIfDirectiveStatement ( SgDeadIfDirectiveStatementStorageArray[i] ) ; 
              }
          delete [] SgDeadIfDirectiveStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgDeallocateStatement ) ;
     std::cout << " SgDeallocateStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgDeallocateStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgDeallocateStatement ( SgDeallocateStatementStorageArray[i] ) ; 
              }
          delete [] SgDeallocateStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgDeclarationModifier ) ;
     std::cout << " SgDeclarationModifier has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgDeclarationModifier ( SgDeclarationModifierStorageArray[i] ) ; 
              }
          delete [] SgDeclarationModifierStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgDeclarationStatement ) ;
     std::cout << " SgDeclarationStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgDeclarationStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgDeclarationStatement ( SgDeclarationStatementStorageArray[i] ) ; 
              }
          delete [] SgDeclarationStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgDefaultOptionStmt ) ;
     std::cout << " SgDefaultOptionStmt has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgDefaultOptionStmtStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgDefaultOptionStmt ( SgDefaultOptionStmtStorageArray[i] ) ; 
              }
          delete [] SgDefaultOptionStmtStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgDefaultSymbol ) ;
     std::cout << " SgDefaultSymbol has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgDefaultSymbolStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgDefaultSymbol ( SgDefaultSymbolStorageArray[i] ) ; 
              }
          delete [] SgDefaultSymbolStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgDefineDirectiveStatement ) ;
     std::cout << " SgDefineDirectiveStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgDefineDirectiveStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgDefineDirectiveStatement ( SgDefineDirectiveStatementStorageArray[i] ) ; 
              }
          delete [] SgDefineDirectiveStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgDeleteExp ) ;
     std::cout << " SgDeleteExp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgDeleteExpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgDeleteExp ( SgDeleteExpStorageArray[i] ) ; 
              }
          delete [] SgDeleteExpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgDerivedTypeStatement ) ;
     std::cout << " SgDerivedTypeStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgDerivedTypeStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgDerivedTypeStatement ( SgDerivedTypeStatementStorageArray[i] ) ; 
              }
          delete [] SgDerivedTypeStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgDesignatedInitializer ) ;
     std::cout << " SgDesignatedInitializer has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgDesignatedInitializerStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgDesignatedInitializer ( SgDesignatedInitializerStorageArray[i] ) ; 
              }
          delete [] SgDesignatedInitializerStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgDictionaryComprehension ) ;
     std::cout << " SgDictionaryComprehension has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgDictionaryComprehensionStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgDictionaryComprehension ( SgDictionaryComprehensionStorageArray[i] ) ; 
              }
          delete [] SgDictionaryComprehensionStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgDictionaryExp ) ;
     std::cout << " SgDictionaryExp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgDictionaryExpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgDictionaryExp ( SgDictionaryExpStorageArray[i] ) ; 
              }
          delete [] SgDictionaryExpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgDimensionObject ) ;
     std::cout << " SgDimensionObject has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgDimensionObject ( SgDimensionObjectStorageArray[i] ) ; 
              }
          delete [] SgDimensionObjectStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgDirectedGraphEdge ) ;
     std::cout << " SgDirectedGraphEdge has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgDirectedGraphEdgeStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgDirectedGraphEdge ( SgDirectedGraphEdgeStorageArray[i] ) ; 
              }
          delete [] SgDirectedGraphEdgeStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgDirectory ) ;
     std::cout << " SgDirectory has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgDirectoryStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgDirectory ( SgDirectoryStorageArray[i] ) ; 
              }
          delete [] SgDirectoryStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgDirectoryList ) ;
     std::cout << " SgDirectoryList has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgDirectoryListStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgDirectoryList ( SgDirectoryListStorageArray[i] ) ; 
              }
          delete [] SgDirectoryListStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgDivAssignOp ) ;
     std::cout << " SgDivAssignOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgDivAssignOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgDivAssignOp ( SgDivAssignOpStorageArray[i] ) ; 
              }
          delete [] SgDivAssignOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgDivideOp ) ;
     std::cout << " SgDivideOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgDivideOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgDivideOp ( SgDivideOpStorageArray[i] ) ; 
              }
          delete [] SgDivideOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgDoWhileStmt ) ;
     std::cout << " SgDoWhileStmt has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgDoWhileStmtStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgDoWhileStmt ( SgDoWhileStmtStorageArray[i] ) ; 
              }
          delete [] SgDoWhileStmtStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgDotExp ) ;
     std::cout << " SgDotExp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgDotExpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgDotExp ( SgDotExpStorageArray[i] ) ; 
              }
          delete [] SgDotExpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgDotStarOp ) ;
     std::cout << " SgDotStarOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgDotStarOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgDotStarOp ( SgDotStarOpStorageArray[i] ) ; 
              }
          delete [] SgDotStarOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgDoubleVal ) ;
     std::cout << " SgDoubleVal has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgDoubleValStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgDoubleVal ( SgDoubleValStorageArray[i] ) ; 
              }
          delete [] SgDoubleValStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgElaboratedTypeModifier ) ;
     std::cout << " SgElaboratedTypeModifier has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgElaboratedTypeModifier ( SgElaboratedTypeModifierStorageArray[i] ) ; 
              }
          delete [] SgElaboratedTypeModifierStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgElseDirectiveStatement ) ;
     std::cout << " SgElseDirectiveStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgElseDirectiveStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgElseDirectiveStatement ( SgElseDirectiveStatementStorageArray[i] ) ; 
              }
          delete [] SgElseDirectiveStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgElseWhereStatement ) ;
     std::cout << " SgElseWhereStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgElseWhereStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgElseWhereStatement ( SgElseWhereStatementStorageArray[i] ) ; 
              }
          delete [] SgElseWhereStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgElseifDirectiveStatement ) ;
     std::cout << " SgElseifDirectiveStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgElseifDirectiveStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgElseifDirectiveStatement ( SgElseifDirectiveStatementStorageArray[i] ) ; 
              }
          delete [] SgElseifDirectiveStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgEmptyDirectiveStatement ) ;
     std::cout << " SgEmptyDirectiveStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgEmptyDirectiveStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgEmptyDirectiveStatement ( SgEmptyDirectiveStatementStorageArray[i] ) ; 
              }
          delete [] SgEmptyDirectiveStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgEndfileStatement ) ;
     std::cout << " SgEndfileStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgEndfileStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgEndfileStatement ( SgEndfileStatementStorageArray[i] ) ; 
              }
          delete [] SgEndfileStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgEndifDirectiveStatement ) ;
     std::cout << " SgEndifDirectiveStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgEndifDirectiveStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgEndifDirectiveStatement ( SgEndifDirectiveStatementStorageArray[i] ) ; 
              }
          delete [] SgEndifDirectiveStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgEntryStatement ) ;
     std::cout << " SgEntryStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgEntryStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgEntryStatement ( SgEntryStatementStorageArray[i] ) ; 
              }
          delete [] SgEntryStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgEnumDeclaration ) ;
     std::cout << " SgEnumDeclaration has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgEnumDeclarationStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgEnumDeclaration ( SgEnumDeclarationStorageArray[i] ) ; 
              }
          delete [] SgEnumDeclarationStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgEnumFieldSymbol ) ;
     std::cout << " SgEnumFieldSymbol has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgEnumFieldSymbolStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgEnumFieldSymbol ( SgEnumFieldSymbolStorageArray[i] ) ; 
              }
          delete [] SgEnumFieldSymbolStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgEnumSymbol ) ;
     std::cout << " SgEnumSymbol has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgEnumSymbolStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgEnumSymbol ( SgEnumSymbolStorageArray[i] ) ; 
              }
          delete [] SgEnumSymbolStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgEnumType ) ;
     std::cout << " SgEnumType has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgEnumTypeStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgEnumType ( SgEnumTypeStorageArray[i] ) ; 
              }
          delete [] SgEnumTypeStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgEnumVal ) ;
     std::cout << " SgEnumVal has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgEnumValStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgEnumVal ( SgEnumValStorageArray[i] ) ; 
              }
          delete [] SgEnumValStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgEqualityOp ) ;
     std::cout << " SgEqualityOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgEqualityOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgEqualityOp ( SgEqualityOpStorageArray[i] ) ; 
              }
          delete [] SgEqualityOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgEquivalenceStatement ) ;
     std::cout << " SgEquivalenceStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgEquivalenceStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgEquivalenceStatement ( SgEquivalenceStatementStorageArray[i] ) ; 
              }
          delete [] SgEquivalenceStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgErrorDirectiveStatement ) ;
     std::cout << " SgErrorDirectiveStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgErrorDirectiveStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgErrorDirectiveStatement ( SgErrorDirectiveStatementStorageArray[i] ) ; 
              }
          delete [] SgErrorDirectiveStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgExecStatement ) ;
     std::cout << " SgExecStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgExecStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgExecStatement ( SgExecStatementStorageArray[i] ) ; 
              }
          delete [] SgExecStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgExponentiationOp ) ;
     std::cout << " SgExponentiationOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgExponentiationOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgExponentiationOp ( SgExponentiationOpStorageArray[i] ) ; 
              }
          delete [] SgExponentiationOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgExponentiationAssignOp ) ;
     std::cout << " SgExponentiationAssignOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgExponentiationAssignOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgExponentiationAssignOp ( SgExponentiationAssignOpStorageArray[i] ) ; 
              }
          delete [] SgExponentiationAssignOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgExprListExp ) ;
     std::cout << " SgExprListExp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgExprListExpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgExprListExp ( SgExprListExpStorageArray[i] ) ; 
              }
          delete [] SgExprListExpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgExprStatement ) ;
     std::cout << " SgExprStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgExprStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgExprStatement ( SgExprStatementStorageArray[i] ) ; 
              }
          delete [] SgExprStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgExpression ) ;
     std::cout << " SgExpression has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgExpressionStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgExpression ( SgExpressionStorageArray[i] ) ; 
              }
          delete [] SgExpressionStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgExpressionRoot ) ;
     std::cout << " SgExpressionRoot has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgExpressionRootStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgExpressionRoot ( SgExpressionRootStorageArray[i] ) ; 
              }
          delete [] SgExpressionRootStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgFile ) ;
     std::cout << " SgFile has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgFileStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgFile ( SgFileStorageArray[i] ) ; 
              }
          delete [] SgFileStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgFileList ) ;
     std::cout << " SgFileList has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgFileListStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgFileList ( SgFileListStorageArray[i] ) ; 
              }
          delete [] SgFileListStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgFloatVal ) ;
     std::cout << " SgFloatVal has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgFloatValStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgFloatVal ( SgFloatValStorageArray[i] ) ; 
              }
          delete [] SgFloatValStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgFlushStatement ) ;
     std::cout << " SgFlushStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgFlushStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgFlushStatement ( SgFlushStatementStorageArray[i] ) ; 
              }
          delete [] SgFlushStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgForAllStatement ) ;
     std::cout << " SgForAllStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgForAllStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgForAllStatement ( SgForAllStatementStorageArray[i] ) ; 
              }
          delete [] SgForAllStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgForInitStatement ) ;
     std::cout << " SgForInitStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgForInitStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgForInitStatement ( SgForInitStatementStorageArray[i] ) ; 
              }
          delete [] SgForInitStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgForStatement ) ;
     std::cout << " SgForStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgForStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgForStatement ( SgForStatementStorageArray[i] ) ; 
              }
          delete [] SgForStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgFormatItem ) ;
     std::cout << " SgFormatItem has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgFormatItem ( SgFormatItemStorageArray[i] ) ; 
              }
          delete [] SgFormatItemStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgFormatItemList ) ;
     std::cout << " SgFormatItemList has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgFormatItemListStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgFormatItemList ( SgFormatItemListStorageArray[i] ) ; 
              }
          delete [] SgFormatItemListStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgFormatStatement ) ;
     std::cout << " SgFormatStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgFormatStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgFormatStatement ( SgFormatStatementStorageArray[i] ) ; 
              }
          delete [] SgFormatStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgFortranDo ) ;
     std::cout << " SgFortranDo has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgFortranDoStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgFortranDo ( SgFortranDoStorageArray[i] ) ; 
              }
          delete [] SgFortranDoStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgFortranIncludeLine ) ;
     std::cout << " SgFortranIncludeLine has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgFortranIncludeLineStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgFortranIncludeLine ( SgFortranIncludeLineStorageArray[i] ) ; 
              }
          delete [] SgFortranIncludeLineStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgFortranNonblockedDo ) ;
     std::cout << " SgFortranNonblockedDo has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgFortranNonblockedDoStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgFortranNonblockedDo ( SgFortranNonblockedDoStorageArray[i] ) ; 
              }
          delete [] SgFortranNonblockedDoStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgFuncDecl_attr ) ;
     std::cout << " SgFuncDecl_attr has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgFuncDecl_attrStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgFuncDecl_attr ( SgFuncDecl_attrStorageArray[i] ) ; 
              }
          delete [] SgFuncDecl_attrStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgFunctionCallExp ) ;
     std::cout << " SgFunctionCallExp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgFunctionCallExpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgFunctionCallExp ( SgFunctionCallExpStorageArray[i] ) ; 
              }
          delete [] SgFunctionCallExpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgFunctionDeclaration ) ;
     std::cout << " SgFunctionDeclaration has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgFunctionDeclarationStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgFunctionDeclaration ( SgFunctionDeclarationStorageArray[i] ) ; 
              }
          delete [] SgFunctionDeclarationStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgFunctionDefinition ) ;
     std::cout << " SgFunctionDefinition has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgFunctionDefinitionStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgFunctionDefinition ( SgFunctionDefinitionStorageArray[i] ) ; 
              }
          delete [] SgFunctionDefinitionStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgFunctionModifier ) ;
     std::cout << " SgFunctionModifier has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgFunctionModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgFunctionModifier ( SgFunctionModifierStorageArray[i] ) ; 
              }
          delete [] SgFunctionModifierStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgFunctionParameterList ) ;
     std::cout << " SgFunctionParameterList has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgFunctionParameterListStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgFunctionParameterList ( SgFunctionParameterListStorageArray[i] ) ; 
              }
          delete [] SgFunctionParameterListStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgFunctionParameterTypeList ) ;
     std::cout << " SgFunctionParameterTypeList has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgFunctionParameterTypeListStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgFunctionParameterTypeList ( SgFunctionParameterTypeListStorageArray[i] ) ; 
              }
          delete [] SgFunctionParameterTypeListStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgFunctionRefExp ) ;
     std::cout << " SgFunctionRefExp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgFunctionRefExpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgFunctionRefExp ( SgFunctionRefExpStorageArray[i] ) ; 
              }
          delete [] SgFunctionRefExpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgFunctionSymbol ) ;
     std::cout << " SgFunctionSymbol has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgFunctionSymbolStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgFunctionSymbol ( SgFunctionSymbolStorageArray[i] ) ; 
              }
          delete [] SgFunctionSymbolStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgFunctionType ) ;
     std::cout << " SgFunctionType has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgFunctionTypeStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgFunctionType ( SgFunctionTypeStorageArray[i] ) ; 
              }
          delete [] SgFunctionTypeStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgFunctionTypeSymbol ) ;
     std::cout << " SgFunctionTypeSymbol has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgFunctionTypeSymbolStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgFunctionTypeSymbol ( SgFunctionTypeSymbolStorageArray[i] ) ; 
              }
          delete [] SgFunctionTypeSymbolStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgFunctionTypeTable ) ;
     std::cout << " SgFunctionTypeTable has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgFunctionTypeTableStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgFunctionTypeTable ( SgFunctionTypeTableStorageArray[i] ) ; 
              }
          delete [] SgFunctionTypeTableStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgTypeTable ) ;
     std::cout << " SgTypeTable has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgTypeTable ( SgTypeTableStorageArray[i] ) ; 
              }
          delete [] SgTypeTableStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgGlobal ) ;
     std::cout << " SgGlobal has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgGlobalStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgGlobal ( SgGlobalStorageArray[i] ) ; 
              }
          delete [] SgGlobalStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgGotoStatement ) ;
     std::cout << " SgGotoStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgGotoStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgGotoStatement ( SgGotoStatementStorageArray[i] ) ; 
              }
          delete [] SgGotoStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgGraph ) ;
     std::cout << " SgGraph has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgGraphStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgGraph ( SgGraphStorageArray[i] ) ; 
              }
          delete [] SgGraphStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgGraphEdge ) ;
     std::cout << " SgGraphEdge has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgGraphEdgeStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgGraphEdge ( SgGraphEdgeStorageArray[i] ) ; 
              }
          delete [] SgGraphEdgeStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgGraphEdgeList ) ;
     std::cout << " SgGraphEdgeList has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgGraphEdgeList ( SgGraphEdgeListStorageArray[i] ) ; 
              }
          delete [] SgGraphEdgeListStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgGraphNode ) ;
     std::cout << " SgGraphNode has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgGraphNodeStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgGraphNode ( SgGraphNodeStorageArray[i] ) ; 
              }
          delete [] SgGraphNodeStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgGraphNodeList ) ;
     std::cout << " SgGraphNodeList has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgGraphNodeList ( SgGraphNodeListStorageArray[i] ) ; 
              }
          delete [] SgGraphNodeListStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgGreaterOrEqualOp ) ;
     std::cout << " SgGreaterOrEqualOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgGreaterOrEqualOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgGreaterOrEqualOp ( SgGreaterOrEqualOpStorageArray[i] ) ; 
              }
          delete [] SgGreaterOrEqualOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgGreaterThanOp ) ;
     std::cout << " SgGreaterThanOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgGreaterThanOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgGreaterThanOp ( SgGreaterThanOpStorageArray[i] ) ; 
              }
          delete [] SgGreaterThanOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgIOItemExpression ) ;
     std::cout << " SgIOItemExpression has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgIOItemExpressionStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgIOItemExpression ( SgIOItemExpressionStorageArray[i] ) ; 
              }
          delete [] SgIOItemExpressionStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgIOStatement ) ;
     std::cout << " SgIOStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgIOStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgIOStatement ( SgIOStatementStorageArray[i] ) ; 
              }
          delete [] SgIOStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgIdentDirectiveStatement ) ;
     std::cout << " SgIdentDirectiveStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgIdentDirectiveStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgIdentDirectiveStatement ( SgIdentDirectiveStatementStorageArray[i] ) ; 
              }
          delete [] SgIdentDirectiveStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgIfDirectiveStatement ) ;
     std::cout << " SgIfDirectiveStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgIfDirectiveStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgIfDirectiveStatement ( SgIfDirectiveStatementStorageArray[i] ) ; 
              }
          delete [] SgIfDirectiveStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgIfStmt ) ;
     std::cout << " SgIfStmt has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgIfStmtStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgIfStmt ( SgIfStmtStorageArray[i] ) ; 
              }
          delete [] SgIfStmtStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgIfdefDirectiveStatement ) ;
     std::cout << " SgIfdefDirectiveStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgIfdefDirectiveStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgIfdefDirectiveStatement ( SgIfdefDirectiveStatementStorageArray[i] ) ; 
              }
          delete [] SgIfdefDirectiveStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgIfndefDirectiveStatement ) ;
     std::cout << " SgIfndefDirectiveStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgIfndefDirectiveStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgIfndefDirectiveStatement ( SgIfndefDirectiveStatementStorageArray[i] ) ; 
              }
          delete [] SgIfndefDirectiveStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgImagPartOp ) ;
     std::cout << " SgImagPartOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgImagPartOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgImagPartOp ( SgImagPartOpStorageArray[i] ) ; 
              }
          delete [] SgImagPartOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgImplicitStatement ) ;
     std::cout << " SgImplicitStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgImplicitStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgImplicitStatement ( SgImplicitStatementStorageArray[i] ) ; 
              }
          delete [] SgImplicitStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgImpliedDo ) ;
     std::cout << " SgImpliedDo has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgImpliedDoStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgImpliedDo ( SgImpliedDoStorageArray[i] ) ; 
              }
          delete [] SgImpliedDoStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgImportStatement ) ;
     std::cout << " SgImportStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgImportStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgImportStatement ( SgImportStatementStorageArray[i] ) ; 
              }
          delete [] SgImportStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgIncidenceDirectedGraph ) ;
     std::cout << " SgIncidenceDirectedGraph has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgIncidenceDirectedGraphStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgIncidenceDirectedGraph ( SgIncidenceDirectedGraphStorageArray[i] ) ; 
              }
          delete [] SgIncidenceDirectedGraphStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgIncidenceUndirectedGraph ) ;
     std::cout << " SgIncidenceUndirectedGraph has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgIncidenceUndirectedGraphStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgIncidenceUndirectedGraph ( SgIncidenceUndirectedGraphStorageArray[i] ) ; 
              }
          delete [] SgIncidenceUndirectedGraphStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgIncludeDirectiveStatement ) ;
     std::cout << " SgIncludeDirectiveStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgIncludeDirectiveStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgIncludeDirectiveStatement ( SgIncludeDirectiveStatementStorageArray[i] ) ; 
              }
          delete [] SgIncludeDirectiveStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgIncludeNextDirectiveStatement ) ;
     std::cout << " SgIncludeNextDirectiveStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgIncludeNextDirectiveStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgIncludeNextDirectiveStatement ( SgIncludeNextDirectiveStatementStorageArray[i] ) ; 
              }
          delete [] SgIncludeNextDirectiveStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgInitializedName ) ;
     std::cout << " SgInitializedName has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgInitializedNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgInitializedName ( SgInitializedNameStorageArray[i] ) ; 
              }
          delete [] SgInitializedNameStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgInitializer ) ;
     std::cout << " SgInitializer has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgInitializerStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgInitializer ( SgInitializerStorageArray[i] ) ; 
              }
          delete [] SgInitializerStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgInquireStatement ) ;
     std::cout << " SgInquireStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgInquireStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgInquireStatement ( SgInquireStatementStorageArray[i] ) ; 
              }
          delete [] SgInquireStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgIntKeyedBidirectionalGraph ) ;
     std::cout << " SgIntKeyedBidirectionalGraph has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgIntKeyedBidirectionalGraphStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgIntKeyedBidirectionalGraph ( SgIntKeyedBidirectionalGraphStorageArray[i] ) ; 
              }
          delete [] SgIntKeyedBidirectionalGraphStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgIntVal ) ;
     std::cout << " SgIntVal has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgIntValStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgIntVal ( SgIntValStorageArray[i] ) ; 
              }
          delete [] SgIntValStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgIntegerDivideOp ) ;
     std::cout << " SgIntegerDivideOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgIntegerDivideOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgIntegerDivideOp ( SgIntegerDivideOpStorageArray[i] ) ; 
              }
          delete [] SgIntegerDivideOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgIntegerDivideAssignOp ) ;
     std::cout << " SgIntegerDivideAssignOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgIntegerDivideAssignOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgIntegerDivideAssignOp ( SgIntegerDivideAssignOpStorageArray[i] ) ; 
              }
          delete [] SgIntegerDivideAssignOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgInterfaceBody ) ;
     std::cout << " SgInterfaceBody has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgInterfaceBodyStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgInterfaceBody ( SgInterfaceBodyStorageArray[i] ) ; 
              }
          delete [] SgInterfaceBodyStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgHeaderFileBody ) ;
     std::cout << " SgHeaderFileBody has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgHeaderFileBodyStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgHeaderFileBody ( SgHeaderFileBodyStorageArray[i] ) ; 
              }
          delete [] SgHeaderFileBodyStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgInterfaceStatement ) ;
     std::cout << " SgInterfaceStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgInterfaceStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgInterfaceStatement ( SgInterfaceStatementStorageArray[i] ) ; 
              }
          delete [] SgInterfaceStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgInterfaceSymbol ) ;
     std::cout << " SgInterfaceSymbol has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgInterfaceSymbolStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgInterfaceSymbol ( SgInterfaceSymbolStorageArray[i] ) ; 
              }
          delete [] SgInterfaceSymbolStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgIntrinsicSymbol ) ;
     std::cout << " SgIntrinsicSymbol has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgIntrinsicSymbolStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgIntrinsicSymbol ( SgIntrinsicSymbolStorageArray[i] ) ; 
              }
          delete [] SgIntrinsicSymbolStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgIsOp ) ;
     std::cout << " SgIsOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgIsOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgIsOp ( SgIsOpStorageArray[i] ) ; 
              }
          delete [] SgIsOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgIsNotOp ) ;
     std::cout << " SgIsNotOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgIsNotOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgIsNotOp ( SgIsNotOpStorageArray[i] ) ; 
              }
          delete [] SgIsNotOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgIorAssignOp ) ;
     std::cout << " SgIorAssignOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgIorAssignOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgIorAssignOp ( SgIorAssignOpStorageArray[i] ) ; 
              }
          delete [] SgIorAssignOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgKeyDatumPair ) ;
     std::cout << " SgKeyDatumPair has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgKeyDatumPairStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgKeyDatumPair ( SgKeyDatumPairStorageArray[i] ) ; 
              }
          delete [] SgKeyDatumPairStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgCudaKernelExecConfig ) ;
     std::cout << " SgCudaKernelExecConfig has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgCudaKernelExecConfigStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgCudaKernelExecConfig ( SgCudaKernelExecConfigStorageArray[i] ) ; 
              }
          delete [] SgCudaKernelExecConfigStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgCudaKernelCallExp ) ;
     std::cout << " SgCudaKernelCallExp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgCudaKernelCallExpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgCudaKernelCallExp ( SgCudaKernelCallExpStorageArray[i] ) ; 
              }
          delete [] SgCudaKernelCallExpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgLabelRefExp ) ;
     std::cout << " SgLabelRefExp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgLabelRefExpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgLabelRefExp ( SgLabelRefExpStorageArray[i] ) ; 
              }
          delete [] SgLabelRefExpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgLabelStatement ) ;
     std::cout << " SgLabelStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgLabelStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgLabelStatement ( SgLabelStatementStorageArray[i] ) ; 
              }
          delete [] SgLabelStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgJavaLabelStatement ) ;
     std::cout << " SgJavaLabelStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgJavaLabelStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgJavaLabelStatement ( SgJavaLabelStatementStorageArray[i] ) ; 
              }
          delete [] SgJavaLabelStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgLabelSymbol ) ;
     std::cout << " SgLabelSymbol has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgLabelSymbolStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgLabelSymbol ( SgLabelSymbolStorageArray[i] ) ; 
              }
          delete [] SgLabelSymbolStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgJavaLabelSymbol ) ;
     std::cout << " SgJavaLabelSymbol has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgJavaLabelSymbolStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgJavaLabelSymbol ( SgJavaLabelSymbolStorageArray[i] ) ; 
              }
          delete [] SgJavaLabelSymbolStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgLambdaRefExp ) ;
     std::cout << " SgLambdaRefExp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgLambdaRefExpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgLambdaRefExp ( SgLambdaRefExpStorageArray[i] ) ; 
              }
          delete [] SgLambdaRefExpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgLessOrEqualOp ) ;
     std::cout << " SgLessOrEqualOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgLessOrEqualOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgLessOrEqualOp ( SgLessOrEqualOpStorageArray[i] ) ; 
              }
          delete [] SgLessOrEqualOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgLessThanOp ) ;
     std::cout << " SgLessThanOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgLessThanOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgLessThanOp ( SgLessThanOpStorageArray[i] ) ; 
              }
          delete [] SgLessThanOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgLineDirectiveStatement ) ;
     std::cout << " SgLineDirectiveStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgLineDirectiveStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgLineDirectiveStatement ( SgLineDirectiveStatementStorageArray[i] ) ; 
              }
          delete [] SgLineDirectiveStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgLinemarkerDirectiveStatement ) ;
     std::cout << " SgLinemarkerDirectiveStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgLinemarkerDirectiveStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgLinemarkerDirectiveStatement ( SgLinemarkerDirectiveStatementStorageArray[i] ) ; 
              }
          delete [] SgLinemarkerDirectiveStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgLinkageModifier ) ;
     std::cout << " SgLinkageModifier has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgLinkageModifier ( SgLinkageModifierStorageArray[i] ) ; 
              }
          delete [] SgLinkageModifierStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgListComprehension ) ;
     std::cout << " SgListComprehension has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgListComprehensionStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgListComprehension ( SgListComprehensionStorageArray[i] ) ; 
              }
          delete [] SgListComprehensionStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgListExp ) ;
     std::cout << " SgListExp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgListExpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgListExp ( SgListExpStorageArray[i] ) ; 
              }
          delete [] SgListExpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgLocatedNode ) ;
     std::cout << " SgLocatedNode has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgLocatedNodeStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgLocatedNode ( SgLocatedNodeStorageArray[i] ) ; 
              }
          delete [] SgLocatedNodeStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgLocatedNodeSupport ) ;
     std::cout << " SgLocatedNodeSupport has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgLocatedNodeSupportStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgLocatedNodeSupport ( SgLocatedNodeSupportStorageArray[i] ) ; 
              }
          delete [] SgLocatedNodeSupportStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgLongDoubleVal ) ;
     std::cout << " SgLongDoubleVal has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgLongDoubleValStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgLongDoubleVal ( SgLongDoubleValStorageArray[i] ) ; 
              }
          delete [] SgLongDoubleValStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgLongIntVal ) ;
     std::cout << " SgLongIntVal has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgLongIntValStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgLongIntVal ( SgLongIntValStorageArray[i] ) ; 
              }
          delete [] SgLongIntValStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgLongLongIntVal ) ;
     std::cout << " SgLongLongIntVal has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgLongLongIntValStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgLongLongIntVal ( SgLongLongIntValStorageArray[i] ) ; 
              }
          delete [] SgLongLongIntValStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgLshiftAssignOp ) ;
     std::cout << " SgLshiftAssignOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgLshiftAssignOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgLshiftAssignOp ( SgLshiftAssignOpStorageArray[i] ) ; 
              }
          delete [] SgLshiftAssignOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgLshiftOp ) ;
     std::cout << " SgLshiftOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgLshiftOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgLshiftOp ( SgLshiftOpStorageArray[i] ) ; 
              }
          delete [] SgLshiftOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgMemberFunctionDeclaration ) ;
     std::cout << " SgMemberFunctionDeclaration has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgMemberFunctionDeclarationStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgMemberFunctionDeclaration ( SgMemberFunctionDeclarationStorageArray[i] ) ; 
              }
          delete [] SgMemberFunctionDeclarationStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgMemberFunctionRefExp ) ;
     std::cout << " SgMemberFunctionRefExp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgMemberFunctionRefExpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgMemberFunctionRefExp ( SgMemberFunctionRefExpStorageArray[i] ) ; 
              }
          delete [] SgMemberFunctionRefExpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgMemberFunctionSymbol ) ;
     std::cout << " SgMemberFunctionSymbol has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgMemberFunctionSymbolStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgMemberFunctionSymbol ( SgMemberFunctionSymbolStorageArray[i] ) ; 
              }
          delete [] SgMemberFunctionSymbolStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgMemberFunctionType ) ;
     std::cout << " SgMemberFunctionType has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgMemberFunctionTypeStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgMemberFunctionType ( SgMemberFunctionTypeStorageArray[i] ) ; 
              }
          delete [] SgMemberFunctionTypeStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgMembershipOp ) ;
     std::cout << " SgMembershipOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgMembershipOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgMembershipOp ( SgMembershipOpStorageArray[i] ) ; 
              }
          delete [] SgMembershipOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgMinusAssignOp ) ;
     std::cout << " SgMinusAssignOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgMinusAssignOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgMinusAssignOp ( SgMinusAssignOpStorageArray[i] ) ; 
              }
          delete [] SgMinusAssignOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgMinusMinusOp ) ;
     std::cout << " SgMinusMinusOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgMinusMinusOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgMinusMinusOp ( SgMinusMinusOpStorageArray[i] ) ; 
              }
          delete [] SgMinusMinusOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgMinusOp ) ;
     std::cout << " SgMinusOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgMinusOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgMinusOp ( SgMinusOpStorageArray[i] ) ; 
              }
          delete [] SgMinusOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgModAssignOp ) ;
     std::cout << " SgModAssignOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgModAssignOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgModAssignOp ( SgModAssignOpStorageArray[i] ) ; 
              }
          delete [] SgModAssignOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgModOp ) ;
     std::cout << " SgModOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgModOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgModOp ( SgModOpStorageArray[i] ) ; 
              }
          delete [] SgModOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgModifier ) ;
     std::cout << " SgModifier has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgModifier ( SgModifierStorageArray[i] ) ; 
              }
          delete [] SgModifierStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgModifierNodes ) ;
     std::cout << " SgModifierNodes has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgModifierNodesStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgModifierNodes ( SgModifierNodesStorageArray[i] ) ; 
              }
          delete [] SgModifierNodesStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgModifierType ) ;
     std::cout << " SgModifierType has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgModifierTypeStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgModifierType ( SgModifierTypeStorageArray[i] ) ; 
              }
          delete [] SgModifierTypeStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgModuleStatement ) ;
     std::cout << " SgModuleStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgModuleStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgModuleStatement ( SgModuleStatementStorageArray[i] ) ; 
              }
          delete [] SgModuleStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgModuleSymbol ) ;
     std::cout << " SgModuleSymbol has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgModuleSymbolStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgModuleSymbol ( SgModuleSymbolStorageArray[i] ) ; 
              }
          delete [] SgModuleSymbolStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgMultAssignOp ) ;
     std::cout << " SgMultAssignOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgMultAssignOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgMultAssignOp ( SgMultAssignOpStorageArray[i] ) ; 
              }
          delete [] SgMultAssignOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgMultiplyOp ) ;
     std::cout << " SgMultiplyOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgMultiplyOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgMultiplyOp ( SgMultiplyOpStorageArray[i] ) ; 
              }
          delete [] SgMultiplyOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgName ) ;
     std::cout << " SgName has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgName ( SgNameStorageArray[i] ) ; 
              }
          delete [] SgNameStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgNameGroup ) ;
     std::cout << " SgNameGroup has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgNameGroupStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgNameGroup ( SgNameGroupStorageArray[i] ) ; 
              }
          delete [] SgNameGroupStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgNamedType ) ;
     std::cout << " SgNamedType has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgNamedTypeStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgNamedType ( SgNamedTypeStorageArray[i] ) ; 
              }
          delete [] SgNamedTypeStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgNamelistStatement ) ;
     std::cout << " SgNamelistStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgNamelistStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgNamelistStatement ( SgNamelistStatementStorageArray[i] ) ; 
              }
          delete [] SgNamelistStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgNamespaceAliasDeclarationStatement ) ;
     std::cout << " SgNamespaceAliasDeclarationStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgNamespaceAliasDeclarationStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgNamespaceAliasDeclarationStatement ( SgNamespaceAliasDeclarationStatementStorageArray[i] ) ; 
              }
          delete [] SgNamespaceAliasDeclarationStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgNamespaceDeclarationStatement ) ;
     std::cout << " SgNamespaceDeclarationStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgNamespaceDeclarationStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgNamespaceDeclarationStatement ( SgNamespaceDeclarationStatementStorageArray[i] ) ; 
              }
          delete [] SgNamespaceDeclarationStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgNamespaceDefinitionStatement ) ;
     std::cout << " SgNamespaceDefinitionStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgNamespaceDefinitionStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgNamespaceDefinitionStatement ( SgNamespaceDefinitionStatementStorageArray[i] ) ; 
              }
          delete [] SgNamespaceDefinitionStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgNamespaceSymbol ) ;
     std::cout << " SgNamespaceSymbol has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgNamespaceSymbolStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgNamespaceSymbol ( SgNamespaceSymbolStorageArray[i] ) ; 
              }
          delete [] SgNamespaceSymbolStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgNaryOp ) ;
     std::cout << " SgNaryOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgNaryOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgNaryOp ( SgNaryOpStorageArray[i] ) ; 
              }
          delete [] SgNaryOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgNaryBooleanOp ) ;
     std::cout << " SgNaryBooleanOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgNaryBooleanOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgNaryBooleanOp ( SgNaryBooleanOpStorageArray[i] ) ; 
              }
          delete [] SgNaryBooleanOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgNaryComparisonOp ) ;
     std::cout << " SgNaryComparisonOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgNaryComparisonOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgNaryComparisonOp ( SgNaryComparisonOpStorageArray[i] ) ; 
              }
          delete [] SgNaryComparisonOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgNewExp ) ;
     std::cout << " SgNewExp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgNewExpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgNewExp ( SgNewExpStorageArray[i] ) ; 
              }
          delete [] SgNewExpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgNode ) ;
     std::cout << " SgNode has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgNode ( SgNodeStorageArray[i] ) ; 
              }
          delete [] SgNodeStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgNotEqualOp ) ;
     std::cout << " SgNotEqualOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgNotEqualOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgNotEqualOp ( SgNotEqualOpStorageArray[i] ) ; 
              }
          delete [] SgNotEqualOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgNotOp ) ;
     std::cout << " SgNotOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgNotOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgNotOp ( SgNotOpStorageArray[i] ) ; 
              }
          delete [] SgNotOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgNonMembershipOp ) ;
     std::cout << " SgNonMembershipOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgNonMembershipOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgNonMembershipOp ( SgNonMembershipOpStorageArray[i] ) ; 
              }
          delete [] SgNonMembershipOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgNullExpression ) ;
     std::cout << " SgNullExpression has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgNullExpressionStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgNullExpression ( SgNullExpressionStorageArray[i] ) ; 
              }
          delete [] SgNullExpressionStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgNullStatement ) ;
     std::cout << " SgNullStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgNullStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgNullStatement ( SgNullStatementStorageArray[i] ) ; 
              }
          delete [] SgNullStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgNullifyStatement ) ;
     std::cout << " SgNullifyStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgNullifyStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgNullifyStatement ( SgNullifyStatementStorageArray[i] ) ; 
              }
          delete [] SgNullifyStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgOmpAtomicStatement ) ;
     std::cout << " SgOmpAtomicStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgOmpAtomicStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgOmpAtomicStatement ( SgOmpAtomicStatementStorageArray[i] ) ; 
              }
          delete [] SgOmpAtomicStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgOmpBarrierStatement ) ;
     std::cout << " SgOmpBarrierStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgOmpBarrierStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgOmpBarrierStatement ( SgOmpBarrierStatementStorageArray[i] ) ; 
              }
          delete [] SgOmpBarrierStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgOmpCriticalStatement ) ;
     std::cout << " SgOmpCriticalStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgOmpCriticalStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgOmpCriticalStatement ( SgOmpCriticalStatementStorageArray[i] ) ; 
              }
          delete [] SgOmpCriticalStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgOmpClauseBodyStatement ) ;
     std::cout << " SgOmpClauseBodyStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgOmpClauseBodyStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgOmpClauseBodyStatement ( SgOmpClauseBodyStatementStorageArray[i] ) ; 
              }
          delete [] SgOmpClauseBodyStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgOmpBodyStatement ) ;
     std::cout << " SgOmpBodyStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgOmpBodyStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgOmpBodyStatement ( SgOmpBodyStatementStorageArray[i] ) ; 
              }
          delete [] SgOmpBodyStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgOmpDoStatement ) ;
     std::cout << " SgOmpDoStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgOmpDoStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgOmpDoStatement ( SgOmpDoStatementStorageArray[i] ) ; 
              }
          delete [] SgOmpDoStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgOmpFlushStatement ) ;
     std::cout << " SgOmpFlushStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgOmpFlushStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgOmpFlushStatement ( SgOmpFlushStatementStorageArray[i] ) ; 
              }
          delete [] SgOmpFlushStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgOmpForStatement ) ;
     std::cout << " SgOmpForStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgOmpForStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgOmpForStatement ( SgOmpForStatementStorageArray[i] ) ; 
              }
          delete [] SgOmpForStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgOmpMasterStatement ) ;
     std::cout << " SgOmpMasterStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgOmpMasterStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgOmpMasterStatement ( SgOmpMasterStatementStorageArray[i] ) ; 
              }
          delete [] SgOmpMasterStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgOmpOrderedStatement ) ;
     std::cout << " SgOmpOrderedStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgOmpOrderedStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgOmpOrderedStatement ( SgOmpOrderedStatementStorageArray[i] ) ; 
              }
          delete [] SgOmpOrderedStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgOmpParallelStatement ) ;
     std::cout << " SgOmpParallelStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgOmpParallelStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgOmpParallelStatement ( SgOmpParallelStatementStorageArray[i] ) ; 
              }
          delete [] SgOmpParallelStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgOmpSectionStatement ) ;
     std::cout << " SgOmpSectionStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgOmpSectionStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgOmpSectionStatement ( SgOmpSectionStatementStorageArray[i] ) ; 
              }
          delete [] SgOmpSectionStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgOmpSectionsStatement ) ;
     std::cout << " SgOmpSectionsStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgOmpSectionsStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgOmpSectionsStatement ( SgOmpSectionsStatementStorageArray[i] ) ; 
              }
          delete [] SgOmpSectionsStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgOmpSingleStatement ) ;
     std::cout << " SgOmpSingleStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgOmpSingleStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgOmpSingleStatement ( SgOmpSingleStatementStorageArray[i] ) ; 
              }
          delete [] SgOmpSingleStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgOmpTaskStatement ) ;
     std::cout << " SgOmpTaskStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgOmpTaskStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgOmpTaskStatement ( SgOmpTaskStatementStorageArray[i] ) ; 
              }
          delete [] SgOmpTaskStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgOmpTaskwaitStatement ) ;
     std::cout << " SgOmpTaskwaitStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgOmpTaskwaitStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgOmpTaskwaitStatement ( SgOmpTaskwaitStatementStorageArray[i] ) ; 
              }
          delete [] SgOmpTaskwaitStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgOmpThreadprivateStatement ) ;
     std::cout << " SgOmpThreadprivateStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgOmpThreadprivateStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgOmpThreadprivateStatement ( SgOmpThreadprivateStatementStorageArray[i] ) ; 
              }
          delete [] SgOmpThreadprivateStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgOmpWorkshareStatement ) ;
     std::cout << " SgOmpWorkshareStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgOmpWorkshareStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgOmpWorkshareStatement ( SgOmpWorkshareStatementStorageArray[i] ) ; 
              }
          delete [] SgOmpWorkshareStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgOmpClause ) ;
     std::cout << " SgOmpClause has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgOmpClauseStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgOmpClause ( SgOmpClauseStorageArray[i] ) ; 
              }
          delete [] SgOmpClauseStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgOmpCollapseClause ) ;
     std::cout << " SgOmpCollapseClause has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgOmpCollapseClauseStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgOmpCollapseClause ( SgOmpCollapseClauseStorageArray[i] ) ; 
              }
          delete [] SgOmpCollapseClauseStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgOmpCopyinClause ) ;
     std::cout << " SgOmpCopyinClause has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgOmpCopyinClauseStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgOmpCopyinClause ( SgOmpCopyinClauseStorageArray[i] ) ; 
              }
          delete [] SgOmpCopyinClauseStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgOmpCopyprivateClause ) ;
     std::cout << " SgOmpCopyprivateClause has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgOmpCopyprivateClauseStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgOmpCopyprivateClause ( SgOmpCopyprivateClauseStorageArray[i] ) ; 
              }
          delete [] SgOmpCopyprivateClauseStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgOmpDefaultClause ) ;
     std::cout << " SgOmpDefaultClause has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgOmpDefaultClauseStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgOmpDefaultClause ( SgOmpDefaultClauseStorageArray[i] ) ; 
              }
          delete [] SgOmpDefaultClauseStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgOmpExpressionClause ) ;
     std::cout << " SgOmpExpressionClause has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgOmpExpressionClauseStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgOmpExpressionClause ( SgOmpExpressionClauseStorageArray[i] ) ; 
              }
          delete [] SgOmpExpressionClauseStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgOmpFirstprivateClause ) ;
     std::cout << " SgOmpFirstprivateClause has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgOmpFirstprivateClauseStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgOmpFirstprivateClause ( SgOmpFirstprivateClauseStorageArray[i] ) ; 
              }
          delete [] SgOmpFirstprivateClauseStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgOmpIfClause ) ;
     std::cout << " SgOmpIfClause has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgOmpIfClauseStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgOmpIfClause ( SgOmpIfClauseStorageArray[i] ) ; 
              }
          delete [] SgOmpIfClauseStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgOmpLastprivateClause ) ;
     std::cout << " SgOmpLastprivateClause has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgOmpLastprivateClauseStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgOmpLastprivateClause ( SgOmpLastprivateClauseStorageArray[i] ) ; 
              }
          delete [] SgOmpLastprivateClauseStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgOmpNowaitClause ) ;
     std::cout << " SgOmpNowaitClause has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgOmpNowaitClauseStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgOmpNowaitClause ( SgOmpNowaitClauseStorageArray[i] ) ; 
              }
          delete [] SgOmpNowaitClauseStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgOmpNumThreadsClause ) ;
     std::cout << " SgOmpNumThreadsClause has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgOmpNumThreadsClauseStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgOmpNumThreadsClause ( SgOmpNumThreadsClauseStorageArray[i] ) ; 
              }
          delete [] SgOmpNumThreadsClauseStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgOmpOrderedClause ) ;
     std::cout << " SgOmpOrderedClause has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgOmpOrderedClauseStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgOmpOrderedClause ( SgOmpOrderedClauseStorageArray[i] ) ; 
              }
          delete [] SgOmpOrderedClauseStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgOmpPrivateClause ) ;
     std::cout << " SgOmpPrivateClause has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgOmpPrivateClauseStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgOmpPrivateClause ( SgOmpPrivateClauseStorageArray[i] ) ; 
              }
          delete [] SgOmpPrivateClauseStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgOmpReductionClause ) ;
     std::cout << " SgOmpReductionClause has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgOmpReductionClauseStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgOmpReductionClause ( SgOmpReductionClauseStorageArray[i] ) ; 
              }
          delete [] SgOmpReductionClauseStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgOmpScheduleClause ) ;
     std::cout << " SgOmpScheduleClause has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgOmpScheduleClauseStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgOmpScheduleClause ( SgOmpScheduleClauseStorageArray[i] ) ; 
              }
          delete [] SgOmpScheduleClauseStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgOmpSharedClause ) ;
     std::cout << " SgOmpSharedClause has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgOmpSharedClauseStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgOmpSharedClause ( SgOmpSharedClauseStorageArray[i] ) ; 
              }
          delete [] SgOmpSharedClauseStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgOmpUntiedClause ) ;
     std::cout << " SgOmpUntiedClause has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgOmpUntiedClauseStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgOmpUntiedClause ( SgOmpUntiedClauseStorageArray[i] ) ; 
              }
          delete [] SgOmpUntiedClauseStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgOmpVariablesClause ) ;
     std::cout << " SgOmpVariablesClause has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgOmpVariablesClauseStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgOmpVariablesClause ( SgOmpVariablesClauseStorageArray[i] ) ; 
              }
          delete [] SgOmpVariablesClauseStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgOpenclAccessModeModifier ) ;
     std::cout << " SgOpenclAccessModeModifier has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgOpenclAccessModeModifier ( SgOpenclAccessModeModifierStorageArray[i] ) ; 
              }
          delete [] SgOpenclAccessModeModifierStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgOpenStatement ) ;
     std::cout << " SgOpenStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgOpenStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgOpenStatement ( SgOpenStatementStorageArray[i] ) ; 
              }
          delete [] SgOpenStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgOptions ) ;
     std::cout << " SgOptions has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgOptions ( SgOptionsStorageArray[i] ) ; 
              }
          delete [] SgOptionsStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgOrOp ) ;
     std::cout << " SgOrOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgOrOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgOrOp ( SgOrOpStorageArray[i] ) ; 
              }
          delete [] SgOrOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgParameterStatement ) ;
     std::cout << " SgParameterStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgParameterStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgParameterStatement ( SgParameterStatementStorageArray[i] ) ; 
              }
          delete [] SgParameterStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgPartialFunctionModifierType ) ;
     std::cout << " SgPartialFunctionModifierType has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgPartialFunctionModifierTypeStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgPartialFunctionModifierType ( SgPartialFunctionModifierTypeStorageArray[i] ) ; 
              }
          delete [] SgPartialFunctionModifierTypeStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgPartialFunctionType ) ;
     std::cout << " SgPartialFunctionType has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgPartialFunctionTypeStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgPartialFunctionType ( SgPartialFunctionTypeStorageArray[i] ) ; 
              }
          delete [] SgPartialFunctionTypeStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgPassStatement ) ;
     std::cout << " SgPassStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgPassStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgPassStatement ( SgPassStatementStorageArray[i] ) ; 
              }
          delete [] SgPassStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgPlusAssignOp ) ;
     std::cout << " SgPlusAssignOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgPlusAssignOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgPlusAssignOp ( SgPlusAssignOpStorageArray[i] ) ; 
              }
          delete [] SgPlusAssignOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgPlusPlusOp ) ;
     std::cout << " SgPlusPlusOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgPlusPlusOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgPlusPlusOp ( SgPlusPlusOpStorageArray[i] ) ; 
              }
          delete [] SgPlusPlusOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgPntrArrRefExp ) ;
     std::cout << " SgPntrArrRefExp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgPntrArrRefExpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgPntrArrRefExp ( SgPntrArrRefExpStorageArray[i] ) ; 
              }
          delete [] SgPntrArrRefExpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgPointerAssignOp ) ;
     std::cout << " SgPointerAssignOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgPointerAssignOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgPointerAssignOp ( SgPointerAssignOpStorageArray[i] ) ; 
              }
          delete [] SgPointerAssignOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgPointerDerefExp ) ;
     std::cout << " SgPointerDerefExp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgPointerDerefExpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgPointerDerefExp ( SgPointerDerefExpStorageArray[i] ) ; 
              }
          delete [] SgPointerDerefExpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgPointerMemberType ) ;
     std::cout << " SgPointerMemberType has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgPointerMemberTypeStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgPointerMemberType ( SgPointerMemberTypeStorageArray[i] ) ; 
              }
          delete [] SgPointerMemberTypeStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgPointerType ) ;
     std::cout << " SgPointerType has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgPointerTypeStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgPointerType ( SgPointerTypeStorageArray[i] ) ; 
              }
          delete [] SgPointerTypeStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgPragma ) ;
     std::cout << " SgPragma has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgPragmaStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgPragma ( SgPragmaStorageArray[i] ) ; 
              }
          delete [] SgPragmaStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgPragmaDeclaration ) ;
     std::cout << " SgPragmaDeclaration has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgPragmaDeclarationStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgPragmaDeclaration ( SgPragmaDeclarationStorageArray[i] ) ; 
              }
          delete [] SgPragmaDeclarationStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgPrintStatement ) ;
     std::cout << " SgPrintStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgPrintStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgPrintStatement ( SgPrintStatementStorageArray[i] ) ; 
              }
          delete [] SgPrintStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgProcedureHeaderStatement ) ;
     std::cout << " SgProcedureHeaderStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgProcedureHeaderStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgProcedureHeaderStatement ( SgProcedureHeaderStatementStorageArray[i] ) ; 
              }
          delete [] SgProcedureHeaderStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgProgramHeaderStatement ) ;
     std::cout << " SgProgramHeaderStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgProgramHeaderStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgProgramHeaderStatement ( SgProgramHeaderStatementStorageArray[i] ) ; 
              }
          delete [] SgProgramHeaderStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgProject ) ;
     std::cout << " SgProject has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgProjectStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgProject ( SgProjectStorageArray[i] ) ; 
              }
          delete [] SgProjectStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgPseudoDestructorRefExp ) ;
     std::cout << " SgPseudoDestructorRefExp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgPseudoDestructorRefExpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgPseudoDestructorRefExp ( SgPseudoDestructorRefExpStorageArray[i] ) ; 
              }
          delete [] SgPseudoDestructorRefExpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgPythonGlobalStmt ) ;
     std::cout << " SgPythonGlobalStmt has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgPythonGlobalStmtStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgPythonGlobalStmt ( SgPythonGlobalStmtStorageArray[i] ) ; 
              }
          delete [] SgPythonGlobalStmtStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgPythonPrintStmt ) ;
     std::cout << " SgPythonPrintStmt has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgPythonPrintStmtStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgPythonPrintStmt ( SgPythonPrintStmtStorageArray[i] ) ; 
              }
          delete [] SgPythonPrintStmtStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgQualifiedName ) ;
     std::cout << " SgQualifiedName has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgQualifiedName ( SgQualifiedNameStorageArray[i] ) ; 
              }
          delete [] SgQualifiedNameStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgQualifiedNameType ) ;
     std::cout << " SgQualifiedNameType has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgQualifiedNameTypeStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgQualifiedNameType ( SgQualifiedNameTypeStorageArray[i] ) ; 
              }
          delete [] SgQualifiedNameTypeStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgReadStatement ) ;
     std::cout << " SgReadStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgReadStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgReadStatement ( SgReadStatementStorageArray[i] ) ; 
              }
          delete [] SgReadStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgRealPartOp ) ;
     std::cout << " SgRealPartOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgRealPartOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgRealPartOp ( SgRealPartOpStorageArray[i] ) ; 
              }
          delete [] SgRealPartOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgRefExp ) ;
     std::cout << " SgRefExp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgRefExpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgRefExp ( SgRefExpStorageArray[i] ) ; 
              }
          delete [] SgRefExpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgReferenceType ) ;
     std::cout << " SgReferenceType has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgReferenceTypeStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgReferenceType ( SgReferenceTypeStorageArray[i] ) ; 
              }
          delete [] SgReferenceTypeStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgRenamePair ) ;
     std::cout << " SgRenamePair has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgRenamePairStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgRenamePair ( SgRenamePairStorageArray[i] ) ; 
              }
          delete [] SgRenamePairStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgRenameSymbol ) ;
     std::cout << " SgRenameSymbol has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgRenameSymbolStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgRenameSymbol ( SgRenameSymbolStorageArray[i] ) ; 
              }
          delete [] SgRenameSymbolStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgReturnStmt ) ;
     std::cout << " SgReturnStmt has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgReturnStmtStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgReturnStmt ( SgReturnStmtStorageArray[i] ) ; 
              }
          delete [] SgReturnStmtStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgRewindStatement ) ;
     std::cout << " SgRewindStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgRewindStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgRewindStatement ( SgRewindStatementStorageArray[i] ) ; 
              }
          delete [] SgRewindStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgRshiftAssignOp ) ;
     std::cout << " SgRshiftAssignOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgRshiftAssignOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgRshiftAssignOp ( SgRshiftAssignOpStorageArray[i] ) ; 
              }
          delete [] SgRshiftAssignOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgRshiftOp ) ;
     std::cout << " SgRshiftOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgRshiftOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgRshiftOp ( SgRshiftOpStorageArray[i] ) ; 
              }
          delete [] SgRshiftOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgJavaUnsignedRshiftAssignOp ) ;
     std::cout << " SgJavaUnsignedRshiftAssignOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgJavaUnsignedRshiftAssignOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgJavaUnsignedRshiftAssignOp ( SgJavaUnsignedRshiftAssignOpStorageArray[i] ) ; 
              }
          delete [] SgJavaUnsignedRshiftAssignOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgJavaUnsignedRshiftOp ) ;
     std::cout << " SgJavaUnsignedRshiftOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgJavaUnsignedRshiftOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgJavaUnsignedRshiftOp ( SgJavaUnsignedRshiftOpStorageArray[i] ) ; 
              }
          delete [] SgJavaUnsignedRshiftOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgScopeOp ) ;
     std::cout << " SgScopeOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgScopeOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgScopeOp ( SgScopeOpStorageArray[i] ) ; 
              }
          delete [] SgScopeOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgScopeStatement ) ;
     std::cout << " SgScopeStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgScopeStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgScopeStatement ( SgScopeStatementStorageArray[i] ) ; 
              }
          delete [] SgScopeStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgSequenceStatement ) ;
     std::cout << " SgSequenceStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgSequenceStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgSequenceStatement ( SgSequenceStatementStorageArray[i] ) ; 
              }
          delete [] SgSequenceStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgSetComprehension ) ;
     std::cout << " SgSetComprehension has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgSetComprehensionStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgSetComprehension ( SgSetComprehensionStorageArray[i] ) ; 
              }
          delete [] SgSetComprehensionStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgShortVal ) ;
     std::cout << " SgShortVal has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgShortValStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgShortVal ( SgShortValStorageArray[i] ) ; 
              }
          delete [] SgShortValStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgSizeOfOp ) ;
     std::cout << " SgSizeOfOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgSizeOfOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgSizeOfOp ( SgSizeOfOpStorageArray[i] ) ; 
              }
          delete [] SgSizeOfOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgJavaInstanceOfOp ) ;
     std::cout << " SgJavaInstanceOfOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgJavaInstanceOfOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgJavaInstanceOfOp ( SgJavaInstanceOfOpStorageArray[i] ) ; 
              }
          delete [] SgJavaInstanceOfOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgSourceFile ) ;
     std::cout << " SgSourceFile has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgSourceFileStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgSourceFile ( SgSourceFileStorageArray[i] ) ; 
              }
          delete [] SgSourceFileStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgSpawnStmt ) ;
     std::cout << " SgSpawnStmt has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgSpawnStmtStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgSpawnStmt ( SgSpawnStmtStorageArray[i] ) ; 
              }
          delete [] SgSpawnStmtStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgJavaThrowStatement ) ;
     std::cout << " SgJavaThrowStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgJavaThrowStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgJavaThrowStatement ( SgJavaThrowStatementStorageArray[i] ) ; 
              }
          delete [] SgJavaThrowStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgJavaForEachStatement ) ;
     std::cout << " SgJavaForEachStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgJavaForEachStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgJavaForEachStatement ( SgJavaForEachStatementStorageArray[i] ) ; 
              }
          delete [] SgJavaForEachStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgJavaSynchronizedStatement ) ;
     std::cout << " SgJavaSynchronizedStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgJavaSynchronizedStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgJavaSynchronizedStatement ( SgJavaSynchronizedStatementStorageArray[i] ) ; 
              }
          delete [] SgJavaSynchronizedStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgJavaParameterizedType ) ;
     std::cout << " SgJavaParameterizedType has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgJavaParameterizedTypeStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgJavaParameterizedType ( SgJavaParameterizedTypeStorageArray[i] ) ; 
              }
          delete [] SgJavaParameterizedTypeStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgSpecialFunctionModifier ) ;
     std::cout << " SgSpecialFunctionModifier has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgSpecialFunctionModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgSpecialFunctionModifier ( SgSpecialFunctionModifierStorageArray[i] ) ; 
              }
          delete [] SgSpecialFunctionModifierStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgStatement ) ;
     std::cout << " SgStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgStatement ( SgStatementStorageArray[i] ) ; 
              }
          delete [] SgStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgStmtDeclarationStatement ) ;
     std::cout << " SgStmtDeclarationStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgStmtDeclarationStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgStmtDeclarationStatement ( SgStmtDeclarationStatementStorageArray[i] ) ; 
              }
          delete [] SgStmtDeclarationStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgStatementExpression ) ;
     std::cout << " SgStatementExpression has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgStatementExpressionStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgStatementExpression ( SgStatementExpressionStorageArray[i] ) ; 
              }
          delete [] SgStatementExpressionStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgStatementFunctionStatement ) ;
     std::cout << " SgStatementFunctionStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgStatementFunctionStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgStatementFunctionStatement ( SgStatementFunctionStatementStorageArray[i] ) ; 
              }
          delete [] SgStatementFunctionStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgStopOrPauseStatement ) ;
     std::cout << " SgStopOrPauseStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgStopOrPauseStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgStopOrPauseStatement ( SgStopOrPauseStatementStorageArray[i] ) ; 
              }
          delete [] SgStopOrPauseStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgStorageModifier ) ;
     std::cout << " SgStorageModifier has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgStorageModifier ( SgStorageModifierStorageArray[i] ) ; 
              }
          delete [] SgStorageModifierStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgStringConversion ) ;
     std::cout << " SgStringConversion has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgStringConversionStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgStringConversion ( SgStringConversionStorageArray[i] ) ; 
              }
          delete [] SgStringConversionStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgStringKeyedBidirectionalGraph ) ;
     std::cout << " SgStringKeyedBidirectionalGraph has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgStringKeyedBidirectionalGraphStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgStringKeyedBidirectionalGraph ( SgStringKeyedBidirectionalGraphStorageArray[i] ) ; 
              }
          delete [] SgStringKeyedBidirectionalGraphStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgStringVal ) ;
     std::cout << " SgStringVal has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgStringValStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgStringVal ( SgStringValStorageArray[i] ) ; 
              }
          delete [] SgStringValStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgSubscriptExpression ) ;
     std::cout << " SgSubscriptExpression has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgSubscriptExpressionStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgSubscriptExpression ( SgSubscriptExpressionStorageArray[i] ) ; 
              }
          delete [] SgSubscriptExpressionStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgSubtractOp ) ;
     std::cout << " SgSubtractOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgSubtractOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgSubtractOp ( SgSubtractOpStorageArray[i] ) ; 
              }
          delete [] SgSubtractOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgSupport ) ;
     std::cout << " SgSupport has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgSupport ( SgSupportStorageArray[i] ) ; 
              }
          delete [] SgSupportStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgSwitchStatement ) ;
     std::cout << " SgSwitchStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgSwitchStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgSwitchStatement ( SgSwitchStatementStorageArray[i] ) ; 
              }
          delete [] SgSwitchStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgSymbolTable ) ;
     std::cout << " SgSymbolTable has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgSymbolTableStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgSymbolTable ( SgSymbolTableStorageArray[i] ) ; 
              }
          delete [] SgSymbolTableStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgTemplateArgument ) ;
     std::cout << " SgTemplateArgument has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgTemplateArgument ( SgTemplateArgumentStorageArray[i] ) ; 
              }
          delete [] SgTemplateArgumentStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgTemplateArgumentList ) ;
     std::cout << " SgTemplateArgumentList has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgTemplateArgumentListStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgTemplateArgumentList ( SgTemplateArgumentListStorageArray[i] ) ; 
              }
          delete [] SgTemplateArgumentListStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgTemplateDeclaration ) ;
     std::cout << " SgTemplateDeclaration has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgTemplateDeclarationStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgTemplateDeclaration ( SgTemplateDeclarationStorageArray[i] ) ; 
              }
          delete [] SgTemplateDeclarationStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgTemplateClassDeclaration ) ;
     std::cout << " SgTemplateClassDeclaration has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgTemplateClassDeclarationStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgTemplateClassDeclaration ( SgTemplateClassDeclarationStorageArray[i] ) ; 
              }
          delete [] SgTemplateClassDeclarationStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgTemplateFunctionDeclaration ) ;
     std::cout << " SgTemplateFunctionDeclaration has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgTemplateFunctionDeclarationStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgTemplateFunctionDeclaration ( SgTemplateFunctionDeclarationStorageArray[i] ) ; 
              }
          delete [] SgTemplateFunctionDeclarationStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgTemplateMemberFunctionDeclaration ) ;
     std::cout << " SgTemplateMemberFunctionDeclaration has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgTemplateMemberFunctionDeclarationStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgTemplateMemberFunctionDeclaration ( SgTemplateMemberFunctionDeclarationStorageArray[i] ) ; 
              }
          delete [] SgTemplateMemberFunctionDeclarationStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgTemplateClassDefinition ) ;
     std::cout << " SgTemplateClassDefinition has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgTemplateClassDefinitionStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgTemplateClassDefinition ( SgTemplateClassDefinitionStorageArray[i] ) ; 
              }
          delete [] SgTemplateClassDefinitionStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgTemplateFunctionDefinition ) ;
     std::cout << " SgTemplateFunctionDefinition has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgTemplateFunctionDefinitionStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgTemplateFunctionDefinition ( SgTemplateFunctionDefinitionStorageArray[i] ) ; 
              }
          delete [] SgTemplateFunctionDefinitionStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgTemplateInstantiationDecl ) ;
     std::cout << " SgTemplateInstantiationDecl has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgTemplateInstantiationDeclStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgTemplateInstantiationDecl ( SgTemplateInstantiationDeclStorageArray[i] ) ; 
              }
          delete [] SgTemplateInstantiationDeclStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgTemplateInstantiationDefn ) ;
     std::cout << " SgTemplateInstantiationDefn has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgTemplateInstantiationDefnStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgTemplateInstantiationDefn ( SgTemplateInstantiationDefnStorageArray[i] ) ; 
              }
          delete [] SgTemplateInstantiationDefnStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgTemplateInstantiationDirectiveStatement ) ;
     std::cout << " SgTemplateInstantiationDirectiveStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgTemplateInstantiationDirectiveStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgTemplateInstantiationDirectiveStatement ( SgTemplateInstantiationDirectiveStatementStorageArray[i] ) ; 
              }
          delete [] SgTemplateInstantiationDirectiveStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgTemplateInstantiationFunctionDecl ) ;
     std::cout << " SgTemplateInstantiationFunctionDecl has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgTemplateInstantiationFunctionDeclStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgTemplateInstantiationFunctionDecl ( SgTemplateInstantiationFunctionDeclStorageArray[i] ) ; 
              }
          delete [] SgTemplateInstantiationFunctionDeclStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgTemplateInstantiationMemberFunctionDecl ) ;
     std::cout << " SgTemplateInstantiationMemberFunctionDecl has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgTemplateInstantiationMemberFunctionDeclStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgTemplateInstantiationMemberFunctionDecl ( SgTemplateInstantiationMemberFunctionDeclStorageArray[i] ) ; 
              }
          delete [] SgTemplateInstantiationMemberFunctionDeclStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgTemplateParameter ) ;
     std::cout << " SgTemplateParameter has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgTemplateParameter ( SgTemplateParameterStorageArray[i] ) ; 
              }
          delete [] SgTemplateParameterStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgTemplateParameterList ) ;
     std::cout << " SgTemplateParameterList has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgTemplateParameterListStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgTemplateParameterList ( SgTemplateParameterListStorageArray[i] ) ; 
              }
          delete [] SgTemplateParameterListStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgTemplateSymbol ) ;
     std::cout << " SgTemplateSymbol has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgTemplateSymbolStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgTemplateSymbol ( SgTemplateSymbolStorageArray[i] ) ; 
              }
          delete [] SgTemplateSymbolStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgTemplateType ) ;
     std::cout << " SgTemplateType has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgTemplateTypeStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgTemplateType ( SgTemplateTypeStorageArray[i] ) ; 
              }
          delete [] SgTemplateTypeStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgThisExp ) ;
     std::cout << " SgThisExp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgThisExpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgThisExp ( SgThisExpStorageArray[i] ) ; 
              }
          delete [] SgThisExpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgSuperExp ) ;
     std::cout << " SgSuperExp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgSuperExpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgSuperExp ( SgSuperExpStorageArray[i] ) ; 
              }
          delete [] SgSuperExpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgThrowOp ) ;
     std::cout << " SgThrowOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgThrowOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgThrowOp ( SgThrowOpStorageArray[i] ) ; 
              }
          delete [] SgThrowOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgToken ) ;
     std::cout << " SgToken has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgTokenStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgToken ( SgTokenStorageArray[i] ) ; 
              }
          delete [] SgTokenStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgTryStmt ) ;
     std::cout << " SgTryStmt has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgTryStmtStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgTryStmt ( SgTryStmtStorageArray[i] ) ; 
              }
          delete [] SgTryStmtStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgTupleExp ) ;
     std::cout << " SgTupleExp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgTupleExpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgTupleExp ( SgTupleExpStorageArray[i] ) ; 
              }
          delete [] SgTupleExpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgType ) ;
     std::cout << " SgType has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgTypeStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgType ( SgTypeStorageArray[i] ) ; 
              }
          delete [] SgTypeStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgTypeBool ) ;
     std::cout << " SgTypeBool has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgTypeBoolStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgTypeBool ( SgTypeBoolStorageArray[i] ) ; 
              }
          delete [] SgTypeBoolStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgTypeChar ) ;
     std::cout << " SgTypeChar has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgTypeCharStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgTypeChar ( SgTypeCharStorageArray[i] ) ; 
              }
          delete [] SgTypeCharStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgTypeComplex ) ;
     std::cout << " SgTypeComplex has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgTypeComplexStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgTypeComplex ( SgTypeComplexStorageArray[i] ) ; 
              }
          delete [] SgTypeComplexStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgTypeDefault ) ;
     std::cout << " SgTypeDefault has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgTypeDefaultStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgTypeDefault ( SgTypeDefaultStorageArray[i] ) ; 
              }
          delete [] SgTypeDefaultStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgTypeLabel ) ;
     std::cout << " SgTypeLabel has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgTypeLabelStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgTypeLabel ( SgTypeLabelStorageArray[i] ) ; 
              }
          delete [] SgTypeLabelStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgTypeDouble ) ;
     std::cout << " SgTypeDouble has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgTypeDoubleStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgTypeDouble ( SgTypeDoubleStorageArray[i] ) ; 
              }
          delete [] SgTypeDoubleStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgTypeEllipse ) ;
     std::cout << " SgTypeEllipse has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgTypeEllipseStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgTypeEllipse ( SgTypeEllipseStorageArray[i] ) ; 
              }
          delete [] SgTypeEllipseStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgTypeFloat ) ;
     std::cout << " SgTypeFloat has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgTypeFloatStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgTypeFloat ( SgTypeFloatStorageArray[i] ) ; 
              }
          delete [] SgTypeFloatStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgTypeGlobalVoid ) ;
     std::cout << " SgTypeGlobalVoid has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgTypeGlobalVoidStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgTypeGlobalVoid ( SgTypeGlobalVoidStorageArray[i] ) ; 
              }
          delete [] SgTypeGlobalVoidStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgTypeIdOp ) ;
     std::cout << " SgTypeIdOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgTypeIdOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgTypeIdOp ( SgTypeIdOpStorageArray[i] ) ; 
              }
          delete [] SgTypeIdOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgTypeImaginary ) ;
     std::cout << " SgTypeImaginary has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgTypeImaginaryStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgTypeImaginary ( SgTypeImaginaryStorageArray[i] ) ; 
              }
          delete [] SgTypeImaginaryStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgTypeInt ) ;
     std::cout << " SgTypeInt has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgTypeIntStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgTypeInt ( SgTypeIntStorageArray[i] ) ; 
              }
          delete [] SgTypeIntStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgTypeLong ) ;
     std::cout << " SgTypeLong has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgTypeLongStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgTypeLong ( SgTypeLongStorageArray[i] ) ; 
              }
          delete [] SgTypeLongStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgTypeLongDouble ) ;
     std::cout << " SgTypeLongDouble has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgTypeLongDoubleStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgTypeLongDouble ( SgTypeLongDoubleStorageArray[i] ) ; 
              }
          delete [] SgTypeLongDoubleStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgTypeLongLong ) ;
     std::cout << " SgTypeLongLong has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgTypeLongLongStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgTypeLongLong ( SgTypeLongLongStorageArray[i] ) ; 
              }
          delete [] SgTypeLongLongStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgTypeModifier ) ;
     std::cout << " SgTypeModifier has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgTypeModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgTypeModifier ( SgTypeModifierStorageArray[i] ) ; 
              }
          delete [] SgTypeModifierStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgTypeShort ) ;
     std::cout << " SgTypeShort has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgTypeShortStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgTypeShort ( SgTypeShortStorageArray[i] ) ; 
              }
          delete [] SgTypeShortStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgTypeSignedChar ) ;
     std::cout << " SgTypeSignedChar has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgTypeSignedCharStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgTypeSignedChar ( SgTypeSignedCharStorageArray[i] ) ; 
              }
          delete [] SgTypeSignedCharStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgTypeSignedInt ) ;
     std::cout << " SgTypeSignedInt has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgTypeSignedIntStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgTypeSignedInt ( SgTypeSignedIntStorageArray[i] ) ; 
              }
          delete [] SgTypeSignedIntStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgTypeSignedLong ) ;
     std::cout << " SgTypeSignedLong has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgTypeSignedLongStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgTypeSignedLong ( SgTypeSignedLongStorageArray[i] ) ; 
              }
          delete [] SgTypeSignedLongStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgTypeSignedLongLong ) ;
     std::cout << " SgTypeSignedLongLong has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgTypeSignedLongLongStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgTypeSignedLongLong ( SgTypeSignedLongLongStorageArray[i] ) ; 
              }
          delete [] SgTypeSignedLongLongStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgTypeSignedShort ) ;
     std::cout << " SgTypeSignedShort has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgTypeSignedShortStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgTypeSignedShort ( SgTypeSignedShortStorageArray[i] ) ; 
              }
          delete [] SgTypeSignedShortStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgTypeString ) ;
     std::cout << " SgTypeString has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgTypeStringStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgTypeString ( SgTypeStringStorageArray[i] ) ; 
              }
          delete [] SgTypeStringStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgTypeUnknown ) ;
     std::cout << " SgTypeUnknown has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgTypeUnknownStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgTypeUnknown ( SgTypeUnknownStorageArray[i] ) ; 
              }
          delete [] SgTypeUnknownStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgTypeUnsignedChar ) ;
     std::cout << " SgTypeUnsignedChar has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgTypeUnsignedCharStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgTypeUnsignedChar ( SgTypeUnsignedCharStorageArray[i] ) ; 
              }
          delete [] SgTypeUnsignedCharStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgTypeUnsignedInt ) ;
     std::cout << " SgTypeUnsignedInt has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgTypeUnsignedIntStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgTypeUnsignedInt ( SgTypeUnsignedIntStorageArray[i] ) ; 
              }
          delete [] SgTypeUnsignedIntStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgTypeUnsignedLong ) ;
     std::cout << " SgTypeUnsignedLong has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgTypeUnsignedLongStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgTypeUnsignedLong ( SgTypeUnsignedLongStorageArray[i] ) ; 
              }
          delete [] SgTypeUnsignedLongStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgTypeUnsignedLongLong ) ;
     std::cout << " SgTypeUnsignedLongLong has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgTypeUnsignedLongLongStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgTypeUnsignedLongLong ( SgTypeUnsignedLongLongStorageArray[i] ) ; 
              }
          delete [] SgTypeUnsignedLongLongStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgTypeUnsignedShort ) ;
     std::cout << " SgTypeUnsignedShort has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgTypeUnsignedShortStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgTypeUnsignedShort ( SgTypeUnsignedShortStorageArray[i] ) ; 
              }
          delete [] SgTypeUnsignedShortStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgTypeVoid ) ;
     std::cout << " SgTypeVoid has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgTypeVoidStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgTypeVoid ( SgTypeVoidStorageArray[i] ) ; 
              }
          delete [] SgTypeVoidStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgTypeWchar ) ;
     std::cout << " SgTypeWchar has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgTypeWcharStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgTypeWchar ( SgTypeWcharStorageArray[i] ) ; 
              }
          delete [] SgTypeWcharStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgTypedefDeclaration ) ;
     std::cout << " SgTypedefDeclaration has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgTypedefDeclarationStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgTypedefDeclaration ( SgTypedefDeclarationStorageArray[i] ) ; 
              }
          delete [] SgTypedefDeclarationStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgTypedefSeq ) ;
     std::cout << " SgTypedefSeq has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgTypedefSeqStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgTypedefSeq ( SgTypedefSeqStorageArray[i] ) ; 
              }
          delete [] SgTypedefSeqStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgTypedefSymbol ) ;
     std::cout << " SgTypedefSymbol has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgTypedefSymbolStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgTypedefSymbol ( SgTypedefSymbolStorageArray[i] ) ; 
              }
          delete [] SgTypedefSymbolStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgTypedefType ) ;
     std::cout << " SgTypedefType has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgTypedefTypeStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgTypedefType ( SgTypedefTypeStorageArray[i] ) ; 
              }
          delete [] SgTypedefTypeStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgUPC_AccessModifier ) ;
     std::cout << " SgUPC_AccessModifier has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgUPC_AccessModifier ( SgUPC_AccessModifierStorageArray[i] ) ; 
              }
          delete [] SgUPC_AccessModifierStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgUnaryAddOp ) ;
     std::cout << " SgUnaryAddOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgUnaryAddOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgUnaryAddOp ( SgUnaryAddOpStorageArray[i] ) ; 
              }
          delete [] SgUnaryAddOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgUnaryOp ) ;
     std::cout << " SgUnaryOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgUnaryOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgUnaryOp ( SgUnaryOpStorageArray[i] ) ; 
              }
          delete [] SgUnaryOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgUndefDirectiveStatement ) ;
     std::cout << " SgUndefDirectiveStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgUndefDirectiveStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgUndefDirectiveStatement ( SgUndefDirectiveStatementStorageArray[i] ) ; 
              }
          delete [] SgUndefDirectiveStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgUndirectedGraphEdge ) ;
     std::cout << " SgUndirectedGraphEdge has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgUndirectedGraphEdgeStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgUndirectedGraphEdge ( SgUndirectedGraphEdgeStorageArray[i] ) ; 
              }
          delete [] SgUndirectedGraphEdgeStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgUnknownArrayOrFunctionReference ) ;
     std::cout << " SgUnknownArrayOrFunctionReference has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgUnknownArrayOrFunctionReferenceStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgUnknownArrayOrFunctionReference ( SgUnknownArrayOrFunctionReferenceStorageArray[i] ) ; 
              }
          delete [] SgUnknownArrayOrFunctionReferenceStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgUnknownFile ) ;
     std::cout << " SgUnknownFile has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgUnknownFileStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgUnknownFile ( SgUnknownFileStorageArray[i] ) ; 
              }
          delete [] SgUnknownFileStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgUnparse_Info ) ;
     std::cout << " SgUnparse_Info has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgUnparse_InfoStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgUnparse_Info ( SgUnparse_InfoStorageArray[i] ) ; 
              }
          delete [] SgUnparse_InfoStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgUnsignedCharVal ) ;
     std::cout << " SgUnsignedCharVal has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgUnsignedCharValStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgUnsignedCharVal ( SgUnsignedCharValStorageArray[i] ) ; 
              }
          delete [] SgUnsignedCharValStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgUnsignedIntVal ) ;
     std::cout << " SgUnsignedIntVal has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgUnsignedIntValStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgUnsignedIntVal ( SgUnsignedIntValStorageArray[i] ) ; 
              }
          delete [] SgUnsignedIntValStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgUnsignedLongLongIntVal ) ;
     std::cout << " SgUnsignedLongLongIntVal has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgUnsignedLongLongIntValStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgUnsignedLongLongIntVal ( SgUnsignedLongLongIntValStorageArray[i] ) ; 
              }
          delete [] SgUnsignedLongLongIntValStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgUnsignedLongVal ) ;
     std::cout << " SgUnsignedLongVal has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgUnsignedLongValStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgUnsignedLongVal ( SgUnsignedLongValStorageArray[i] ) ; 
              }
          delete [] SgUnsignedLongValStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgUnsignedShortVal ) ;
     std::cout << " SgUnsignedShortVal has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgUnsignedShortValStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgUnsignedShortVal ( SgUnsignedShortValStorageArray[i] ) ; 
              }
          delete [] SgUnsignedShortValStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgUpcBarrierStatement ) ;
     std::cout << " SgUpcBarrierStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgUpcBarrierStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgUpcBarrierStatement ( SgUpcBarrierStatementStorageArray[i] ) ; 
              }
          delete [] SgUpcBarrierStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgUpcBlocksizeofExpression ) ;
     std::cout << " SgUpcBlocksizeofExpression has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgUpcBlocksizeofExpressionStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgUpcBlocksizeofExpression ( SgUpcBlocksizeofExpressionStorageArray[i] ) ; 
              }
          delete [] SgUpcBlocksizeofExpressionStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgUpcElemsizeofExpression ) ;
     std::cout << " SgUpcElemsizeofExpression has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgUpcElemsizeofExpressionStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgUpcElemsizeofExpression ( SgUpcElemsizeofExpressionStorageArray[i] ) ; 
              }
          delete [] SgUpcElemsizeofExpressionStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgUpcFenceStatement ) ;
     std::cout << " SgUpcFenceStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgUpcFenceStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgUpcFenceStatement ( SgUpcFenceStatementStorageArray[i] ) ; 
              }
          delete [] SgUpcFenceStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgUpcForAllStatement ) ;
     std::cout << " SgUpcForAllStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgUpcForAllStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgUpcForAllStatement ( SgUpcForAllStatementStorageArray[i] ) ; 
              }
          delete [] SgUpcForAllStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgUpcLocalsizeofExpression ) ;
     std::cout << " SgUpcLocalsizeofExpression has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgUpcLocalsizeofExpressionStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgUpcLocalsizeofExpression ( SgUpcLocalsizeofExpressionStorageArray[i] ) ; 
              }
          delete [] SgUpcLocalsizeofExpressionStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgUpcMythread ) ;
     std::cout << " SgUpcMythread has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgUpcMythreadStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgUpcMythread ( SgUpcMythreadStorageArray[i] ) ; 
              }
          delete [] SgUpcMythreadStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgUpcNotifyStatement ) ;
     std::cout << " SgUpcNotifyStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgUpcNotifyStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgUpcNotifyStatement ( SgUpcNotifyStatementStorageArray[i] ) ; 
              }
          delete [] SgUpcNotifyStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgUpcThreads ) ;
     std::cout << " SgUpcThreads has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgUpcThreadsStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgUpcThreads ( SgUpcThreadsStorageArray[i] ) ; 
              }
          delete [] SgUpcThreadsStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgUpcWaitStatement ) ;
     std::cout << " SgUpcWaitStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgUpcWaitStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgUpcWaitStatement ( SgUpcWaitStatementStorageArray[i] ) ; 
              }
          delete [] SgUpcWaitStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgUseStatement ) ;
     std::cout << " SgUseStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgUseStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgUseStatement ( SgUseStatementStorageArray[i] ) ; 
              }
          delete [] SgUseStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgUserDefinedBinaryOp ) ;
     std::cout << " SgUserDefinedBinaryOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgUserDefinedBinaryOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgUserDefinedBinaryOp ( SgUserDefinedBinaryOpStorageArray[i] ) ; 
              }
          delete [] SgUserDefinedBinaryOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgUserDefinedUnaryOp ) ;
     std::cout << " SgUserDefinedUnaryOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgUserDefinedUnaryOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgUserDefinedUnaryOp ( SgUserDefinedUnaryOpStorageArray[i] ) ; 
              }
          delete [] SgUserDefinedUnaryOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgUsingDeclarationStatement ) ;
     std::cout << " SgUsingDeclarationStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgUsingDeclarationStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgUsingDeclarationStatement ( SgUsingDeclarationStatementStorageArray[i] ) ; 
              }
          delete [] SgUsingDeclarationStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgUsingDirectiveStatement ) ;
     std::cout << " SgUsingDirectiveStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgUsingDirectiveStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgUsingDirectiveStatement ( SgUsingDirectiveStatementStorageArray[i] ) ; 
              }
          delete [] SgUsingDirectiveStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgValueExp ) ;
     std::cout << " SgValueExp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgValueExpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgValueExp ( SgValueExpStorageArray[i] ) ; 
              }
          delete [] SgValueExpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgVarArgCopyOp ) ;
     std::cout << " SgVarArgCopyOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgVarArgCopyOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgVarArgCopyOp ( SgVarArgCopyOpStorageArray[i] ) ; 
              }
          delete [] SgVarArgCopyOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgVarArgEndOp ) ;
     std::cout << " SgVarArgEndOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgVarArgEndOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgVarArgEndOp ( SgVarArgEndOpStorageArray[i] ) ; 
              }
          delete [] SgVarArgEndOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgVarArgOp ) ;
     std::cout << " SgVarArgOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgVarArgOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgVarArgOp ( SgVarArgOpStorageArray[i] ) ; 
              }
          delete [] SgVarArgOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgVarArgStartOneOperandOp ) ;
     std::cout << " SgVarArgStartOneOperandOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgVarArgStartOneOperandOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgVarArgStartOneOperandOp ( SgVarArgStartOneOperandOpStorageArray[i] ) ; 
              }
          delete [] SgVarArgStartOneOperandOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgVarArgStartOp ) ;
     std::cout << " SgVarArgStartOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgVarArgStartOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgVarArgStartOp ( SgVarArgStartOpStorageArray[i] ) ; 
              }
          delete [] SgVarArgStartOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgVarRefExp ) ;
     std::cout << " SgVarRefExp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgVarRefExpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgVarRefExp ( SgVarRefExpStorageArray[i] ) ; 
              }
          delete [] SgVarRefExpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgVariableDeclaration ) ;
     std::cout << " SgVariableDeclaration has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgVariableDeclarationStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgVariableDeclaration ( SgVariableDeclarationStorageArray[i] ) ; 
              }
          delete [] SgVariableDeclarationStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgVariableDefinition ) ;
     std::cout << " SgVariableDefinition has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgVariableDefinitionStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgVariableDefinition ( SgVariableDefinitionStorageArray[i] ) ; 
              }
          delete [] SgVariableDefinitionStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgVariableSymbol ) ;
     std::cout << " SgVariableSymbol has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgVariableSymbolStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgVariableSymbol ( SgVariableSymbolStorageArray[i] ) ; 
              }
          delete [] SgVariableSymbolStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgVariantExpression ) ;
     std::cout << " SgVariantExpression has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgVariantExpressionStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgVariantExpression ( SgVariantExpressionStorageArray[i] ) ; 
              }
          delete [] SgVariantExpressionStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgVariantStatement ) ;
     std::cout << " SgVariantStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgVariantStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgVariantStatement ( SgVariantStatementStorageArray[i] ) ; 
              }
          delete [] SgVariantStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgWaitStatement ) ;
     std::cout << " SgWaitStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgWaitStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgWaitStatement ( SgWaitStatementStorageArray[i] ) ; 
              }
          delete [] SgWaitStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgWarningDirectiveStatement ) ;
     std::cout << " SgWarningDirectiveStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgWarningDirectiveStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgWarningDirectiveStatement ( SgWarningDirectiveStatementStorageArray[i] ) ; 
              }
          delete [] SgWarningDirectiveStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgWithStatement ) ;
     std::cout << " SgWithStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgWithStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgWithStatement ( SgWithStatementStorageArray[i] ) ; 
              }
          delete [] SgWithStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgWcharVal ) ;
     std::cout << " SgWcharVal has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgWcharValStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgWcharVal ( SgWcharValStorageArray[i] ) ; 
              }
          delete [] SgWcharValStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgWhereStatement ) ;
     std::cout << " SgWhereStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgWhereStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgWhereStatement ( SgWhereStatementStorageArray[i] ) ; 
              }
          delete [] SgWhereStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgWhileStmt ) ;
     std::cout << " SgWhileStmt has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgWhileStmtStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgWhileStmt ( SgWhileStmtStorageArray[i] ) ; 
              }
          delete [] SgWhileStmtStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgWriteStatement ) ;
     std::cout << " SgWriteStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgWriteStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgWriteStatement ( SgWriteStatementStorageArray[i] ) ; 
              }
          delete [] SgWriteStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgXorAssignOp ) ;
     std::cout << " SgXorAssignOp has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgXorAssignOpStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgXorAssignOp ( SgXorAssignOpStorageArray[i] ) ; 
              }
          delete [] SgXorAssignOpStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgYieldExpression ) ;
     std::cout << " SgYieldExpression has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgYieldExpressionStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgYieldExpression ( SgYieldExpressionStorageArray[i] ) ; 
              }
          delete [] SgYieldExpressionStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_Sg_File_Info ) ;
     std::cout << " Sg_File_Info has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          Sg_File_InfoStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new Sg_File_Info ( Sg_File_InfoStorageArray[i] ) ; 
              }
          delete [] Sg_File_InfoStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgTypeCAFTeam ) ;
     std::cout << " SgTypeCAFTeam has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgTypeCAFTeamStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgTypeCAFTeam ( SgTypeCAFTeamStorageArray[i] ) ; 
              }
          delete [] SgTypeCAFTeamStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgCAFWithTeamStatement ) ;
     std::cout << " SgCAFWithTeamStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgCAFWithTeamStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgCAFWithTeamStatement ( SgCAFWithTeamStatementStorageArray[i] ) ; 
              }
          delete [] SgCAFWithTeamStatementStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgCAFCoExpression ) ;
     std::cout << " SgCAFCoExpression has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgCAFCoExpressionStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgCAFCoExpression ( SgCAFCoExpressionStorageArray[i] ) ; 
              }
          delete [] SgCAFCoExpressionStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgCallExpression ) ;
     std::cout << " SgCallExpression has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgCallExpressionStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgCallExpression ( SgCallExpressionStorageArray[i] ) ; 
              }
          delete [] SgCallExpressionStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgTypeCrayPointer ) ;
     std::cout << " SgTypeCrayPointer has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgTypeCrayPointerStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgTypeCrayPointer ( SgTypeCrayPointerStorageArray[i] ) ; 
              }
          delete [] SgTypeCrayPointerStorageArray;
        } 
     sizeOfActualPool =  getPoolSizeOfNewAst( V_SgJavaImportStatement ) ;
     std::cout << " SgJavaImportStatement has size " << sizeOfActualPool << std::endl;
     if ( 0 < sizeOfActualPool )
        { 
          SgJavaImportStatementStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock () ; 
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
              {
               new SgJavaImportStatement ( SgJavaImportStatementStorageArray[i] ) ; 
              }
          delete [] SgJavaImportStatementStorageArray;
        } 

/* #line 264 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarAST_FileIoSource.code" */

#if FILE_IO_EXTRA_CHECK
  // DQ (4/22/2006): Added timer information for AST File I/O
     TimingPerformance nested_timer ("AST_FILE_IO::compressAstInMemoryPool() FILE_IO_EXTRA_CHECK:");
 
     for ( int i = 0; i < totalNumberOfIRNodes; ++i)
        {
          listOfMemoryPoolSizes[i] += getPoolSizeOfNewAst(i);
        }
     listOfMemoryPoolSizes[totalNumberOfIRNodes] += getTotalNumberOfNodesOfNewAst();
  // std::cout << "Starting check, that all IRNodes are in the memory pools ... " << std::flush;
#if 0
  // AST_FileIO::MemoryCheckingTraversalForAstFileIO memoryCheckingTraversal;
     MemoryCheckingTraversalForAstFileIO memoryCheckingTraversal;
     memoryCheckingTraversal.traverseMemoryPool();
#endif
     // std::cout << "  done ! " << std::endl;
#endif

   }


void
AST_FILE_IO :: resetValidAstAfterWriting ( )
   {
     printf ("Inside of AST_FILE_IO::resetValidAstAfterWriting() \n");

// DQ (2/26/2010): Test this uncommented.
#if 1
     SgAccessModifier_resetValidFreepointers( );
     SgActualArgumentExpression_resetValidFreepointers( );
     SgAddOp_resetValidFreepointers( );
     SgAddressOfOp_resetValidFreepointers( );
     SgAggregateInitializer_resetValidFreepointers( );
     SgAliasSymbol_resetValidFreepointers( );
     SgAllocateStatement_resetValidFreepointers( );
     SgAndAssignOp_resetValidFreepointers( );
     SgAndOp_resetValidFreepointers( );
     SgArithmeticIfStatement_resetValidFreepointers( );
     SgArrayType_resetValidFreepointers( );
     SgArrowExp_resetValidFreepointers( );
     SgArrowStarOp_resetValidFreepointers( );
     SgAsmArmInstruction_resetValidFreepointers( );
     SgAsmArmRegisterReferenceExpression_resetValidFreepointers( );
     SgAsmBasicString_resetValidFreepointers( );
     SgAsmBinaryAdd_resetValidFreepointers( );
     SgAsmBinaryAddPostupdate_resetValidFreepointers( );
     SgAsmBinaryAddPreupdate_resetValidFreepointers( );
     SgAsmBinaryAsr_resetValidFreepointers( );
     SgAsmBinaryDivide_resetValidFreepointers( );
     SgAsmBinaryExpression_resetValidFreepointers( );
     SgAsmBinaryLsl_resetValidFreepointers( );
     SgAsmBinaryLsr_resetValidFreepointers( );
     SgAsmBinaryMod_resetValidFreepointers( );
     SgAsmBinaryMultiply_resetValidFreepointers( );
     SgAsmBinaryRor_resetValidFreepointers( );
     SgAsmBinarySubtract_resetValidFreepointers( );
     SgAsmBinarySubtractPostupdate_resetValidFreepointers( );
     SgAsmBinarySubtractPreupdate_resetValidFreepointers( );
     SgAsmBlock_resetValidFreepointers( );
     SgAsmByteValueExpression_resetValidFreepointers( );
     SgAsmCoffStrtab_resetValidFreepointers( );
     SgAsmCoffSymbol_resetValidFreepointers( );
     SgAsmCoffSymbolList_resetValidFreepointers( );
     SgAsmCoffSymbolTable_resetValidFreepointers( );
     SgAsmCommonSubExpression_resetValidFreepointers( );
     SgAsmControlFlagsExpression_resetValidFreepointers( );
     SgAsmDOSExtendedHeader_resetValidFreepointers( );
     SgAsmDOSFileHeader_resetValidFreepointers( );
     SgAsmDoubleFloatValueExpression_resetValidFreepointers( );
     SgAsmDoubleWordValueExpression_resetValidFreepointers( );
     SgAsmDwarfAccessDeclaration_resetValidFreepointers( );
     SgAsmDwarfArrayType_resetValidFreepointers( );
     SgAsmDwarfBaseType_resetValidFreepointers( );
     SgAsmDwarfCatchBlock_resetValidFreepointers( );
     SgAsmDwarfClassTemplate_resetValidFreepointers( );
     SgAsmDwarfClassType_resetValidFreepointers( );
     SgAsmDwarfCommonBlock_resetValidFreepointers( );
     SgAsmDwarfCommonInclusion_resetValidFreepointers( );
     SgAsmDwarfCompilationUnit_resetValidFreepointers( );
     SgAsmDwarfCompilationUnitList_resetValidFreepointers( );
     SgAsmDwarfCondition_resetValidFreepointers( );
     SgAsmDwarfConstType_resetValidFreepointers( );
     SgAsmDwarfConstant_resetValidFreepointers( );
     SgAsmDwarfConstruct_resetValidFreepointers( );
     SgAsmDwarfConstructList_resetValidFreepointers( );
     SgAsmDwarfDwarfProcedure_resetValidFreepointers( );
     SgAsmDwarfEntryPoint_resetValidFreepointers( );
     SgAsmDwarfEnumerationType_resetValidFreepointers( );
     SgAsmDwarfEnumerator_resetValidFreepointers( );
     SgAsmDwarfFileType_resetValidFreepointers( );
     SgAsmDwarfFormalParameter_resetValidFreepointers( );
     SgAsmDwarfFormatLabel_resetValidFreepointers( );
     SgAsmDwarfFriend_resetValidFreepointers( );
     SgAsmDwarfFunctionTemplate_resetValidFreepointers( );
     SgAsmDwarfImportedDeclaration_resetValidFreepointers( );
     SgAsmDwarfImportedModule_resetValidFreepointers( );
     SgAsmDwarfImportedUnit_resetValidFreepointers( );
     SgAsmDwarfInformation_resetValidFreepointers( );
     SgAsmDwarfInheritance_resetValidFreepointers( );
     SgAsmDwarfInlinedSubroutine_resetValidFreepointers( );
     SgAsmDwarfInterfaceType_resetValidFreepointers( );
     SgAsmDwarfLabel_resetValidFreepointers( );
     SgAsmDwarfLexicalBlock_resetValidFreepointers( );
     SgAsmDwarfLine_resetValidFreepointers( );
     SgAsmDwarfLineList_resetValidFreepointers( );
     SgAsmDwarfMacro_resetValidFreepointers( );
     SgAsmDwarfMacroList_resetValidFreepointers( );
     SgAsmDwarfMember_resetValidFreepointers( );
     SgAsmDwarfModule_resetValidFreepointers( );
     SgAsmDwarfMutableType_resetValidFreepointers( );
     SgAsmDwarfNamelist_resetValidFreepointers( );
     SgAsmDwarfNamelistItem_resetValidFreepointers( );
     SgAsmDwarfNamespace_resetValidFreepointers( );
     SgAsmDwarfPackedType_resetValidFreepointers( );
     SgAsmDwarfPartialUnit_resetValidFreepointers( );
     SgAsmDwarfPointerType_resetValidFreepointers( );
     SgAsmDwarfPtrToMemberType_resetValidFreepointers( );
     SgAsmDwarfReferenceType_resetValidFreepointers( );
     SgAsmDwarfRestrictType_resetValidFreepointers( );
     SgAsmDwarfSetType_resetValidFreepointers( );
     SgAsmDwarfSharedType_resetValidFreepointers( );
     SgAsmDwarfStringType_resetValidFreepointers( );
     SgAsmDwarfStructureType_resetValidFreepointers( );
     SgAsmDwarfSubprogram_resetValidFreepointers( );
     SgAsmDwarfSubrangeType_resetValidFreepointers( );
     SgAsmDwarfSubroutineType_resetValidFreepointers( );
     SgAsmDwarfTemplateTypeParameter_resetValidFreepointers( );
     SgAsmDwarfTemplateValueParameter_resetValidFreepointers( );
     SgAsmDwarfThrownType_resetValidFreepointers( );
     SgAsmDwarfTryBlock_resetValidFreepointers( );
     SgAsmDwarfTypedef_resetValidFreepointers( );
     SgAsmDwarfUnionType_resetValidFreepointers( );
     SgAsmDwarfUnknownConstruct_resetValidFreepointers( );
     SgAsmDwarfUnspecifiedParameters_resetValidFreepointers( );
     SgAsmDwarfUnspecifiedType_resetValidFreepointers( );
     SgAsmDwarfUpcRelaxedType_resetValidFreepointers( );
     SgAsmDwarfUpcSharedType_resetValidFreepointers( );
     SgAsmDwarfUpcStrictType_resetValidFreepointers( );
     SgAsmDwarfVariable_resetValidFreepointers( );
     SgAsmDwarfVariant_resetValidFreepointers( );
     SgAsmDwarfVariantPart_resetValidFreepointers( );
     SgAsmDwarfVolatileType_resetValidFreepointers( );
     SgAsmDwarfWithStmt_resetValidFreepointers( );
     SgAsmElfDynamicEntry_resetValidFreepointers( );
     SgAsmElfDynamicEntryList_resetValidFreepointers( );
     SgAsmElfDynamicSection_resetValidFreepointers( );
     SgAsmElfEHFrameEntryCI_resetValidFreepointers( );
     SgAsmElfEHFrameEntryCIList_resetValidFreepointers( );
     SgAsmElfEHFrameEntryFD_resetValidFreepointers( );
     SgAsmElfEHFrameEntryFDList_resetValidFreepointers( );
     SgAsmElfEHFrameSection_resetValidFreepointers( );
     SgAsmElfFileHeader_resetValidFreepointers( );
     SgAsmElfNoteEntry_resetValidFreepointers( );
     SgAsmElfNoteEntryList_resetValidFreepointers( );
     SgAsmElfNoteSection_resetValidFreepointers( );
     SgAsmElfRelocEntry_resetValidFreepointers( );
     SgAsmElfRelocEntryList_resetValidFreepointers( );
     SgAsmElfRelocSection_resetValidFreepointers( );
     SgAsmElfSection_resetValidFreepointers( );
     SgAsmElfSectionTable_resetValidFreepointers( );
     SgAsmElfSectionTableEntry_resetValidFreepointers( );
     SgAsmElfSegmentTable_resetValidFreepointers( );
     SgAsmElfSegmentTableEntry_resetValidFreepointers( );
     SgAsmElfSegmentTableEntryList_resetValidFreepointers( );
     SgAsmElfStringSection_resetValidFreepointers( );
     SgAsmElfStrtab_resetValidFreepointers( );
     SgAsmElfSymbol_resetValidFreepointers( );
     SgAsmElfSymbolList_resetValidFreepointers( );
     SgAsmElfSymbolSection_resetValidFreepointers( );
     SgAsmElfSymverDefinedAux_resetValidFreepointers( );
     SgAsmElfSymverDefinedAuxList_resetValidFreepointers( );
     SgAsmElfSymverDefinedEntry_resetValidFreepointers( );
     SgAsmElfSymverDefinedEntryList_resetValidFreepointers( );
     SgAsmElfSymverDefinedSection_resetValidFreepointers( );
     SgAsmElfSymverEntry_resetValidFreepointers( );
     SgAsmElfSymverEntryList_resetValidFreepointers( );
     SgAsmElfSymverNeededAux_resetValidFreepointers( );
     SgAsmElfSymverNeededAuxList_resetValidFreepointers( );
     SgAsmElfSymverNeededEntry_resetValidFreepointers( );
     SgAsmElfSymverNeededEntryList_resetValidFreepointers( );
     SgAsmElfSymverNeededSection_resetValidFreepointers( );
     SgAsmElfSymverSection_resetValidFreepointers( );
     SgAsmExecutableFileFormat_resetValidFreepointers( );
     SgAsmExprListExp_resetValidFreepointers( );
     SgAsmExpression_resetValidFreepointers( );
     SgAsmFunction_resetValidFreepointers( );
     SgAsmGenericDLL_resetValidFreepointers( );
     SgAsmGenericDLLList_resetValidFreepointers( );
     SgAsmGenericFile_resetValidFreepointers( );
     SgAsmGenericFileList_resetValidFreepointers( );
     SgAsmGenericFormat_resetValidFreepointers( );
     SgAsmGenericHeader_resetValidFreepointers( );
     SgAsmGenericHeaderList_resetValidFreepointers( );
     SgAsmGenericSection_resetValidFreepointers( );
     SgAsmGenericSectionList_resetValidFreepointers( );
     SgAsmGenericString_resetValidFreepointers( );
     SgAsmGenericStrtab_resetValidFreepointers( );
     SgAsmGenericSymbol_resetValidFreepointers( );
     SgAsmGenericSymbolList_resetValidFreepointers( );
     SgAsmInstruction_resetValidFreepointers( );
     SgAsmIntegerValueExpression_resetValidFreepointers( );
     SgAsmInterpretation_resetValidFreepointers( );
     SgAsmInterpretationList_resetValidFreepointers( );
     SgAsmLEEntryPoint_resetValidFreepointers( );
     SgAsmLEEntryTable_resetValidFreepointers( );
     SgAsmLEFileHeader_resetValidFreepointers( );
     SgAsmLENameTable_resetValidFreepointers( );
     SgAsmLEPageTable_resetValidFreepointers( );
     SgAsmLEPageTableEntry_resetValidFreepointers( );
     SgAsmLERelocTable_resetValidFreepointers( );
     SgAsmLESection_resetValidFreepointers( );
     SgAsmLESectionTable_resetValidFreepointers( );
     SgAsmLESectionTableEntry_resetValidFreepointers( );
     SgAsmMemoryReferenceExpression_resetValidFreepointers( );
     SgAsmNEEntryPoint_resetValidFreepointers( );
     SgAsmNEEntryTable_resetValidFreepointers( );
     SgAsmNEFileHeader_resetValidFreepointers( );
     SgAsmNEModuleTable_resetValidFreepointers( );
     SgAsmNENameTable_resetValidFreepointers( );
     SgAsmNERelocEntry_resetValidFreepointers( );
     SgAsmNERelocTable_resetValidFreepointers( );
     SgAsmNESection_resetValidFreepointers( );
     SgAsmNESectionTable_resetValidFreepointers( );
     SgAsmNESectionTableEntry_resetValidFreepointers( );
     SgAsmNEStringTable_resetValidFreepointers( );
     SgAsmNode_resetValidFreepointers( );
     SgAsmOp_resetValidFreepointers( );
     SgAsmOperandList_resetValidFreepointers( );
     SgAsmPEExportDirectory_resetValidFreepointers( );
     SgAsmPEExportEntry_resetValidFreepointers( );
     SgAsmPEExportEntryList_resetValidFreepointers( );
     SgAsmPEExportSection_resetValidFreepointers( );
     SgAsmPEFileHeader_resetValidFreepointers( );
     SgAsmPEImportDirectory_resetValidFreepointers( );
     SgAsmPEImportDirectoryList_resetValidFreepointers( );
     SgAsmPEImportItem_resetValidFreepointers( );
     SgAsmPEImportItemList_resetValidFreepointers( );
     SgAsmPEImportSection_resetValidFreepointers( );
     SgAsmPERVASizePair_resetValidFreepointers( );
     SgAsmPERVASizePairList_resetValidFreepointers( );
     SgAsmPESection_resetValidFreepointers( );
     SgAsmPESectionTable_resetValidFreepointers( );
     SgAsmPESectionTableEntry_resetValidFreepointers( );
     SgAsmPEStringSection_resetValidFreepointers( );
     SgAsmPowerpcInstruction_resetValidFreepointers( );
     SgAsmPowerpcRegisterReferenceExpression_resetValidFreepointers( );
     SgAsmQuadWordValueExpression_resetValidFreepointers( );
     SgAsmRegisterReferenceExpression_resetValidFreepointers( );
     SgAsmSingleFloatValueExpression_resetValidFreepointers( );
     SgAsmStatement_resetValidFreepointers( );
     SgAsmStaticData_resetValidFreepointers( );
     SgAsmStmt_resetValidFreepointers( );
     SgAsmStoredString_resetValidFreepointers( );
     SgAsmStringStorage_resetValidFreepointers( );
     SgAsmType_resetValidFreepointers( );
     SgAsmType128bitFloat_resetValidFreepointers( );
     SgAsmType80bitFloat_resetValidFreepointers( );
     SgAsmTypeByte_resetValidFreepointers( );
     SgAsmTypeDoubleFloat_resetValidFreepointers( );
     SgAsmTypeDoubleQuadWord_resetValidFreepointers( );
     SgAsmTypeDoubleWord_resetValidFreepointers( );
     SgAsmTypeQuadWord_resetValidFreepointers( );
     SgAsmTypeSingleFloat_resetValidFreepointers( );
     SgAsmTypeVector_resetValidFreepointers( );
     SgAsmTypeWord_resetValidFreepointers( );
     SgAsmUnaryArmSpecialRegisterList_resetValidFreepointers( );
     SgAsmUnaryExpression_resetValidFreepointers( );
     SgAsmUnaryMinus_resetValidFreepointers( );
     SgAsmUnaryPlus_resetValidFreepointers( );
     SgAsmUnaryRrx_resetValidFreepointers( );
     SgAsmValueExpression_resetValidFreepointers( );
     SgAsmVectorValueExpression_resetValidFreepointers( );
     SgAsmWordValueExpression_resetValidFreepointers( );
     SgAsmx86Instruction_resetValidFreepointers( );
     SgAsmx86RegisterReferenceExpression_resetValidFreepointers( );
     SgAsmBinaryAddressSymbol_resetValidFreepointers( );
     SgAsmBinaryDataSymbol_resetValidFreepointers( );
     SgAssertStmt_resetValidFreepointers( );
     SgAssignInitializer_resetValidFreepointers( );
     SgAssignOp_resetValidFreepointers( );
     SgAssignStatement_resetValidFreepointers( );
     SgAssignedGotoStatement_resetValidFreepointers( );
     SgAssociateStatement_resetValidFreepointers( );
     SgAsteriskShapeExp_resetValidFreepointers( );
     SgAttribute_resetValidFreepointers( );
     SgAttributeSpecificationStatement_resetValidFreepointers( );
     SgBackspaceStatement_resetValidFreepointers( );
     SgBaseClass_resetValidFreepointers( );
     SgExpBaseClass_resetValidFreepointers( );
     SgBaseClassModifier_resetValidFreepointers( );
     SgBasicBlock_resetValidFreepointers( );
     SgBidirectionalGraph_resetValidFreepointers( );
     SgBinaryComposite_resetValidFreepointers( );
     SgBinaryOp_resetValidFreepointers( );
     SgBitAndOp_resetValidFreepointers( );
     SgBitAttribute_resetValidFreepointers( );
     SgBitComplementOp_resetValidFreepointers( );
     SgBitOrOp_resetValidFreepointers( );
     SgBitXorOp_resetValidFreepointers( );
     SgBlockDataStatement_resetValidFreepointers( );
     SgBoolValExp_resetValidFreepointers( );
     SgBreakStmt_resetValidFreepointers( );
     SgC_PreprocessorDirectiveStatement_resetValidFreepointers( );
     SgCaseOptionStmt_resetValidFreepointers( );
     SgCastExp_resetValidFreepointers( );
     SgCatchOptionStmt_resetValidFreepointers( );
     SgCatchStatementSeq_resetValidFreepointers( );
     SgCharVal_resetValidFreepointers( );
     SgClassDecl_attr_resetValidFreepointers( );
     SgClassDeclaration_resetValidFreepointers( );
     SgClassDefinition_resetValidFreepointers( );
     SgClassNameRefExp_resetValidFreepointers( );
     SgClassSymbol_resetValidFreepointers( );
     SgClassType_resetValidFreepointers( );
     SgClinkageDeclarationStatement_resetValidFreepointers( );
     SgClinkageEndStatement_resetValidFreepointers( );
     SgClinkageStartStatement_resetValidFreepointers( );
     SgCloseStatement_resetValidFreepointers( );
     SgColonShapeExp_resetValidFreepointers( );
     SgCommaOpExp_resetValidFreepointers( );
     SgCommonBlock_resetValidFreepointers( );
     SgCommonBlockObject_resetValidFreepointers( );
     SgCommonSymbol_resetValidFreepointers( );
     SgComplexVal_resetValidFreepointers( );
     SgComprehension_resetValidFreepointers( );
     SgCompoundAssignOp_resetValidFreepointers( );
     SgCompoundInitializer_resetValidFreepointers( );
     SgComputedGotoStatement_resetValidFreepointers( );
     SgConcatenationOp_resetValidFreepointers( );
     SgConditionalExp_resetValidFreepointers( );
     SgConjugateOp_resetValidFreepointers( );
     SgConstVolatileModifier_resetValidFreepointers( );
     SgConstructorInitializer_resetValidFreepointers( );
     SgContainsStatement_resetValidFreepointers( );
     SgContinueStmt_resetValidFreepointers( );
     SgCtorInitializerList_resetValidFreepointers( );
     SgDataStatementGroup_resetValidFreepointers( );
     SgDataStatementObject_resetValidFreepointers( );
     SgDataStatementValue_resetValidFreepointers( );
     SgDeadIfDirectiveStatement_resetValidFreepointers( );
     SgDeallocateStatement_resetValidFreepointers( );
     SgDeclarationModifier_resetValidFreepointers( );
     SgDeclarationStatement_resetValidFreepointers( );
     SgDefaultOptionStmt_resetValidFreepointers( );
     SgDefaultSymbol_resetValidFreepointers( );
     SgDefineDirectiveStatement_resetValidFreepointers( );
     SgDeleteExp_resetValidFreepointers( );
     SgDerivedTypeStatement_resetValidFreepointers( );
     SgDesignatedInitializer_resetValidFreepointers( );
     SgDictionaryComprehension_resetValidFreepointers( );
     SgDictionaryExp_resetValidFreepointers( );
     SgDimensionObject_resetValidFreepointers( );
     SgDirectedGraphEdge_resetValidFreepointers( );
     SgDirectory_resetValidFreepointers( );
     SgDirectoryList_resetValidFreepointers( );
     SgDivAssignOp_resetValidFreepointers( );
     SgDivideOp_resetValidFreepointers( );
     SgDoWhileStmt_resetValidFreepointers( );
     SgDotExp_resetValidFreepointers( );
     SgDotStarOp_resetValidFreepointers( );
     SgDoubleVal_resetValidFreepointers( );
     SgElaboratedTypeModifier_resetValidFreepointers( );
     SgElseDirectiveStatement_resetValidFreepointers( );
     SgElseWhereStatement_resetValidFreepointers( );
     SgElseifDirectiveStatement_resetValidFreepointers( );
     SgEmptyDirectiveStatement_resetValidFreepointers( );
     SgEndfileStatement_resetValidFreepointers( );
     SgEndifDirectiveStatement_resetValidFreepointers( );
     SgEntryStatement_resetValidFreepointers( );
     SgEnumDeclaration_resetValidFreepointers( );
     SgEnumFieldSymbol_resetValidFreepointers( );
     SgEnumSymbol_resetValidFreepointers( );
     SgEnumType_resetValidFreepointers( );
     SgEnumVal_resetValidFreepointers( );
     SgEqualityOp_resetValidFreepointers( );
     SgEquivalenceStatement_resetValidFreepointers( );
     SgErrorDirectiveStatement_resetValidFreepointers( );
     SgExecStatement_resetValidFreepointers( );
     SgExponentiationOp_resetValidFreepointers( );
     SgExponentiationAssignOp_resetValidFreepointers( );
     SgExprListExp_resetValidFreepointers( );
     SgExprStatement_resetValidFreepointers( );
     SgExpression_resetValidFreepointers( );
     SgExpressionRoot_resetValidFreepointers( );
     SgFile_resetValidFreepointers( );
     SgFileList_resetValidFreepointers( );
     SgFloatVal_resetValidFreepointers( );
     SgFlushStatement_resetValidFreepointers( );
     SgForAllStatement_resetValidFreepointers( );
     SgForInitStatement_resetValidFreepointers( );
     SgForStatement_resetValidFreepointers( );
     SgFormatItem_resetValidFreepointers( );
     SgFormatItemList_resetValidFreepointers( );
     SgFormatStatement_resetValidFreepointers( );
     SgFortranDo_resetValidFreepointers( );
     SgFortranIncludeLine_resetValidFreepointers( );
     SgFortranNonblockedDo_resetValidFreepointers( );
     SgFuncDecl_attr_resetValidFreepointers( );
     SgFunctionCallExp_resetValidFreepointers( );
     SgFunctionDeclaration_resetValidFreepointers( );
     SgFunctionDefinition_resetValidFreepointers( );
     SgFunctionModifier_resetValidFreepointers( );
     SgFunctionParameterList_resetValidFreepointers( );
     SgFunctionParameterTypeList_resetValidFreepointers( );
     SgFunctionRefExp_resetValidFreepointers( );
     SgFunctionSymbol_resetValidFreepointers( );
     SgFunctionType_resetValidFreepointers( );
     SgFunctionTypeSymbol_resetValidFreepointers( );
     SgFunctionTypeTable_resetValidFreepointers( );
     SgTypeTable_resetValidFreepointers( );
     SgGlobal_resetValidFreepointers( );
     SgGotoStatement_resetValidFreepointers( );
     SgGraph_resetValidFreepointers( );
     SgGraphEdge_resetValidFreepointers( );
     SgGraphEdgeList_resetValidFreepointers( );
     SgGraphNode_resetValidFreepointers( );
     SgGraphNodeList_resetValidFreepointers( );
     SgGreaterOrEqualOp_resetValidFreepointers( );
     SgGreaterThanOp_resetValidFreepointers( );
     SgIOItemExpression_resetValidFreepointers( );
     SgIOStatement_resetValidFreepointers( );
     SgIdentDirectiveStatement_resetValidFreepointers( );
     SgIfDirectiveStatement_resetValidFreepointers( );
     SgIfStmt_resetValidFreepointers( );
     SgIfdefDirectiveStatement_resetValidFreepointers( );
     SgIfndefDirectiveStatement_resetValidFreepointers( );
     SgImagPartOp_resetValidFreepointers( );
     SgImplicitStatement_resetValidFreepointers( );
     SgImpliedDo_resetValidFreepointers( );
     SgImportStatement_resetValidFreepointers( );
     SgIncidenceDirectedGraph_resetValidFreepointers( );
     SgIncidenceUndirectedGraph_resetValidFreepointers( );
     SgIncludeDirectiveStatement_resetValidFreepointers( );
     SgIncludeNextDirectiveStatement_resetValidFreepointers( );
     SgInitializedName_resetValidFreepointers( );
     SgInitializer_resetValidFreepointers( );
     SgInquireStatement_resetValidFreepointers( );
     SgIntKeyedBidirectionalGraph_resetValidFreepointers( );
     SgIntVal_resetValidFreepointers( );
     SgIntegerDivideOp_resetValidFreepointers( );
     SgIntegerDivideAssignOp_resetValidFreepointers( );
     SgInterfaceBody_resetValidFreepointers( );
     SgHeaderFileBody_resetValidFreepointers( );
     SgInterfaceStatement_resetValidFreepointers( );
     SgInterfaceSymbol_resetValidFreepointers( );
     SgIntrinsicSymbol_resetValidFreepointers( );
     SgIsOp_resetValidFreepointers( );
     SgIsNotOp_resetValidFreepointers( );
     SgIorAssignOp_resetValidFreepointers( );
     SgKeyDatumPair_resetValidFreepointers( );
     SgCudaKernelExecConfig_resetValidFreepointers( );
     SgCudaKernelCallExp_resetValidFreepointers( );
     SgLabelRefExp_resetValidFreepointers( );
     SgLabelStatement_resetValidFreepointers( );
     SgJavaLabelStatement_resetValidFreepointers( );
     SgLabelSymbol_resetValidFreepointers( );
     SgJavaLabelSymbol_resetValidFreepointers( );
     SgLambdaRefExp_resetValidFreepointers( );
     SgLessOrEqualOp_resetValidFreepointers( );
     SgLessThanOp_resetValidFreepointers( );
     SgLineDirectiveStatement_resetValidFreepointers( );
     SgLinemarkerDirectiveStatement_resetValidFreepointers( );
     SgLinkageModifier_resetValidFreepointers( );
     SgListComprehension_resetValidFreepointers( );
     SgListExp_resetValidFreepointers( );
     SgLocatedNode_resetValidFreepointers( );
     SgLocatedNodeSupport_resetValidFreepointers( );
     SgLongDoubleVal_resetValidFreepointers( );
     SgLongIntVal_resetValidFreepointers( );
     SgLongLongIntVal_resetValidFreepointers( );
     SgLshiftAssignOp_resetValidFreepointers( );
     SgLshiftOp_resetValidFreepointers( );
     SgMemberFunctionDeclaration_resetValidFreepointers( );
     SgMemberFunctionRefExp_resetValidFreepointers( );
     SgMemberFunctionSymbol_resetValidFreepointers( );
     SgMemberFunctionType_resetValidFreepointers( );
     SgMembershipOp_resetValidFreepointers( );
     SgMinusAssignOp_resetValidFreepointers( );
     SgMinusMinusOp_resetValidFreepointers( );
     SgMinusOp_resetValidFreepointers( );
     SgModAssignOp_resetValidFreepointers( );
     SgModOp_resetValidFreepointers( );
     SgModifier_resetValidFreepointers( );
     SgModifierNodes_resetValidFreepointers( );
     SgModifierType_resetValidFreepointers( );
     SgModuleStatement_resetValidFreepointers( );
     SgModuleSymbol_resetValidFreepointers( );
     SgMultAssignOp_resetValidFreepointers( );
     SgMultiplyOp_resetValidFreepointers( );
     SgName_resetValidFreepointers( );
     SgNameGroup_resetValidFreepointers( );
     SgNamedType_resetValidFreepointers( );
     SgNamelistStatement_resetValidFreepointers( );
     SgNamespaceAliasDeclarationStatement_resetValidFreepointers( );
     SgNamespaceDeclarationStatement_resetValidFreepointers( );
     SgNamespaceDefinitionStatement_resetValidFreepointers( );
     SgNamespaceSymbol_resetValidFreepointers( );
     SgNaryOp_resetValidFreepointers( );
     SgNaryBooleanOp_resetValidFreepointers( );
     SgNaryComparisonOp_resetValidFreepointers( );
     SgNewExp_resetValidFreepointers( );
     SgNode_resetValidFreepointers( );
     SgNotEqualOp_resetValidFreepointers( );
     SgNotOp_resetValidFreepointers( );
     SgNonMembershipOp_resetValidFreepointers( );
     SgNullExpression_resetValidFreepointers( );
     SgNullStatement_resetValidFreepointers( );
     SgNullifyStatement_resetValidFreepointers( );
     SgOmpAtomicStatement_resetValidFreepointers( );
     SgOmpBarrierStatement_resetValidFreepointers( );
     SgOmpCriticalStatement_resetValidFreepointers( );
     SgOmpClauseBodyStatement_resetValidFreepointers( );
     SgOmpBodyStatement_resetValidFreepointers( );
     SgOmpDoStatement_resetValidFreepointers( );
     SgOmpFlushStatement_resetValidFreepointers( );
     SgOmpForStatement_resetValidFreepointers( );
     SgOmpMasterStatement_resetValidFreepointers( );
     SgOmpOrderedStatement_resetValidFreepointers( );
     SgOmpParallelStatement_resetValidFreepointers( );
     SgOmpSectionStatement_resetValidFreepointers( );
     SgOmpSectionsStatement_resetValidFreepointers( );
     SgOmpSingleStatement_resetValidFreepointers( );
     SgOmpTaskStatement_resetValidFreepointers( );
     SgOmpTaskwaitStatement_resetValidFreepointers( );
     SgOmpThreadprivateStatement_resetValidFreepointers( );
     SgOmpWorkshareStatement_resetValidFreepointers( );
     SgOmpClause_resetValidFreepointers( );
     SgOmpCollapseClause_resetValidFreepointers( );
     SgOmpCopyinClause_resetValidFreepointers( );
     SgOmpCopyprivateClause_resetValidFreepointers( );
     SgOmpDefaultClause_resetValidFreepointers( );
     SgOmpExpressionClause_resetValidFreepointers( );
     SgOmpFirstprivateClause_resetValidFreepointers( );
     SgOmpIfClause_resetValidFreepointers( );
     SgOmpLastprivateClause_resetValidFreepointers( );
     SgOmpNowaitClause_resetValidFreepointers( );
     SgOmpNumThreadsClause_resetValidFreepointers( );
     SgOmpOrderedClause_resetValidFreepointers( );
     SgOmpPrivateClause_resetValidFreepointers( );
     SgOmpReductionClause_resetValidFreepointers( );
     SgOmpScheduleClause_resetValidFreepointers( );
     SgOmpSharedClause_resetValidFreepointers( );
     SgOmpUntiedClause_resetValidFreepointers( );
     SgOmpVariablesClause_resetValidFreepointers( );
     SgOpenclAccessModeModifier_resetValidFreepointers( );
     SgOpenStatement_resetValidFreepointers( );
     SgOptions_resetValidFreepointers( );
     SgOrOp_resetValidFreepointers( );
     SgParameterStatement_resetValidFreepointers( );
     SgPartialFunctionModifierType_resetValidFreepointers( );
     SgPartialFunctionType_resetValidFreepointers( );
     SgPassStatement_resetValidFreepointers( );
     SgPlusAssignOp_resetValidFreepointers( );
     SgPlusPlusOp_resetValidFreepointers( );
     SgPntrArrRefExp_resetValidFreepointers( );
     SgPointerAssignOp_resetValidFreepointers( );
     SgPointerDerefExp_resetValidFreepointers( );
     SgPointerMemberType_resetValidFreepointers( );
     SgPointerType_resetValidFreepointers( );
     SgPragma_resetValidFreepointers( );
     SgPragmaDeclaration_resetValidFreepointers( );
     SgPrintStatement_resetValidFreepointers( );
     SgProcedureHeaderStatement_resetValidFreepointers( );
     SgProgramHeaderStatement_resetValidFreepointers( );
     SgProject_resetValidFreepointers( );
     SgPseudoDestructorRefExp_resetValidFreepointers( );
     SgPythonGlobalStmt_resetValidFreepointers( );
     SgPythonPrintStmt_resetValidFreepointers( );
     SgQualifiedName_resetValidFreepointers( );
     SgQualifiedNameType_resetValidFreepointers( );
     SgReadStatement_resetValidFreepointers( );
     SgRealPartOp_resetValidFreepointers( );
     SgRefExp_resetValidFreepointers( );
     SgReferenceType_resetValidFreepointers( );
     SgRenamePair_resetValidFreepointers( );
     SgRenameSymbol_resetValidFreepointers( );
     SgReturnStmt_resetValidFreepointers( );
     SgRewindStatement_resetValidFreepointers( );
     SgRshiftAssignOp_resetValidFreepointers( );
     SgRshiftOp_resetValidFreepointers( );
     SgJavaUnsignedRshiftAssignOp_resetValidFreepointers( );
     SgJavaUnsignedRshiftOp_resetValidFreepointers( );
     SgScopeOp_resetValidFreepointers( );
     SgScopeStatement_resetValidFreepointers( );
     SgSequenceStatement_resetValidFreepointers( );
     SgSetComprehension_resetValidFreepointers( );
     SgShortVal_resetValidFreepointers( );
     SgSizeOfOp_resetValidFreepointers( );
     SgJavaInstanceOfOp_resetValidFreepointers( );
     SgSourceFile_resetValidFreepointers( );
     SgSpawnStmt_resetValidFreepointers( );
     SgJavaThrowStatement_resetValidFreepointers( );
     SgJavaForEachStatement_resetValidFreepointers( );
     SgJavaSynchronizedStatement_resetValidFreepointers( );
     SgJavaParameterizedType_resetValidFreepointers( );
     SgSpecialFunctionModifier_resetValidFreepointers( );
     SgStatement_resetValidFreepointers( );
     SgStmtDeclarationStatement_resetValidFreepointers( );
     SgStatementExpression_resetValidFreepointers( );
     SgStatementFunctionStatement_resetValidFreepointers( );
     SgStopOrPauseStatement_resetValidFreepointers( );
     SgStorageModifier_resetValidFreepointers( );
     SgStringConversion_resetValidFreepointers( );
     SgStringKeyedBidirectionalGraph_resetValidFreepointers( );
     SgStringVal_resetValidFreepointers( );
     SgSubscriptExpression_resetValidFreepointers( );
     SgSubtractOp_resetValidFreepointers( );
     SgSupport_resetValidFreepointers( );
     SgSwitchStatement_resetValidFreepointers( );
     SgSymbol_resetValidFreepointers( );
     SgSymbolTable_resetValidFreepointers( );
     SgTemplateArgument_resetValidFreepointers( );
     SgTemplateArgumentList_resetValidFreepointers( );
     SgTemplateDeclaration_resetValidFreepointers( );
     SgTemplateClassDeclaration_resetValidFreepointers( );
     SgTemplateFunctionDeclaration_resetValidFreepointers( );
     SgTemplateMemberFunctionDeclaration_resetValidFreepointers( );
     SgTemplateClassDefinition_resetValidFreepointers( );
     SgTemplateFunctionDefinition_resetValidFreepointers( );
     SgTemplateInstantiationDecl_resetValidFreepointers( );
     SgTemplateInstantiationDefn_resetValidFreepointers( );
     SgTemplateInstantiationDirectiveStatement_resetValidFreepointers( );
     SgTemplateInstantiationFunctionDecl_resetValidFreepointers( );
     SgTemplateInstantiationMemberFunctionDecl_resetValidFreepointers( );
     SgTemplateParameter_resetValidFreepointers( );
     SgTemplateParameterList_resetValidFreepointers( );
     SgTemplateSymbol_resetValidFreepointers( );
     SgTemplateType_resetValidFreepointers( );
     SgThisExp_resetValidFreepointers( );
     SgSuperExp_resetValidFreepointers( );
     SgThrowOp_resetValidFreepointers( );
     SgToken_resetValidFreepointers( );
     SgTryStmt_resetValidFreepointers( );
     SgTupleExp_resetValidFreepointers( );
     SgType_resetValidFreepointers( );
     SgTypeBool_resetValidFreepointers( );
     SgTypeChar_resetValidFreepointers( );
     SgTypeComplex_resetValidFreepointers( );
     SgTypeDefault_resetValidFreepointers( );
     SgTypeLabel_resetValidFreepointers( );
     SgTypeDouble_resetValidFreepointers( );
     SgTypeEllipse_resetValidFreepointers( );
     SgTypeFloat_resetValidFreepointers( );
     SgTypeGlobalVoid_resetValidFreepointers( );
     SgTypeIdOp_resetValidFreepointers( );
     SgTypeImaginary_resetValidFreepointers( );
     SgTypeInt_resetValidFreepointers( );
     SgTypeLong_resetValidFreepointers( );
     SgTypeLongDouble_resetValidFreepointers( );
     SgTypeLongLong_resetValidFreepointers( );
     SgTypeModifier_resetValidFreepointers( );
     SgTypeShort_resetValidFreepointers( );
     SgTypeSignedChar_resetValidFreepointers( );
     SgTypeSignedInt_resetValidFreepointers( );
     SgTypeSignedLong_resetValidFreepointers( );
     SgTypeSignedLongLong_resetValidFreepointers( );
     SgTypeSignedShort_resetValidFreepointers( );
     SgTypeString_resetValidFreepointers( );
     SgTypeUnknown_resetValidFreepointers( );
     SgTypeUnsignedChar_resetValidFreepointers( );
     SgTypeUnsignedInt_resetValidFreepointers( );
     SgTypeUnsignedLong_resetValidFreepointers( );
     SgTypeUnsignedLongLong_resetValidFreepointers( );
     SgTypeUnsignedShort_resetValidFreepointers( );
     SgTypeVoid_resetValidFreepointers( );
     SgTypeWchar_resetValidFreepointers( );
     SgTypedefDeclaration_resetValidFreepointers( );
     SgTypedefSeq_resetValidFreepointers( );
     SgTypedefSymbol_resetValidFreepointers( );
     SgTypedefType_resetValidFreepointers( );
     SgUPC_AccessModifier_resetValidFreepointers( );
     SgUnaryAddOp_resetValidFreepointers( );
     SgUnaryOp_resetValidFreepointers( );
     SgUndefDirectiveStatement_resetValidFreepointers( );
     SgUndirectedGraphEdge_resetValidFreepointers( );
     SgUnknownArrayOrFunctionReference_resetValidFreepointers( );
     SgUnknownFile_resetValidFreepointers( );
     SgUnparse_Info_resetValidFreepointers( );
     SgUnsignedCharVal_resetValidFreepointers( );
     SgUnsignedIntVal_resetValidFreepointers( );
     SgUnsignedLongLongIntVal_resetValidFreepointers( );
     SgUnsignedLongVal_resetValidFreepointers( );
     SgUnsignedShortVal_resetValidFreepointers( );
     SgUpcBarrierStatement_resetValidFreepointers( );
     SgUpcBlocksizeofExpression_resetValidFreepointers( );
     SgUpcElemsizeofExpression_resetValidFreepointers( );
     SgUpcFenceStatement_resetValidFreepointers( );
     SgUpcForAllStatement_resetValidFreepointers( );
     SgUpcLocalsizeofExpression_resetValidFreepointers( );
     SgUpcMythread_resetValidFreepointers( );
     SgUpcNotifyStatement_resetValidFreepointers( );
     SgUpcThreads_resetValidFreepointers( );
     SgUpcWaitStatement_resetValidFreepointers( );
     SgUseStatement_resetValidFreepointers( );
     SgUserDefinedBinaryOp_resetValidFreepointers( );
     SgUserDefinedUnaryOp_resetValidFreepointers( );
     SgUsingDeclarationStatement_resetValidFreepointers( );
     SgUsingDirectiveStatement_resetValidFreepointers( );
     SgValueExp_resetValidFreepointers( );
     SgVarArgCopyOp_resetValidFreepointers( );
     SgVarArgEndOp_resetValidFreepointers( );
     SgVarArgOp_resetValidFreepointers( );
     SgVarArgStartOneOperandOp_resetValidFreepointers( );
     SgVarArgStartOp_resetValidFreepointers( );
     SgVarRefExp_resetValidFreepointers( );
     SgVariableDeclaration_resetValidFreepointers( );
     SgVariableDefinition_resetValidFreepointers( );
     SgVariableSymbol_resetValidFreepointers( );
     SgVariantExpression_resetValidFreepointers( );
     SgVariantStatement_resetValidFreepointers( );
     SgWaitStatement_resetValidFreepointers( );
     SgWarningDirectiveStatement_resetValidFreepointers( );
     SgWithStatement_resetValidFreepointers( );
     SgWcharVal_resetValidFreepointers( );
     SgWhereStatement_resetValidFreepointers( );
     SgWhileStmt_resetValidFreepointers( );
     SgWriteStatement_resetValidFreepointers( );
     SgXorAssignOp_resetValidFreepointers( );
     SgYieldExpression_resetValidFreepointers( );
     Sg_File_Info_resetValidFreepointers( );
     SgTypeCAFTeam_resetValidFreepointers( );
     SgCAFWithTeamStatement_resetValidFreepointers( );
     SgCAFCoExpression_resetValidFreepointers( );
     SgCallExpression_resetValidFreepointers( );
     SgTypeCrayPointer_resetValidFreepointers( );
     SgJavaImportStatement_resetValidFreepointers( );

/* #line 294 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarAST_FileIoSource.code" */
#endif
     freepointersOfCurrentAstAreSetToGlobalIndices = false;
   }


bool
AST_FILE_IO :: areFreepointersContainingGlobalIndices ( )
   {
      return freepointersOfCurrentAstAreSetToGlobalIndices;
   }



/* JH (01/03/2006) manipulatePointerDataMembers: check if the pointer points to a valid SgNode.
   First check, if the pointer is a NILL pointer. If so, do nothing. Otherwise:
   * if yes, call the appropriate virual function to receive the global index. That is stored
     in the pointer again.
   * if no, we have somehow a pointer that is not valid. Thus, we look, if the pointer is in any
     memory pools. If so, we get its global index an store it, but print a warning. If not, we
     break with an assert.
*/
unsigned long
AST_FILE_IO::getGlobalIndexFromSgClassPointer ( SgNode* pointer )
  {
  // This converts the pointer value held in the p_freepointer into a global index.
     unsigned long globalIndex = 0;
     if ( pointer != NULL )
        {
#if FILE_IO_EXTRA_CHECK
          assert ( freepointersOfCurrentAstAreSetToGlobalIndices == true );
#if 0
       // Debugging code
          printf ("In AST_FILE_IO::getGlobalIndexFromSgClassPointer(): pointer = %p \n",pointer);
          printf ("In AST_FILE_IO::getGlobalIndexFromSgClassPointer(): pointer = %p = %s \n",pointer,pointer->class_name().c_str());
          printf ("In AST_FILE_IO::getGlobalIndexFromSgClassPointer(): pointer->p_freepointer = %p \n",pointer->p_freepointer);
          printf ("In AST_FILE_IO::getGlobalIndexFromSgClassPointer(): AST_FileIO::IS_VALID_POINTER() = %p \n",AST_FileIO::IS_VALID_POINTER());
          printf ("In AST_FILE_IO::getGlobalIndexFromSgClassPointer(): pointer = %p = %s \n",pointer,pointer->class_name().c_str());
#endif
          assert ( pointer->p_freepointer != AST_FileIO::IS_VALID_POINTER() );
#endif

#if FILE_IO_EXTRA_CHECK
          if (pointer->p_freepointer == NULL)
             {
               printf ("In AST_FILE_IO::getGlobalIndexFromSgClassPointer(): pointer = %p \n",pointer);
               printf ("In AST_FILE_IO::getGlobalIndexFromSgClassPointer(): pointer = %p = %s \n",pointer,pointer->class_name().c_str());
               printf ("In AST_FILE_IO::getGlobalIndexFromSgClassPointer(): pointer->p_freepointer = %p \n",pointer->p_freepointer);
               printf ("In AST_FILE_IO::getGlobalIndexFromSgClassPointer(): AST_FileIO::IS_VALID_POINTER() = %p \n",AST_FileIO::IS_VALID_POINTER());
               printf ("In AST_FILE_IO::getGlobalIndexFromSgClassPointer(): pointer = %p = %s \n",pointer,pointer->class_name().c_str());
             }
#endif
       // DQ (6/6/2010): This is equivalent to the test for (globalIndex > 0).
          assert ( pointer->p_freepointer != NULL );

          globalIndex = (unsigned long) (pointer->p_freepointer);

#if FILE_IO_EXTRA_CHECK
          if (globalIndex == 0)
             {
               printf ("In AST_FILE_IO::getGlobalIndexFromSgClassPointer(): globalIndex = %lu \n",globalIndex);
               printf ("In AST_FILE_IO::getGlobalIndexFromSgClassPointer(): pointer = %p \n",pointer);
               printf ("In AST_FILE_IO::getGlobalIndexFromSgClassPointer(): pointer = %p = %s \n",pointer,pointer->class_name().c_str());
               printf ("In AST_FILE_IO::getGlobalIndexFromSgClassPointer(): pointer->p_freepointer = %p \n",pointer->p_freepointer);
               printf ("In AST_FILE_IO::getGlobalIndexFromSgClassPointer(): AST_FileIO::IS_VALID_POINTER() = %p \n",AST_FileIO::IS_VALID_POINTER());
               printf ("In AST_FILE_IO::getGlobalIndexFromSgClassPointer(): pointer = %p = %s \n",pointer,pointer->class_name().c_str());
             }

          assert (  0 < globalIndex );
       // DQ (7/10/2010): I think this is not a reasonable test. And large AST's demonstrate this problem.
#if 0
       // assert ( AST_FILE_IO::getAccumulatedPoolSizeOfNewAst(pointer->variantT()) <= globalIndex );
          if (AST_FILE_IO::getAccumulatedPoolSizeOfNewAst(pointer->variantT()) > globalIndex )
             {
               printf ("In AST_FILE_IO::getGlobalIndexFromSgClassPointer( SgNode* pointer = %p = %s) \n",pointer,pointer->class_name().c_str());
               printf ("     pointer->p_freepointer = %p = %zu \n",pointer->p_freepointer,(unsigned long)pointer->p_freepointer);
               printf ("     AST_FILE_IO::getAccumulatedPoolSizeOfNewAst(pointer->variantT()) = %zu \n",AST_FILE_IO::getAccumulatedPoolSizeOfNewAst(pointer->variantT()));
             }
       // assert ( AST_FILE_IO::getAccumulatedPoolSizeOfNewAst(pointer->variantT()) <= globalIndex );
#endif

       // DQ (7/10/2010): I think this is not a reasonable test. And large AST's demonstrate this problem.
#if 0
       // assert ( globalIndex < AST_FILE_IO::getAccumulatedPoolSizeOfNewAst(pointer->variantT()+1) );
          if (globalIndex >= AST_FILE_IO::getAccumulatedPoolSizeOfNewAst(pointer->variantT()+1) )
             {
               printf ("In AST_FILE_IO::getGlobalIndexFromSgClassPointer( SgNode* pointer = %p = %s) \n",pointer,pointer->class_name().c_str());
               printf ("     pointer->p_freepointer = %p = %zu \n",pointer->p_freepointer,(unsigned long)pointer->p_freepointer);
               printf ("     AST_FILE_IO::getAccumulatedPoolSizeOfNewAst(pointer->variantT()+1) = %zu \n",AST_FILE_IO::getAccumulatedPoolSizeOfNewAst(pointer->variantT()+1));
             }
       // assert ( globalIndex < AST_FILE_IO::getAccumulatedPoolSizeOfNewAst(pointer->variantT()+1) );
#endif
#endif
        }

     return globalIndex;
   }




/* JH (01/03/2006) remanipulatePointerDataMembers: check if the index stored in the pointer is
   lesss than 100, then we have one of the operate types or an builtin type. Otherwise,
   we get the pointer after computing the type od memory pool, that contains the pointer.
*/
SgNode*
AST_FILE_IO :: getSgClassPointerFromGlobalIndex ( unsigned long globalIndex )
  {
#if FILE_IO_EXTRA_CHECK
     assert ( freepointersOfCurrentAstAreSetToGlobalIndices == false );
  // std::cout << globalIndex << " " << getTotalNumberOfNodesOfAstInMemoryPool() << " " << getTotalNumberOfNodesOfNewAst( ) << std::endl;
     assert ( globalIndex < getTotalNumberOfNodesOfAstInMemoryPool() + getTotalNumberOfNodesOfNewAst( ));
#endif

     SgNode* returnPointer = NULL;

    if ( 0 < globalIndex )
       { 
         unsigned long sgVariantOfIRNodeTypeOfIndex = binarySearch ( globalIndex );
#if FILE_IO_EXTRA_CHECK
         // Check, wheather the index is really within the range of this memory pool
         assert ( getAccumulatedPoolSizeOfNewAst(sgVariantOfIRNodeTypeOfIndex) <= globalIndex );
         assert ( globalIndex < AST_FILE_IO::getAccumulatedPoolSizeOfNewAst(sgVariantOfIRNodeTypeOfIndex+1) );
#endif
         switch ( sgVariantOfIRNodeTypeOfIndex )
            {
             case V_SgAccessModifier: 
                 returnPointer =  SgAccessModifier_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgActualArgumentExpression: 
                 returnPointer =  SgActualArgumentExpression_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAddOp: 
                 returnPointer =  SgAddOp_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAddressOfOp: 
                 returnPointer =  SgAddressOfOp_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAggregateInitializer: 
                 returnPointer =  SgAggregateInitializer_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAliasSymbol: 
                 returnPointer =  SgAliasSymbol_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAllocateStatement: 
                 returnPointer =  SgAllocateStatement_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAndAssignOp: 
                 returnPointer =  SgAndAssignOp_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAndOp: 
                 returnPointer =  SgAndOp_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgArithmeticIfStatement: 
                 returnPointer =  SgArithmeticIfStatement_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgArrayType: 
                 returnPointer =  SgArrayType_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgArrowExp: 
                 returnPointer =  SgArrowExp_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgArrowStarOp: 
                 returnPointer =  SgArrowStarOp_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmArmInstruction: 
                 returnPointer =  SgAsmArmInstruction_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmArmRegisterReferenceExpression: 
                 returnPointer =  SgAsmArmRegisterReferenceExpression_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmBasicString: 
                 returnPointer =  SgAsmBasicString_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmBinaryAdd: 
                 returnPointer =  SgAsmBinaryAdd_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmBinaryAddPostupdate: 
                 returnPointer =  SgAsmBinaryAddPostupdate_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmBinaryAddPreupdate: 
                 returnPointer =  SgAsmBinaryAddPreupdate_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmBinaryAsr: 
                 returnPointer =  SgAsmBinaryAsr_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmBinaryDivide: 
                 returnPointer =  SgAsmBinaryDivide_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmBinaryExpression: 
                 returnPointer =  SgAsmBinaryExpression_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmBinaryLsl: 
                 returnPointer =  SgAsmBinaryLsl_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmBinaryLsr: 
                 returnPointer =  SgAsmBinaryLsr_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmBinaryMod: 
                 returnPointer =  SgAsmBinaryMod_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmBinaryMultiply: 
                 returnPointer =  SgAsmBinaryMultiply_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmBinaryRor: 
                 returnPointer =  SgAsmBinaryRor_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmBinarySubtract: 
                 returnPointer =  SgAsmBinarySubtract_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmBinarySubtractPostupdate: 
                 returnPointer =  SgAsmBinarySubtractPostupdate_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmBinarySubtractPreupdate: 
                 returnPointer =  SgAsmBinarySubtractPreupdate_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmBlock: 
                 returnPointer =  SgAsmBlock_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmByteValueExpression: 
                 returnPointer =  SgAsmByteValueExpression_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmCoffStrtab: 
                 returnPointer =  SgAsmCoffStrtab_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmCoffSymbol: 
                 returnPointer =  SgAsmCoffSymbol_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmCoffSymbolList: 
                 returnPointer =  SgAsmCoffSymbolList_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmCoffSymbolTable: 
                 returnPointer =  SgAsmCoffSymbolTable_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmCommonSubExpression: 
                 returnPointer =  SgAsmCommonSubExpression_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmControlFlagsExpression: 
                 returnPointer =  SgAsmControlFlagsExpression_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDOSExtendedHeader: 
                 returnPointer =  SgAsmDOSExtendedHeader_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDOSFileHeader: 
                 returnPointer =  SgAsmDOSFileHeader_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDoubleFloatValueExpression: 
                 returnPointer =  SgAsmDoubleFloatValueExpression_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDoubleWordValueExpression: 
                 returnPointer =  SgAsmDoubleWordValueExpression_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDwarfAccessDeclaration: 
                 returnPointer =  SgAsmDwarfAccessDeclaration_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDwarfArrayType: 
                 returnPointer =  SgAsmDwarfArrayType_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDwarfBaseType: 
                 returnPointer =  SgAsmDwarfBaseType_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDwarfCatchBlock: 
                 returnPointer =  SgAsmDwarfCatchBlock_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDwarfClassTemplate: 
                 returnPointer =  SgAsmDwarfClassTemplate_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDwarfClassType: 
                 returnPointer =  SgAsmDwarfClassType_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDwarfCommonBlock: 
                 returnPointer =  SgAsmDwarfCommonBlock_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDwarfCommonInclusion: 
                 returnPointer =  SgAsmDwarfCommonInclusion_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDwarfCompilationUnit: 
                 returnPointer =  SgAsmDwarfCompilationUnit_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDwarfCompilationUnitList: 
                 returnPointer =  SgAsmDwarfCompilationUnitList_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDwarfCondition: 
                 returnPointer =  SgAsmDwarfCondition_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDwarfConstType: 
                 returnPointer =  SgAsmDwarfConstType_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDwarfConstant: 
                 returnPointer =  SgAsmDwarfConstant_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDwarfConstruct: 
                 returnPointer =  SgAsmDwarfConstruct_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDwarfConstructList: 
                 returnPointer =  SgAsmDwarfConstructList_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDwarfDwarfProcedure: 
                 returnPointer =  SgAsmDwarfDwarfProcedure_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDwarfEntryPoint: 
                 returnPointer =  SgAsmDwarfEntryPoint_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDwarfEnumerationType: 
                 returnPointer =  SgAsmDwarfEnumerationType_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDwarfEnumerator: 
                 returnPointer =  SgAsmDwarfEnumerator_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDwarfFileType: 
                 returnPointer =  SgAsmDwarfFileType_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDwarfFormalParameter: 
                 returnPointer =  SgAsmDwarfFormalParameter_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDwarfFormatLabel: 
                 returnPointer =  SgAsmDwarfFormatLabel_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDwarfFriend: 
                 returnPointer =  SgAsmDwarfFriend_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDwarfFunctionTemplate: 
                 returnPointer =  SgAsmDwarfFunctionTemplate_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDwarfImportedDeclaration: 
                 returnPointer =  SgAsmDwarfImportedDeclaration_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDwarfImportedModule: 
                 returnPointer =  SgAsmDwarfImportedModule_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDwarfImportedUnit: 
                 returnPointer =  SgAsmDwarfImportedUnit_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDwarfInformation: 
                 returnPointer =  SgAsmDwarfInformation_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDwarfInheritance: 
                 returnPointer =  SgAsmDwarfInheritance_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDwarfInlinedSubroutine: 
                 returnPointer =  SgAsmDwarfInlinedSubroutine_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDwarfInterfaceType: 
                 returnPointer =  SgAsmDwarfInterfaceType_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDwarfLabel: 
                 returnPointer =  SgAsmDwarfLabel_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDwarfLexicalBlock: 
                 returnPointer =  SgAsmDwarfLexicalBlock_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDwarfLine: 
                 returnPointer =  SgAsmDwarfLine_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDwarfLineList: 
                 returnPointer =  SgAsmDwarfLineList_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDwarfMacro: 
                 returnPointer =  SgAsmDwarfMacro_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDwarfMacroList: 
                 returnPointer =  SgAsmDwarfMacroList_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDwarfMember: 
                 returnPointer =  SgAsmDwarfMember_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDwarfModule: 
                 returnPointer =  SgAsmDwarfModule_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDwarfMutableType: 
                 returnPointer =  SgAsmDwarfMutableType_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDwarfNamelist: 
                 returnPointer =  SgAsmDwarfNamelist_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDwarfNamelistItem: 
                 returnPointer =  SgAsmDwarfNamelistItem_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDwarfNamespace: 
                 returnPointer =  SgAsmDwarfNamespace_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDwarfPackedType: 
                 returnPointer =  SgAsmDwarfPackedType_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDwarfPartialUnit: 
                 returnPointer =  SgAsmDwarfPartialUnit_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDwarfPointerType: 
                 returnPointer =  SgAsmDwarfPointerType_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDwarfPtrToMemberType: 
                 returnPointer =  SgAsmDwarfPtrToMemberType_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDwarfReferenceType: 
                 returnPointer =  SgAsmDwarfReferenceType_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDwarfRestrictType: 
                 returnPointer =  SgAsmDwarfRestrictType_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDwarfSetType: 
                 returnPointer =  SgAsmDwarfSetType_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDwarfSharedType: 
                 returnPointer =  SgAsmDwarfSharedType_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDwarfStringType: 
                 returnPointer =  SgAsmDwarfStringType_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDwarfStructureType: 
                 returnPointer =  SgAsmDwarfStructureType_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDwarfSubprogram: 
                 returnPointer =  SgAsmDwarfSubprogram_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDwarfSubrangeType: 
                 returnPointer =  SgAsmDwarfSubrangeType_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDwarfSubroutineType: 
                 returnPointer =  SgAsmDwarfSubroutineType_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDwarfTemplateTypeParameter: 
                 returnPointer =  SgAsmDwarfTemplateTypeParameter_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDwarfTemplateValueParameter: 
                 returnPointer =  SgAsmDwarfTemplateValueParameter_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDwarfThrownType: 
                 returnPointer =  SgAsmDwarfThrownType_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDwarfTryBlock: 
                 returnPointer =  SgAsmDwarfTryBlock_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDwarfTypedef: 
                 returnPointer =  SgAsmDwarfTypedef_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDwarfUnionType: 
                 returnPointer =  SgAsmDwarfUnionType_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDwarfUnknownConstruct: 
                 returnPointer =  SgAsmDwarfUnknownConstruct_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDwarfUnspecifiedParameters: 
                 returnPointer =  SgAsmDwarfUnspecifiedParameters_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDwarfUnspecifiedType: 
                 returnPointer =  SgAsmDwarfUnspecifiedType_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDwarfUpcRelaxedType: 
                 returnPointer =  SgAsmDwarfUpcRelaxedType_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDwarfUpcSharedType: 
                 returnPointer =  SgAsmDwarfUpcSharedType_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDwarfUpcStrictType: 
                 returnPointer =  SgAsmDwarfUpcStrictType_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDwarfVariable: 
                 returnPointer =  SgAsmDwarfVariable_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDwarfVariant: 
                 returnPointer =  SgAsmDwarfVariant_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDwarfVariantPart: 
                 returnPointer =  SgAsmDwarfVariantPart_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDwarfVolatileType: 
                 returnPointer =  SgAsmDwarfVolatileType_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmDwarfWithStmt: 
                 returnPointer =  SgAsmDwarfWithStmt_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmElfDynamicEntry: 
                 returnPointer =  SgAsmElfDynamicEntry_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmElfDynamicEntryList: 
                 returnPointer =  SgAsmElfDynamicEntryList_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmElfDynamicSection: 
                 returnPointer =  SgAsmElfDynamicSection_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmElfEHFrameEntryCI: 
                 returnPointer =  SgAsmElfEHFrameEntryCI_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmElfEHFrameEntryCIList: 
                 returnPointer =  SgAsmElfEHFrameEntryCIList_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmElfEHFrameEntryFD: 
                 returnPointer =  SgAsmElfEHFrameEntryFD_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmElfEHFrameEntryFDList: 
                 returnPointer =  SgAsmElfEHFrameEntryFDList_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmElfEHFrameSection: 
                 returnPointer =  SgAsmElfEHFrameSection_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmElfFileHeader: 
                 returnPointer =  SgAsmElfFileHeader_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmElfNoteEntry: 
                 returnPointer =  SgAsmElfNoteEntry_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmElfNoteEntryList: 
                 returnPointer =  SgAsmElfNoteEntryList_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmElfNoteSection: 
                 returnPointer =  SgAsmElfNoteSection_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmElfRelocEntry: 
                 returnPointer =  SgAsmElfRelocEntry_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmElfRelocEntryList: 
                 returnPointer =  SgAsmElfRelocEntryList_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmElfRelocSection: 
                 returnPointer =  SgAsmElfRelocSection_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmElfSection: 
                 returnPointer =  SgAsmElfSection_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmElfSectionTable: 
                 returnPointer =  SgAsmElfSectionTable_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmElfSectionTableEntry: 
                 returnPointer =  SgAsmElfSectionTableEntry_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmElfSegmentTable: 
                 returnPointer =  SgAsmElfSegmentTable_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmElfSegmentTableEntry: 
                 returnPointer =  SgAsmElfSegmentTableEntry_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmElfSegmentTableEntryList: 
                 returnPointer =  SgAsmElfSegmentTableEntryList_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmElfStringSection: 
                 returnPointer =  SgAsmElfStringSection_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmElfStrtab: 
                 returnPointer =  SgAsmElfStrtab_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmElfSymbol: 
                 returnPointer =  SgAsmElfSymbol_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmElfSymbolList: 
                 returnPointer =  SgAsmElfSymbolList_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmElfSymbolSection: 
                 returnPointer =  SgAsmElfSymbolSection_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmElfSymverDefinedAux: 
                 returnPointer =  SgAsmElfSymverDefinedAux_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmElfSymverDefinedAuxList: 
                 returnPointer =  SgAsmElfSymverDefinedAuxList_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmElfSymverDefinedEntry: 
                 returnPointer =  SgAsmElfSymverDefinedEntry_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmElfSymverDefinedEntryList: 
                 returnPointer =  SgAsmElfSymverDefinedEntryList_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmElfSymverDefinedSection: 
                 returnPointer =  SgAsmElfSymverDefinedSection_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmElfSymverEntry: 
                 returnPointer =  SgAsmElfSymverEntry_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmElfSymverEntryList: 
                 returnPointer =  SgAsmElfSymverEntryList_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmElfSymverNeededAux: 
                 returnPointer =  SgAsmElfSymverNeededAux_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmElfSymverNeededAuxList: 
                 returnPointer =  SgAsmElfSymverNeededAuxList_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmElfSymverNeededEntry: 
                 returnPointer =  SgAsmElfSymverNeededEntry_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmElfSymverNeededEntryList: 
                 returnPointer =  SgAsmElfSymverNeededEntryList_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmElfSymverNeededSection: 
                 returnPointer =  SgAsmElfSymverNeededSection_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmElfSymverSection: 
                 returnPointer =  SgAsmElfSymverSection_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmExecutableFileFormat: 
                 returnPointer =  SgAsmExecutableFileFormat_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmExprListExp: 
                 returnPointer =  SgAsmExprListExp_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmExpression: 
                 returnPointer =  SgAsmExpression_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmFunction: 
                 returnPointer =  SgAsmFunction_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmGenericDLL: 
                 returnPointer =  SgAsmGenericDLL_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmGenericDLLList: 
                 returnPointer =  SgAsmGenericDLLList_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmGenericFile: 
                 returnPointer =  SgAsmGenericFile_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmGenericFileList: 
                 returnPointer =  SgAsmGenericFileList_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmGenericFormat: 
                 returnPointer =  SgAsmGenericFormat_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmGenericHeader: 
                 returnPointer =  SgAsmGenericHeader_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmGenericHeaderList: 
                 returnPointer =  SgAsmGenericHeaderList_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmGenericSection: 
                 returnPointer =  SgAsmGenericSection_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmGenericSectionList: 
                 returnPointer =  SgAsmGenericSectionList_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmGenericString: 
                 returnPointer =  SgAsmGenericString_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmGenericStrtab: 
                 returnPointer =  SgAsmGenericStrtab_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmGenericSymbol: 
                 returnPointer =  SgAsmGenericSymbol_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmGenericSymbolList: 
                 returnPointer =  SgAsmGenericSymbolList_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmInstruction: 
                 returnPointer =  SgAsmInstruction_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmIntegerValueExpression: 
                 returnPointer =  SgAsmIntegerValueExpression_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmInterpretation: 
                 returnPointer =  SgAsmInterpretation_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmInterpretationList: 
                 returnPointer =  SgAsmInterpretationList_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmLEEntryPoint: 
                 returnPointer =  SgAsmLEEntryPoint_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmLEEntryTable: 
                 returnPointer =  SgAsmLEEntryTable_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmLEFileHeader: 
                 returnPointer =  SgAsmLEFileHeader_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmLENameTable: 
                 returnPointer =  SgAsmLENameTable_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmLEPageTable: 
                 returnPointer =  SgAsmLEPageTable_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmLEPageTableEntry: 
                 returnPointer =  SgAsmLEPageTableEntry_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmLERelocTable: 
                 returnPointer =  SgAsmLERelocTable_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmLESection: 
                 returnPointer =  SgAsmLESection_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmLESectionTable: 
                 returnPointer =  SgAsmLESectionTable_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmLESectionTableEntry: 
                 returnPointer =  SgAsmLESectionTableEntry_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmMemoryReferenceExpression: 
                 returnPointer =  SgAsmMemoryReferenceExpression_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmNEEntryPoint: 
                 returnPointer =  SgAsmNEEntryPoint_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmNEEntryTable: 
                 returnPointer =  SgAsmNEEntryTable_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmNEFileHeader: 
                 returnPointer =  SgAsmNEFileHeader_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmNEModuleTable: 
                 returnPointer =  SgAsmNEModuleTable_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmNENameTable: 
                 returnPointer =  SgAsmNENameTable_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmNERelocEntry: 
                 returnPointer =  SgAsmNERelocEntry_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmNERelocTable: 
                 returnPointer =  SgAsmNERelocTable_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmNESection: 
                 returnPointer =  SgAsmNESection_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmNESectionTable: 
                 returnPointer =  SgAsmNESectionTable_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmNESectionTableEntry: 
                 returnPointer =  SgAsmNESectionTableEntry_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmNEStringTable: 
                 returnPointer =  SgAsmNEStringTable_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmNode: 
                 returnPointer =  SgAsmNode_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmOp: 
                 returnPointer =  SgAsmOp_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmOperandList: 
                 returnPointer =  SgAsmOperandList_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmPEExportDirectory: 
                 returnPointer =  SgAsmPEExportDirectory_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmPEExportEntry: 
                 returnPointer =  SgAsmPEExportEntry_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmPEExportEntryList: 
                 returnPointer =  SgAsmPEExportEntryList_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmPEExportSection: 
                 returnPointer =  SgAsmPEExportSection_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmPEFileHeader: 
                 returnPointer =  SgAsmPEFileHeader_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmPEImportDirectory: 
                 returnPointer =  SgAsmPEImportDirectory_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmPEImportDirectoryList: 
                 returnPointer =  SgAsmPEImportDirectoryList_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmPEImportItem: 
                 returnPointer =  SgAsmPEImportItem_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmPEImportItemList: 
                 returnPointer =  SgAsmPEImportItemList_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmPEImportSection: 
                 returnPointer =  SgAsmPEImportSection_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmPERVASizePair: 
                 returnPointer =  SgAsmPERVASizePair_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmPERVASizePairList: 
                 returnPointer =  SgAsmPERVASizePairList_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmPESection: 
                 returnPointer =  SgAsmPESection_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmPESectionTable: 
                 returnPointer =  SgAsmPESectionTable_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmPESectionTableEntry: 
                 returnPointer =  SgAsmPESectionTableEntry_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmPEStringSection: 
                 returnPointer =  SgAsmPEStringSection_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmPowerpcInstruction: 
                 returnPointer =  SgAsmPowerpcInstruction_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmPowerpcRegisterReferenceExpression: 
                 returnPointer =  SgAsmPowerpcRegisterReferenceExpression_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmQuadWordValueExpression: 
                 returnPointer =  SgAsmQuadWordValueExpression_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmRegisterReferenceExpression: 
                 returnPointer =  SgAsmRegisterReferenceExpression_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmSingleFloatValueExpression: 
                 returnPointer =  SgAsmSingleFloatValueExpression_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmStatement: 
                 returnPointer =  SgAsmStatement_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmStaticData: 
                 returnPointer =  SgAsmStaticData_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmStmt: 
                 returnPointer =  SgAsmStmt_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmStoredString: 
                 returnPointer =  SgAsmStoredString_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmStringStorage: 
                 returnPointer =  SgAsmStringStorage_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmType: 
                 returnPointer =  SgAsmType_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmType128bitFloat: 
                 returnPointer =  SgAsmType128bitFloat_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmType80bitFloat: 
                 returnPointer =  SgAsmType80bitFloat_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmTypeByte: 
                 returnPointer =  SgAsmTypeByte_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmTypeDoubleFloat: 
                 returnPointer =  SgAsmTypeDoubleFloat_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmTypeDoubleQuadWord: 
                 returnPointer =  SgAsmTypeDoubleQuadWord_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmTypeDoubleWord: 
                 returnPointer =  SgAsmTypeDoubleWord_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmTypeQuadWord: 
                 returnPointer =  SgAsmTypeQuadWord_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmTypeSingleFloat: 
                 returnPointer =  SgAsmTypeSingleFloat_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmTypeVector: 
                 returnPointer =  SgAsmTypeVector_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmTypeWord: 
                 returnPointer =  SgAsmTypeWord_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmUnaryArmSpecialRegisterList: 
                 returnPointer =  SgAsmUnaryArmSpecialRegisterList_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmUnaryExpression: 
                 returnPointer =  SgAsmUnaryExpression_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmUnaryMinus: 
                 returnPointer =  SgAsmUnaryMinus_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmUnaryPlus: 
                 returnPointer =  SgAsmUnaryPlus_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmUnaryRrx: 
                 returnPointer =  SgAsmUnaryRrx_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmValueExpression: 
                 returnPointer =  SgAsmValueExpression_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmVectorValueExpression: 
                 returnPointer =  SgAsmVectorValueExpression_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmWordValueExpression: 
                 returnPointer =  SgAsmWordValueExpression_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmx86Instruction: 
                 returnPointer =  SgAsmx86Instruction_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmx86RegisterReferenceExpression: 
                 returnPointer =  SgAsmx86RegisterReferenceExpression_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmBinaryAddressSymbol: 
                 returnPointer =  SgAsmBinaryAddressSymbol_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsmBinaryDataSymbol: 
                 returnPointer =  SgAsmBinaryDataSymbol_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAssertStmt: 
                 returnPointer =  SgAssertStmt_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAssignInitializer: 
                 returnPointer =  SgAssignInitializer_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAssignOp: 
                 returnPointer =  SgAssignOp_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAssignStatement: 
                 returnPointer =  SgAssignStatement_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAssignedGotoStatement: 
                 returnPointer =  SgAssignedGotoStatement_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAssociateStatement: 
                 returnPointer =  SgAssociateStatement_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAsteriskShapeExp: 
                 returnPointer =  SgAsteriskShapeExp_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAttribute: 
                 returnPointer =  SgAttribute_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgAttributeSpecificationStatement: 
                 returnPointer =  SgAttributeSpecificationStatement_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgBackspaceStatement: 
                 returnPointer =  SgBackspaceStatement_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgBaseClass: 
                 returnPointer =  SgBaseClass_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgExpBaseClass: 
                 returnPointer =  SgExpBaseClass_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgBaseClassModifier: 
                 returnPointer =  SgBaseClassModifier_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgBasicBlock: 
                 returnPointer =  SgBasicBlock_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgBidirectionalGraph: 
                 returnPointer =  SgBidirectionalGraph_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgBinaryComposite: 
                 returnPointer =  SgBinaryComposite_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgBinaryOp: 
                 returnPointer =  SgBinaryOp_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgBitAndOp: 
                 returnPointer =  SgBitAndOp_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgBitAttribute: 
                 returnPointer =  SgBitAttribute_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgBitComplementOp: 
                 returnPointer =  SgBitComplementOp_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgBitOrOp: 
                 returnPointer =  SgBitOrOp_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgBitXorOp: 
                 returnPointer =  SgBitXorOp_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgBlockDataStatement: 
                 returnPointer =  SgBlockDataStatement_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgBoolValExp: 
                 returnPointer =  SgBoolValExp_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgBreakStmt: 
                 returnPointer =  SgBreakStmt_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgC_PreprocessorDirectiveStatement: 
                 returnPointer =  SgC_PreprocessorDirectiveStatement_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgCaseOptionStmt: 
                 returnPointer =  SgCaseOptionStmt_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgCastExp: 
                 returnPointer =  SgCastExp_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgCatchOptionStmt: 
                 returnPointer =  SgCatchOptionStmt_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgCatchStatementSeq: 
                 returnPointer =  SgCatchStatementSeq_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgCharVal: 
                 returnPointer =  SgCharVal_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgClassDecl_attr: 
                 returnPointer =  SgClassDecl_attr_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgClassDeclaration: 
                 returnPointer =  SgClassDeclaration_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgClassDefinition: 
                 returnPointer =  SgClassDefinition_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgClassNameRefExp: 
                 returnPointer =  SgClassNameRefExp_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgClassSymbol: 
                 returnPointer =  SgClassSymbol_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgClassType: 
                 returnPointer =  SgClassType_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgClinkageDeclarationStatement: 
                 returnPointer =  SgClinkageDeclarationStatement_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgClinkageEndStatement: 
                 returnPointer =  SgClinkageEndStatement_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgClinkageStartStatement: 
                 returnPointer =  SgClinkageStartStatement_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgCloseStatement: 
                 returnPointer =  SgCloseStatement_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgColonShapeExp: 
                 returnPointer =  SgColonShapeExp_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgCommaOpExp: 
                 returnPointer =  SgCommaOpExp_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgCommonBlock: 
                 returnPointer =  SgCommonBlock_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgCommonBlockObject: 
                 returnPointer =  SgCommonBlockObject_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgCommonSymbol: 
                 returnPointer =  SgCommonSymbol_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgComplexVal: 
                 returnPointer =  SgComplexVal_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgComprehension: 
                 returnPointer =  SgComprehension_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgCompoundAssignOp: 
                 returnPointer =  SgCompoundAssignOp_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgCompoundInitializer: 
                 returnPointer =  SgCompoundInitializer_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgComputedGotoStatement: 
                 returnPointer =  SgComputedGotoStatement_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgConcatenationOp: 
                 returnPointer =  SgConcatenationOp_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgConditionalExp: 
                 returnPointer =  SgConditionalExp_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgConjugateOp: 
                 returnPointer =  SgConjugateOp_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgConstVolatileModifier: 
                 returnPointer =  SgConstVolatileModifier_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgConstructorInitializer: 
                 returnPointer =  SgConstructorInitializer_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgContainsStatement: 
                 returnPointer =  SgContainsStatement_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgContinueStmt: 
                 returnPointer =  SgContinueStmt_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgCtorInitializerList: 
                 returnPointer =  SgCtorInitializerList_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgDataStatementGroup: 
                 returnPointer =  SgDataStatementGroup_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgDataStatementObject: 
                 returnPointer =  SgDataStatementObject_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgDataStatementValue: 
                 returnPointer =  SgDataStatementValue_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgDeadIfDirectiveStatement: 
                 returnPointer =  SgDeadIfDirectiveStatement_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgDeallocateStatement: 
                 returnPointer =  SgDeallocateStatement_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgDeclarationModifier: 
                 returnPointer =  SgDeclarationModifier_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgDeclarationStatement: 
                 returnPointer =  SgDeclarationStatement_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgDefaultOptionStmt: 
                 returnPointer =  SgDefaultOptionStmt_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgDefaultSymbol: 
                 returnPointer =  SgDefaultSymbol_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgDefineDirectiveStatement: 
                 returnPointer =  SgDefineDirectiveStatement_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgDeleteExp: 
                 returnPointer =  SgDeleteExp_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgDerivedTypeStatement: 
                 returnPointer =  SgDerivedTypeStatement_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgDesignatedInitializer: 
                 returnPointer =  SgDesignatedInitializer_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgDictionaryComprehension: 
                 returnPointer =  SgDictionaryComprehension_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgDictionaryExp: 
                 returnPointer =  SgDictionaryExp_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgDimensionObject: 
                 returnPointer =  SgDimensionObject_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgDirectedGraphEdge: 
                 returnPointer =  SgDirectedGraphEdge_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgDirectory: 
                 returnPointer =  SgDirectory_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgDirectoryList: 
                 returnPointer =  SgDirectoryList_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgDivAssignOp: 
                 returnPointer =  SgDivAssignOp_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgDivideOp: 
                 returnPointer =  SgDivideOp_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgDoWhileStmt: 
                 returnPointer =  SgDoWhileStmt_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgDotExp: 
                 returnPointer =  SgDotExp_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgDotStarOp: 
                 returnPointer =  SgDotStarOp_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgDoubleVal: 
                 returnPointer =  SgDoubleVal_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgElaboratedTypeModifier: 
                 returnPointer =  SgElaboratedTypeModifier_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgElseDirectiveStatement: 
                 returnPointer =  SgElseDirectiveStatement_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgElseWhereStatement: 
                 returnPointer =  SgElseWhereStatement_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgElseifDirectiveStatement: 
                 returnPointer =  SgElseifDirectiveStatement_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgEmptyDirectiveStatement: 
                 returnPointer =  SgEmptyDirectiveStatement_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgEndfileStatement: 
                 returnPointer =  SgEndfileStatement_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgEndifDirectiveStatement: 
                 returnPointer =  SgEndifDirectiveStatement_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgEntryStatement: 
                 returnPointer =  SgEntryStatement_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgEnumDeclaration: 
                 returnPointer =  SgEnumDeclaration_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgEnumFieldSymbol: 
                 returnPointer =  SgEnumFieldSymbol_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgEnumSymbol: 
                 returnPointer =  SgEnumSymbol_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgEnumType: 
                 returnPointer =  SgEnumType_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgEnumVal: 
                 returnPointer =  SgEnumVal_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgEqualityOp: 
                 returnPointer =  SgEqualityOp_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgEquivalenceStatement: 
                 returnPointer =  SgEquivalenceStatement_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgErrorDirectiveStatement: 
                 returnPointer =  SgErrorDirectiveStatement_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgExecStatement: 
                 returnPointer =  SgExecStatement_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgExponentiationOp: 
                 returnPointer =  SgExponentiationOp_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgExponentiationAssignOp: 
                 returnPointer =  SgExponentiationAssignOp_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgExprListExp: 
                 returnPointer =  SgExprListExp_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgExprStatement: 
                 returnPointer =  SgExprStatement_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgExpression: 
                 returnPointer =  SgExpression_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgExpressionRoot: 
                 returnPointer =  SgExpressionRoot_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgFile: 
                 returnPointer =  SgFile_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgFileList: 
                 returnPointer =  SgFileList_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgFloatVal: 
                 returnPointer =  SgFloatVal_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgFlushStatement: 
                 returnPointer =  SgFlushStatement_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgForAllStatement: 
                 returnPointer =  SgForAllStatement_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgForInitStatement: 
                 returnPointer =  SgForInitStatement_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgForStatement: 
                 returnPointer =  SgForStatement_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgFormatItem: 
                 returnPointer =  SgFormatItem_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgFormatItemList: 
                 returnPointer =  SgFormatItemList_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgFormatStatement: 
                 returnPointer =  SgFormatStatement_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgFortranDo: 
                 returnPointer =  SgFortranDo_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgFortranIncludeLine: 
                 returnPointer =  SgFortranIncludeLine_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgFortranNonblockedDo: 
                 returnPointer =  SgFortranNonblockedDo_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgFuncDecl_attr: 
                 returnPointer =  SgFuncDecl_attr_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgFunctionCallExp: 
                 returnPointer =  SgFunctionCallExp_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgFunctionDeclaration: 
                 returnPointer =  SgFunctionDeclaration_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgFunctionDefinition: 
                 returnPointer =  SgFunctionDefinition_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgFunctionModifier: 
                 returnPointer =  SgFunctionModifier_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgFunctionParameterList: 
                 returnPointer =  SgFunctionParameterList_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgFunctionParameterTypeList: 
                 returnPointer =  SgFunctionParameterTypeList_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgFunctionRefExp: 
                 returnPointer =  SgFunctionRefExp_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgFunctionSymbol: 
                 returnPointer =  SgFunctionSymbol_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgFunctionType: 
                 returnPointer =  SgFunctionType_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgFunctionTypeSymbol: 
                 returnPointer =  SgFunctionTypeSymbol_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgFunctionTypeTable: 
                 returnPointer =  SgFunctionTypeTable_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgTypeTable: 
                 returnPointer =  SgTypeTable_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgGlobal: 
                 returnPointer =  SgGlobal_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgGotoStatement: 
                 returnPointer =  SgGotoStatement_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgGraph: 
                 returnPointer =  SgGraph_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgGraphEdge: 
                 returnPointer =  SgGraphEdge_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgGraphEdgeList: 
                 returnPointer =  SgGraphEdgeList_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgGraphNode: 
                 returnPointer =  SgGraphNode_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgGraphNodeList: 
                 returnPointer =  SgGraphNodeList_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgGreaterOrEqualOp: 
                 returnPointer =  SgGreaterOrEqualOp_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgGreaterThanOp: 
                 returnPointer =  SgGreaterThanOp_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgIOItemExpression: 
                 returnPointer =  SgIOItemExpression_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgIOStatement: 
                 returnPointer =  SgIOStatement_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgIdentDirectiveStatement: 
                 returnPointer =  SgIdentDirectiveStatement_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgIfDirectiveStatement: 
                 returnPointer =  SgIfDirectiveStatement_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgIfStmt: 
                 returnPointer =  SgIfStmt_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgIfdefDirectiveStatement: 
                 returnPointer =  SgIfdefDirectiveStatement_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgIfndefDirectiveStatement: 
                 returnPointer =  SgIfndefDirectiveStatement_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgImagPartOp: 
                 returnPointer =  SgImagPartOp_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgImplicitStatement: 
                 returnPointer =  SgImplicitStatement_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgImpliedDo: 
                 returnPointer =  SgImpliedDo_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgImportStatement: 
                 returnPointer =  SgImportStatement_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgIncidenceDirectedGraph: 
                 returnPointer =  SgIncidenceDirectedGraph_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgIncidenceUndirectedGraph: 
                 returnPointer =  SgIncidenceUndirectedGraph_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgIncludeDirectiveStatement: 
                 returnPointer =  SgIncludeDirectiveStatement_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgIncludeNextDirectiveStatement: 
                 returnPointer =  SgIncludeNextDirectiveStatement_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgInitializedName: 
                 returnPointer =  SgInitializedName_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgInitializer: 
                 returnPointer =  SgInitializer_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgInquireStatement: 
                 returnPointer =  SgInquireStatement_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgIntKeyedBidirectionalGraph: 
                 returnPointer =  SgIntKeyedBidirectionalGraph_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgIntVal: 
                 returnPointer =  SgIntVal_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgIntegerDivideOp: 
                 returnPointer =  SgIntegerDivideOp_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgIntegerDivideAssignOp: 
                 returnPointer =  SgIntegerDivideAssignOp_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgInterfaceBody: 
                 returnPointer =  SgInterfaceBody_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgHeaderFileBody: 
                 returnPointer =  SgHeaderFileBody_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgInterfaceStatement: 
                 returnPointer =  SgInterfaceStatement_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgInterfaceSymbol: 
                 returnPointer =  SgInterfaceSymbol_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgIntrinsicSymbol: 
                 returnPointer =  SgIntrinsicSymbol_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgIsOp: 
                 returnPointer =  SgIsOp_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgIsNotOp: 
                 returnPointer =  SgIsNotOp_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgIorAssignOp: 
                 returnPointer =  SgIorAssignOp_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgKeyDatumPair: 
                 returnPointer =  SgKeyDatumPair_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgCudaKernelExecConfig: 
                 returnPointer =  SgCudaKernelExecConfig_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgCudaKernelCallExp: 
                 returnPointer =  SgCudaKernelCallExp_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgLabelRefExp: 
                 returnPointer =  SgLabelRefExp_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgLabelStatement: 
                 returnPointer =  SgLabelStatement_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgJavaLabelStatement: 
                 returnPointer =  SgJavaLabelStatement_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgLabelSymbol: 
                 returnPointer =  SgLabelSymbol_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgJavaLabelSymbol: 
                 returnPointer =  SgJavaLabelSymbol_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgLambdaRefExp: 
                 returnPointer =  SgLambdaRefExp_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgLessOrEqualOp: 
                 returnPointer =  SgLessOrEqualOp_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgLessThanOp: 
                 returnPointer =  SgLessThanOp_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgLineDirectiveStatement: 
                 returnPointer =  SgLineDirectiveStatement_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgLinemarkerDirectiveStatement: 
                 returnPointer =  SgLinemarkerDirectiveStatement_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgLinkageModifier: 
                 returnPointer =  SgLinkageModifier_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgListComprehension: 
                 returnPointer =  SgListComprehension_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgListExp: 
                 returnPointer =  SgListExp_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgLocatedNode: 
                 returnPointer =  SgLocatedNode_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgLocatedNodeSupport: 
                 returnPointer =  SgLocatedNodeSupport_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgLongDoubleVal: 
                 returnPointer =  SgLongDoubleVal_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgLongIntVal: 
                 returnPointer =  SgLongIntVal_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgLongLongIntVal: 
                 returnPointer =  SgLongLongIntVal_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgLshiftAssignOp: 
                 returnPointer =  SgLshiftAssignOp_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgLshiftOp: 
                 returnPointer =  SgLshiftOp_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgMemberFunctionDeclaration: 
                 returnPointer =  SgMemberFunctionDeclaration_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgMemberFunctionRefExp: 
                 returnPointer =  SgMemberFunctionRefExp_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgMemberFunctionSymbol: 
                 returnPointer =  SgMemberFunctionSymbol_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgMemberFunctionType: 
                 returnPointer =  SgMemberFunctionType_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgMembershipOp: 
                 returnPointer =  SgMembershipOp_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgMinusAssignOp: 
                 returnPointer =  SgMinusAssignOp_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgMinusMinusOp: 
                 returnPointer =  SgMinusMinusOp_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgMinusOp: 
                 returnPointer =  SgMinusOp_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgModAssignOp: 
                 returnPointer =  SgModAssignOp_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgModOp: 
                 returnPointer =  SgModOp_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgModifier: 
                 returnPointer =  SgModifier_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgModifierNodes: 
                 returnPointer =  SgModifierNodes_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgModifierType: 
                 returnPointer =  SgModifierType_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgModuleStatement: 
                 returnPointer =  SgModuleStatement_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgModuleSymbol: 
                 returnPointer =  SgModuleSymbol_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgMultAssignOp: 
                 returnPointer =  SgMultAssignOp_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgMultiplyOp: 
                 returnPointer =  SgMultiplyOp_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgName: 
                 returnPointer =  SgName_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgNameGroup: 
                 returnPointer =  SgNameGroup_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgNamedType: 
                 returnPointer =  SgNamedType_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgNamelistStatement: 
                 returnPointer =  SgNamelistStatement_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgNamespaceAliasDeclarationStatement: 
                 returnPointer =  SgNamespaceAliasDeclarationStatement_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgNamespaceDeclarationStatement: 
                 returnPointer =  SgNamespaceDeclarationStatement_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgNamespaceDefinitionStatement: 
                 returnPointer =  SgNamespaceDefinitionStatement_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgNamespaceSymbol: 
                 returnPointer =  SgNamespaceSymbol_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgNaryOp: 
                 returnPointer =  SgNaryOp_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgNaryBooleanOp: 
                 returnPointer =  SgNaryBooleanOp_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgNaryComparisonOp: 
                 returnPointer =  SgNaryComparisonOp_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgNewExp: 
                 returnPointer =  SgNewExp_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgNode: 
                 returnPointer =  SgNode_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgNotEqualOp: 
                 returnPointer =  SgNotEqualOp_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgNotOp: 
                 returnPointer =  SgNotOp_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgNonMembershipOp: 
                 returnPointer =  SgNonMembershipOp_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgNullExpression: 
                 returnPointer =  SgNullExpression_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgNullStatement: 
                 returnPointer =  SgNullStatement_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgNullifyStatement: 
                 returnPointer =  SgNullifyStatement_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgOmpAtomicStatement: 
                 returnPointer =  SgOmpAtomicStatement_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgOmpBarrierStatement: 
                 returnPointer =  SgOmpBarrierStatement_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgOmpCriticalStatement: 
                 returnPointer =  SgOmpCriticalStatement_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgOmpClauseBodyStatement: 
                 returnPointer =  SgOmpClauseBodyStatement_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgOmpBodyStatement: 
                 returnPointer =  SgOmpBodyStatement_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgOmpDoStatement: 
                 returnPointer =  SgOmpDoStatement_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgOmpFlushStatement: 
                 returnPointer =  SgOmpFlushStatement_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgOmpForStatement: 
                 returnPointer =  SgOmpForStatement_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgOmpMasterStatement: 
                 returnPointer =  SgOmpMasterStatement_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgOmpOrderedStatement: 
                 returnPointer =  SgOmpOrderedStatement_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgOmpParallelStatement: 
                 returnPointer =  SgOmpParallelStatement_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgOmpSectionStatement: 
                 returnPointer =  SgOmpSectionStatement_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgOmpSectionsStatement: 
                 returnPointer =  SgOmpSectionsStatement_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgOmpSingleStatement: 
                 returnPointer =  SgOmpSingleStatement_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgOmpTaskStatement: 
                 returnPointer =  SgOmpTaskStatement_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgOmpTaskwaitStatement: 
                 returnPointer =  SgOmpTaskwaitStatement_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgOmpThreadprivateStatement: 
                 returnPointer =  SgOmpThreadprivateStatement_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgOmpWorkshareStatement: 
                 returnPointer =  SgOmpWorkshareStatement_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgOmpClause: 
                 returnPointer =  SgOmpClause_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgOmpCollapseClause: 
                 returnPointer =  SgOmpCollapseClause_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgOmpCopyinClause: 
                 returnPointer =  SgOmpCopyinClause_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgOmpCopyprivateClause: 
                 returnPointer =  SgOmpCopyprivateClause_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgOmpDefaultClause: 
                 returnPointer =  SgOmpDefaultClause_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgOmpExpressionClause: 
                 returnPointer =  SgOmpExpressionClause_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgOmpFirstprivateClause: 
                 returnPointer =  SgOmpFirstprivateClause_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgOmpIfClause: 
                 returnPointer =  SgOmpIfClause_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgOmpLastprivateClause: 
                 returnPointer =  SgOmpLastprivateClause_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgOmpNowaitClause: 
                 returnPointer =  SgOmpNowaitClause_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgOmpNumThreadsClause: 
                 returnPointer =  SgOmpNumThreadsClause_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgOmpOrderedClause: 
                 returnPointer =  SgOmpOrderedClause_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgOmpPrivateClause: 
                 returnPointer =  SgOmpPrivateClause_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgOmpReductionClause: 
                 returnPointer =  SgOmpReductionClause_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgOmpScheduleClause: 
                 returnPointer =  SgOmpScheduleClause_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgOmpSharedClause: 
                 returnPointer =  SgOmpSharedClause_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgOmpUntiedClause: 
                 returnPointer =  SgOmpUntiedClause_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgOmpVariablesClause: 
                 returnPointer =  SgOmpVariablesClause_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgOpenclAccessModeModifier: 
                 returnPointer =  SgOpenclAccessModeModifier_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgOpenStatement: 
                 returnPointer =  SgOpenStatement_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgOptions: 
                 returnPointer =  SgOptions_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgOrOp: 
                 returnPointer =  SgOrOp_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgParameterStatement: 
                 returnPointer =  SgParameterStatement_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgPartialFunctionModifierType: 
                 returnPointer =  SgPartialFunctionModifierType_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgPartialFunctionType: 
                 returnPointer =  SgPartialFunctionType_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgPassStatement: 
                 returnPointer =  SgPassStatement_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgPlusAssignOp: 
                 returnPointer =  SgPlusAssignOp_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgPlusPlusOp: 
                 returnPointer =  SgPlusPlusOp_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgPntrArrRefExp: 
                 returnPointer =  SgPntrArrRefExp_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgPointerAssignOp: 
                 returnPointer =  SgPointerAssignOp_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgPointerDerefExp: 
                 returnPointer =  SgPointerDerefExp_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgPointerMemberType: 
                 returnPointer =  SgPointerMemberType_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgPointerType: 
                 returnPointer =  SgPointerType_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgPragma: 
                 returnPointer =  SgPragma_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgPragmaDeclaration: 
                 returnPointer =  SgPragmaDeclaration_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgPrintStatement: 
                 returnPointer =  SgPrintStatement_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgProcedureHeaderStatement: 
                 returnPointer =  SgProcedureHeaderStatement_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgProgramHeaderStatement: 
                 returnPointer =  SgProgramHeaderStatement_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgProject: 
                 returnPointer =  SgProject_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgPseudoDestructorRefExp: 
                 returnPointer =  SgPseudoDestructorRefExp_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgPythonGlobalStmt: 
                 returnPointer =  SgPythonGlobalStmt_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgPythonPrintStmt: 
                 returnPointer =  SgPythonPrintStmt_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgQualifiedName: 
                 returnPointer =  SgQualifiedName_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgQualifiedNameType: 
                 returnPointer =  SgQualifiedNameType_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgReadStatement: 
                 returnPointer =  SgReadStatement_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgRealPartOp: 
                 returnPointer =  SgRealPartOp_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgRefExp: 
                 returnPointer =  SgRefExp_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgReferenceType: 
                 returnPointer =  SgReferenceType_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgRenamePair: 
                 returnPointer =  SgRenamePair_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgRenameSymbol: 
                 returnPointer =  SgRenameSymbol_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgReturnStmt: 
                 returnPointer =  SgReturnStmt_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgRewindStatement: 
                 returnPointer =  SgRewindStatement_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgRshiftAssignOp: 
                 returnPointer =  SgRshiftAssignOp_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgRshiftOp: 
                 returnPointer =  SgRshiftOp_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgJavaUnsignedRshiftAssignOp: 
                 returnPointer =  SgJavaUnsignedRshiftAssignOp_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgJavaUnsignedRshiftOp: 
                 returnPointer =  SgJavaUnsignedRshiftOp_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgScopeOp: 
                 returnPointer =  SgScopeOp_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgScopeStatement: 
                 returnPointer =  SgScopeStatement_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgSequenceStatement: 
                 returnPointer =  SgSequenceStatement_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgSetComprehension: 
                 returnPointer =  SgSetComprehension_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgShortVal: 
                 returnPointer =  SgShortVal_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgSizeOfOp: 
                 returnPointer =  SgSizeOfOp_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgJavaInstanceOfOp: 
                 returnPointer =  SgJavaInstanceOfOp_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgSourceFile: 
                 returnPointer =  SgSourceFile_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgSpawnStmt: 
                 returnPointer =  SgSpawnStmt_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgJavaThrowStatement: 
                 returnPointer =  SgJavaThrowStatement_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgJavaForEachStatement: 
                 returnPointer =  SgJavaForEachStatement_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgJavaSynchronizedStatement: 
                 returnPointer =  SgJavaSynchronizedStatement_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgJavaParameterizedType: 
                 returnPointer =  SgJavaParameterizedType_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgSpecialFunctionModifier: 
                 returnPointer =  SgSpecialFunctionModifier_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgStatement: 
                 returnPointer =  SgStatement_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgStmtDeclarationStatement: 
                 returnPointer =  SgStmtDeclarationStatement_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgStatementExpression: 
                 returnPointer =  SgStatementExpression_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgStatementFunctionStatement: 
                 returnPointer =  SgStatementFunctionStatement_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgStopOrPauseStatement: 
                 returnPointer =  SgStopOrPauseStatement_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgStorageModifier: 
                 returnPointer =  SgStorageModifier_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgStringConversion: 
                 returnPointer =  SgStringConversion_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgStringKeyedBidirectionalGraph: 
                 returnPointer =  SgStringKeyedBidirectionalGraph_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgStringVal: 
                 returnPointer =  SgStringVal_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgSubscriptExpression: 
                 returnPointer =  SgSubscriptExpression_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgSubtractOp: 
                 returnPointer =  SgSubtractOp_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgSupport: 
                 returnPointer =  SgSupport_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgSwitchStatement: 
                 returnPointer =  SgSwitchStatement_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgSymbol: 
                 returnPointer =  SgSymbol_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgSymbolTable: 
                 returnPointer =  SgSymbolTable_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgTemplateArgument: 
                 returnPointer =  SgTemplateArgument_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgTemplateArgumentList: 
                 returnPointer =  SgTemplateArgumentList_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgTemplateDeclaration: 
                 returnPointer =  SgTemplateDeclaration_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgTemplateClassDeclaration: 
                 returnPointer =  SgTemplateClassDeclaration_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgTemplateFunctionDeclaration: 
                 returnPointer =  SgTemplateFunctionDeclaration_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgTemplateMemberFunctionDeclaration: 
                 returnPointer =  SgTemplateMemberFunctionDeclaration_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgTemplateClassDefinition: 
                 returnPointer =  SgTemplateClassDefinition_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgTemplateFunctionDefinition: 
                 returnPointer =  SgTemplateFunctionDefinition_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgTemplateInstantiationDecl: 
                 returnPointer =  SgTemplateInstantiationDecl_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgTemplateInstantiationDefn: 
                 returnPointer =  SgTemplateInstantiationDefn_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgTemplateInstantiationDirectiveStatement: 
                 returnPointer =  SgTemplateInstantiationDirectiveStatement_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgTemplateInstantiationFunctionDecl: 
                 returnPointer =  SgTemplateInstantiationFunctionDecl_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgTemplateInstantiationMemberFunctionDecl: 
                 returnPointer =  SgTemplateInstantiationMemberFunctionDecl_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgTemplateParameter: 
                 returnPointer =  SgTemplateParameter_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgTemplateParameterList: 
                 returnPointer =  SgTemplateParameterList_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgTemplateSymbol: 
                 returnPointer =  SgTemplateSymbol_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgTemplateType: 
                 returnPointer =  SgTemplateType_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgThisExp: 
                 returnPointer =  SgThisExp_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgSuperExp: 
                 returnPointer =  SgSuperExp_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgThrowOp: 
                 returnPointer =  SgThrowOp_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgToken: 
                 returnPointer =  SgToken_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgTryStmt: 
                 returnPointer =  SgTryStmt_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgTupleExp: 
                 returnPointer =  SgTupleExp_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgType: 
                 returnPointer =  SgType_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgTypeBool: 
                 returnPointer =  SgTypeBool_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgTypeChar: 
                 returnPointer =  SgTypeChar_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgTypeComplex: 
                 returnPointer =  SgTypeComplex_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgTypeDefault: 
                 returnPointer =  SgTypeDefault_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgTypeLabel: 
                 returnPointer =  SgTypeLabel_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgTypeDouble: 
                 returnPointer =  SgTypeDouble_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgTypeEllipse: 
                 returnPointer =  SgTypeEllipse_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgTypeFloat: 
                 returnPointer =  SgTypeFloat_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgTypeGlobalVoid: 
                 returnPointer =  SgTypeGlobalVoid_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgTypeIdOp: 
                 returnPointer =  SgTypeIdOp_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgTypeImaginary: 
                 returnPointer =  SgTypeImaginary_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgTypeInt: 
                 returnPointer =  SgTypeInt_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgTypeLong: 
                 returnPointer =  SgTypeLong_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgTypeLongDouble: 
                 returnPointer =  SgTypeLongDouble_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgTypeLongLong: 
                 returnPointer =  SgTypeLongLong_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgTypeModifier: 
                 returnPointer =  SgTypeModifier_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgTypeShort: 
                 returnPointer =  SgTypeShort_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgTypeSignedChar: 
                 returnPointer =  SgTypeSignedChar_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgTypeSignedInt: 
                 returnPointer =  SgTypeSignedInt_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgTypeSignedLong: 
                 returnPointer =  SgTypeSignedLong_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgTypeSignedLongLong: 
                 returnPointer =  SgTypeSignedLongLong_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgTypeSignedShort: 
                 returnPointer =  SgTypeSignedShort_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgTypeString: 
                 returnPointer =  SgTypeString_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgTypeUnknown: 
                 returnPointer =  SgTypeUnknown_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgTypeUnsignedChar: 
                 returnPointer =  SgTypeUnsignedChar_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgTypeUnsignedInt: 
                 returnPointer =  SgTypeUnsignedInt_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgTypeUnsignedLong: 
                 returnPointer =  SgTypeUnsignedLong_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgTypeUnsignedLongLong: 
                 returnPointer =  SgTypeUnsignedLongLong_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgTypeUnsignedShort: 
                 returnPointer =  SgTypeUnsignedShort_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgTypeVoid: 
                 returnPointer =  SgTypeVoid_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgTypeWchar: 
                 returnPointer =  SgTypeWchar_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgTypedefDeclaration: 
                 returnPointer =  SgTypedefDeclaration_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgTypedefSeq: 
                 returnPointer =  SgTypedefSeq_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgTypedefSymbol: 
                 returnPointer =  SgTypedefSymbol_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgTypedefType: 
                 returnPointer =  SgTypedefType_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgUPC_AccessModifier: 
                 returnPointer =  SgUPC_AccessModifier_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgUnaryAddOp: 
                 returnPointer =  SgUnaryAddOp_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgUnaryOp: 
                 returnPointer =  SgUnaryOp_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgUndefDirectiveStatement: 
                 returnPointer =  SgUndefDirectiveStatement_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgUndirectedGraphEdge: 
                 returnPointer =  SgUndirectedGraphEdge_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgUnknownArrayOrFunctionReference: 
                 returnPointer =  SgUnknownArrayOrFunctionReference_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgUnknownFile: 
                 returnPointer =  SgUnknownFile_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgUnparse_Info: 
                 returnPointer =  SgUnparse_Info_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgUnsignedCharVal: 
                 returnPointer =  SgUnsignedCharVal_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgUnsignedIntVal: 
                 returnPointer =  SgUnsignedIntVal_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgUnsignedLongLongIntVal: 
                 returnPointer =  SgUnsignedLongLongIntVal_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgUnsignedLongVal: 
                 returnPointer =  SgUnsignedLongVal_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgUnsignedShortVal: 
                 returnPointer =  SgUnsignedShortVal_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgUpcBarrierStatement: 
                 returnPointer =  SgUpcBarrierStatement_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgUpcBlocksizeofExpression: 
                 returnPointer =  SgUpcBlocksizeofExpression_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgUpcElemsizeofExpression: 
                 returnPointer =  SgUpcElemsizeofExpression_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgUpcFenceStatement: 
                 returnPointer =  SgUpcFenceStatement_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgUpcForAllStatement: 
                 returnPointer =  SgUpcForAllStatement_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgUpcLocalsizeofExpression: 
                 returnPointer =  SgUpcLocalsizeofExpression_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgUpcMythread: 
                 returnPointer =  SgUpcMythread_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgUpcNotifyStatement: 
                 returnPointer =  SgUpcNotifyStatement_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgUpcThreads: 
                 returnPointer =  SgUpcThreads_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgUpcWaitStatement: 
                 returnPointer =  SgUpcWaitStatement_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgUseStatement: 
                 returnPointer =  SgUseStatement_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgUserDefinedBinaryOp: 
                 returnPointer =  SgUserDefinedBinaryOp_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgUserDefinedUnaryOp: 
                 returnPointer =  SgUserDefinedUnaryOp_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgUsingDeclarationStatement: 
                 returnPointer =  SgUsingDeclarationStatement_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgUsingDirectiveStatement: 
                 returnPointer =  SgUsingDirectiveStatement_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgValueExp: 
                 returnPointer =  SgValueExp_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgVarArgCopyOp: 
                 returnPointer =  SgVarArgCopyOp_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgVarArgEndOp: 
                 returnPointer =  SgVarArgEndOp_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgVarArgOp: 
                 returnPointer =  SgVarArgOp_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgVarArgStartOneOperandOp: 
                 returnPointer =  SgVarArgStartOneOperandOp_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgVarArgStartOp: 
                 returnPointer =  SgVarArgStartOp_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgVarRefExp: 
                 returnPointer =  SgVarRefExp_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgVariableDeclaration: 
                 returnPointer =  SgVariableDeclaration_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgVariableDefinition: 
                 returnPointer =  SgVariableDefinition_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgVariableSymbol: 
                 returnPointer =  SgVariableSymbol_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgVariantExpression: 
                 returnPointer =  SgVariantExpression_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgVariantStatement: 
                 returnPointer =  SgVariantStatement_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgWaitStatement: 
                 returnPointer =  SgWaitStatement_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgWarningDirectiveStatement: 
                 returnPointer =  SgWarningDirectiveStatement_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgWithStatement: 
                 returnPointer =  SgWithStatement_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgWcharVal: 
                 returnPointer =  SgWcharVal_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgWhereStatement: 
                 returnPointer =  SgWhereStatement_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgWhileStmt: 
                 returnPointer =  SgWhileStmt_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgWriteStatement: 
                 returnPointer =  SgWriteStatement_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgXorAssignOp: 
                 returnPointer =  SgXorAssignOp_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgYieldExpression: 
                 returnPointer =  SgYieldExpression_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_Sg_File_Info: 
                 returnPointer =  Sg_File_Info_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgTypeCAFTeam: 
                 returnPointer =  SgTypeCAFTeam_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgCAFWithTeamStatement: 
                 returnPointer =  SgCAFWithTeamStatement_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgCAFCoExpression: 
                 returnPointer =  SgCAFCoExpression_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgCallExpression: 
                 returnPointer =  SgCallExpression_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgTypeCrayPointer: 
                 returnPointer =  SgTypeCrayPointer_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
             case V_SgJavaImportStatement: 
                 returnPointer =  SgJavaImportStatement_getPointerFromGlobalIndex( globalIndex )  ;
                break ; 
              default:
                 assert ( !" Index error in getPointerFromGlobalIndex !" ) ;
                 break ;
            }
#if FILE_IO_EXTRA_CHECK
         assert ( returnPointer != NULL );
#endif
       }

/* #line 410 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarAST_FileIoSource.code" */

     return returnPointer;
   }



/* JH (01/03/2006) This mehtods steps through all memory pools and deletes all data contained in
   the pools, to prepare the base for starting the memory extension for rebuilding the AST.
*/
void
AST_FILE_IO :: clearAllMemoryPools ( )
  {
    freepointersOfCurrentAstAreSetToGlobalIndices = false;
 // JH (08/08/2006) calling delete on the roots of the stored ASTs, in order to have 
 // empty memory pools afterwards
    for (unsigned long i = 0; i < vectorOfASTs.size(); ++i)
       {
         delete (vectorOfASTs[i]->getRootOfAst());
       }
 // JH (08/08/2006) the new version of clear memory pools has nothing to delete anymore, 
 // but still sets the freepointers to have a ordered linked list - maybe this method 
 // should now be renamed  ...

     SgAccessModifier_clearMemoryPool( );
     SgActualArgumentExpression_clearMemoryPool( );
     SgAddOp_clearMemoryPool( );
     SgAddressOfOp_clearMemoryPool( );
     SgAggregateInitializer_clearMemoryPool( );
     SgAliasSymbol_clearMemoryPool( );
     SgAllocateStatement_clearMemoryPool( );
     SgAndAssignOp_clearMemoryPool( );
     SgAndOp_clearMemoryPool( );
     SgArithmeticIfStatement_clearMemoryPool( );
     SgArrayType_clearMemoryPool( );
     SgArrowExp_clearMemoryPool( );
     SgArrowStarOp_clearMemoryPool( );
     SgAsmArmInstruction_clearMemoryPool( );
     SgAsmArmRegisterReferenceExpression_clearMemoryPool( );
     SgAsmBasicString_clearMemoryPool( );
     SgAsmBinaryAdd_clearMemoryPool( );
     SgAsmBinaryAddPostupdate_clearMemoryPool( );
     SgAsmBinaryAddPreupdate_clearMemoryPool( );
     SgAsmBinaryAsr_clearMemoryPool( );
     SgAsmBinaryDivide_clearMemoryPool( );
     SgAsmBinaryExpression_clearMemoryPool( );
     SgAsmBinaryLsl_clearMemoryPool( );
     SgAsmBinaryLsr_clearMemoryPool( );
     SgAsmBinaryMod_clearMemoryPool( );
     SgAsmBinaryMultiply_clearMemoryPool( );
     SgAsmBinaryRor_clearMemoryPool( );
     SgAsmBinarySubtract_clearMemoryPool( );
     SgAsmBinarySubtractPostupdate_clearMemoryPool( );
     SgAsmBinarySubtractPreupdate_clearMemoryPool( );
     SgAsmBlock_clearMemoryPool( );
     SgAsmByteValueExpression_clearMemoryPool( );
     SgAsmCoffStrtab_clearMemoryPool( );
     SgAsmCoffSymbol_clearMemoryPool( );
     SgAsmCoffSymbolList_clearMemoryPool( );
     SgAsmCoffSymbolTable_clearMemoryPool( );
     SgAsmCommonSubExpression_clearMemoryPool( );
     SgAsmControlFlagsExpression_clearMemoryPool( );
     SgAsmDOSExtendedHeader_clearMemoryPool( );
     SgAsmDOSFileHeader_clearMemoryPool( );
     SgAsmDoubleFloatValueExpression_clearMemoryPool( );
     SgAsmDoubleWordValueExpression_clearMemoryPool( );
     SgAsmDwarfAccessDeclaration_clearMemoryPool( );
     SgAsmDwarfArrayType_clearMemoryPool( );
     SgAsmDwarfBaseType_clearMemoryPool( );
     SgAsmDwarfCatchBlock_clearMemoryPool( );
     SgAsmDwarfClassTemplate_clearMemoryPool( );
     SgAsmDwarfClassType_clearMemoryPool( );
     SgAsmDwarfCommonBlock_clearMemoryPool( );
     SgAsmDwarfCommonInclusion_clearMemoryPool( );
     SgAsmDwarfCompilationUnit_clearMemoryPool( );
     SgAsmDwarfCompilationUnitList_clearMemoryPool( );
     SgAsmDwarfCondition_clearMemoryPool( );
     SgAsmDwarfConstType_clearMemoryPool( );
     SgAsmDwarfConstant_clearMemoryPool( );
     SgAsmDwarfConstruct_clearMemoryPool( );
     SgAsmDwarfConstructList_clearMemoryPool( );
     SgAsmDwarfDwarfProcedure_clearMemoryPool( );
     SgAsmDwarfEntryPoint_clearMemoryPool( );
     SgAsmDwarfEnumerationType_clearMemoryPool( );
     SgAsmDwarfEnumerator_clearMemoryPool( );
     SgAsmDwarfFileType_clearMemoryPool( );
     SgAsmDwarfFormalParameter_clearMemoryPool( );
     SgAsmDwarfFormatLabel_clearMemoryPool( );
     SgAsmDwarfFriend_clearMemoryPool( );
     SgAsmDwarfFunctionTemplate_clearMemoryPool( );
     SgAsmDwarfImportedDeclaration_clearMemoryPool( );
     SgAsmDwarfImportedModule_clearMemoryPool( );
     SgAsmDwarfImportedUnit_clearMemoryPool( );
     SgAsmDwarfInformation_clearMemoryPool( );
     SgAsmDwarfInheritance_clearMemoryPool( );
     SgAsmDwarfInlinedSubroutine_clearMemoryPool( );
     SgAsmDwarfInterfaceType_clearMemoryPool( );
     SgAsmDwarfLabel_clearMemoryPool( );
     SgAsmDwarfLexicalBlock_clearMemoryPool( );
     SgAsmDwarfLine_clearMemoryPool( );
     SgAsmDwarfLineList_clearMemoryPool( );
     SgAsmDwarfMacro_clearMemoryPool( );
     SgAsmDwarfMacroList_clearMemoryPool( );
     SgAsmDwarfMember_clearMemoryPool( );
     SgAsmDwarfModule_clearMemoryPool( );
     SgAsmDwarfMutableType_clearMemoryPool( );
     SgAsmDwarfNamelist_clearMemoryPool( );
     SgAsmDwarfNamelistItem_clearMemoryPool( );
     SgAsmDwarfNamespace_clearMemoryPool( );
     SgAsmDwarfPackedType_clearMemoryPool( );
     SgAsmDwarfPartialUnit_clearMemoryPool( );
     SgAsmDwarfPointerType_clearMemoryPool( );
     SgAsmDwarfPtrToMemberType_clearMemoryPool( );
     SgAsmDwarfReferenceType_clearMemoryPool( );
     SgAsmDwarfRestrictType_clearMemoryPool( );
     SgAsmDwarfSetType_clearMemoryPool( );
     SgAsmDwarfSharedType_clearMemoryPool( );
     SgAsmDwarfStringType_clearMemoryPool( );
     SgAsmDwarfStructureType_clearMemoryPool( );
     SgAsmDwarfSubprogram_clearMemoryPool( );
     SgAsmDwarfSubrangeType_clearMemoryPool( );
     SgAsmDwarfSubroutineType_clearMemoryPool( );
     SgAsmDwarfTemplateTypeParameter_clearMemoryPool( );
     SgAsmDwarfTemplateValueParameter_clearMemoryPool( );
     SgAsmDwarfThrownType_clearMemoryPool( );
     SgAsmDwarfTryBlock_clearMemoryPool( );
     SgAsmDwarfTypedef_clearMemoryPool( );
     SgAsmDwarfUnionType_clearMemoryPool( );
     SgAsmDwarfUnknownConstruct_clearMemoryPool( );
     SgAsmDwarfUnspecifiedParameters_clearMemoryPool( );
     SgAsmDwarfUnspecifiedType_clearMemoryPool( );
     SgAsmDwarfUpcRelaxedType_clearMemoryPool( );
     SgAsmDwarfUpcSharedType_clearMemoryPool( );
     SgAsmDwarfUpcStrictType_clearMemoryPool( );
     SgAsmDwarfVariable_clearMemoryPool( );
     SgAsmDwarfVariant_clearMemoryPool( );
     SgAsmDwarfVariantPart_clearMemoryPool( );
     SgAsmDwarfVolatileType_clearMemoryPool( );
     SgAsmDwarfWithStmt_clearMemoryPool( );
     SgAsmElfDynamicEntry_clearMemoryPool( );
     SgAsmElfDynamicEntryList_clearMemoryPool( );
     SgAsmElfDynamicSection_clearMemoryPool( );
     SgAsmElfEHFrameEntryCI_clearMemoryPool( );
     SgAsmElfEHFrameEntryCIList_clearMemoryPool( );
     SgAsmElfEHFrameEntryFD_clearMemoryPool( );
     SgAsmElfEHFrameEntryFDList_clearMemoryPool( );
     SgAsmElfEHFrameSection_clearMemoryPool( );
     SgAsmElfFileHeader_clearMemoryPool( );
     SgAsmElfNoteEntry_clearMemoryPool( );
     SgAsmElfNoteEntryList_clearMemoryPool( );
     SgAsmElfNoteSection_clearMemoryPool( );
     SgAsmElfRelocEntry_clearMemoryPool( );
     SgAsmElfRelocEntryList_clearMemoryPool( );
     SgAsmElfRelocSection_clearMemoryPool( );
     SgAsmElfSection_clearMemoryPool( );
     SgAsmElfSectionTable_clearMemoryPool( );
     SgAsmElfSectionTableEntry_clearMemoryPool( );
     SgAsmElfSegmentTable_clearMemoryPool( );
     SgAsmElfSegmentTableEntry_clearMemoryPool( );
     SgAsmElfSegmentTableEntryList_clearMemoryPool( );
     SgAsmElfStringSection_clearMemoryPool( );
     SgAsmElfStrtab_clearMemoryPool( );
     SgAsmElfSymbol_clearMemoryPool( );
     SgAsmElfSymbolList_clearMemoryPool( );
     SgAsmElfSymbolSection_clearMemoryPool( );
     SgAsmElfSymverDefinedAux_clearMemoryPool( );
     SgAsmElfSymverDefinedAuxList_clearMemoryPool( );
     SgAsmElfSymverDefinedEntry_clearMemoryPool( );
     SgAsmElfSymverDefinedEntryList_clearMemoryPool( );
     SgAsmElfSymverDefinedSection_clearMemoryPool( );
     SgAsmElfSymverEntry_clearMemoryPool( );
     SgAsmElfSymverEntryList_clearMemoryPool( );
     SgAsmElfSymverNeededAux_clearMemoryPool( );
     SgAsmElfSymverNeededAuxList_clearMemoryPool( );
     SgAsmElfSymverNeededEntry_clearMemoryPool( );
     SgAsmElfSymverNeededEntryList_clearMemoryPool( );
     SgAsmElfSymverNeededSection_clearMemoryPool( );
     SgAsmElfSymverSection_clearMemoryPool( );
     SgAsmExecutableFileFormat_clearMemoryPool( );
     SgAsmExprListExp_clearMemoryPool( );
     SgAsmExpression_clearMemoryPool( );
     SgAsmFunction_clearMemoryPool( );
     SgAsmGenericDLL_clearMemoryPool( );
     SgAsmGenericDLLList_clearMemoryPool( );
     SgAsmGenericFile_clearMemoryPool( );
     SgAsmGenericFileList_clearMemoryPool( );
     SgAsmGenericFormat_clearMemoryPool( );
     SgAsmGenericHeader_clearMemoryPool( );
     SgAsmGenericHeaderList_clearMemoryPool( );
     SgAsmGenericSection_clearMemoryPool( );
     SgAsmGenericSectionList_clearMemoryPool( );
     SgAsmGenericString_clearMemoryPool( );
     SgAsmGenericStrtab_clearMemoryPool( );
     SgAsmGenericSymbol_clearMemoryPool( );
     SgAsmGenericSymbolList_clearMemoryPool( );
     SgAsmInstruction_clearMemoryPool( );
     SgAsmIntegerValueExpression_clearMemoryPool( );
     SgAsmInterpretation_clearMemoryPool( );
     SgAsmInterpretationList_clearMemoryPool( );
     SgAsmLEEntryPoint_clearMemoryPool( );
     SgAsmLEEntryTable_clearMemoryPool( );
     SgAsmLEFileHeader_clearMemoryPool( );
     SgAsmLENameTable_clearMemoryPool( );
     SgAsmLEPageTable_clearMemoryPool( );
     SgAsmLEPageTableEntry_clearMemoryPool( );
     SgAsmLERelocTable_clearMemoryPool( );
     SgAsmLESection_clearMemoryPool( );
     SgAsmLESectionTable_clearMemoryPool( );
     SgAsmLESectionTableEntry_clearMemoryPool( );
     SgAsmMemoryReferenceExpression_clearMemoryPool( );
     SgAsmNEEntryPoint_clearMemoryPool( );
     SgAsmNEEntryTable_clearMemoryPool( );
     SgAsmNEFileHeader_clearMemoryPool( );
     SgAsmNEModuleTable_clearMemoryPool( );
     SgAsmNENameTable_clearMemoryPool( );
     SgAsmNERelocEntry_clearMemoryPool( );
     SgAsmNERelocTable_clearMemoryPool( );
     SgAsmNESection_clearMemoryPool( );
     SgAsmNESectionTable_clearMemoryPool( );
     SgAsmNESectionTableEntry_clearMemoryPool( );
     SgAsmNEStringTable_clearMemoryPool( );
     SgAsmNode_clearMemoryPool( );
     SgAsmOp_clearMemoryPool( );
     SgAsmOperandList_clearMemoryPool( );
     SgAsmPEExportDirectory_clearMemoryPool( );
     SgAsmPEExportEntry_clearMemoryPool( );
     SgAsmPEExportEntryList_clearMemoryPool( );
     SgAsmPEExportSection_clearMemoryPool( );
     SgAsmPEFileHeader_clearMemoryPool( );
     SgAsmPEImportDirectory_clearMemoryPool( );
     SgAsmPEImportDirectoryList_clearMemoryPool( );
     SgAsmPEImportItem_clearMemoryPool( );
     SgAsmPEImportItemList_clearMemoryPool( );
     SgAsmPEImportSection_clearMemoryPool( );
     SgAsmPERVASizePair_clearMemoryPool( );
     SgAsmPERVASizePairList_clearMemoryPool( );
     SgAsmPESection_clearMemoryPool( );
     SgAsmPESectionTable_clearMemoryPool( );
     SgAsmPESectionTableEntry_clearMemoryPool( );
     SgAsmPEStringSection_clearMemoryPool( );
     SgAsmPowerpcInstruction_clearMemoryPool( );
     SgAsmPowerpcRegisterReferenceExpression_clearMemoryPool( );
     SgAsmQuadWordValueExpression_clearMemoryPool( );
     SgAsmRegisterReferenceExpression_clearMemoryPool( );
     SgAsmSingleFloatValueExpression_clearMemoryPool( );
     SgAsmStatement_clearMemoryPool( );
     SgAsmStaticData_clearMemoryPool( );
     SgAsmStmt_clearMemoryPool( );
     SgAsmStoredString_clearMemoryPool( );
     SgAsmStringStorage_clearMemoryPool( );
     SgAsmType_clearMemoryPool( );
     SgAsmType128bitFloat_clearMemoryPool( );
     SgAsmType80bitFloat_clearMemoryPool( );
     SgAsmTypeByte_clearMemoryPool( );
     SgAsmTypeDoubleFloat_clearMemoryPool( );
     SgAsmTypeDoubleQuadWord_clearMemoryPool( );
     SgAsmTypeDoubleWord_clearMemoryPool( );
     SgAsmTypeQuadWord_clearMemoryPool( );
     SgAsmTypeSingleFloat_clearMemoryPool( );
     SgAsmTypeVector_clearMemoryPool( );
     SgAsmTypeWord_clearMemoryPool( );
     SgAsmUnaryArmSpecialRegisterList_clearMemoryPool( );
     SgAsmUnaryExpression_clearMemoryPool( );
     SgAsmUnaryMinus_clearMemoryPool( );
     SgAsmUnaryPlus_clearMemoryPool( );
     SgAsmUnaryRrx_clearMemoryPool( );
     SgAsmValueExpression_clearMemoryPool( );
     SgAsmVectorValueExpression_clearMemoryPool( );
     SgAsmWordValueExpression_clearMemoryPool( );
     SgAsmx86Instruction_clearMemoryPool( );
     SgAsmx86RegisterReferenceExpression_clearMemoryPool( );
     SgAsmBinaryAddressSymbol_clearMemoryPool( );
     SgAsmBinaryDataSymbol_clearMemoryPool( );
     SgAssertStmt_clearMemoryPool( );
     SgAssignInitializer_clearMemoryPool( );
     SgAssignOp_clearMemoryPool( );
     SgAssignStatement_clearMemoryPool( );
     SgAssignedGotoStatement_clearMemoryPool( );
     SgAssociateStatement_clearMemoryPool( );
     SgAsteriskShapeExp_clearMemoryPool( );
     SgAttribute_clearMemoryPool( );
     SgAttributeSpecificationStatement_clearMemoryPool( );
     SgBackspaceStatement_clearMemoryPool( );
     SgBaseClass_clearMemoryPool( );
     SgExpBaseClass_clearMemoryPool( );
     SgBaseClassModifier_clearMemoryPool( );
     SgBasicBlock_clearMemoryPool( );
     SgBidirectionalGraph_clearMemoryPool( );
     SgBinaryComposite_clearMemoryPool( );
     SgBinaryOp_clearMemoryPool( );
     SgBitAndOp_clearMemoryPool( );
     SgBitAttribute_clearMemoryPool( );
     SgBitComplementOp_clearMemoryPool( );
     SgBitOrOp_clearMemoryPool( );
     SgBitXorOp_clearMemoryPool( );
     SgBlockDataStatement_clearMemoryPool( );
     SgBoolValExp_clearMemoryPool( );
     SgBreakStmt_clearMemoryPool( );
     SgC_PreprocessorDirectiveStatement_clearMemoryPool( );
     SgCaseOptionStmt_clearMemoryPool( );
     SgCastExp_clearMemoryPool( );
     SgCatchOptionStmt_clearMemoryPool( );
     SgCatchStatementSeq_clearMemoryPool( );
     SgCharVal_clearMemoryPool( );
     SgClassDecl_attr_clearMemoryPool( );
     SgClassDeclaration_clearMemoryPool( );
     SgClassDefinition_clearMemoryPool( );
     SgClassNameRefExp_clearMemoryPool( );
     SgClassSymbol_clearMemoryPool( );
     SgClassType_clearMemoryPool( );
     SgClinkageDeclarationStatement_clearMemoryPool( );
     SgClinkageEndStatement_clearMemoryPool( );
     SgClinkageStartStatement_clearMemoryPool( );
     SgCloseStatement_clearMemoryPool( );
     SgColonShapeExp_clearMemoryPool( );
     SgCommaOpExp_clearMemoryPool( );
     SgCommonBlock_clearMemoryPool( );
     SgCommonBlockObject_clearMemoryPool( );
     SgCommonSymbol_clearMemoryPool( );
     SgComplexVal_clearMemoryPool( );
     SgComprehension_clearMemoryPool( );
     SgCompoundAssignOp_clearMemoryPool( );
     SgCompoundInitializer_clearMemoryPool( );
     SgComputedGotoStatement_clearMemoryPool( );
     SgConcatenationOp_clearMemoryPool( );
     SgConditionalExp_clearMemoryPool( );
     SgConjugateOp_clearMemoryPool( );
     SgConstVolatileModifier_clearMemoryPool( );
     SgConstructorInitializer_clearMemoryPool( );
     SgContainsStatement_clearMemoryPool( );
     SgContinueStmt_clearMemoryPool( );
     SgCtorInitializerList_clearMemoryPool( );
     SgDataStatementGroup_clearMemoryPool( );
     SgDataStatementObject_clearMemoryPool( );
     SgDataStatementValue_clearMemoryPool( );
     SgDeadIfDirectiveStatement_clearMemoryPool( );
     SgDeallocateStatement_clearMemoryPool( );
     SgDeclarationModifier_clearMemoryPool( );
     SgDeclarationStatement_clearMemoryPool( );
     SgDefaultOptionStmt_clearMemoryPool( );
     SgDefaultSymbol_clearMemoryPool( );
     SgDefineDirectiveStatement_clearMemoryPool( );
     SgDeleteExp_clearMemoryPool( );
     SgDerivedTypeStatement_clearMemoryPool( );
     SgDesignatedInitializer_clearMemoryPool( );
     SgDictionaryComprehension_clearMemoryPool( );
     SgDictionaryExp_clearMemoryPool( );
     SgDimensionObject_clearMemoryPool( );
     SgDirectedGraphEdge_clearMemoryPool( );
     SgDirectory_clearMemoryPool( );
     SgDirectoryList_clearMemoryPool( );
     SgDivAssignOp_clearMemoryPool( );
     SgDivideOp_clearMemoryPool( );
     SgDoWhileStmt_clearMemoryPool( );
     SgDotExp_clearMemoryPool( );
     SgDotStarOp_clearMemoryPool( );
     SgDoubleVal_clearMemoryPool( );
     SgElaboratedTypeModifier_clearMemoryPool( );
     SgElseDirectiveStatement_clearMemoryPool( );
     SgElseWhereStatement_clearMemoryPool( );
     SgElseifDirectiveStatement_clearMemoryPool( );
     SgEmptyDirectiveStatement_clearMemoryPool( );
     SgEndfileStatement_clearMemoryPool( );
     SgEndifDirectiveStatement_clearMemoryPool( );
     SgEntryStatement_clearMemoryPool( );
     SgEnumDeclaration_clearMemoryPool( );
     SgEnumFieldSymbol_clearMemoryPool( );
     SgEnumSymbol_clearMemoryPool( );
     SgEnumType_clearMemoryPool( );
     SgEnumVal_clearMemoryPool( );
     SgEqualityOp_clearMemoryPool( );
     SgEquivalenceStatement_clearMemoryPool( );
     SgErrorDirectiveStatement_clearMemoryPool( );
     SgExecStatement_clearMemoryPool( );
     SgExponentiationOp_clearMemoryPool( );
     SgExponentiationAssignOp_clearMemoryPool( );
     SgExprListExp_clearMemoryPool( );
     SgExprStatement_clearMemoryPool( );
     SgExpression_clearMemoryPool( );
     SgExpressionRoot_clearMemoryPool( );
     SgFile_clearMemoryPool( );
     SgFileList_clearMemoryPool( );
     SgFloatVal_clearMemoryPool( );
     SgFlushStatement_clearMemoryPool( );
     SgForAllStatement_clearMemoryPool( );
     SgForInitStatement_clearMemoryPool( );
     SgForStatement_clearMemoryPool( );
     SgFormatItem_clearMemoryPool( );
     SgFormatItemList_clearMemoryPool( );
     SgFormatStatement_clearMemoryPool( );
     SgFortranDo_clearMemoryPool( );
     SgFortranIncludeLine_clearMemoryPool( );
     SgFortranNonblockedDo_clearMemoryPool( );
     SgFuncDecl_attr_clearMemoryPool( );
     SgFunctionCallExp_clearMemoryPool( );
     SgFunctionDeclaration_clearMemoryPool( );
     SgFunctionDefinition_clearMemoryPool( );
     SgFunctionModifier_clearMemoryPool( );
     SgFunctionParameterList_clearMemoryPool( );
     SgFunctionParameterTypeList_clearMemoryPool( );
     SgFunctionRefExp_clearMemoryPool( );
     SgFunctionSymbol_clearMemoryPool( );
     SgFunctionType_clearMemoryPool( );
     SgFunctionTypeSymbol_clearMemoryPool( );
     SgFunctionTypeTable_clearMemoryPool( );
     SgTypeTable_clearMemoryPool( );
     SgGlobal_clearMemoryPool( );
     SgGotoStatement_clearMemoryPool( );
     SgGraph_clearMemoryPool( );
     SgGraphEdge_clearMemoryPool( );
     SgGraphEdgeList_clearMemoryPool( );
     SgGraphNode_clearMemoryPool( );
     SgGraphNodeList_clearMemoryPool( );
     SgGreaterOrEqualOp_clearMemoryPool( );
     SgGreaterThanOp_clearMemoryPool( );
     SgIOItemExpression_clearMemoryPool( );
     SgIOStatement_clearMemoryPool( );
     SgIdentDirectiveStatement_clearMemoryPool( );
     SgIfDirectiveStatement_clearMemoryPool( );
     SgIfStmt_clearMemoryPool( );
     SgIfdefDirectiveStatement_clearMemoryPool( );
     SgIfndefDirectiveStatement_clearMemoryPool( );
     SgImagPartOp_clearMemoryPool( );
     SgImplicitStatement_clearMemoryPool( );
     SgImpliedDo_clearMemoryPool( );
     SgImportStatement_clearMemoryPool( );
     SgIncidenceDirectedGraph_clearMemoryPool( );
     SgIncidenceUndirectedGraph_clearMemoryPool( );
     SgIncludeDirectiveStatement_clearMemoryPool( );
     SgIncludeNextDirectiveStatement_clearMemoryPool( );
     SgInitializedName_clearMemoryPool( );
     SgInitializer_clearMemoryPool( );
     SgInquireStatement_clearMemoryPool( );
     SgIntKeyedBidirectionalGraph_clearMemoryPool( );
     SgIntVal_clearMemoryPool( );
     SgIntegerDivideOp_clearMemoryPool( );
     SgIntegerDivideAssignOp_clearMemoryPool( );
     SgInterfaceBody_clearMemoryPool( );
     SgHeaderFileBody_clearMemoryPool( );
     SgInterfaceStatement_clearMemoryPool( );
     SgInterfaceSymbol_clearMemoryPool( );
     SgIntrinsicSymbol_clearMemoryPool( );
     SgIsOp_clearMemoryPool( );
     SgIsNotOp_clearMemoryPool( );
     SgIorAssignOp_clearMemoryPool( );
     SgKeyDatumPair_clearMemoryPool( );
     SgCudaKernelExecConfig_clearMemoryPool( );
     SgCudaKernelCallExp_clearMemoryPool( );
     SgLabelRefExp_clearMemoryPool( );
     SgLabelStatement_clearMemoryPool( );
     SgJavaLabelStatement_clearMemoryPool( );
     SgLabelSymbol_clearMemoryPool( );
     SgJavaLabelSymbol_clearMemoryPool( );
     SgLambdaRefExp_clearMemoryPool( );
     SgLessOrEqualOp_clearMemoryPool( );
     SgLessThanOp_clearMemoryPool( );
     SgLineDirectiveStatement_clearMemoryPool( );
     SgLinemarkerDirectiveStatement_clearMemoryPool( );
     SgLinkageModifier_clearMemoryPool( );
     SgListComprehension_clearMemoryPool( );
     SgListExp_clearMemoryPool( );
     SgLocatedNode_clearMemoryPool( );
     SgLocatedNodeSupport_clearMemoryPool( );
     SgLongDoubleVal_clearMemoryPool( );
     SgLongIntVal_clearMemoryPool( );
     SgLongLongIntVal_clearMemoryPool( );
     SgLshiftAssignOp_clearMemoryPool( );
     SgLshiftOp_clearMemoryPool( );
     SgMemberFunctionDeclaration_clearMemoryPool( );
     SgMemberFunctionRefExp_clearMemoryPool( );
     SgMemberFunctionSymbol_clearMemoryPool( );
     SgMemberFunctionType_clearMemoryPool( );
     SgMembershipOp_clearMemoryPool( );
     SgMinusAssignOp_clearMemoryPool( );
     SgMinusMinusOp_clearMemoryPool( );
     SgMinusOp_clearMemoryPool( );
     SgModAssignOp_clearMemoryPool( );
     SgModOp_clearMemoryPool( );
     SgModifier_clearMemoryPool( );
     SgModifierNodes_clearMemoryPool( );
     SgModifierType_clearMemoryPool( );
     SgModuleStatement_clearMemoryPool( );
     SgModuleSymbol_clearMemoryPool( );
     SgMultAssignOp_clearMemoryPool( );
     SgMultiplyOp_clearMemoryPool( );
     SgName_clearMemoryPool( );
     SgNameGroup_clearMemoryPool( );
     SgNamedType_clearMemoryPool( );
     SgNamelistStatement_clearMemoryPool( );
     SgNamespaceAliasDeclarationStatement_clearMemoryPool( );
     SgNamespaceDeclarationStatement_clearMemoryPool( );
     SgNamespaceDefinitionStatement_clearMemoryPool( );
     SgNamespaceSymbol_clearMemoryPool( );
     SgNaryOp_clearMemoryPool( );
     SgNaryBooleanOp_clearMemoryPool( );
     SgNaryComparisonOp_clearMemoryPool( );
     SgNewExp_clearMemoryPool( );
     SgNode_clearMemoryPool( );
     SgNotEqualOp_clearMemoryPool( );
     SgNotOp_clearMemoryPool( );
     SgNonMembershipOp_clearMemoryPool( );
     SgNullExpression_clearMemoryPool( );
     SgNullStatement_clearMemoryPool( );
     SgNullifyStatement_clearMemoryPool( );
     SgOmpAtomicStatement_clearMemoryPool( );
     SgOmpBarrierStatement_clearMemoryPool( );
     SgOmpCriticalStatement_clearMemoryPool( );
     SgOmpClauseBodyStatement_clearMemoryPool( );
     SgOmpBodyStatement_clearMemoryPool( );
     SgOmpDoStatement_clearMemoryPool( );
     SgOmpFlushStatement_clearMemoryPool( );
     SgOmpForStatement_clearMemoryPool( );
     SgOmpMasterStatement_clearMemoryPool( );
     SgOmpOrderedStatement_clearMemoryPool( );
     SgOmpParallelStatement_clearMemoryPool( );
     SgOmpSectionStatement_clearMemoryPool( );
     SgOmpSectionsStatement_clearMemoryPool( );
     SgOmpSingleStatement_clearMemoryPool( );
     SgOmpTaskStatement_clearMemoryPool( );
     SgOmpTaskwaitStatement_clearMemoryPool( );
     SgOmpThreadprivateStatement_clearMemoryPool( );
     SgOmpWorkshareStatement_clearMemoryPool( );
     SgOmpClause_clearMemoryPool( );
     SgOmpCollapseClause_clearMemoryPool( );
     SgOmpCopyinClause_clearMemoryPool( );
     SgOmpCopyprivateClause_clearMemoryPool( );
     SgOmpDefaultClause_clearMemoryPool( );
     SgOmpExpressionClause_clearMemoryPool( );
     SgOmpFirstprivateClause_clearMemoryPool( );
     SgOmpIfClause_clearMemoryPool( );
     SgOmpLastprivateClause_clearMemoryPool( );
     SgOmpNowaitClause_clearMemoryPool( );
     SgOmpNumThreadsClause_clearMemoryPool( );
     SgOmpOrderedClause_clearMemoryPool( );
     SgOmpPrivateClause_clearMemoryPool( );
     SgOmpReductionClause_clearMemoryPool( );
     SgOmpScheduleClause_clearMemoryPool( );
     SgOmpSharedClause_clearMemoryPool( );
     SgOmpUntiedClause_clearMemoryPool( );
     SgOmpVariablesClause_clearMemoryPool( );
     SgOpenclAccessModeModifier_clearMemoryPool( );
     SgOpenStatement_clearMemoryPool( );
     SgOptions_clearMemoryPool( );
     SgOrOp_clearMemoryPool( );
     SgParameterStatement_clearMemoryPool( );
     SgPartialFunctionModifierType_clearMemoryPool( );
     SgPartialFunctionType_clearMemoryPool( );
     SgPassStatement_clearMemoryPool( );
     SgPlusAssignOp_clearMemoryPool( );
     SgPlusPlusOp_clearMemoryPool( );
     SgPntrArrRefExp_clearMemoryPool( );
     SgPointerAssignOp_clearMemoryPool( );
     SgPointerDerefExp_clearMemoryPool( );
     SgPointerMemberType_clearMemoryPool( );
     SgPointerType_clearMemoryPool( );
     SgPragma_clearMemoryPool( );
     SgPragmaDeclaration_clearMemoryPool( );
     SgPrintStatement_clearMemoryPool( );
     SgProcedureHeaderStatement_clearMemoryPool( );
     SgProgramHeaderStatement_clearMemoryPool( );
     SgProject_clearMemoryPool( );
     SgPseudoDestructorRefExp_clearMemoryPool( );
     SgPythonGlobalStmt_clearMemoryPool( );
     SgPythonPrintStmt_clearMemoryPool( );
     SgQualifiedName_clearMemoryPool( );
     SgQualifiedNameType_clearMemoryPool( );
     SgReadStatement_clearMemoryPool( );
     SgRealPartOp_clearMemoryPool( );
     SgRefExp_clearMemoryPool( );
     SgReferenceType_clearMemoryPool( );
     SgRenamePair_clearMemoryPool( );
     SgRenameSymbol_clearMemoryPool( );
     SgReturnStmt_clearMemoryPool( );
     SgRewindStatement_clearMemoryPool( );
     SgRshiftAssignOp_clearMemoryPool( );
     SgRshiftOp_clearMemoryPool( );
     SgJavaUnsignedRshiftAssignOp_clearMemoryPool( );
     SgJavaUnsignedRshiftOp_clearMemoryPool( );
     SgScopeOp_clearMemoryPool( );
     SgScopeStatement_clearMemoryPool( );
     SgSequenceStatement_clearMemoryPool( );
     SgSetComprehension_clearMemoryPool( );
     SgShortVal_clearMemoryPool( );
     SgSizeOfOp_clearMemoryPool( );
     SgJavaInstanceOfOp_clearMemoryPool( );
     SgSourceFile_clearMemoryPool( );
     SgSpawnStmt_clearMemoryPool( );
     SgJavaThrowStatement_clearMemoryPool( );
     SgJavaForEachStatement_clearMemoryPool( );
     SgJavaSynchronizedStatement_clearMemoryPool( );
     SgJavaParameterizedType_clearMemoryPool( );
     SgSpecialFunctionModifier_clearMemoryPool( );
     SgStatement_clearMemoryPool( );
     SgStmtDeclarationStatement_clearMemoryPool( );
     SgStatementExpression_clearMemoryPool( );
     SgStatementFunctionStatement_clearMemoryPool( );
     SgStopOrPauseStatement_clearMemoryPool( );
     SgStorageModifier_clearMemoryPool( );
     SgStringConversion_clearMemoryPool( );
     SgStringKeyedBidirectionalGraph_clearMemoryPool( );
     SgStringVal_clearMemoryPool( );
     SgSubscriptExpression_clearMemoryPool( );
     SgSubtractOp_clearMemoryPool( );
     SgSupport_clearMemoryPool( );
     SgSwitchStatement_clearMemoryPool( );
     SgSymbol_clearMemoryPool( );
     SgSymbolTable_clearMemoryPool( );
     SgTemplateArgument_clearMemoryPool( );
     SgTemplateArgumentList_clearMemoryPool( );
     SgTemplateDeclaration_clearMemoryPool( );
     SgTemplateClassDeclaration_clearMemoryPool( );
     SgTemplateFunctionDeclaration_clearMemoryPool( );
     SgTemplateMemberFunctionDeclaration_clearMemoryPool( );
     SgTemplateClassDefinition_clearMemoryPool( );
     SgTemplateFunctionDefinition_clearMemoryPool( );
     SgTemplateInstantiationDecl_clearMemoryPool( );
     SgTemplateInstantiationDefn_clearMemoryPool( );
     SgTemplateInstantiationDirectiveStatement_clearMemoryPool( );
     SgTemplateInstantiationFunctionDecl_clearMemoryPool( );
     SgTemplateInstantiationMemberFunctionDecl_clearMemoryPool( );
     SgTemplateParameter_clearMemoryPool( );
     SgTemplateParameterList_clearMemoryPool( );
     SgTemplateSymbol_clearMemoryPool( );
     SgTemplateType_clearMemoryPool( );
     SgThisExp_clearMemoryPool( );
     SgSuperExp_clearMemoryPool( );
     SgThrowOp_clearMemoryPool( );
     SgToken_clearMemoryPool( );
     SgTryStmt_clearMemoryPool( );
     SgTupleExp_clearMemoryPool( );
     SgType_clearMemoryPool( );
     SgTypeBool_clearMemoryPool( );
     SgTypeChar_clearMemoryPool( );
     SgTypeComplex_clearMemoryPool( );
     SgTypeDefault_clearMemoryPool( );
     SgTypeLabel_clearMemoryPool( );
     SgTypeDouble_clearMemoryPool( );
     SgTypeEllipse_clearMemoryPool( );
     SgTypeFloat_clearMemoryPool( );
     SgTypeGlobalVoid_clearMemoryPool( );
     SgTypeIdOp_clearMemoryPool( );
     SgTypeImaginary_clearMemoryPool( );
     SgTypeInt_clearMemoryPool( );
     SgTypeLong_clearMemoryPool( );
     SgTypeLongDouble_clearMemoryPool( );
     SgTypeLongLong_clearMemoryPool( );
     SgTypeModifier_clearMemoryPool( );
     SgTypeShort_clearMemoryPool( );
     SgTypeSignedChar_clearMemoryPool( );
     SgTypeSignedInt_clearMemoryPool( );
     SgTypeSignedLong_clearMemoryPool( );
     SgTypeSignedLongLong_clearMemoryPool( );
     SgTypeSignedShort_clearMemoryPool( );
     SgTypeString_clearMemoryPool( );
     SgTypeUnknown_clearMemoryPool( );
     SgTypeUnsignedChar_clearMemoryPool( );
     SgTypeUnsignedInt_clearMemoryPool( );
     SgTypeUnsignedLong_clearMemoryPool( );
     SgTypeUnsignedLongLong_clearMemoryPool( );
     SgTypeUnsignedShort_clearMemoryPool( );
     SgTypeVoid_clearMemoryPool( );
     SgTypeWchar_clearMemoryPool( );
     SgTypedefDeclaration_clearMemoryPool( );
     SgTypedefSeq_clearMemoryPool( );
     SgTypedefSymbol_clearMemoryPool( );
     SgTypedefType_clearMemoryPool( );
     SgUPC_AccessModifier_clearMemoryPool( );
     SgUnaryAddOp_clearMemoryPool( );
     SgUnaryOp_clearMemoryPool( );
     SgUndefDirectiveStatement_clearMemoryPool( );
     SgUndirectedGraphEdge_clearMemoryPool( );
     SgUnknownArrayOrFunctionReference_clearMemoryPool( );
     SgUnknownFile_clearMemoryPool( );
     SgUnparse_Info_clearMemoryPool( );
     SgUnsignedCharVal_clearMemoryPool( );
     SgUnsignedIntVal_clearMemoryPool( );
     SgUnsignedLongLongIntVal_clearMemoryPool( );
     SgUnsignedLongVal_clearMemoryPool( );
     SgUnsignedShortVal_clearMemoryPool( );
     SgUpcBarrierStatement_clearMemoryPool( );
     SgUpcBlocksizeofExpression_clearMemoryPool( );
     SgUpcElemsizeofExpression_clearMemoryPool( );
     SgUpcFenceStatement_clearMemoryPool( );
     SgUpcForAllStatement_clearMemoryPool( );
     SgUpcLocalsizeofExpression_clearMemoryPool( );
     SgUpcMythread_clearMemoryPool( );
     SgUpcNotifyStatement_clearMemoryPool( );
     SgUpcThreads_clearMemoryPool( );
     SgUpcWaitStatement_clearMemoryPool( );
     SgUseStatement_clearMemoryPool( );
     SgUserDefinedBinaryOp_clearMemoryPool( );
     SgUserDefinedUnaryOp_clearMemoryPool( );
     SgUsingDeclarationStatement_clearMemoryPool( );
     SgUsingDirectiveStatement_clearMemoryPool( );
     SgValueExp_clearMemoryPool( );
     SgVarArgCopyOp_clearMemoryPool( );
     SgVarArgEndOp_clearMemoryPool( );
     SgVarArgOp_clearMemoryPool( );
     SgVarArgStartOneOperandOp_clearMemoryPool( );
     SgVarArgStartOp_clearMemoryPool( );
     SgVarRefExp_clearMemoryPool( );
     SgVariableDeclaration_clearMemoryPool( );
     SgVariableDefinition_clearMemoryPool( );
     SgVariableSymbol_clearMemoryPool( );
     SgVariantExpression_clearMemoryPool( );
     SgVariantStatement_clearMemoryPool( );
     SgWaitStatement_clearMemoryPool( );
     SgWarningDirectiveStatement_clearMemoryPool( );
     SgWithStatement_clearMemoryPool( );
     SgWcharVal_clearMemoryPool( );
     SgWhereStatement_clearMemoryPool( );
     SgWhileStmt_clearMemoryPool( );
     SgWriteStatement_clearMemoryPool( );
     SgXorAssignOp_clearMemoryPool( );
     SgYieldExpression_clearMemoryPool( );
     Sg_File_Info_clearMemoryPool( );
     SgTypeCAFTeam_clearMemoryPool( );
     SgCAFWithTeamStatement_clearMemoryPool( );
     SgCAFCoExpression_clearMemoryPool( );
     SgCallExpression_clearMemoryPool( );
     SgTypeCrayPointer_clearMemoryPool( );
     SgJavaImportStatement_clearMemoryPool( );

/* #line 434 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarAST_FileIoSource.code" */

     
   /* JH (02/03/2006) since the memory pool contain no data anymore, we reset the 
      contents of the listOfMemoryPoolSizes to 0!
   */
     for (int i= 0; i < totalNumberOfIRNodes + 1; ++i)
        {
          listOfMemoryPoolSizes[i] = 0;
        }
   /* JH (03/21/2006) additionally, we need a method, that resets the static 
      data pointers to NULL!
   */
     deleteStaticData();
     deleteStoredAsts();
     return;
   }

void
AST_FILE_IO :: deleteStaticData ( )
  {
     SgNode::p_globalFunctionTypeTable = NULL ;
     SgNode::p_globalTypeTable = NULL ;
     SgNode::p_globalMangledNameMap.clear();
     SgNode::p_shortMangledNameCache.clear();
     SgNode::p_globalQualifiedNameMapForNames.clear();
     SgNode::p_globalQualifiedNameMapForTypes.clear();
     SgNode::p_globalTypeNameMap.clear();
     Sg_File_Info::p_fileidtoname_map.clear();
     Sg_File_Info::p_nametofileid_map.clear();
     SgUnparse_Info::p_forceDefaultConstructorToTriggerError = (bool)(0);
     SgGraph::p_index_counter = (int)(0);
     SgGraphNode::p_index_counter = (int)(0);
     SgGraphEdge::p_index_counter = (int)(0);
     SgTypeUnknown::p_builtin_type = NULL ;
     SgTypeChar::p_builtin_type = NULL ;
     SgTypeSignedChar::p_builtin_type = NULL ;
     SgTypeUnsignedChar::p_builtin_type = NULL ;
     SgTypeShort::p_builtin_type = NULL ;
     SgTypeSignedShort::p_builtin_type = NULL ;
     SgTypeUnsignedShort::p_builtin_type = NULL ;
     SgTypeInt::p_builtin_type = NULL ;
     SgTypeSignedInt::p_builtin_type = NULL ;
     SgTypeUnsignedInt::p_builtin_type = NULL ;
     SgTypeLong::p_builtin_type = NULL ;
     SgTypeSignedLong::p_builtin_type = NULL ;
     SgTypeUnsignedLong::p_builtin_type = NULL ;
     SgTypeVoid::p_builtin_type = NULL ;
     SgTypeGlobalVoid::p_builtin_type = NULL ;
     SgTypeWchar::p_builtin_type = NULL ;
     SgTypeFloat::p_builtin_type = NULL ;
     SgTypeDouble::p_builtin_type = NULL ;
     SgTypeLongLong::p_builtin_type = NULL ;
     SgTypeSignedLongLong::p_builtin_type = NULL ;
     SgTypeUnsignedLongLong::p_builtin_type = NULL ;
     SgTypeLongDouble::p_builtin_type = NULL ;
     SgTypeBool::p_builtin_type = NULL ;
     SgNamedType::p_builtin_type = NULL ;
     SgPartialFunctionModifierType::p_builtin_type = NULL ;
     SgTypeEllipse::p_builtin_type = NULL ;
     SgTypeDefault::p_builtin_type = NULL ;
     SgTypeCAFTeam::p_builtin_type = NULL ;
     SgTypeCrayPointer::p_builtin_type = NULL ;
     SgTypeLabel::p_builtin_type = NULL ;
     SgAsmTypeByte::p_builtin_type = NULL ;
     SgAsmTypeWord::p_builtin_type = NULL ;
     SgAsmTypeDoubleWord::p_builtin_type = NULL ;
     SgAsmTypeQuadWord::p_builtin_type = NULL ;
     SgAsmTypeDoubleQuadWord::p_builtin_type = NULL ;
     SgAsmType80bitFloat::p_builtin_type = NULL ;
     SgAsmType128bitFloat::p_builtin_type = NULL ;
     SgAsmTypeSingleFloat::p_builtin_type = NULL ;
     SgAsmTypeDoubleFloat::p_builtin_type = NULL ;

/* #line 455 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarAST_FileIoSource.code" */

   /* JH (02/03/2006) since the memory pool contain no data anymore, we reset the 
      contents of the listOfMemoryPoolSizes to 0!
   */
     return;
   }

/* JH (01/03/2006) This mehtods steps through all memory pools and extends it to that amount it 
   will have after the AST was rebuilt. Thereby, we can set the pointers, even if there is no 
   valid data at the address they are pointing to. But it will be! 
*/
void
AST_FILE_IO :: extendMemoryPoolsForRebuildingAST (  )
   {
     assert ( freepointersOfCurrentAstAreSetToGlobalIndices == false );
     assert ( 0 < getTotalNumberOfNodesOfNewAst( ) );

     SgAccessModifier_extendMemoryPoolForFileIO( );
     SgActualArgumentExpression_extendMemoryPoolForFileIO( );
     SgAddOp_extendMemoryPoolForFileIO( );
     SgAddressOfOp_extendMemoryPoolForFileIO( );
     SgAggregateInitializer_extendMemoryPoolForFileIO( );
     SgAliasSymbol_extendMemoryPoolForFileIO( );
     SgAllocateStatement_extendMemoryPoolForFileIO( );
     SgAndAssignOp_extendMemoryPoolForFileIO( );
     SgAndOp_extendMemoryPoolForFileIO( );
     SgArithmeticIfStatement_extendMemoryPoolForFileIO( );
     SgArrayType_extendMemoryPoolForFileIO( );
     SgArrowExp_extendMemoryPoolForFileIO( );
     SgArrowStarOp_extendMemoryPoolForFileIO( );
     SgAsmArmInstruction_extendMemoryPoolForFileIO( );
     SgAsmArmRegisterReferenceExpression_extendMemoryPoolForFileIO( );
     SgAsmBasicString_extendMemoryPoolForFileIO( );
     SgAsmBinaryAdd_extendMemoryPoolForFileIO( );
     SgAsmBinaryAddPostupdate_extendMemoryPoolForFileIO( );
     SgAsmBinaryAddPreupdate_extendMemoryPoolForFileIO( );
     SgAsmBinaryAsr_extendMemoryPoolForFileIO( );
     SgAsmBinaryDivide_extendMemoryPoolForFileIO( );
     SgAsmBinaryExpression_extendMemoryPoolForFileIO( );
     SgAsmBinaryLsl_extendMemoryPoolForFileIO( );
     SgAsmBinaryLsr_extendMemoryPoolForFileIO( );
     SgAsmBinaryMod_extendMemoryPoolForFileIO( );
     SgAsmBinaryMultiply_extendMemoryPoolForFileIO( );
     SgAsmBinaryRor_extendMemoryPoolForFileIO( );
     SgAsmBinarySubtract_extendMemoryPoolForFileIO( );
     SgAsmBinarySubtractPostupdate_extendMemoryPoolForFileIO( );
     SgAsmBinarySubtractPreupdate_extendMemoryPoolForFileIO( );
     SgAsmBlock_extendMemoryPoolForFileIO( );
     SgAsmByteValueExpression_extendMemoryPoolForFileIO( );
     SgAsmCoffStrtab_extendMemoryPoolForFileIO( );
     SgAsmCoffSymbol_extendMemoryPoolForFileIO( );
     SgAsmCoffSymbolList_extendMemoryPoolForFileIO( );
     SgAsmCoffSymbolTable_extendMemoryPoolForFileIO( );
     SgAsmCommonSubExpression_extendMemoryPoolForFileIO( );
     SgAsmControlFlagsExpression_extendMemoryPoolForFileIO( );
     SgAsmDOSExtendedHeader_extendMemoryPoolForFileIO( );
     SgAsmDOSFileHeader_extendMemoryPoolForFileIO( );
     SgAsmDoubleFloatValueExpression_extendMemoryPoolForFileIO( );
     SgAsmDoubleWordValueExpression_extendMemoryPoolForFileIO( );
     SgAsmDwarfAccessDeclaration_extendMemoryPoolForFileIO( );
     SgAsmDwarfArrayType_extendMemoryPoolForFileIO( );
     SgAsmDwarfBaseType_extendMemoryPoolForFileIO( );
     SgAsmDwarfCatchBlock_extendMemoryPoolForFileIO( );
     SgAsmDwarfClassTemplate_extendMemoryPoolForFileIO( );
     SgAsmDwarfClassType_extendMemoryPoolForFileIO( );
     SgAsmDwarfCommonBlock_extendMemoryPoolForFileIO( );
     SgAsmDwarfCommonInclusion_extendMemoryPoolForFileIO( );
     SgAsmDwarfCompilationUnit_extendMemoryPoolForFileIO( );
     SgAsmDwarfCompilationUnitList_extendMemoryPoolForFileIO( );
     SgAsmDwarfCondition_extendMemoryPoolForFileIO( );
     SgAsmDwarfConstType_extendMemoryPoolForFileIO( );
     SgAsmDwarfConstant_extendMemoryPoolForFileIO( );
     SgAsmDwarfConstruct_extendMemoryPoolForFileIO( );
     SgAsmDwarfConstructList_extendMemoryPoolForFileIO( );
     SgAsmDwarfDwarfProcedure_extendMemoryPoolForFileIO( );
     SgAsmDwarfEntryPoint_extendMemoryPoolForFileIO( );
     SgAsmDwarfEnumerationType_extendMemoryPoolForFileIO( );
     SgAsmDwarfEnumerator_extendMemoryPoolForFileIO( );
     SgAsmDwarfFileType_extendMemoryPoolForFileIO( );
     SgAsmDwarfFormalParameter_extendMemoryPoolForFileIO( );
     SgAsmDwarfFormatLabel_extendMemoryPoolForFileIO( );
     SgAsmDwarfFriend_extendMemoryPoolForFileIO( );
     SgAsmDwarfFunctionTemplate_extendMemoryPoolForFileIO( );
     SgAsmDwarfImportedDeclaration_extendMemoryPoolForFileIO( );
     SgAsmDwarfImportedModule_extendMemoryPoolForFileIO( );
     SgAsmDwarfImportedUnit_extendMemoryPoolForFileIO( );
     SgAsmDwarfInformation_extendMemoryPoolForFileIO( );
     SgAsmDwarfInheritance_extendMemoryPoolForFileIO( );
     SgAsmDwarfInlinedSubroutine_extendMemoryPoolForFileIO( );
     SgAsmDwarfInterfaceType_extendMemoryPoolForFileIO( );
     SgAsmDwarfLabel_extendMemoryPoolForFileIO( );
     SgAsmDwarfLexicalBlock_extendMemoryPoolForFileIO( );
     SgAsmDwarfLine_extendMemoryPoolForFileIO( );
     SgAsmDwarfLineList_extendMemoryPoolForFileIO( );
     SgAsmDwarfMacro_extendMemoryPoolForFileIO( );
     SgAsmDwarfMacroList_extendMemoryPoolForFileIO( );
     SgAsmDwarfMember_extendMemoryPoolForFileIO( );
     SgAsmDwarfModule_extendMemoryPoolForFileIO( );
     SgAsmDwarfMutableType_extendMemoryPoolForFileIO( );
     SgAsmDwarfNamelist_extendMemoryPoolForFileIO( );
     SgAsmDwarfNamelistItem_extendMemoryPoolForFileIO( );
     SgAsmDwarfNamespace_extendMemoryPoolForFileIO( );
     SgAsmDwarfPackedType_extendMemoryPoolForFileIO( );
     SgAsmDwarfPartialUnit_extendMemoryPoolForFileIO( );
     SgAsmDwarfPointerType_extendMemoryPoolForFileIO( );
     SgAsmDwarfPtrToMemberType_extendMemoryPoolForFileIO( );
     SgAsmDwarfReferenceType_extendMemoryPoolForFileIO( );
     SgAsmDwarfRestrictType_extendMemoryPoolForFileIO( );
     SgAsmDwarfSetType_extendMemoryPoolForFileIO( );
     SgAsmDwarfSharedType_extendMemoryPoolForFileIO( );
     SgAsmDwarfStringType_extendMemoryPoolForFileIO( );
     SgAsmDwarfStructureType_extendMemoryPoolForFileIO( );
     SgAsmDwarfSubprogram_extendMemoryPoolForFileIO( );
     SgAsmDwarfSubrangeType_extendMemoryPoolForFileIO( );
     SgAsmDwarfSubroutineType_extendMemoryPoolForFileIO( );
     SgAsmDwarfTemplateTypeParameter_extendMemoryPoolForFileIO( );
     SgAsmDwarfTemplateValueParameter_extendMemoryPoolForFileIO( );
     SgAsmDwarfThrownType_extendMemoryPoolForFileIO( );
     SgAsmDwarfTryBlock_extendMemoryPoolForFileIO( );
     SgAsmDwarfTypedef_extendMemoryPoolForFileIO( );
     SgAsmDwarfUnionType_extendMemoryPoolForFileIO( );
     SgAsmDwarfUnknownConstruct_extendMemoryPoolForFileIO( );
     SgAsmDwarfUnspecifiedParameters_extendMemoryPoolForFileIO( );
     SgAsmDwarfUnspecifiedType_extendMemoryPoolForFileIO( );
     SgAsmDwarfUpcRelaxedType_extendMemoryPoolForFileIO( );
     SgAsmDwarfUpcSharedType_extendMemoryPoolForFileIO( );
     SgAsmDwarfUpcStrictType_extendMemoryPoolForFileIO( );
     SgAsmDwarfVariable_extendMemoryPoolForFileIO( );
     SgAsmDwarfVariant_extendMemoryPoolForFileIO( );
     SgAsmDwarfVariantPart_extendMemoryPoolForFileIO( );
     SgAsmDwarfVolatileType_extendMemoryPoolForFileIO( );
     SgAsmDwarfWithStmt_extendMemoryPoolForFileIO( );
     SgAsmElfDynamicEntry_extendMemoryPoolForFileIO( );
     SgAsmElfDynamicEntryList_extendMemoryPoolForFileIO( );
     SgAsmElfDynamicSection_extendMemoryPoolForFileIO( );
     SgAsmElfEHFrameEntryCI_extendMemoryPoolForFileIO( );
     SgAsmElfEHFrameEntryCIList_extendMemoryPoolForFileIO( );
     SgAsmElfEHFrameEntryFD_extendMemoryPoolForFileIO( );
     SgAsmElfEHFrameEntryFDList_extendMemoryPoolForFileIO( );
     SgAsmElfEHFrameSection_extendMemoryPoolForFileIO( );
     SgAsmElfFileHeader_extendMemoryPoolForFileIO( );
     SgAsmElfNoteEntry_extendMemoryPoolForFileIO( );
     SgAsmElfNoteEntryList_extendMemoryPoolForFileIO( );
     SgAsmElfNoteSection_extendMemoryPoolForFileIO( );
     SgAsmElfRelocEntry_extendMemoryPoolForFileIO( );
     SgAsmElfRelocEntryList_extendMemoryPoolForFileIO( );
     SgAsmElfRelocSection_extendMemoryPoolForFileIO( );
     SgAsmElfSection_extendMemoryPoolForFileIO( );
     SgAsmElfSectionTable_extendMemoryPoolForFileIO( );
     SgAsmElfSectionTableEntry_extendMemoryPoolForFileIO( );
     SgAsmElfSegmentTable_extendMemoryPoolForFileIO( );
     SgAsmElfSegmentTableEntry_extendMemoryPoolForFileIO( );
     SgAsmElfSegmentTableEntryList_extendMemoryPoolForFileIO( );
     SgAsmElfStringSection_extendMemoryPoolForFileIO( );
     SgAsmElfStrtab_extendMemoryPoolForFileIO( );
     SgAsmElfSymbol_extendMemoryPoolForFileIO( );
     SgAsmElfSymbolList_extendMemoryPoolForFileIO( );
     SgAsmElfSymbolSection_extendMemoryPoolForFileIO( );
     SgAsmElfSymverDefinedAux_extendMemoryPoolForFileIO( );
     SgAsmElfSymverDefinedAuxList_extendMemoryPoolForFileIO( );
     SgAsmElfSymverDefinedEntry_extendMemoryPoolForFileIO( );
     SgAsmElfSymverDefinedEntryList_extendMemoryPoolForFileIO( );
     SgAsmElfSymverDefinedSection_extendMemoryPoolForFileIO( );
     SgAsmElfSymverEntry_extendMemoryPoolForFileIO( );
     SgAsmElfSymverEntryList_extendMemoryPoolForFileIO( );
     SgAsmElfSymverNeededAux_extendMemoryPoolForFileIO( );
     SgAsmElfSymverNeededAuxList_extendMemoryPoolForFileIO( );
     SgAsmElfSymverNeededEntry_extendMemoryPoolForFileIO( );
     SgAsmElfSymverNeededEntryList_extendMemoryPoolForFileIO( );
     SgAsmElfSymverNeededSection_extendMemoryPoolForFileIO( );
     SgAsmElfSymverSection_extendMemoryPoolForFileIO( );
     SgAsmExecutableFileFormat_extendMemoryPoolForFileIO( );
     SgAsmExprListExp_extendMemoryPoolForFileIO( );
     SgAsmExpression_extendMemoryPoolForFileIO( );
     SgAsmFunction_extendMemoryPoolForFileIO( );
     SgAsmGenericDLL_extendMemoryPoolForFileIO( );
     SgAsmGenericDLLList_extendMemoryPoolForFileIO( );
     SgAsmGenericFile_extendMemoryPoolForFileIO( );
     SgAsmGenericFileList_extendMemoryPoolForFileIO( );
     SgAsmGenericFormat_extendMemoryPoolForFileIO( );
     SgAsmGenericHeader_extendMemoryPoolForFileIO( );
     SgAsmGenericHeaderList_extendMemoryPoolForFileIO( );
     SgAsmGenericSection_extendMemoryPoolForFileIO( );
     SgAsmGenericSectionList_extendMemoryPoolForFileIO( );
     SgAsmGenericString_extendMemoryPoolForFileIO( );
     SgAsmGenericStrtab_extendMemoryPoolForFileIO( );
     SgAsmGenericSymbol_extendMemoryPoolForFileIO( );
     SgAsmGenericSymbolList_extendMemoryPoolForFileIO( );
     SgAsmInstruction_extendMemoryPoolForFileIO( );
     SgAsmIntegerValueExpression_extendMemoryPoolForFileIO( );
     SgAsmInterpretation_extendMemoryPoolForFileIO( );
     SgAsmInterpretationList_extendMemoryPoolForFileIO( );
     SgAsmLEEntryPoint_extendMemoryPoolForFileIO( );
     SgAsmLEEntryTable_extendMemoryPoolForFileIO( );
     SgAsmLEFileHeader_extendMemoryPoolForFileIO( );
     SgAsmLENameTable_extendMemoryPoolForFileIO( );
     SgAsmLEPageTable_extendMemoryPoolForFileIO( );
     SgAsmLEPageTableEntry_extendMemoryPoolForFileIO( );
     SgAsmLERelocTable_extendMemoryPoolForFileIO( );
     SgAsmLESection_extendMemoryPoolForFileIO( );
     SgAsmLESectionTable_extendMemoryPoolForFileIO( );
     SgAsmLESectionTableEntry_extendMemoryPoolForFileIO( );
     SgAsmMemoryReferenceExpression_extendMemoryPoolForFileIO( );
     SgAsmNEEntryPoint_extendMemoryPoolForFileIO( );
     SgAsmNEEntryTable_extendMemoryPoolForFileIO( );
     SgAsmNEFileHeader_extendMemoryPoolForFileIO( );
     SgAsmNEModuleTable_extendMemoryPoolForFileIO( );
     SgAsmNENameTable_extendMemoryPoolForFileIO( );
     SgAsmNERelocEntry_extendMemoryPoolForFileIO( );
     SgAsmNERelocTable_extendMemoryPoolForFileIO( );
     SgAsmNESection_extendMemoryPoolForFileIO( );
     SgAsmNESectionTable_extendMemoryPoolForFileIO( );
     SgAsmNESectionTableEntry_extendMemoryPoolForFileIO( );
     SgAsmNEStringTable_extendMemoryPoolForFileIO( );
     SgAsmNode_extendMemoryPoolForFileIO( );
     SgAsmOp_extendMemoryPoolForFileIO( );
     SgAsmOperandList_extendMemoryPoolForFileIO( );
     SgAsmPEExportDirectory_extendMemoryPoolForFileIO( );
     SgAsmPEExportEntry_extendMemoryPoolForFileIO( );
     SgAsmPEExportEntryList_extendMemoryPoolForFileIO( );
     SgAsmPEExportSection_extendMemoryPoolForFileIO( );
     SgAsmPEFileHeader_extendMemoryPoolForFileIO( );
     SgAsmPEImportDirectory_extendMemoryPoolForFileIO( );
     SgAsmPEImportDirectoryList_extendMemoryPoolForFileIO( );
     SgAsmPEImportItem_extendMemoryPoolForFileIO( );
     SgAsmPEImportItemList_extendMemoryPoolForFileIO( );
     SgAsmPEImportSection_extendMemoryPoolForFileIO( );
     SgAsmPERVASizePair_extendMemoryPoolForFileIO( );
     SgAsmPERVASizePairList_extendMemoryPoolForFileIO( );
     SgAsmPESection_extendMemoryPoolForFileIO( );
     SgAsmPESectionTable_extendMemoryPoolForFileIO( );
     SgAsmPESectionTableEntry_extendMemoryPoolForFileIO( );
     SgAsmPEStringSection_extendMemoryPoolForFileIO( );
     SgAsmPowerpcInstruction_extendMemoryPoolForFileIO( );
     SgAsmPowerpcRegisterReferenceExpression_extendMemoryPoolForFileIO( );
     SgAsmQuadWordValueExpression_extendMemoryPoolForFileIO( );
     SgAsmRegisterReferenceExpression_extendMemoryPoolForFileIO( );
     SgAsmSingleFloatValueExpression_extendMemoryPoolForFileIO( );
     SgAsmStatement_extendMemoryPoolForFileIO( );
     SgAsmStaticData_extendMemoryPoolForFileIO( );
     SgAsmStmt_extendMemoryPoolForFileIO( );
     SgAsmStoredString_extendMemoryPoolForFileIO( );
     SgAsmStringStorage_extendMemoryPoolForFileIO( );
     SgAsmType_extendMemoryPoolForFileIO( );
     SgAsmType128bitFloat_extendMemoryPoolForFileIO( );
     SgAsmType80bitFloat_extendMemoryPoolForFileIO( );
     SgAsmTypeByte_extendMemoryPoolForFileIO( );
     SgAsmTypeDoubleFloat_extendMemoryPoolForFileIO( );
     SgAsmTypeDoubleQuadWord_extendMemoryPoolForFileIO( );
     SgAsmTypeDoubleWord_extendMemoryPoolForFileIO( );
     SgAsmTypeQuadWord_extendMemoryPoolForFileIO( );
     SgAsmTypeSingleFloat_extendMemoryPoolForFileIO( );
     SgAsmTypeVector_extendMemoryPoolForFileIO( );
     SgAsmTypeWord_extendMemoryPoolForFileIO( );
     SgAsmUnaryArmSpecialRegisterList_extendMemoryPoolForFileIO( );
     SgAsmUnaryExpression_extendMemoryPoolForFileIO( );
     SgAsmUnaryMinus_extendMemoryPoolForFileIO( );
     SgAsmUnaryPlus_extendMemoryPoolForFileIO( );
     SgAsmUnaryRrx_extendMemoryPoolForFileIO( );
     SgAsmValueExpression_extendMemoryPoolForFileIO( );
     SgAsmVectorValueExpression_extendMemoryPoolForFileIO( );
     SgAsmWordValueExpression_extendMemoryPoolForFileIO( );
     SgAsmx86Instruction_extendMemoryPoolForFileIO( );
     SgAsmx86RegisterReferenceExpression_extendMemoryPoolForFileIO( );
     SgAsmBinaryAddressSymbol_extendMemoryPoolForFileIO( );
     SgAsmBinaryDataSymbol_extendMemoryPoolForFileIO( );
     SgAssertStmt_extendMemoryPoolForFileIO( );
     SgAssignInitializer_extendMemoryPoolForFileIO( );
     SgAssignOp_extendMemoryPoolForFileIO( );
     SgAssignStatement_extendMemoryPoolForFileIO( );
     SgAssignedGotoStatement_extendMemoryPoolForFileIO( );
     SgAssociateStatement_extendMemoryPoolForFileIO( );
     SgAsteriskShapeExp_extendMemoryPoolForFileIO( );
     SgAttribute_extendMemoryPoolForFileIO( );
     SgAttributeSpecificationStatement_extendMemoryPoolForFileIO( );
     SgBackspaceStatement_extendMemoryPoolForFileIO( );
     SgBaseClass_extendMemoryPoolForFileIO( );
     SgExpBaseClass_extendMemoryPoolForFileIO( );
     SgBaseClassModifier_extendMemoryPoolForFileIO( );
     SgBasicBlock_extendMemoryPoolForFileIO( );
     SgBidirectionalGraph_extendMemoryPoolForFileIO( );
     SgBinaryComposite_extendMemoryPoolForFileIO( );
     SgBinaryOp_extendMemoryPoolForFileIO( );
     SgBitAndOp_extendMemoryPoolForFileIO( );
     SgBitAttribute_extendMemoryPoolForFileIO( );
     SgBitComplementOp_extendMemoryPoolForFileIO( );
     SgBitOrOp_extendMemoryPoolForFileIO( );
     SgBitXorOp_extendMemoryPoolForFileIO( );
     SgBlockDataStatement_extendMemoryPoolForFileIO( );
     SgBoolValExp_extendMemoryPoolForFileIO( );
     SgBreakStmt_extendMemoryPoolForFileIO( );
     SgC_PreprocessorDirectiveStatement_extendMemoryPoolForFileIO( );
     SgCaseOptionStmt_extendMemoryPoolForFileIO( );
     SgCastExp_extendMemoryPoolForFileIO( );
     SgCatchOptionStmt_extendMemoryPoolForFileIO( );
     SgCatchStatementSeq_extendMemoryPoolForFileIO( );
     SgCharVal_extendMemoryPoolForFileIO( );
     SgClassDecl_attr_extendMemoryPoolForFileIO( );
     SgClassDeclaration_extendMemoryPoolForFileIO( );
     SgClassDefinition_extendMemoryPoolForFileIO( );
     SgClassNameRefExp_extendMemoryPoolForFileIO( );
     SgClassSymbol_extendMemoryPoolForFileIO( );
     SgClassType_extendMemoryPoolForFileIO( );
     SgClinkageDeclarationStatement_extendMemoryPoolForFileIO( );
     SgClinkageEndStatement_extendMemoryPoolForFileIO( );
     SgClinkageStartStatement_extendMemoryPoolForFileIO( );
     SgCloseStatement_extendMemoryPoolForFileIO( );
     SgColonShapeExp_extendMemoryPoolForFileIO( );
     SgCommaOpExp_extendMemoryPoolForFileIO( );
     SgCommonBlock_extendMemoryPoolForFileIO( );
     SgCommonBlockObject_extendMemoryPoolForFileIO( );
     SgCommonSymbol_extendMemoryPoolForFileIO( );
     SgComplexVal_extendMemoryPoolForFileIO( );
     SgComprehension_extendMemoryPoolForFileIO( );
     SgCompoundAssignOp_extendMemoryPoolForFileIO( );
     SgCompoundInitializer_extendMemoryPoolForFileIO( );
     SgComputedGotoStatement_extendMemoryPoolForFileIO( );
     SgConcatenationOp_extendMemoryPoolForFileIO( );
     SgConditionalExp_extendMemoryPoolForFileIO( );
     SgConjugateOp_extendMemoryPoolForFileIO( );
     SgConstVolatileModifier_extendMemoryPoolForFileIO( );
     SgConstructorInitializer_extendMemoryPoolForFileIO( );
     SgContainsStatement_extendMemoryPoolForFileIO( );
     SgContinueStmt_extendMemoryPoolForFileIO( );
     SgCtorInitializerList_extendMemoryPoolForFileIO( );
     SgDataStatementGroup_extendMemoryPoolForFileIO( );
     SgDataStatementObject_extendMemoryPoolForFileIO( );
     SgDataStatementValue_extendMemoryPoolForFileIO( );
     SgDeadIfDirectiveStatement_extendMemoryPoolForFileIO( );
     SgDeallocateStatement_extendMemoryPoolForFileIO( );
     SgDeclarationModifier_extendMemoryPoolForFileIO( );
     SgDeclarationStatement_extendMemoryPoolForFileIO( );
     SgDefaultOptionStmt_extendMemoryPoolForFileIO( );
     SgDefaultSymbol_extendMemoryPoolForFileIO( );
     SgDefineDirectiveStatement_extendMemoryPoolForFileIO( );
     SgDeleteExp_extendMemoryPoolForFileIO( );
     SgDerivedTypeStatement_extendMemoryPoolForFileIO( );
     SgDesignatedInitializer_extendMemoryPoolForFileIO( );
     SgDictionaryComprehension_extendMemoryPoolForFileIO( );
     SgDictionaryExp_extendMemoryPoolForFileIO( );
     SgDimensionObject_extendMemoryPoolForFileIO( );
     SgDirectedGraphEdge_extendMemoryPoolForFileIO( );
     SgDirectory_extendMemoryPoolForFileIO( );
     SgDirectoryList_extendMemoryPoolForFileIO( );
     SgDivAssignOp_extendMemoryPoolForFileIO( );
     SgDivideOp_extendMemoryPoolForFileIO( );
     SgDoWhileStmt_extendMemoryPoolForFileIO( );
     SgDotExp_extendMemoryPoolForFileIO( );
     SgDotStarOp_extendMemoryPoolForFileIO( );
     SgDoubleVal_extendMemoryPoolForFileIO( );
     SgElaboratedTypeModifier_extendMemoryPoolForFileIO( );
     SgElseDirectiveStatement_extendMemoryPoolForFileIO( );
     SgElseWhereStatement_extendMemoryPoolForFileIO( );
     SgElseifDirectiveStatement_extendMemoryPoolForFileIO( );
     SgEmptyDirectiveStatement_extendMemoryPoolForFileIO( );
     SgEndfileStatement_extendMemoryPoolForFileIO( );
     SgEndifDirectiveStatement_extendMemoryPoolForFileIO( );
     SgEntryStatement_extendMemoryPoolForFileIO( );
     SgEnumDeclaration_extendMemoryPoolForFileIO( );
     SgEnumFieldSymbol_extendMemoryPoolForFileIO( );
     SgEnumSymbol_extendMemoryPoolForFileIO( );
     SgEnumType_extendMemoryPoolForFileIO( );
     SgEnumVal_extendMemoryPoolForFileIO( );
     SgEqualityOp_extendMemoryPoolForFileIO( );
     SgEquivalenceStatement_extendMemoryPoolForFileIO( );
     SgErrorDirectiveStatement_extendMemoryPoolForFileIO( );
     SgExecStatement_extendMemoryPoolForFileIO( );
     SgExponentiationOp_extendMemoryPoolForFileIO( );
     SgExponentiationAssignOp_extendMemoryPoolForFileIO( );
     SgExprListExp_extendMemoryPoolForFileIO( );
     SgExprStatement_extendMemoryPoolForFileIO( );
     SgExpression_extendMemoryPoolForFileIO( );
     SgExpressionRoot_extendMemoryPoolForFileIO( );
     SgFile_extendMemoryPoolForFileIO( );
     SgFileList_extendMemoryPoolForFileIO( );
     SgFloatVal_extendMemoryPoolForFileIO( );
     SgFlushStatement_extendMemoryPoolForFileIO( );
     SgForAllStatement_extendMemoryPoolForFileIO( );
     SgForInitStatement_extendMemoryPoolForFileIO( );
     SgForStatement_extendMemoryPoolForFileIO( );
     SgFormatItem_extendMemoryPoolForFileIO( );
     SgFormatItemList_extendMemoryPoolForFileIO( );
     SgFormatStatement_extendMemoryPoolForFileIO( );
     SgFortranDo_extendMemoryPoolForFileIO( );
     SgFortranIncludeLine_extendMemoryPoolForFileIO( );
     SgFortranNonblockedDo_extendMemoryPoolForFileIO( );
     SgFuncDecl_attr_extendMemoryPoolForFileIO( );
     SgFunctionCallExp_extendMemoryPoolForFileIO( );
     SgFunctionDeclaration_extendMemoryPoolForFileIO( );
     SgFunctionDefinition_extendMemoryPoolForFileIO( );
     SgFunctionModifier_extendMemoryPoolForFileIO( );
     SgFunctionParameterList_extendMemoryPoolForFileIO( );
     SgFunctionParameterTypeList_extendMemoryPoolForFileIO( );
     SgFunctionRefExp_extendMemoryPoolForFileIO( );
     SgFunctionSymbol_extendMemoryPoolForFileIO( );
     SgFunctionType_extendMemoryPoolForFileIO( );
     SgFunctionTypeSymbol_extendMemoryPoolForFileIO( );
     SgFunctionTypeTable_extendMemoryPoolForFileIO( );
     SgTypeTable_extendMemoryPoolForFileIO( );
     SgGlobal_extendMemoryPoolForFileIO( );
     SgGotoStatement_extendMemoryPoolForFileIO( );
     SgGraph_extendMemoryPoolForFileIO( );
     SgGraphEdge_extendMemoryPoolForFileIO( );
     SgGraphEdgeList_extendMemoryPoolForFileIO( );
     SgGraphNode_extendMemoryPoolForFileIO( );
     SgGraphNodeList_extendMemoryPoolForFileIO( );
     SgGreaterOrEqualOp_extendMemoryPoolForFileIO( );
     SgGreaterThanOp_extendMemoryPoolForFileIO( );
     SgIOItemExpression_extendMemoryPoolForFileIO( );
     SgIOStatement_extendMemoryPoolForFileIO( );
     SgIdentDirectiveStatement_extendMemoryPoolForFileIO( );
     SgIfDirectiveStatement_extendMemoryPoolForFileIO( );
     SgIfStmt_extendMemoryPoolForFileIO( );
     SgIfdefDirectiveStatement_extendMemoryPoolForFileIO( );
     SgIfndefDirectiveStatement_extendMemoryPoolForFileIO( );
     SgImagPartOp_extendMemoryPoolForFileIO( );
     SgImplicitStatement_extendMemoryPoolForFileIO( );
     SgImpliedDo_extendMemoryPoolForFileIO( );
     SgImportStatement_extendMemoryPoolForFileIO( );
     SgIncidenceDirectedGraph_extendMemoryPoolForFileIO( );
     SgIncidenceUndirectedGraph_extendMemoryPoolForFileIO( );
     SgIncludeDirectiveStatement_extendMemoryPoolForFileIO( );
     SgIncludeNextDirectiveStatement_extendMemoryPoolForFileIO( );
     SgInitializedName_extendMemoryPoolForFileIO( );
     SgInitializer_extendMemoryPoolForFileIO( );
     SgInquireStatement_extendMemoryPoolForFileIO( );
     SgIntKeyedBidirectionalGraph_extendMemoryPoolForFileIO( );
     SgIntVal_extendMemoryPoolForFileIO( );
     SgIntegerDivideOp_extendMemoryPoolForFileIO( );
     SgIntegerDivideAssignOp_extendMemoryPoolForFileIO( );
     SgInterfaceBody_extendMemoryPoolForFileIO( );
     SgHeaderFileBody_extendMemoryPoolForFileIO( );
     SgInterfaceStatement_extendMemoryPoolForFileIO( );
     SgInterfaceSymbol_extendMemoryPoolForFileIO( );
     SgIntrinsicSymbol_extendMemoryPoolForFileIO( );
     SgIsOp_extendMemoryPoolForFileIO( );
     SgIsNotOp_extendMemoryPoolForFileIO( );
     SgIorAssignOp_extendMemoryPoolForFileIO( );
     SgKeyDatumPair_extendMemoryPoolForFileIO( );
     SgCudaKernelExecConfig_extendMemoryPoolForFileIO( );
     SgCudaKernelCallExp_extendMemoryPoolForFileIO( );
     SgLabelRefExp_extendMemoryPoolForFileIO( );
     SgLabelStatement_extendMemoryPoolForFileIO( );
     SgJavaLabelStatement_extendMemoryPoolForFileIO( );
     SgLabelSymbol_extendMemoryPoolForFileIO( );
     SgJavaLabelSymbol_extendMemoryPoolForFileIO( );
     SgLambdaRefExp_extendMemoryPoolForFileIO( );
     SgLessOrEqualOp_extendMemoryPoolForFileIO( );
     SgLessThanOp_extendMemoryPoolForFileIO( );
     SgLineDirectiveStatement_extendMemoryPoolForFileIO( );
     SgLinemarkerDirectiveStatement_extendMemoryPoolForFileIO( );
     SgLinkageModifier_extendMemoryPoolForFileIO( );
     SgListComprehension_extendMemoryPoolForFileIO( );
     SgListExp_extendMemoryPoolForFileIO( );
     SgLocatedNode_extendMemoryPoolForFileIO( );
     SgLocatedNodeSupport_extendMemoryPoolForFileIO( );
     SgLongDoubleVal_extendMemoryPoolForFileIO( );
     SgLongIntVal_extendMemoryPoolForFileIO( );
     SgLongLongIntVal_extendMemoryPoolForFileIO( );
     SgLshiftAssignOp_extendMemoryPoolForFileIO( );
     SgLshiftOp_extendMemoryPoolForFileIO( );
     SgMemberFunctionDeclaration_extendMemoryPoolForFileIO( );
     SgMemberFunctionRefExp_extendMemoryPoolForFileIO( );
     SgMemberFunctionSymbol_extendMemoryPoolForFileIO( );
     SgMemberFunctionType_extendMemoryPoolForFileIO( );
     SgMembershipOp_extendMemoryPoolForFileIO( );
     SgMinusAssignOp_extendMemoryPoolForFileIO( );
     SgMinusMinusOp_extendMemoryPoolForFileIO( );
     SgMinusOp_extendMemoryPoolForFileIO( );
     SgModAssignOp_extendMemoryPoolForFileIO( );
     SgModOp_extendMemoryPoolForFileIO( );
     SgModifier_extendMemoryPoolForFileIO( );
     SgModifierNodes_extendMemoryPoolForFileIO( );
     SgModifierType_extendMemoryPoolForFileIO( );
     SgModuleStatement_extendMemoryPoolForFileIO( );
     SgModuleSymbol_extendMemoryPoolForFileIO( );
     SgMultAssignOp_extendMemoryPoolForFileIO( );
     SgMultiplyOp_extendMemoryPoolForFileIO( );
     SgName_extendMemoryPoolForFileIO( );
     SgNameGroup_extendMemoryPoolForFileIO( );
     SgNamedType_extendMemoryPoolForFileIO( );
     SgNamelistStatement_extendMemoryPoolForFileIO( );
     SgNamespaceAliasDeclarationStatement_extendMemoryPoolForFileIO( );
     SgNamespaceDeclarationStatement_extendMemoryPoolForFileIO( );
     SgNamespaceDefinitionStatement_extendMemoryPoolForFileIO( );
     SgNamespaceSymbol_extendMemoryPoolForFileIO( );
     SgNaryOp_extendMemoryPoolForFileIO( );
     SgNaryBooleanOp_extendMemoryPoolForFileIO( );
     SgNaryComparisonOp_extendMemoryPoolForFileIO( );
     SgNewExp_extendMemoryPoolForFileIO( );
     SgNode_extendMemoryPoolForFileIO( );
     SgNotEqualOp_extendMemoryPoolForFileIO( );
     SgNotOp_extendMemoryPoolForFileIO( );
     SgNonMembershipOp_extendMemoryPoolForFileIO( );
     SgNullExpression_extendMemoryPoolForFileIO( );
     SgNullStatement_extendMemoryPoolForFileIO( );
     SgNullifyStatement_extendMemoryPoolForFileIO( );
     SgOmpAtomicStatement_extendMemoryPoolForFileIO( );
     SgOmpBarrierStatement_extendMemoryPoolForFileIO( );
     SgOmpCriticalStatement_extendMemoryPoolForFileIO( );
     SgOmpClauseBodyStatement_extendMemoryPoolForFileIO( );
     SgOmpBodyStatement_extendMemoryPoolForFileIO( );
     SgOmpDoStatement_extendMemoryPoolForFileIO( );
     SgOmpFlushStatement_extendMemoryPoolForFileIO( );
     SgOmpForStatement_extendMemoryPoolForFileIO( );
     SgOmpMasterStatement_extendMemoryPoolForFileIO( );
     SgOmpOrderedStatement_extendMemoryPoolForFileIO( );
     SgOmpParallelStatement_extendMemoryPoolForFileIO( );
     SgOmpSectionStatement_extendMemoryPoolForFileIO( );
     SgOmpSectionsStatement_extendMemoryPoolForFileIO( );
     SgOmpSingleStatement_extendMemoryPoolForFileIO( );
     SgOmpTaskStatement_extendMemoryPoolForFileIO( );
     SgOmpTaskwaitStatement_extendMemoryPoolForFileIO( );
     SgOmpThreadprivateStatement_extendMemoryPoolForFileIO( );
     SgOmpWorkshareStatement_extendMemoryPoolForFileIO( );
     SgOmpClause_extendMemoryPoolForFileIO( );
     SgOmpCollapseClause_extendMemoryPoolForFileIO( );
     SgOmpCopyinClause_extendMemoryPoolForFileIO( );
     SgOmpCopyprivateClause_extendMemoryPoolForFileIO( );
     SgOmpDefaultClause_extendMemoryPoolForFileIO( );
     SgOmpExpressionClause_extendMemoryPoolForFileIO( );
     SgOmpFirstprivateClause_extendMemoryPoolForFileIO( );
     SgOmpIfClause_extendMemoryPoolForFileIO( );
     SgOmpLastprivateClause_extendMemoryPoolForFileIO( );
     SgOmpNowaitClause_extendMemoryPoolForFileIO( );
     SgOmpNumThreadsClause_extendMemoryPoolForFileIO( );
     SgOmpOrderedClause_extendMemoryPoolForFileIO( );
     SgOmpPrivateClause_extendMemoryPoolForFileIO( );
     SgOmpReductionClause_extendMemoryPoolForFileIO( );
     SgOmpScheduleClause_extendMemoryPoolForFileIO( );
     SgOmpSharedClause_extendMemoryPoolForFileIO( );
     SgOmpUntiedClause_extendMemoryPoolForFileIO( );
     SgOmpVariablesClause_extendMemoryPoolForFileIO( );
     SgOpenclAccessModeModifier_extendMemoryPoolForFileIO( );
     SgOpenStatement_extendMemoryPoolForFileIO( );
     SgOptions_extendMemoryPoolForFileIO( );
     SgOrOp_extendMemoryPoolForFileIO( );
     SgParameterStatement_extendMemoryPoolForFileIO( );
     SgPartialFunctionModifierType_extendMemoryPoolForFileIO( );
     SgPartialFunctionType_extendMemoryPoolForFileIO( );
     SgPassStatement_extendMemoryPoolForFileIO( );
     SgPlusAssignOp_extendMemoryPoolForFileIO( );
     SgPlusPlusOp_extendMemoryPoolForFileIO( );
     SgPntrArrRefExp_extendMemoryPoolForFileIO( );
     SgPointerAssignOp_extendMemoryPoolForFileIO( );
     SgPointerDerefExp_extendMemoryPoolForFileIO( );
     SgPointerMemberType_extendMemoryPoolForFileIO( );
     SgPointerType_extendMemoryPoolForFileIO( );
     SgPragma_extendMemoryPoolForFileIO( );
     SgPragmaDeclaration_extendMemoryPoolForFileIO( );
     SgPrintStatement_extendMemoryPoolForFileIO( );
     SgProcedureHeaderStatement_extendMemoryPoolForFileIO( );
     SgProgramHeaderStatement_extendMemoryPoolForFileIO( );
     SgProject_extendMemoryPoolForFileIO( );
     SgPseudoDestructorRefExp_extendMemoryPoolForFileIO( );
     SgPythonGlobalStmt_extendMemoryPoolForFileIO( );
     SgPythonPrintStmt_extendMemoryPoolForFileIO( );
     SgQualifiedName_extendMemoryPoolForFileIO( );
     SgQualifiedNameType_extendMemoryPoolForFileIO( );
     SgReadStatement_extendMemoryPoolForFileIO( );
     SgRealPartOp_extendMemoryPoolForFileIO( );
     SgRefExp_extendMemoryPoolForFileIO( );
     SgReferenceType_extendMemoryPoolForFileIO( );
     SgRenamePair_extendMemoryPoolForFileIO( );
     SgRenameSymbol_extendMemoryPoolForFileIO( );
     SgReturnStmt_extendMemoryPoolForFileIO( );
     SgRewindStatement_extendMemoryPoolForFileIO( );
     SgRshiftAssignOp_extendMemoryPoolForFileIO( );
     SgRshiftOp_extendMemoryPoolForFileIO( );
     SgJavaUnsignedRshiftAssignOp_extendMemoryPoolForFileIO( );
     SgJavaUnsignedRshiftOp_extendMemoryPoolForFileIO( );
     SgScopeOp_extendMemoryPoolForFileIO( );
     SgScopeStatement_extendMemoryPoolForFileIO( );
     SgSequenceStatement_extendMemoryPoolForFileIO( );
     SgSetComprehension_extendMemoryPoolForFileIO( );
     SgShortVal_extendMemoryPoolForFileIO( );
     SgSizeOfOp_extendMemoryPoolForFileIO( );
     SgJavaInstanceOfOp_extendMemoryPoolForFileIO( );
     SgSourceFile_extendMemoryPoolForFileIO( );
     SgSpawnStmt_extendMemoryPoolForFileIO( );
     SgJavaThrowStatement_extendMemoryPoolForFileIO( );
     SgJavaForEachStatement_extendMemoryPoolForFileIO( );
     SgJavaSynchronizedStatement_extendMemoryPoolForFileIO( );
     SgJavaParameterizedType_extendMemoryPoolForFileIO( );
     SgSpecialFunctionModifier_extendMemoryPoolForFileIO( );
     SgStatement_extendMemoryPoolForFileIO( );
     SgStmtDeclarationStatement_extendMemoryPoolForFileIO( );
     SgStatementExpression_extendMemoryPoolForFileIO( );
     SgStatementFunctionStatement_extendMemoryPoolForFileIO( );
     SgStopOrPauseStatement_extendMemoryPoolForFileIO( );
     SgStorageModifier_extendMemoryPoolForFileIO( );
     SgStringConversion_extendMemoryPoolForFileIO( );
     SgStringKeyedBidirectionalGraph_extendMemoryPoolForFileIO( );
     SgStringVal_extendMemoryPoolForFileIO( );
     SgSubscriptExpression_extendMemoryPoolForFileIO( );
     SgSubtractOp_extendMemoryPoolForFileIO( );
     SgSupport_extendMemoryPoolForFileIO( );
     SgSwitchStatement_extendMemoryPoolForFileIO( );
     SgSymbol_extendMemoryPoolForFileIO( );
     SgSymbolTable_extendMemoryPoolForFileIO( );
     SgTemplateArgument_extendMemoryPoolForFileIO( );
     SgTemplateArgumentList_extendMemoryPoolForFileIO( );
     SgTemplateDeclaration_extendMemoryPoolForFileIO( );
     SgTemplateClassDeclaration_extendMemoryPoolForFileIO( );
     SgTemplateFunctionDeclaration_extendMemoryPoolForFileIO( );
     SgTemplateMemberFunctionDeclaration_extendMemoryPoolForFileIO( );
     SgTemplateClassDefinition_extendMemoryPoolForFileIO( );
     SgTemplateFunctionDefinition_extendMemoryPoolForFileIO( );
     SgTemplateInstantiationDecl_extendMemoryPoolForFileIO( );
     SgTemplateInstantiationDefn_extendMemoryPoolForFileIO( );
     SgTemplateInstantiationDirectiveStatement_extendMemoryPoolForFileIO( );
     SgTemplateInstantiationFunctionDecl_extendMemoryPoolForFileIO( );
     SgTemplateInstantiationMemberFunctionDecl_extendMemoryPoolForFileIO( );
     SgTemplateParameter_extendMemoryPoolForFileIO( );
     SgTemplateParameterList_extendMemoryPoolForFileIO( );
     SgTemplateSymbol_extendMemoryPoolForFileIO( );
     SgTemplateType_extendMemoryPoolForFileIO( );
     SgThisExp_extendMemoryPoolForFileIO( );
     SgSuperExp_extendMemoryPoolForFileIO( );
     SgThrowOp_extendMemoryPoolForFileIO( );
     SgToken_extendMemoryPoolForFileIO( );
     SgTryStmt_extendMemoryPoolForFileIO( );
     SgTupleExp_extendMemoryPoolForFileIO( );
     SgType_extendMemoryPoolForFileIO( );
     SgTypeBool_extendMemoryPoolForFileIO( );
     SgTypeChar_extendMemoryPoolForFileIO( );
     SgTypeComplex_extendMemoryPoolForFileIO( );
     SgTypeDefault_extendMemoryPoolForFileIO( );
     SgTypeLabel_extendMemoryPoolForFileIO( );
     SgTypeDouble_extendMemoryPoolForFileIO( );
     SgTypeEllipse_extendMemoryPoolForFileIO( );
     SgTypeFloat_extendMemoryPoolForFileIO( );
     SgTypeGlobalVoid_extendMemoryPoolForFileIO( );
     SgTypeIdOp_extendMemoryPoolForFileIO( );
     SgTypeImaginary_extendMemoryPoolForFileIO( );
     SgTypeInt_extendMemoryPoolForFileIO( );
     SgTypeLong_extendMemoryPoolForFileIO( );
     SgTypeLongDouble_extendMemoryPoolForFileIO( );
     SgTypeLongLong_extendMemoryPoolForFileIO( );
     SgTypeModifier_extendMemoryPoolForFileIO( );
     SgTypeShort_extendMemoryPoolForFileIO( );
     SgTypeSignedChar_extendMemoryPoolForFileIO( );
     SgTypeSignedInt_extendMemoryPoolForFileIO( );
     SgTypeSignedLong_extendMemoryPoolForFileIO( );
     SgTypeSignedLongLong_extendMemoryPoolForFileIO( );
     SgTypeSignedShort_extendMemoryPoolForFileIO( );
     SgTypeString_extendMemoryPoolForFileIO( );
     SgTypeUnknown_extendMemoryPoolForFileIO( );
     SgTypeUnsignedChar_extendMemoryPoolForFileIO( );
     SgTypeUnsignedInt_extendMemoryPoolForFileIO( );
     SgTypeUnsignedLong_extendMemoryPoolForFileIO( );
     SgTypeUnsignedLongLong_extendMemoryPoolForFileIO( );
     SgTypeUnsignedShort_extendMemoryPoolForFileIO( );
     SgTypeVoid_extendMemoryPoolForFileIO( );
     SgTypeWchar_extendMemoryPoolForFileIO( );
     SgTypedefDeclaration_extendMemoryPoolForFileIO( );
     SgTypedefSeq_extendMemoryPoolForFileIO( );
     SgTypedefSymbol_extendMemoryPoolForFileIO( );
     SgTypedefType_extendMemoryPoolForFileIO( );
     SgUPC_AccessModifier_extendMemoryPoolForFileIO( );
     SgUnaryAddOp_extendMemoryPoolForFileIO( );
     SgUnaryOp_extendMemoryPoolForFileIO( );
     SgUndefDirectiveStatement_extendMemoryPoolForFileIO( );
     SgUndirectedGraphEdge_extendMemoryPoolForFileIO( );
     SgUnknownArrayOrFunctionReference_extendMemoryPoolForFileIO( );
     SgUnknownFile_extendMemoryPoolForFileIO( );
     SgUnparse_Info_extendMemoryPoolForFileIO( );
     SgUnsignedCharVal_extendMemoryPoolForFileIO( );
     SgUnsignedIntVal_extendMemoryPoolForFileIO( );
     SgUnsignedLongLongIntVal_extendMemoryPoolForFileIO( );
     SgUnsignedLongVal_extendMemoryPoolForFileIO( );
     SgUnsignedShortVal_extendMemoryPoolForFileIO( );
     SgUpcBarrierStatement_extendMemoryPoolForFileIO( );
     SgUpcBlocksizeofExpression_extendMemoryPoolForFileIO( );
     SgUpcElemsizeofExpression_extendMemoryPoolForFileIO( );
     SgUpcFenceStatement_extendMemoryPoolForFileIO( );
     SgUpcForAllStatement_extendMemoryPoolForFileIO( );
     SgUpcLocalsizeofExpression_extendMemoryPoolForFileIO( );
     SgUpcMythread_extendMemoryPoolForFileIO( );
     SgUpcNotifyStatement_extendMemoryPoolForFileIO( );
     SgUpcThreads_extendMemoryPoolForFileIO( );
     SgUpcWaitStatement_extendMemoryPoolForFileIO( );
     SgUseStatement_extendMemoryPoolForFileIO( );
     SgUserDefinedBinaryOp_extendMemoryPoolForFileIO( );
     SgUserDefinedUnaryOp_extendMemoryPoolForFileIO( );
     SgUsingDeclarationStatement_extendMemoryPoolForFileIO( );
     SgUsingDirectiveStatement_extendMemoryPoolForFileIO( );
     SgValueExp_extendMemoryPoolForFileIO( );
     SgVarArgCopyOp_extendMemoryPoolForFileIO( );
     SgVarArgEndOp_extendMemoryPoolForFileIO( );
     SgVarArgOp_extendMemoryPoolForFileIO( );
     SgVarArgStartOneOperandOp_extendMemoryPoolForFileIO( );
     SgVarArgStartOp_extendMemoryPoolForFileIO( );
     SgVarRefExp_extendMemoryPoolForFileIO( );
     SgVariableDeclaration_extendMemoryPoolForFileIO( );
     SgVariableDefinition_extendMemoryPoolForFileIO( );
     SgVariableSymbol_extendMemoryPoolForFileIO( );
     SgVariantExpression_extendMemoryPoolForFileIO( );
     SgVariantStatement_extendMemoryPoolForFileIO( );
     SgWaitStatement_extendMemoryPoolForFileIO( );
     SgWarningDirectiveStatement_extendMemoryPoolForFileIO( );
     SgWithStatement_extendMemoryPoolForFileIO( );
     SgWcharVal_extendMemoryPoolForFileIO( );
     SgWhereStatement_extendMemoryPoolForFileIO( );
     SgWhileStmt_extendMemoryPoolForFileIO( );
     SgWriteStatement_extendMemoryPoolForFileIO( );
     SgXorAssignOp_extendMemoryPoolForFileIO( );
     SgYieldExpression_extendMemoryPoolForFileIO( );
     Sg_File_Info_extendMemoryPoolForFileIO( );
     SgTypeCAFTeam_extendMemoryPoolForFileIO( );
     SgCAFWithTeamStatement_extendMemoryPoolForFileIO( );
     SgCAFCoExpression_extendMemoryPoolForFileIO( );
     SgCallExpression_extendMemoryPoolForFileIO( );
     SgTypeCrayPointer_extendMemoryPoolForFileIO( );
     SgJavaImportStatement_extendMemoryPoolForFileIO( );

/* #line 473 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarAST_FileIoSource.code" */
  
     return;
   }


int 
AST_FILE_IO::getNumberOfAsts ()
   {
     return vectorOfASTs.size();
   }


void
AST_FILE_IO::addNewAst (AstData* newAst)
   {
     vectorOfASTs.push_back(newAst);
     actualRebuildAst = newAst;
     return;
   }


void
AST_FILE_IO::printFileMaps ()
   {
      std::map<int,std::string> :: iterator Iter1 = Sg_File_Info::p_fileidtoname_map.begin();
      for ( ; Iter1 != Sg_File_Info::p_fileidtoname_map.end(); ++Iter1)
         {
           std::cout << Iter1->first << " " << Iter1->second << std::endl;
         }
      std::map<std::string,int> :: iterator Iter2 = Sg_File_Info::p_nametofileid_map.begin();
      for ( ; Iter2 != Sg_File_Info::p_nametofileid_map.end(); ++Iter2)
         {
           std::cout << Iter2->first << " " << Iter2->second << std::endl;
         }
   }



void
AST_FILE_IO::deleteStoredAsts ()
   {
     std::vector<AstData*>::iterator astIterator = vectorOfASTs.begin(); 
     for ( ; astIterator != vectorOfASTs.end(); ++astIterator)
         {
           delete (*astIterator);
         }
     vectorOfASTs.clear();
     return;
   }



void
AST_FILE_IO::setStaticDataOfAst (AstData *astInPool)
   {
     assert (astInPool->get_AstIndex() < (int)vectorOfASTs.size());
     astInPool->setStaticDataMembersOfIRNodes();
     return;
   }




void 
AST_FILE_IO::printListOfPoolSizes ()
   {
     std::cout << "Memory pool size of SgAccessModifier: " <<  listOfMemoryPoolSizes[V_SgAccessModifier] << std::endl; 
     std::cout << "Memory pool size of SgActualArgumentExpression: " <<  listOfMemoryPoolSizes[V_SgActualArgumentExpression] << std::endl; 
     std::cout << "Memory pool size of SgAddOp: " <<  listOfMemoryPoolSizes[V_SgAddOp] << std::endl; 
     std::cout << "Memory pool size of SgAddressOfOp: " <<  listOfMemoryPoolSizes[V_SgAddressOfOp] << std::endl; 
     std::cout << "Memory pool size of SgAggregateInitializer: " <<  listOfMemoryPoolSizes[V_SgAggregateInitializer] << std::endl; 
     std::cout << "Memory pool size of SgAliasSymbol: " <<  listOfMemoryPoolSizes[V_SgAliasSymbol] << std::endl; 
     std::cout << "Memory pool size of SgAllocateStatement: " <<  listOfMemoryPoolSizes[V_SgAllocateStatement] << std::endl; 
     std::cout << "Memory pool size of SgAndAssignOp: " <<  listOfMemoryPoolSizes[V_SgAndAssignOp] << std::endl; 
     std::cout << "Memory pool size of SgAndOp: " <<  listOfMemoryPoolSizes[V_SgAndOp] << std::endl; 
     std::cout << "Memory pool size of SgArithmeticIfStatement: " <<  listOfMemoryPoolSizes[V_SgArithmeticIfStatement] << std::endl; 
     std::cout << "Memory pool size of SgArrayType: " <<  listOfMemoryPoolSizes[V_SgArrayType] << std::endl; 
     std::cout << "Memory pool size of SgArrowExp: " <<  listOfMemoryPoolSizes[V_SgArrowExp] << std::endl; 
     std::cout << "Memory pool size of SgArrowStarOp: " <<  listOfMemoryPoolSizes[V_SgArrowStarOp] << std::endl; 
     std::cout << "Memory pool size of SgAsmArmInstruction: " <<  listOfMemoryPoolSizes[V_SgAsmArmInstruction] << std::endl; 
     std::cout << "Memory pool size of SgAsmArmRegisterReferenceExpression: " <<  listOfMemoryPoolSizes[V_SgAsmArmRegisterReferenceExpression] << std::endl; 
     std::cout << "Memory pool size of SgAsmBasicString: " <<  listOfMemoryPoolSizes[V_SgAsmBasicString] << std::endl; 
     std::cout << "Memory pool size of SgAsmBinaryAdd: " <<  listOfMemoryPoolSizes[V_SgAsmBinaryAdd] << std::endl; 
     std::cout << "Memory pool size of SgAsmBinaryAddPostupdate: " <<  listOfMemoryPoolSizes[V_SgAsmBinaryAddPostupdate] << std::endl; 
     std::cout << "Memory pool size of SgAsmBinaryAddPreupdate: " <<  listOfMemoryPoolSizes[V_SgAsmBinaryAddPreupdate] << std::endl; 
     std::cout << "Memory pool size of SgAsmBinaryAsr: " <<  listOfMemoryPoolSizes[V_SgAsmBinaryAsr] << std::endl; 
     std::cout << "Memory pool size of SgAsmBinaryDivide: " <<  listOfMemoryPoolSizes[V_SgAsmBinaryDivide] << std::endl; 
     std::cout << "Memory pool size of SgAsmBinaryExpression: " <<  listOfMemoryPoolSizes[V_SgAsmBinaryExpression] << std::endl; 
     std::cout << "Memory pool size of SgAsmBinaryLsl: " <<  listOfMemoryPoolSizes[V_SgAsmBinaryLsl] << std::endl; 
     std::cout << "Memory pool size of SgAsmBinaryLsr: " <<  listOfMemoryPoolSizes[V_SgAsmBinaryLsr] << std::endl; 
     std::cout << "Memory pool size of SgAsmBinaryMod: " <<  listOfMemoryPoolSizes[V_SgAsmBinaryMod] << std::endl; 
     std::cout << "Memory pool size of SgAsmBinaryMultiply: " <<  listOfMemoryPoolSizes[V_SgAsmBinaryMultiply] << std::endl; 
     std::cout << "Memory pool size of SgAsmBinaryRor: " <<  listOfMemoryPoolSizes[V_SgAsmBinaryRor] << std::endl; 
     std::cout << "Memory pool size of SgAsmBinarySubtract: " <<  listOfMemoryPoolSizes[V_SgAsmBinarySubtract] << std::endl; 
     std::cout << "Memory pool size of SgAsmBinarySubtractPostupdate: " <<  listOfMemoryPoolSizes[V_SgAsmBinarySubtractPostupdate] << std::endl; 
     std::cout << "Memory pool size of SgAsmBinarySubtractPreupdate: " <<  listOfMemoryPoolSizes[V_SgAsmBinarySubtractPreupdate] << std::endl; 
     std::cout << "Memory pool size of SgAsmBlock: " <<  listOfMemoryPoolSizes[V_SgAsmBlock] << std::endl; 
     std::cout << "Memory pool size of SgAsmByteValueExpression: " <<  listOfMemoryPoolSizes[V_SgAsmByteValueExpression] << std::endl; 
     std::cout << "Memory pool size of SgAsmCoffStrtab: " <<  listOfMemoryPoolSizes[V_SgAsmCoffStrtab] << std::endl; 
     std::cout << "Memory pool size of SgAsmCoffSymbol: " <<  listOfMemoryPoolSizes[V_SgAsmCoffSymbol] << std::endl; 
     std::cout << "Memory pool size of SgAsmCoffSymbolList: " <<  listOfMemoryPoolSizes[V_SgAsmCoffSymbolList] << std::endl; 
     std::cout << "Memory pool size of SgAsmCoffSymbolTable: " <<  listOfMemoryPoolSizes[V_SgAsmCoffSymbolTable] << std::endl; 
     std::cout << "Memory pool size of SgAsmCommonSubExpression: " <<  listOfMemoryPoolSizes[V_SgAsmCommonSubExpression] << std::endl; 
     std::cout << "Memory pool size of SgAsmControlFlagsExpression: " <<  listOfMemoryPoolSizes[V_SgAsmControlFlagsExpression] << std::endl; 
     std::cout << "Memory pool size of SgAsmDOSExtendedHeader: " <<  listOfMemoryPoolSizes[V_SgAsmDOSExtendedHeader] << std::endl; 
     std::cout << "Memory pool size of SgAsmDOSFileHeader: " <<  listOfMemoryPoolSizes[V_SgAsmDOSFileHeader] << std::endl; 
     std::cout << "Memory pool size of SgAsmDoubleFloatValueExpression: " <<  listOfMemoryPoolSizes[V_SgAsmDoubleFloatValueExpression] << std::endl; 
     std::cout << "Memory pool size of SgAsmDoubleWordValueExpression: " <<  listOfMemoryPoolSizes[V_SgAsmDoubleWordValueExpression] << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfAccessDeclaration: " <<  listOfMemoryPoolSizes[V_SgAsmDwarfAccessDeclaration] << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfArrayType: " <<  listOfMemoryPoolSizes[V_SgAsmDwarfArrayType] << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfBaseType: " <<  listOfMemoryPoolSizes[V_SgAsmDwarfBaseType] << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfCatchBlock: " <<  listOfMemoryPoolSizes[V_SgAsmDwarfCatchBlock] << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfClassTemplate: " <<  listOfMemoryPoolSizes[V_SgAsmDwarfClassTemplate] << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfClassType: " <<  listOfMemoryPoolSizes[V_SgAsmDwarfClassType] << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfCommonBlock: " <<  listOfMemoryPoolSizes[V_SgAsmDwarfCommonBlock] << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfCommonInclusion: " <<  listOfMemoryPoolSizes[V_SgAsmDwarfCommonInclusion] << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfCompilationUnit: " <<  listOfMemoryPoolSizes[V_SgAsmDwarfCompilationUnit] << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfCompilationUnitList: " <<  listOfMemoryPoolSizes[V_SgAsmDwarfCompilationUnitList] << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfCondition: " <<  listOfMemoryPoolSizes[V_SgAsmDwarfCondition] << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfConstType: " <<  listOfMemoryPoolSizes[V_SgAsmDwarfConstType] << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfConstant: " <<  listOfMemoryPoolSizes[V_SgAsmDwarfConstant] << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfConstruct: " <<  listOfMemoryPoolSizes[V_SgAsmDwarfConstruct] << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfConstructList: " <<  listOfMemoryPoolSizes[V_SgAsmDwarfConstructList] << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfDwarfProcedure: " <<  listOfMemoryPoolSizes[V_SgAsmDwarfDwarfProcedure] << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfEntryPoint: " <<  listOfMemoryPoolSizes[V_SgAsmDwarfEntryPoint] << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfEnumerationType: " <<  listOfMemoryPoolSizes[V_SgAsmDwarfEnumerationType] << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfEnumerator: " <<  listOfMemoryPoolSizes[V_SgAsmDwarfEnumerator] << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfFileType: " <<  listOfMemoryPoolSizes[V_SgAsmDwarfFileType] << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfFormalParameter: " <<  listOfMemoryPoolSizes[V_SgAsmDwarfFormalParameter] << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfFormatLabel: " <<  listOfMemoryPoolSizes[V_SgAsmDwarfFormatLabel] << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfFriend: " <<  listOfMemoryPoolSizes[V_SgAsmDwarfFriend] << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfFunctionTemplate: " <<  listOfMemoryPoolSizes[V_SgAsmDwarfFunctionTemplate] << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfImportedDeclaration: " <<  listOfMemoryPoolSizes[V_SgAsmDwarfImportedDeclaration] << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfImportedModule: " <<  listOfMemoryPoolSizes[V_SgAsmDwarfImportedModule] << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfImportedUnit: " <<  listOfMemoryPoolSizes[V_SgAsmDwarfImportedUnit] << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfInformation: " <<  listOfMemoryPoolSizes[V_SgAsmDwarfInformation] << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfInheritance: " <<  listOfMemoryPoolSizes[V_SgAsmDwarfInheritance] << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfInlinedSubroutine: " <<  listOfMemoryPoolSizes[V_SgAsmDwarfInlinedSubroutine] << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfInterfaceType: " <<  listOfMemoryPoolSizes[V_SgAsmDwarfInterfaceType] << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfLabel: " <<  listOfMemoryPoolSizes[V_SgAsmDwarfLabel] << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfLexicalBlock: " <<  listOfMemoryPoolSizes[V_SgAsmDwarfLexicalBlock] << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfLine: " <<  listOfMemoryPoolSizes[V_SgAsmDwarfLine] << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfLineList: " <<  listOfMemoryPoolSizes[V_SgAsmDwarfLineList] << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfMacro: " <<  listOfMemoryPoolSizes[V_SgAsmDwarfMacro] << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfMacroList: " <<  listOfMemoryPoolSizes[V_SgAsmDwarfMacroList] << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfMember: " <<  listOfMemoryPoolSizes[V_SgAsmDwarfMember] << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfModule: " <<  listOfMemoryPoolSizes[V_SgAsmDwarfModule] << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfMutableType: " <<  listOfMemoryPoolSizes[V_SgAsmDwarfMutableType] << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfNamelist: " <<  listOfMemoryPoolSizes[V_SgAsmDwarfNamelist] << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfNamelistItem: " <<  listOfMemoryPoolSizes[V_SgAsmDwarfNamelistItem] << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfNamespace: " <<  listOfMemoryPoolSizes[V_SgAsmDwarfNamespace] << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfPackedType: " <<  listOfMemoryPoolSizes[V_SgAsmDwarfPackedType] << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfPartialUnit: " <<  listOfMemoryPoolSizes[V_SgAsmDwarfPartialUnit] << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfPointerType: " <<  listOfMemoryPoolSizes[V_SgAsmDwarfPointerType] << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfPtrToMemberType: " <<  listOfMemoryPoolSizes[V_SgAsmDwarfPtrToMemberType] << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfReferenceType: " <<  listOfMemoryPoolSizes[V_SgAsmDwarfReferenceType] << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfRestrictType: " <<  listOfMemoryPoolSizes[V_SgAsmDwarfRestrictType] << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfSetType: " <<  listOfMemoryPoolSizes[V_SgAsmDwarfSetType] << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfSharedType: " <<  listOfMemoryPoolSizes[V_SgAsmDwarfSharedType] << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfStringType: " <<  listOfMemoryPoolSizes[V_SgAsmDwarfStringType] << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfStructureType: " <<  listOfMemoryPoolSizes[V_SgAsmDwarfStructureType] << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfSubprogram: " <<  listOfMemoryPoolSizes[V_SgAsmDwarfSubprogram] << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfSubrangeType: " <<  listOfMemoryPoolSizes[V_SgAsmDwarfSubrangeType] << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfSubroutineType: " <<  listOfMemoryPoolSizes[V_SgAsmDwarfSubroutineType] << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfTemplateTypeParameter: " <<  listOfMemoryPoolSizes[V_SgAsmDwarfTemplateTypeParameter] << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfTemplateValueParameter: " <<  listOfMemoryPoolSizes[V_SgAsmDwarfTemplateValueParameter] << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfThrownType: " <<  listOfMemoryPoolSizes[V_SgAsmDwarfThrownType] << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfTryBlock: " <<  listOfMemoryPoolSizes[V_SgAsmDwarfTryBlock] << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfTypedef: " <<  listOfMemoryPoolSizes[V_SgAsmDwarfTypedef] << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfUnionType: " <<  listOfMemoryPoolSizes[V_SgAsmDwarfUnionType] << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfUnknownConstruct: " <<  listOfMemoryPoolSizes[V_SgAsmDwarfUnknownConstruct] << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfUnspecifiedParameters: " <<  listOfMemoryPoolSizes[V_SgAsmDwarfUnspecifiedParameters] << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfUnspecifiedType: " <<  listOfMemoryPoolSizes[V_SgAsmDwarfUnspecifiedType] << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfUpcRelaxedType: " <<  listOfMemoryPoolSizes[V_SgAsmDwarfUpcRelaxedType] << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfUpcSharedType: " <<  listOfMemoryPoolSizes[V_SgAsmDwarfUpcSharedType] << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfUpcStrictType: " <<  listOfMemoryPoolSizes[V_SgAsmDwarfUpcStrictType] << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfVariable: " <<  listOfMemoryPoolSizes[V_SgAsmDwarfVariable] << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfVariant: " <<  listOfMemoryPoolSizes[V_SgAsmDwarfVariant] << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfVariantPart: " <<  listOfMemoryPoolSizes[V_SgAsmDwarfVariantPart] << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfVolatileType: " <<  listOfMemoryPoolSizes[V_SgAsmDwarfVolatileType] << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfWithStmt: " <<  listOfMemoryPoolSizes[V_SgAsmDwarfWithStmt] << std::endl; 
     std::cout << "Memory pool size of SgAsmElfDynamicEntry: " <<  listOfMemoryPoolSizes[V_SgAsmElfDynamicEntry] << std::endl; 
     std::cout << "Memory pool size of SgAsmElfDynamicEntryList: " <<  listOfMemoryPoolSizes[V_SgAsmElfDynamicEntryList] << std::endl; 
     std::cout << "Memory pool size of SgAsmElfDynamicSection: " <<  listOfMemoryPoolSizes[V_SgAsmElfDynamicSection] << std::endl; 
     std::cout << "Memory pool size of SgAsmElfEHFrameEntryCI: " <<  listOfMemoryPoolSizes[V_SgAsmElfEHFrameEntryCI] << std::endl; 
     std::cout << "Memory pool size of SgAsmElfEHFrameEntryCIList: " <<  listOfMemoryPoolSizes[V_SgAsmElfEHFrameEntryCIList] << std::endl; 
     std::cout << "Memory pool size of SgAsmElfEHFrameEntryFD: " <<  listOfMemoryPoolSizes[V_SgAsmElfEHFrameEntryFD] << std::endl; 
     std::cout << "Memory pool size of SgAsmElfEHFrameEntryFDList: " <<  listOfMemoryPoolSizes[V_SgAsmElfEHFrameEntryFDList] << std::endl; 
     std::cout << "Memory pool size of SgAsmElfEHFrameSection: " <<  listOfMemoryPoolSizes[V_SgAsmElfEHFrameSection] << std::endl; 
     std::cout << "Memory pool size of SgAsmElfFileHeader: " <<  listOfMemoryPoolSizes[V_SgAsmElfFileHeader] << std::endl; 
     std::cout << "Memory pool size of SgAsmElfNoteEntry: " <<  listOfMemoryPoolSizes[V_SgAsmElfNoteEntry] << std::endl; 
     std::cout << "Memory pool size of SgAsmElfNoteEntryList: " <<  listOfMemoryPoolSizes[V_SgAsmElfNoteEntryList] << std::endl; 
     std::cout << "Memory pool size of SgAsmElfNoteSection: " <<  listOfMemoryPoolSizes[V_SgAsmElfNoteSection] << std::endl; 
     std::cout << "Memory pool size of SgAsmElfRelocEntry: " <<  listOfMemoryPoolSizes[V_SgAsmElfRelocEntry] << std::endl; 
     std::cout << "Memory pool size of SgAsmElfRelocEntryList: " <<  listOfMemoryPoolSizes[V_SgAsmElfRelocEntryList] << std::endl; 
     std::cout << "Memory pool size of SgAsmElfRelocSection: " <<  listOfMemoryPoolSizes[V_SgAsmElfRelocSection] << std::endl; 
     std::cout << "Memory pool size of SgAsmElfSection: " <<  listOfMemoryPoolSizes[V_SgAsmElfSection] << std::endl; 
     std::cout << "Memory pool size of SgAsmElfSectionTable: " <<  listOfMemoryPoolSizes[V_SgAsmElfSectionTable] << std::endl; 
     std::cout << "Memory pool size of SgAsmElfSectionTableEntry: " <<  listOfMemoryPoolSizes[V_SgAsmElfSectionTableEntry] << std::endl; 
     std::cout << "Memory pool size of SgAsmElfSegmentTable: " <<  listOfMemoryPoolSizes[V_SgAsmElfSegmentTable] << std::endl; 
     std::cout << "Memory pool size of SgAsmElfSegmentTableEntry: " <<  listOfMemoryPoolSizes[V_SgAsmElfSegmentTableEntry] << std::endl; 
     std::cout << "Memory pool size of SgAsmElfSegmentTableEntryList: " <<  listOfMemoryPoolSizes[V_SgAsmElfSegmentTableEntryList] << std::endl; 
     std::cout << "Memory pool size of SgAsmElfStringSection: " <<  listOfMemoryPoolSizes[V_SgAsmElfStringSection] << std::endl; 
     std::cout << "Memory pool size of SgAsmElfStrtab: " <<  listOfMemoryPoolSizes[V_SgAsmElfStrtab] << std::endl; 
     std::cout << "Memory pool size of SgAsmElfSymbol: " <<  listOfMemoryPoolSizes[V_SgAsmElfSymbol] << std::endl; 
     std::cout << "Memory pool size of SgAsmElfSymbolList: " <<  listOfMemoryPoolSizes[V_SgAsmElfSymbolList] << std::endl; 
     std::cout << "Memory pool size of SgAsmElfSymbolSection: " <<  listOfMemoryPoolSizes[V_SgAsmElfSymbolSection] << std::endl; 
     std::cout << "Memory pool size of SgAsmElfSymverDefinedAux: " <<  listOfMemoryPoolSizes[V_SgAsmElfSymverDefinedAux] << std::endl; 
     std::cout << "Memory pool size of SgAsmElfSymverDefinedAuxList: " <<  listOfMemoryPoolSizes[V_SgAsmElfSymverDefinedAuxList] << std::endl; 
     std::cout << "Memory pool size of SgAsmElfSymverDefinedEntry: " <<  listOfMemoryPoolSizes[V_SgAsmElfSymverDefinedEntry] << std::endl; 
     std::cout << "Memory pool size of SgAsmElfSymverDefinedEntryList: " <<  listOfMemoryPoolSizes[V_SgAsmElfSymverDefinedEntryList] << std::endl; 
     std::cout << "Memory pool size of SgAsmElfSymverDefinedSection: " <<  listOfMemoryPoolSizes[V_SgAsmElfSymverDefinedSection] << std::endl; 
     std::cout << "Memory pool size of SgAsmElfSymverEntry: " <<  listOfMemoryPoolSizes[V_SgAsmElfSymverEntry] << std::endl; 
     std::cout << "Memory pool size of SgAsmElfSymverEntryList: " <<  listOfMemoryPoolSizes[V_SgAsmElfSymverEntryList] << std::endl; 
     std::cout << "Memory pool size of SgAsmElfSymverNeededAux: " <<  listOfMemoryPoolSizes[V_SgAsmElfSymverNeededAux] << std::endl; 
     std::cout << "Memory pool size of SgAsmElfSymverNeededAuxList: " <<  listOfMemoryPoolSizes[V_SgAsmElfSymverNeededAuxList] << std::endl; 
     std::cout << "Memory pool size of SgAsmElfSymverNeededEntry: " <<  listOfMemoryPoolSizes[V_SgAsmElfSymverNeededEntry] << std::endl; 
     std::cout << "Memory pool size of SgAsmElfSymverNeededEntryList: " <<  listOfMemoryPoolSizes[V_SgAsmElfSymverNeededEntryList] << std::endl; 
     std::cout << "Memory pool size of SgAsmElfSymverNeededSection: " <<  listOfMemoryPoolSizes[V_SgAsmElfSymverNeededSection] << std::endl; 
     std::cout << "Memory pool size of SgAsmElfSymverSection: " <<  listOfMemoryPoolSizes[V_SgAsmElfSymverSection] << std::endl; 
     std::cout << "Memory pool size of SgAsmExecutableFileFormat: " <<  listOfMemoryPoolSizes[V_SgAsmExecutableFileFormat] << std::endl; 
     std::cout << "Memory pool size of SgAsmExprListExp: " <<  listOfMemoryPoolSizes[V_SgAsmExprListExp] << std::endl; 
     std::cout << "Memory pool size of SgAsmExpression: " <<  listOfMemoryPoolSizes[V_SgAsmExpression] << std::endl; 
     std::cout << "Memory pool size of SgAsmFunction: " <<  listOfMemoryPoolSizes[V_SgAsmFunction] << std::endl; 
     std::cout << "Memory pool size of SgAsmGenericDLL: " <<  listOfMemoryPoolSizes[V_SgAsmGenericDLL] << std::endl; 
     std::cout << "Memory pool size of SgAsmGenericDLLList: " <<  listOfMemoryPoolSizes[V_SgAsmGenericDLLList] << std::endl; 
     std::cout << "Memory pool size of SgAsmGenericFile: " <<  listOfMemoryPoolSizes[V_SgAsmGenericFile] << std::endl; 
     std::cout << "Memory pool size of SgAsmGenericFileList: " <<  listOfMemoryPoolSizes[V_SgAsmGenericFileList] << std::endl; 
     std::cout << "Memory pool size of SgAsmGenericFormat: " <<  listOfMemoryPoolSizes[V_SgAsmGenericFormat] << std::endl; 
     std::cout << "Memory pool size of SgAsmGenericHeader: " <<  listOfMemoryPoolSizes[V_SgAsmGenericHeader] << std::endl; 
     std::cout << "Memory pool size of SgAsmGenericHeaderList: " <<  listOfMemoryPoolSizes[V_SgAsmGenericHeaderList] << std::endl; 
     std::cout << "Memory pool size of SgAsmGenericSection: " <<  listOfMemoryPoolSizes[V_SgAsmGenericSection] << std::endl; 
     std::cout << "Memory pool size of SgAsmGenericSectionList: " <<  listOfMemoryPoolSizes[V_SgAsmGenericSectionList] << std::endl; 
     std::cout << "Memory pool size of SgAsmGenericString: " <<  listOfMemoryPoolSizes[V_SgAsmGenericString] << std::endl; 
     std::cout << "Memory pool size of SgAsmGenericStrtab: " <<  listOfMemoryPoolSizes[V_SgAsmGenericStrtab] << std::endl; 
     std::cout << "Memory pool size of SgAsmGenericSymbol: " <<  listOfMemoryPoolSizes[V_SgAsmGenericSymbol] << std::endl; 
     std::cout << "Memory pool size of SgAsmGenericSymbolList: " <<  listOfMemoryPoolSizes[V_SgAsmGenericSymbolList] << std::endl; 
     std::cout << "Memory pool size of SgAsmInstruction: " <<  listOfMemoryPoolSizes[V_SgAsmInstruction] << std::endl; 
     std::cout << "Memory pool size of SgAsmIntegerValueExpression: " <<  listOfMemoryPoolSizes[V_SgAsmIntegerValueExpression] << std::endl; 
     std::cout << "Memory pool size of SgAsmInterpretation: " <<  listOfMemoryPoolSizes[V_SgAsmInterpretation] << std::endl; 
     std::cout << "Memory pool size of SgAsmInterpretationList: " <<  listOfMemoryPoolSizes[V_SgAsmInterpretationList] << std::endl; 
     std::cout << "Memory pool size of SgAsmLEEntryPoint: " <<  listOfMemoryPoolSizes[V_SgAsmLEEntryPoint] << std::endl; 
     std::cout << "Memory pool size of SgAsmLEEntryTable: " <<  listOfMemoryPoolSizes[V_SgAsmLEEntryTable] << std::endl; 
     std::cout << "Memory pool size of SgAsmLEFileHeader: " <<  listOfMemoryPoolSizes[V_SgAsmLEFileHeader] << std::endl; 
     std::cout << "Memory pool size of SgAsmLENameTable: " <<  listOfMemoryPoolSizes[V_SgAsmLENameTable] << std::endl; 
     std::cout << "Memory pool size of SgAsmLEPageTable: " <<  listOfMemoryPoolSizes[V_SgAsmLEPageTable] << std::endl; 
     std::cout << "Memory pool size of SgAsmLEPageTableEntry: " <<  listOfMemoryPoolSizes[V_SgAsmLEPageTableEntry] << std::endl; 
     std::cout << "Memory pool size of SgAsmLERelocTable: " <<  listOfMemoryPoolSizes[V_SgAsmLERelocTable] << std::endl; 
     std::cout << "Memory pool size of SgAsmLESection: " <<  listOfMemoryPoolSizes[V_SgAsmLESection] << std::endl; 
     std::cout << "Memory pool size of SgAsmLESectionTable: " <<  listOfMemoryPoolSizes[V_SgAsmLESectionTable] << std::endl; 
     std::cout << "Memory pool size of SgAsmLESectionTableEntry: " <<  listOfMemoryPoolSizes[V_SgAsmLESectionTableEntry] << std::endl; 
     std::cout << "Memory pool size of SgAsmMemoryReferenceExpression: " <<  listOfMemoryPoolSizes[V_SgAsmMemoryReferenceExpression] << std::endl; 
     std::cout << "Memory pool size of SgAsmNEEntryPoint: " <<  listOfMemoryPoolSizes[V_SgAsmNEEntryPoint] << std::endl; 
     std::cout << "Memory pool size of SgAsmNEEntryTable: " <<  listOfMemoryPoolSizes[V_SgAsmNEEntryTable] << std::endl; 
     std::cout << "Memory pool size of SgAsmNEFileHeader: " <<  listOfMemoryPoolSizes[V_SgAsmNEFileHeader] << std::endl; 
     std::cout << "Memory pool size of SgAsmNEModuleTable: " <<  listOfMemoryPoolSizes[V_SgAsmNEModuleTable] << std::endl; 
     std::cout << "Memory pool size of SgAsmNENameTable: " <<  listOfMemoryPoolSizes[V_SgAsmNENameTable] << std::endl; 
     std::cout << "Memory pool size of SgAsmNERelocEntry: " <<  listOfMemoryPoolSizes[V_SgAsmNERelocEntry] << std::endl; 
     std::cout << "Memory pool size of SgAsmNERelocTable: " <<  listOfMemoryPoolSizes[V_SgAsmNERelocTable] << std::endl; 
     std::cout << "Memory pool size of SgAsmNESection: " <<  listOfMemoryPoolSizes[V_SgAsmNESection] << std::endl; 
     std::cout << "Memory pool size of SgAsmNESectionTable: " <<  listOfMemoryPoolSizes[V_SgAsmNESectionTable] << std::endl; 
     std::cout << "Memory pool size of SgAsmNESectionTableEntry: " <<  listOfMemoryPoolSizes[V_SgAsmNESectionTableEntry] << std::endl; 
     std::cout << "Memory pool size of SgAsmNEStringTable: " <<  listOfMemoryPoolSizes[V_SgAsmNEStringTable] << std::endl; 
     std::cout << "Memory pool size of SgAsmNode: " <<  listOfMemoryPoolSizes[V_SgAsmNode] << std::endl; 
     std::cout << "Memory pool size of SgAsmOp: " <<  listOfMemoryPoolSizes[V_SgAsmOp] << std::endl; 
     std::cout << "Memory pool size of SgAsmOperandList: " <<  listOfMemoryPoolSizes[V_SgAsmOperandList] << std::endl; 
     std::cout << "Memory pool size of SgAsmPEExportDirectory: " <<  listOfMemoryPoolSizes[V_SgAsmPEExportDirectory] << std::endl; 
     std::cout << "Memory pool size of SgAsmPEExportEntry: " <<  listOfMemoryPoolSizes[V_SgAsmPEExportEntry] << std::endl; 
     std::cout << "Memory pool size of SgAsmPEExportEntryList: " <<  listOfMemoryPoolSizes[V_SgAsmPEExportEntryList] << std::endl; 
     std::cout << "Memory pool size of SgAsmPEExportSection: " <<  listOfMemoryPoolSizes[V_SgAsmPEExportSection] << std::endl; 
     std::cout << "Memory pool size of SgAsmPEFileHeader: " <<  listOfMemoryPoolSizes[V_SgAsmPEFileHeader] << std::endl; 
     std::cout << "Memory pool size of SgAsmPEImportDirectory: " <<  listOfMemoryPoolSizes[V_SgAsmPEImportDirectory] << std::endl; 
     std::cout << "Memory pool size of SgAsmPEImportDirectoryList: " <<  listOfMemoryPoolSizes[V_SgAsmPEImportDirectoryList] << std::endl; 
     std::cout << "Memory pool size of SgAsmPEImportItem: " <<  listOfMemoryPoolSizes[V_SgAsmPEImportItem] << std::endl; 
     std::cout << "Memory pool size of SgAsmPEImportItemList: " <<  listOfMemoryPoolSizes[V_SgAsmPEImportItemList] << std::endl; 
     std::cout << "Memory pool size of SgAsmPEImportSection: " <<  listOfMemoryPoolSizes[V_SgAsmPEImportSection] << std::endl; 
     std::cout << "Memory pool size of SgAsmPERVASizePair: " <<  listOfMemoryPoolSizes[V_SgAsmPERVASizePair] << std::endl; 
     std::cout << "Memory pool size of SgAsmPERVASizePairList: " <<  listOfMemoryPoolSizes[V_SgAsmPERVASizePairList] << std::endl; 
     std::cout << "Memory pool size of SgAsmPESection: " <<  listOfMemoryPoolSizes[V_SgAsmPESection] << std::endl; 
     std::cout << "Memory pool size of SgAsmPESectionTable: " <<  listOfMemoryPoolSizes[V_SgAsmPESectionTable] << std::endl; 
     std::cout << "Memory pool size of SgAsmPESectionTableEntry: " <<  listOfMemoryPoolSizes[V_SgAsmPESectionTableEntry] << std::endl; 
     std::cout << "Memory pool size of SgAsmPEStringSection: " <<  listOfMemoryPoolSizes[V_SgAsmPEStringSection] << std::endl; 
     std::cout << "Memory pool size of SgAsmPowerpcInstruction: " <<  listOfMemoryPoolSizes[V_SgAsmPowerpcInstruction] << std::endl; 
     std::cout << "Memory pool size of SgAsmPowerpcRegisterReferenceExpression: " <<  listOfMemoryPoolSizes[V_SgAsmPowerpcRegisterReferenceExpression] << std::endl; 
     std::cout << "Memory pool size of SgAsmQuadWordValueExpression: " <<  listOfMemoryPoolSizes[V_SgAsmQuadWordValueExpression] << std::endl; 
     std::cout << "Memory pool size of SgAsmRegisterReferenceExpression: " <<  listOfMemoryPoolSizes[V_SgAsmRegisterReferenceExpression] << std::endl; 
     std::cout << "Memory pool size of SgAsmSingleFloatValueExpression: " <<  listOfMemoryPoolSizes[V_SgAsmSingleFloatValueExpression] << std::endl; 
     std::cout << "Memory pool size of SgAsmStatement: " <<  listOfMemoryPoolSizes[V_SgAsmStatement] << std::endl; 
     std::cout << "Memory pool size of SgAsmStaticData: " <<  listOfMemoryPoolSizes[V_SgAsmStaticData] << std::endl; 
     std::cout << "Memory pool size of SgAsmStmt: " <<  listOfMemoryPoolSizes[V_SgAsmStmt] << std::endl; 
     std::cout << "Memory pool size of SgAsmStoredString: " <<  listOfMemoryPoolSizes[V_SgAsmStoredString] << std::endl; 
     std::cout << "Memory pool size of SgAsmStringStorage: " <<  listOfMemoryPoolSizes[V_SgAsmStringStorage] << std::endl; 
     std::cout << "Memory pool size of SgAsmType: " <<  listOfMemoryPoolSizes[V_SgAsmType] << std::endl; 
     std::cout << "Memory pool size of SgAsmType128bitFloat: " <<  listOfMemoryPoolSizes[V_SgAsmType128bitFloat] << std::endl; 
     std::cout << "Memory pool size of SgAsmType80bitFloat: " <<  listOfMemoryPoolSizes[V_SgAsmType80bitFloat] << std::endl; 
     std::cout << "Memory pool size of SgAsmTypeByte: " <<  listOfMemoryPoolSizes[V_SgAsmTypeByte] << std::endl; 
     std::cout << "Memory pool size of SgAsmTypeDoubleFloat: " <<  listOfMemoryPoolSizes[V_SgAsmTypeDoubleFloat] << std::endl; 
     std::cout << "Memory pool size of SgAsmTypeDoubleQuadWord: " <<  listOfMemoryPoolSizes[V_SgAsmTypeDoubleQuadWord] << std::endl; 
     std::cout << "Memory pool size of SgAsmTypeDoubleWord: " <<  listOfMemoryPoolSizes[V_SgAsmTypeDoubleWord] << std::endl; 
     std::cout << "Memory pool size of SgAsmTypeQuadWord: " <<  listOfMemoryPoolSizes[V_SgAsmTypeQuadWord] << std::endl; 
     std::cout << "Memory pool size of SgAsmTypeSingleFloat: " <<  listOfMemoryPoolSizes[V_SgAsmTypeSingleFloat] << std::endl; 
     std::cout << "Memory pool size of SgAsmTypeVector: " <<  listOfMemoryPoolSizes[V_SgAsmTypeVector] << std::endl; 
     std::cout << "Memory pool size of SgAsmTypeWord: " <<  listOfMemoryPoolSizes[V_SgAsmTypeWord] << std::endl; 
     std::cout << "Memory pool size of SgAsmUnaryArmSpecialRegisterList: " <<  listOfMemoryPoolSizes[V_SgAsmUnaryArmSpecialRegisterList] << std::endl; 
     std::cout << "Memory pool size of SgAsmUnaryExpression: " <<  listOfMemoryPoolSizes[V_SgAsmUnaryExpression] << std::endl; 
     std::cout << "Memory pool size of SgAsmUnaryMinus: " <<  listOfMemoryPoolSizes[V_SgAsmUnaryMinus] << std::endl; 
     std::cout << "Memory pool size of SgAsmUnaryPlus: " <<  listOfMemoryPoolSizes[V_SgAsmUnaryPlus] << std::endl; 
     std::cout << "Memory pool size of SgAsmUnaryRrx: " <<  listOfMemoryPoolSizes[V_SgAsmUnaryRrx] << std::endl; 
     std::cout << "Memory pool size of SgAsmValueExpression: " <<  listOfMemoryPoolSizes[V_SgAsmValueExpression] << std::endl; 
     std::cout << "Memory pool size of SgAsmVectorValueExpression: " <<  listOfMemoryPoolSizes[V_SgAsmVectorValueExpression] << std::endl; 
     std::cout << "Memory pool size of SgAsmWordValueExpression: " <<  listOfMemoryPoolSizes[V_SgAsmWordValueExpression] << std::endl; 
     std::cout << "Memory pool size of SgAsmx86Instruction: " <<  listOfMemoryPoolSizes[V_SgAsmx86Instruction] << std::endl; 
     std::cout << "Memory pool size of SgAsmx86RegisterReferenceExpression: " <<  listOfMemoryPoolSizes[V_SgAsmx86RegisterReferenceExpression] << std::endl; 
     std::cout << "Memory pool size of SgAsmBinaryAddressSymbol: " <<  listOfMemoryPoolSizes[V_SgAsmBinaryAddressSymbol] << std::endl; 
     std::cout << "Memory pool size of SgAsmBinaryDataSymbol: " <<  listOfMemoryPoolSizes[V_SgAsmBinaryDataSymbol] << std::endl; 
     std::cout << "Memory pool size of SgAssertStmt: " <<  listOfMemoryPoolSizes[V_SgAssertStmt] << std::endl; 
     std::cout << "Memory pool size of SgAssignInitializer: " <<  listOfMemoryPoolSizes[V_SgAssignInitializer] << std::endl; 
     std::cout << "Memory pool size of SgAssignOp: " <<  listOfMemoryPoolSizes[V_SgAssignOp] << std::endl; 
     std::cout << "Memory pool size of SgAssignStatement: " <<  listOfMemoryPoolSizes[V_SgAssignStatement] << std::endl; 
     std::cout << "Memory pool size of SgAssignedGotoStatement: " <<  listOfMemoryPoolSizes[V_SgAssignedGotoStatement] << std::endl; 
     std::cout << "Memory pool size of SgAssociateStatement: " <<  listOfMemoryPoolSizes[V_SgAssociateStatement] << std::endl; 
     std::cout << "Memory pool size of SgAsteriskShapeExp: " <<  listOfMemoryPoolSizes[V_SgAsteriskShapeExp] << std::endl; 
     std::cout << "Memory pool size of SgAttribute: " <<  listOfMemoryPoolSizes[V_SgAttribute] << std::endl; 
     std::cout << "Memory pool size of SgAttributeSpecificationStatement: " <<  listOfMemoryPoolSizes[V_SgAttributeSpecificationStatement] << std::endl; 
     std::cout << "Memory pool size of SgBackspaceStatement: " <<  listOfMemoryPoolSizes[V_SgBackspaceStatement] << std::endl; 
     std::cout << "Memory pool size of SgBaseClass: " <<  listOfMemoryPoolSizes[V_SgBaseClass] << std::endl; 
     std::cout << "Memory pool size of SgExpBaseClass: " <<  listOfMemoryPoolSizes[V_SgExpBaseClass] << std::endl; 
     std::cout << "Memory pool size of SgBaseClassModifier: " <<  listOfMemoryPoolSizes[V_SgBaseClassModifier] << std::endl; 
     std::cout << "Memory pool size of SgBasicBlock: " <<  listOfMemoryPoolSizes[V_SgBasicBlock] << std::endl; 
     std::cout << "Memory pool size of SgBidirectionalGraph: " <<  listOfMemoryPoolSizes[V_SgBidirectionalGraph] << std::endl; 
     std::cout << "Memory pool size of SgBinaryComposite: " <<  listOfMemoryPoolSizes[V_SgBinaryComposite] << std::endl; 
     std::cout << "Memory pool size of SgBinaryOp: " <<  listOfMemoryPoolSizes[V_SgBinaryOp] << std::endl; 
     std::cout << "Memory pool size of SgBitAndOp: " <<  listOfMemoryPoolSizes[V_SgBitAndOp] << std::endl; 
     std::cout << "Memory pool size of SgBitAttribute: " <<  listOfMemoryPoolSizes[V_SgBitAttribute] << std::endl; 
     std::cout << "Memory pool size of SgBitComplementOp: " <<  listOfMemoryPoolSizes[V_SgBitComplementOp] << std::endl; 
     std::cout << "Memory pool size of SgBitOrOp: " <<  listOfMemoryPoolSizes[V_SgBitOrOp] << std::endl; 
     std::cout << "Memory pool size of SgBitXorOp: " <<  listOfMemoryPoolSizes[V_SgBitXorOp] << std::endl; 
     std::cout << "Memory pool size of SgBlockDataStatement: " <<  listOfMemoryPoolSizes[V_SgBlockDataStatement] << std::endl; 
     std::cout << "Memory pool size of SgBoolValExp: " <<  listOfMemoryPoolSizes[V_SgBoolValExp] << std::endl; 
     std::cout << "Memory pool size of SgBreakStmt: " <<  listOfMemoryPoolSizes[V_SgBreakStmt] << std::endl; 
     std::cout << "Memory pool size of SgC_PreprocessorDirectiveStatement: " <<  listOfMemoryPoolSizes[V_SgC_PreprocessorDirectiveStatement] << std::endl; 
     std::cout << "Memory pool size of SgCaseOptionStmt: " <<  listOfMemoryPoolSizes[V_SgCaseOptionStmt] << std::endl; 
     std::cout << "Memory pool size of SgCastExp: " <<  listOfMemoryPoolSizes[V_SgCastExp] << std::endl; 
     std::cout << "Memory pool size of SgCatchOptionStmt: " <<  listOfMemoryPoolSizes[V_SgCatchOptionStmt] << std::endl; 
     std::cout << "Memory pool size of SgCatchStatementSeq: " <<  listOfMemoryPoolSizes[V_SgCatchStatementSeq] << std::endl; 
     std::cout << "Memory pool size of SgCharVal: " <<  listOfMemoryPoolSizes[V_SgCharVal] << std::endl; 
     std::cout << "Memory pool size of SgClassDecl_attr: " <<  listOfMemoryPoolSizes[V_SgClassDecl_attr] << std::endl; 
     std::cout << "Memory pool size of SgClassDeclaration: " <<  listOfMemoryPoolSizes[V_SgClassDeclaration] << std::endl; 
     std::cout << "Memory pool size of SgClassDefinition: " <<  listOfMemoryPoolSizes[V_SgClassDefinition] << std::endl; 
     std::cout << "Memory pool size of SgClassNameRefExp: " <<  listOfMemoryPoolSizes[V_SgClassNameRefExp] << std::endl; 
     std::cout << "Memory pool size of SgClassSymbol: " <<  listOfMemoryPoolSizes[V_SgClassSymbol] << std::endl; 
     std::cout << "Memory pool size of SgClassType: " <<  listOfMemoryPoolSizes[V_SgClassType] << std::endl; 
     std::cout << "Memory pool size of SgClinkageDeclarationStatement: " <<  listOfMemoryPoolSizes[V_SgClinkageDeclarationStatement] << std::endl; 
     std::cout << "Memory pool size of SgClinkageEndStatement: " <<  listOfMemoryPoolSizes[V_SgClinkageEndStatement] << std::endl; 
     std::cout << "Memory pool size of SgClinkageStartStatement: " <<  listOfMemoryPoolSizes[V_SgClinkageStartStatement] << std::endl; 
     std::cout << "Memory pool size of SgCloseStatement: " <<  listOfMemoryPoolSizes[V_SgCloseStatement] << std::endl; 
     std::cout << "Memory pool size of SgColonShapeExp: " <<  listOfMemoryPoolSizes[V_SgColonShapeExp] << std::endl; 
     std::cout << "Memory pool size of SgCommaOpExp: " <<  listOfMemoryPoolSizes[V_SgCommaOpExp] << std::endl; 
     std::cout << "Memory pool size of SgCommonBlock: " <<  listOfMemoryPoolSizes[V_SgCommonBlock] << std::endl; 
     std::cout << "Memory pool size of SgCommonBlockObject: " <<  listOfMemoryPoolSizes[V_SgCommonBlockObject] << std::endl; 
     std::cout << "Memory pool size of SgCommonSymbol: " <<  listOfMemoryPoolSizes[V_SgCommonSymbol] << std::endl; 
     std::cout << "Memory pool size of SgComplexVal: " <<  listOfMemoryPoolSizes[V_SgComplexVal] << std::endl; 
     std::cout << "Memory pool size of SgComprehension: " <<  listOfMemoryPoolSizes[V_SgComprehension] << std::endl; 
     std::cout << "Memory pool size of SgCompoundAssignOp: " <<  listOfMemoryPoolSizes[V_SgCompoundAssignOp] << std::endl; 
     std::cout << "Memory pool size of SgCompoundInitializer: " <<  listOfMemoryPoolSizes[V_SgCompoundInitializer] << std::endl; 
     std::cout << "Memory pool size of SgComputedGotoStatement: " <<  listOfMemoryPoolSizes[V_SgComputedGotoStatement] << std::endl; 
     std::cout << "Memory pool size of SgConcatenationOp: " <<  listOfMemoryPoolSizes[V_SgConcatenationOp] << std::endl; 
     std::cout << "Memory pool size of SgConditionalExp: " <<  listOfMemoryPoolSizes[V_SgConditionalExp] << std::endl; 
     std::cout << "Memory pool size of SgConjugateOp: " <<  listOfMemoryPoolSizes[V_SgConjugateOp] << std::endl; 
     std::cout << "Memory pool size of SgConstVolatileModifier: " <<  listOfMemoryPoolSizes[V_SgConstVolatileModifier] << std::endl; 
     std::cout << "Memory pool size of SgConstructorInitializer: " <<  listOfMemoryPoolSizes[V_SgConstructorInitializer] << std::endl; 
     std::cout << "Memory pool size of SgContainsStatement: " <<  listOfMemoryPoolSizes[V_SgContainsStatement] << std::endl; 
     std::cout << "Memory pool size of SgContinueStmt: " <<  listOfMemoryPoolSizes[V_SgContinueStmt] << std::endl; 
     std::cout << "Memory pool size of SgCtorInitializerList: " <<  listOfMemoryPoolSizes[V_SgCtorInitializerList] << std::endl; 
     std::cout << "Memory pool size of SgDataStatementGroup: " <<  listOfMemoryPoolSizes[V_SgDataStatementGroup] << std::endl; 
     std::cout << "Memory pool size of SgDataStatementObject: " <<  listOfMemoryPoolSizes[V_SgDataStatementObject] << std::endl; 
     std::cout << "Memory pool size of SgDataStatementValue: " <<  listOfMemoryPoolSizes[V_SgDataStatementValue] << std::endl; 
     std::cout << "Memory pool size of SgDeadIfDirectiveStatement: " <<  listOfMemoryPoolSizes[V_SgDeadIfDirectiveStatement] << std::endl; 
     std::cout << "Memory pool size of SgDeallocateStatement: " <<  listOfMemoryPoolSizes[V_SgDeallocateStatement] << std::endl; 
     std::cout << "Memory pool size of SgDeclarationModifier: " <<  listOfMemoryPoolSizes[V_SgDeclarationModifier] << std::endl; 
     std::cout << "Memory pool size of SgDeclarationStatement: " <<  listOfMemoryPoolSizes[V_SgDeclarationStatement] << std::endl; 
     std::cout << "Memory pool size of SgDefaultOptionStmt: " <<  listOfMemoryPoolSizes[V_SgDefaultOptionStmt] << std::endl; 
     std::cout << "Memory pool size of SgDefaultSymbol: " <<  listOfMemoryPoolSizes[V_SgDefaultSymbol] << std::endl; 
     std::cout << "Memory pool size of SgDefineDirectiveStatement: " <<  listOfMemoryPoolSizes[V_SgDefineDirectiveStatement] << std::endl; 
     std::cout << "Memory pool size of SgDeleteExp: " <<  listOfMemoryPoolSizes[V_SgDeleteExp] << std::endl; 
     std::cout << "Memory pool size of SgDerivedTypeStatement: " <<  listOfMemoryPoolSizes[V_SgDerivedTypeStatement] << std::endl; 
     std::cout << "Memory pool size of SgDesignatedInitializer: " <<  listOfMemoryPoolSizes[V_SgDesignatedInitializer] << std::endl; 
     std::cout << "Memory pool size of SgDictionaryComprehension: " <<  listOfMemoryPoolSizes[V_SgDictionaryComprehension] << std::endl; 
     std::cout << "Memory pool size of SgDictionaryExp: " <<  listOfMemoryPoolSizes[V_SgDictionaryExp] << std::endl; 
     std::cout << "Memory pool size of SgDimensionObject: " <<  listOfMemoryPoolSizes[V_SgDimensionObject] << std::endl; 
     std::cout << "Memory pool size of SgDirectedGraphEdge: " <<  listOfMemoryPoolSizes[V_SgDirectedGraphEdge] << std::endl; 
     std::cout << "Memory pool size of SgDirectory: " <<  listOfMemoryPoolSizes[V_SgDirectory] << std::endl; 
     std::cout << "Memory pool size of SgDirectoryList: " <<  listOfMemoryPoolSizes[V_SgDirectoryList] << std::endl; 
     std::cout << "Memory pool size of SgDivAssignOp: " <<  listOfMemoryPoolSizes[V_SgDivAssignOp] << std::endl; 
     std::cout << "Memory pool size of SgDivideOp: " <<  listOfMemoryPoolSizes[V_SgDivideOp] << std::endl; 
     std::cout << "Memory pool size of SgDoWhileStmt: " <<  listOfMemoryPoolSizes[V_SgDoWhileStmt] << std::endl; 
     std::cout << "Memory pool size of SgDotExp: " <<  listOfMemoryPoolSizes[V_SgDotExp] << std::endl; 
     std::cout << "Memory pool size of SgDotStarOp: " <<  listOfMemoryPoolSizes[V_SgDotStarOp] << std::endl; 
     std::cout << "Memory pool size of SgDoubleVal: " <<  listOfMemoryPoolSizes[V_SgDoubleVal] << std::endl; 
     std::cout << "Memory pool size of SgElaboratedTypeModifier: " <<  listOfMemoryPoolSizes[V_SgElaboratedTypeModifier] << std::endl; 
     std::cout << "Memory pool size of SgElseDirectiveStatement: " <<  listOfMemoryPoolSizes[V_SgElseDirectiveStatement] << std::endl; 
     std::cout << "Memory pool size of SgElseWhereStatement: " <<  listOfMemoryPoolSizes[V_SgElseWhereStatement] << std::endl; 
     std::cout << "Memory pool size of SgElseifDirectiveStatement: " <<  listOfMemoryPoolSizes[V_SgElseifDirectiveStatement] << std::endl; 
     std::cout << "Memory pool size of SgEmptyDirectiveStatement: " <<  listOfMemoryPoolSizes[V_SgEmptyDirectiveStatement] << std::endl; 
     std::cout << "Memory pool size of SgEndfileStatement: " <<  listOfMemoryPoolSizes[V_SgEndfileStatement] << std::endl; 
     std::cout << "Memory pool size of SgEndifDirectiveStatement: " <<  listOfMemoryPoolSizes[V_SgEndifDirectiveStatement] << std::endl; 
     std::cout << "Memory pool size of SgEntryStatement: " <<  listOfMemoryPoolSizes[V_SgEntryStatement] << std::endl; 
     std::cout << "Memory pool size of SgEnumDeclaration: " <<  listOfMemoryPoolSizes[V_SgEnumDeclaration] << std::endl; 
     std::cout << "Memory pool size of SgEnumFieldSymbol: " <<  listOfMemoryPoolSizes[V_SgEnumFieldSymbol] << std::endl; 
     std::cout << "Memory pool size of SgEnumSymbol: " <<  listOfMemoryPoolSizes[V_SgEnumSymbol] << std::endl; 
     std::cout << "Memory pool size of SgEnumType: " <<  listOfMemoryPoolSizes[V_SgEnumType] << std::endl; 
     std::cout << "Memory pool size of SgEnumVal: " <<  listOfMemoryPoolSizes[V_SgEnumVal] << std::endl; 
     std::cout << "Memory pool size of SgEqualityOp: " <<  listOfMemoryPoolSizes[V_SgEqualityOp] << std::endl; 
     std::cout << "Memory pool size of SgEquivalenceStatement: " <<  listOfMemoryPoolSizes[V_SgEquivalenceStatement] << std::endl; 
     std::cout << "Memory pool size of SgErrorDirectiveStatement: " <<  listOfMemoryPoolSizes[V_SgErrorDirectiveStatement] << std::endl; 
     std::cout << "Memory pool size of SgExecStatement: " <<  listOfMemoryPoolSizes[V_SgExecStatement] << std::endl; 
     std::cout << "Memory pool size of SgExponentiationOp: " <<  listOfMemoryPoolSizes[V_SgExponentiationOp] << std::endl; 
     std::cout << "Memory pool size of SgExponentiationAssignOp: " <<  listOfMemoryPoolSizes[V_SgExponentiationAssignOp] << std::endl; 
     std::cout << "Memory pool size of SgExprListExp: " <<  listOfMemoryPoolSizes[V_SgExprListExp] << std::endl; 
     std::cout << "Memory pool size of SgExprStatement: " <<  listOfMemoryPoolSizes[V_SgExprStatement] << std::endl; 
     std::cout << "Memory pool size of SgExpression: " <<  listOfMemoryPoolSizes[V_SgExpression] << std::endl; 
     std::cout << "Memory pool size of SgExpressionRoot: " <<  listOfMemoryPoolSizes[V_SgExpressionRoot] << std::endl; 
     std::cout << "Memory pool size of SgFile: " <<  listOfMemoryPoolSizes[V_SgFile] << std::endl; 
     std::cout << "Memory pool size of SgFileList: " <<  listOfMemoryPoolSizes[V_SgFileList] << std::endl; 
     std::cout << "Memory pool size of SgFloatVal: " <<  listOfMemoryPoolSizes[V_SgFloatVal] << std::endl; 
     std::cout << "Memory pool size of SgFlushStatement: " <<  listOfMemoryPoolSizes[V_SgFlushStatement] << std::endl; 
     std::cout << "Memory pool size of SgForAllStatement: " <<  listOfMemoryPoolSizes[V_SgForAllStatement] << std::endl; 
     std::cout << "Memory pool size of SgForInitStatement: " <<  listOfMemoryPoolSizes[V_SgForInitStatement] << std::endl; 
     std::cout << "Memory pool size of SgForStatement: " <<  listOfMemoryPoolSizes[V_SgForStatement] << std::endl; 
     std::cout << "Memory pool size of SgFormatItem: " <<  listOfMemoryPoolSizes[V_SgFormatItem] << std::endl; 
     std::cout << "Memory pool size of SgFormatItemList: " <<  listOfMemoryPoolSizes[V_SgFormatItemList] << std::endl; 
     std::cout << "Memory pool size of SgFormatStatement: " <<  listOfMemoryPoolSizes[V_SgFormatStatement] << std::endl; 
     std::cout << "Memory pool size of SgFortranDo: " <<  listOfMemoryPoolSizes[V_SgFortranDo] << std::endl; 
     std::cout << "Memory pool size of SgFortranIncludeLine: " <<  listOfMemoryPoolSizes[V_SgFortranIncludeLine] << std::endl; 
     std::cout << "Memory pool size of SgFortranNonblockedDo: " <<  listOfMemoryPoolSizes[V_SgFortranNonblockedDo] << std::endl; 
     std::cout << "Memory pool size of SgFuncDecl_attr: " <<  listOfMemoryPoolSizes[V_SgFuncDecl_attr] << std::endl; 
     std::cout << "Memory pool size of SgFunctionCallExp: " <<  listOfMemoryPoolSizes[V_SgFunctionCallExp] << std::endl; 
     std::cout << "Memory pool size of SgFunctionDeclaration: " <<  listOfMemoryPoolSizes[V_SgFunctionDeclaration] << std::endl; 
     std::cout << "Memory pool size of SgFunctionDefinition: " <<  listOfMemoryPoolSizes[V_SgFunctionDefinition] << std::endl; 
     std::cout << "Memory pool size of SgFunctionModifier: " <<  listOfMemoryPoolSizes[V_SgFunctionModifier] << std::endl; 
     std::cout << "Memory pool size of SgFunctionParameterList: " <<  listOfMemoryPoolSizes[V_SgFunctionParameterList] << std::endl; 
     std::cout << "Memory pool size of SgFunctionParameterTypeList: " <<  listOfMemoryPoolSizes[V_SgFunctionParameterTypeList] << std::endl; 
     std::cout << "Memory pool size of SgFunctionRefExp: " <<  listOfMemoryPoolSizes[V_SgFunctionRefExp] << std::endl; 
     std::cout << "Memory pool size of SgFunctionSymbol: " <<  listOfMemoryPoolSizes[V_SgFunctionSymbol] << std::endl; 
     std::cout << "Memory pool size of SgFunctionType: " <<  listOfMemoryPoolSizes[V_SgFunctionType] << std::endl; 
     std::cout << "Memory pool size of SgFunctionTypeSymbol: " <<  listOfMemoryPoolSizes[V_SgFunctionTypeSymbol] << std::endl; 
     std::cout << "Memory pool size of SgFunctionTypeTable: " <<  listOfMemoryPoolSizes[V_SgFunctionTypeTable] << std::endl; 
     std::cout << "Memory pool size of SgTypeTable: " <<  listOfMemoryPoolSizes[V_SgTypeTable] << std::endl; 
     std::cout << "Memory pool size of SgGlobal: " <<  listOfMemoryPoolSizes[V_SgGlobal] << std::endl; 
     std::cout << "Memory pool size of SgGotoStatement: " <<  listOfMemoryPoolSizes[V_SgGotoStatement] << std::endl; 
     std::cout << "Memory pool size of SgGraph: " <<  listOfMemoryPoolSizes[V_SgGraph] << std::endl; 
     std::cout << "Memory pool size of SgGraphEdge: " <<  listOfMemoryPoolSizes[V_SgGraphEdge] << std::endl; 
     std::cout << "Memory pool size of SgGraphEdgeList: " <<  listOfMemoryPoolSizes[V_SgGraphEdgeList] << std::endl; 
     std::cout << "Memory pool size of SgGraphNode: " <<  listOfMemoryPoolSizes[V_SgGraphNode] << std::endl; 
     std::cout << "Memory pool size of SgGraphNodeList: " <<  listOfMemoryPoolSizes[V_SgGraphNodeList] << std::endl; 
     std::cout << "Memory pool size of SgGreaterOrEqualOp: " <<  listOfMemoryPoolSizes[V_SgGreaterOrEqualOp] << std::endl; 
     std::cout << "Memory pool size of SgGreaterThanOp: " <<  listOfMemoryPoolSizes[V_SgGreaterThanOp] << std::endl; 
     std::cout << "Memory pool size of SgIOItemExpression: " <<  listOfMemoryPoolSizes[V_SgIOItemExpression] << std::endl; 
     std::cout << "Memory pool size of SgIOStatement: " <<  listOfMemoryPoolSizes[V_SgIOStatement] << std::endl; 
     std::cout << "Memory pool size of SgIdentDirectiveStatement: " <<  listOfMemoryPoolSizes[V_SgIdentDirectiveStatement] << std::endl; 
     std::cout << "Memory pool size of SgIfDirectiveStatement: " <<  listOfMemoryPoolSizes[V_SgIfDirectiveStatement] << std::endl; 
     std::cout << "Memory pool size of SgIfStmt: " <<  listOfMemoryPoolSizes[V_SgIfStmt] << std::endl; 
     std::cout << "Memory pool size of SgIfdefDirectiveStatement: " <<  listOfMemoryPoolSizes[V_SgIfdefDirectiveStatement] << std::endl; 
     std::cout << "Memory pool size of SgIfndefDirectiveStatement: " <<  listOfMemoryPoolSizes[V_SgIfndefDirectiveStatement] << std::endl; 
     std::cout << "Memory pool size of SgImagPartOp: " <<  listOfMemoryPoolSizes[V_SgImagPartOp] << std::endl; 
     std::cout << "Memory pool size of SgImplicitStatement: " <<  listOfMemoryPoolSizes[V_SgImplicitStatement] << std::endl; 
     std::cout << "Memory pool size of SgImpliedDo: " <<  listOfMemoryPoolSizes[V_SgImpliedDo] << std::endl; 
     std::cout << "Memory pool size of SgImportStatement: " <<  listOfMemoryPoolSizes[V_SgImportStatement] << std::endl; 
     std::cout << "Memory pool size of SgIncidenceDirectedGraph: " <<  listOfMemoryPoolSizes[V_SgIncidenceDirectedGraph] << std::endl; 
     std::cout << "Memory pool size of SgIncidenceUndirectedGraph: " <<  listOfMemoryPoolSizes[V_SgIncidenceUndirectedGraph] << std::endl; 
     std::cout << "Memory pool size of SgIncludeDirectiveStatement: " <<  listOfMemoryPoolSizes[V_SgIncludeDirectiveStatement] << std::endl; 
     std::cout << "Memory pool size of SgIncludeNextDirectiveStatement: " <<  listOfMemoryPoolSizes[V_SgIncludeNextDirectiveStatement] << std::endl; 
     std::cout << "Memory pool size of SgInitializedName: " <<  listOfMemoryPoolSizes[V_SgInitializedName] << std::endl; 
     std::cout << "Memory pool size of SgInitializer: " <<  listOfMemoryPoolSizes[V_SgInitializer] << std::endl; 
     std::cout << "Memory pool size of SgInquireStatement: " <<  listOfMemoryPoolSizes[V_SgInquireStatement] << std::endl; 
     std::cout << "Memory pool size of SgIntKeyedBidirectionalGraph: " <<  listOfMemoryPoolSizes[V_SgIntKeyedBidirectionalGraph] << std::endl; 
     std::cout << "Memory pool size of SgIntVal: " <<  listOfMemoryPoolSizes[V_SgIntVal] << std::endl; 
     std::cout << "Memory pool size of SgIntegerDivideOp: " <<  listOfMemoryPoolSizes[V_SgIntegerDivideOp] << std::endl; 
     std::cout << "Memory pool size of SgIntegerDivideAssignOp: " <<  listOfMemoryPoolSizes[V_SgIntegerDivideAssignOp] << std::endl; 
     std::cout << "Memory pool size of SgInterfaceBody: " <<  listOfMemoryPoolSizes[V_SgInterfaceBody] << std::endl; 
     std::cout << "Memory pool size of SgHeaderFileBody: " <<  listOfMemoryPoolSizes[V_SgHeaderFileBody] << std::endl; 
     std::cout << "Memory pool size of SgInterfaceStatement: " <<  listOfMemoryPoolSizes[V_SgInterfaceStatement] << std::endl; 
     std::cout << "Memory pool size of SgInterfaceSymbol: " <<  listOfMemoryPoolSizes[V_SgInterfaceSymbol] << std::endl; 
     std::cout << "Memory pool size of SgIntrinsicSymbol: " <<  listOfMemoryPoolSizes[V_SgIntrinsicSymbol] << std::endl; 
     std::cout << "Memory pool size of SgIsOp: " <<  listOfMemoryPoolSizes[V_SgIsOp] << std::endl; 
     std::cout << "Memory pool size of SgIsNotOp: " <<  listOfMemoryPoolSizes[V_SgIsNotOp] << std::endl; 
     std::cout << "Memory pool size of SgIorAssignOp: " <<  listOfMemoryPoolSizes[V_SgIorAssignOp] << std::endl; 
     std::cout << "Memory pool size of SgKeyDatumPair: " <<  listOfMemoryPoolSizes[V_SgKeyDatumPair] << std::endl; 
     std::cout << "Memory pool size of SgCudaKernelExecConfig: " <<  listOfMemoryPoolSizes[V_SgCudaKernelExecConfig] << std::endl; 
     std::cout << "Memory pool size of SgCudaKernelCallExp: " <<  listOfMemoryPoolSizes[V_SgCudaKernelCallExp] << std::endl; 
     std::cout << "Memory pool size of SgLabelRefExp: " <<  listOfMemoryPoolSizes[V_SgLabelRefExp] << std::endl; 
     std::cout << "Memory pool size of SgLabelStatement: " <<  listOfMemoryPoolSizes[V_SgLabelStatement] << std::endl; 
     std::cout << "Memory pool size of SgJavaLabelStatement: " <<  listOfMemoryPoolSizes[V_SgJavaLabelStatement] << std::endl; 
     std::cout << "Memory pool size of SgLabelSymbol: " <<  listOfMemoryPoolSizes[V_SgLabelSymbol] << std::endl; 
     std::cout << "Memory pool size of SgJavaLabelSymbol: " <<  listOfMemoryPoolSizes[V_SgJavaLabelSymbol] << std::endl; 
     std::cout << "Memory pool size of SgLambdaRefExp: " <<  listOfMemoryPoolSizes[V_SgLambdaRefExp] << std::endl; 
     std::cout << "Memory pool size of SgLessOrEqualOp: " <<  listOfMemoryPoolSizes[V_SgLessOrEqualOp] << std::endl; 
     std::cout << "Memory pool size of SgLessThanOp: " <<  listOfMemoryPoolSizes[V_SgLessThanOp] << std::endl; 
     std::cout << "Memory pool size of SgLineDirectiveStatement: " <<  listOfMemoryPoolSizes[V_SgLineDirectiveStatement] << std::endl; 
     std::cout << "Memory pool size of SgLinemarkerDirectiveStatement: " <<  listOfMemoryPoolSizes[V_SgLinemarkerDirectiveStatement] << std::endl; 
     std::cout << "Memory pool size of SgLinkageModifier: " <<  listOfMemoryPoolSizes[V_SgLinkageModifier] << std::endl; 
     std::cout << "Memory pool size of SgListComprehension: " <<  listOfMemoryPoolSizes[V_SgListComprehension] << std::endl; 
     std::cout << "Memory pool size of SgListExp: " <<  listOfMemoryPoolSizes[V_SgListExp] << std::endl; 
     std::cout << "Memory pool size of SgLocatedNode: " <<  listOfMemoryPoolSizes[V_SgLocatedNode] << std::endl; 
     std::cout << "Memory pool size of SgLocatedNodeSupport: " <<  listOfMemoryPoolSizes[V_SgLocatedNodeSupport] << std::endl; 
     std::cout << "Memory pool size of SgLongDoubleVal: " <<  listOfMemoryPoolSizes[V_SgLongDoubleVal] << std::endl; 
     std::cout << "Memory pool size of SgLongIntVal: " <<  listOfMemoryPoolSizes[V_SgLongIntVal] << std::endl; 
     std::cout << "Memory pool size of SgLongLongIntVal: " <<  listOfMemoryPoolSizes[V_SgLongLongIntVal] << std::endl; 
     std::cout << "Memory pool size of SgLshiftAssignOp: " <<  listOfMemoryPoolSizes[V_SgLshiftAssignOp] << std::endl; 
     std::cout << "Memory pool size of SgLshiftOp: " <<  listOfMemoryPoolSizes[V_SgLshiftOp] << std::endl; 
     std::cout << "Memory pool size of SgMemberFunctionDeclaration: " <<  listOfMemoryPoolSizes[V_SgMemberFunctionDeclaration] << std::endl; 
     std::cout << "Memory pool size of SgMemberFunctionRefExp: " <<  listOfMemoryPoolSizes[V_SgMemberFunctionRefExp] << std::endl; 
     std::cout << "Memory pool size of SgMemberFunctionSymbol: " <<  listOfMemoryPoolSizes[V_SgMemberFunctionSymbol] << std::endl; 
     std::cout << "Memory pool size of SgMemberFunctionType: " <<  listOfMemoryPoolSizes[V_SgMemberFunctionType] << std::endl; 
     std::cout << "Memory pool size of SgMembershipOp: " <<  listOfMemoryPoolSizes[V_SgMembershipOp] << std::endl; 
     std::cout << "Memory pool size of SgMinusAssignOp: " <<  listOfMemoryPoolSizes[V_SgMinusAssignOp] << std::endl; 
     std::cout << "Memory pool size of SgMinusMinusOp: " <<  listOfMemoryPoolSizes[V_SgMinusMinusOp] << std::endl; 
     std::cout << "Memory pool size of SgMinusOp: " <<  listOfMemoryPoolSizes[V_SgMinusOp] << std::endl; 
     std::cout << "Memory pool size of SgModAssignOp: " <<  listOfMemoryPoolSizes[V_SgModAssignOp] << std::endl; 
     std::cout << "Memory pool size of SgModOp: " <<  listOfMemoryPoolSizes[V_SgModOp] << std::endl; 
     std::cout << "Memory pool size of SgModifier: " <<  listOfMemoryPoolSizes[V_SgModifier] << std::endl; 
     std::cout << "Memory pool size of SgModifierNodes: " <<  listOfMemoryPoolSizes[V_SgModifierNodes] << std::endl; 
     std::cout << "Memory pool size of SgModifierType: " <<  listOfMemoryPoolSizes[V_SgModifierType] << std::endl; 
     std::cout << "Memory pool size of SgModuleStatement: " <<  listOfMemoryPoolSizes[V_SgModuleStatement] << std::endl; 
     std::cout << "Memory pool size of SgModuleSymbol: " <<  listOfMemoryPoolSizes[V_SgModuleSymbol] << std::endl; 
     std::cout << "Memory pool size of SgMultAssignOp: " <<  listOfMemoryPoolSizes[V_SgMultAssignOp] << std::endl; 
     std::cout << "Memory pool size of SgMultiplyOp: " <<  listOfMemoryPoolSizes[V_SgMultiplyOp] << std::endl; 
     std::cout << "Memory pool size of SgName: " <<  listOfMemoryPoolSizes[V_SgName] << std::endl; 
     std::cout << "Memory pool size of SgNameGroup: " <<  listOfMemoryPoolSizes[V_SgNameGroup] << std::endl; 
     std::cout << "Memory pool size of SgNamedType: " <<  listOfMemoryPoolSizes[V_SgNamedType] << std::endl; 
     std::cout << "Memory pool size of SgNamelistStatement: " <<  listOfMemoryPoolSizes[V_SgNamelistStatement] << std::endl; 
     std::cout << "Memory pool size of SgNamespaceAliasDeclarationStatement: " <<  listOfMemoryPoolSizes[V_SgNamespaceAliasDeclarationStatement] << std::endl; 
     std::cout << "Memory pool size of SgNamespaceDeclarationStatement: " <<  listOfMemoryPoolSizes[V_SgNamespaceDeclarationStatement] << std::endl; 
     std::cout << "Memory pool size of SgNamespaceDefinitionStatement: " <<  listOfMemoryPoolSizes[V_SgNamespaceDefinitionStatement] << std::endl; 
     std::cout << "Memory pool size of SgNamespaceSymbol: " <<  listOfMemoryPoolSizes[V_SgNamespaceSymbol] << std::endl; 
     std::cout << "Memory pool size of SgNaryOp: " <<  listOfMemoryPoolSizes[V_SgNaryOp] << std::endl; 
     std::cout << "Memory pool size of SgNaryBooleanOp: " <<  listOfMemoryPoolSizes[V_SgNaryBooleanOp] << std::endl; 
     std::cout << "Memory pool size of SgNaryComparisonOp: " <<  listOfMemoryPoolSizes[V_SgNaryComparisonOp] << std::endl; 
     std::cout << "Memory pool size of SgNewExp: " <<  listOfMemoryPoolSizes[V_SgNewExp] << std::endl; 
     std::cout << "Memory pool size of SgNode: " <<  listOfMemoryPoolSizes[V_SgNode] << std::endl; 
     std::cout << "Memory pool size of SgNotEqualOp: " <<  listOfMemoryPoolSizes[V_SgNotEqualOp] << std::endl; 
     std::cout << "Memory pool size of SgNotOp: " <<  listOfMemoryPoolSizes[V_SgNotOp] << std::endl; 
     std::cout << "Memory pool size of SgNonMembershipOp: " <<  listOfMemoryPoolSizes[V_SgNonMembershipOp] << std::endl; 
     std::cout << "Memory pool size of SgNullExpression: " <<  listOfMemoryPoolSizes[V_SgNullExpression] << std::endl; 
     std::cout << "Memory pool size of SgNullStatement: " <<  listOfMemoryPoolSizes[V_SgNullStatement] << std::endl; 
     std::cout << "Memory pool size of SgNullifyStatement: " <<  listOfMemoryPoolSizes[V_SgNullifyStatement] << std::endl; 
     std::cout << "Memory pool size of SgOmpAtomicStatement: " <<  listOfMemoryPoolSizes[V_SgOmpAtomicStatement] << std::endl; 
     std::cout << "Memory pool size of SgOmpBarrierStatement: " <<  listOfMemoryPoolSizes[V_SgOmpBarrierStatement] << std::endl; 
     std::cout << "Memory pool size of SgOmpCriticalStatement: " <<  listOfMemoryPoolSizes[V_SgOmpCriticalStatement] << std::endl; 
     std::cout << "Memory pool size of SgOmpClauseBodyStatement: " <<  listOfMemoryPoolSizes[V_SgOmpClauseBodyStatement] << std::endl; 
     std::cout << "Memory pool size of SgOmpBodyStatement: " <<  listOfMemoryPoolSizes[V_SgOmpBodyStatement] << std::endl; 
     std::cout << "Memory pool size of SgOmpDoStatement: " <<  listOfMemoryPoolSizes[V_SgOmpDoStatement] << std::endl; 
     std::cout << "Memory pool size of SgOmpFlushStatement: " <<  listOfMemoryPoolSizes[V_SgOmpFlushStatement] << std::endl; 
     std::cout << "Memory pool size of SgOmpForStatement: " <<  listOfMemoryPoolSizes[V_SgOmpForStatement] << std::endl; 
     std::cout << "Memory pool size of SgOmpMasterStatement: " <<  listOfMemoryPoolSizes[V_SgOmpMasterStatement] << std::endl; 
     std::cout << "Memory pool size of SgOmpOrderedStatement: " <<  listOfMemoryPoolSizes[V_SgOmpOrderedStatement] << std::endl; 
     std::cout << "Memory pool size of SgOmpParallelStatement: " <<  listOfMemoryPoolSizes[V_SgOmpParallelStatement] << std::endl; 
     std::cout << "Memory pool size of SgOmpSectionStatement: " <<  listOfMemoryPoolSizes[V_SgOmpSectionStatement] << std::endl; 
     std::cout << "Memory pool size of SgOmpSectionsStatement: " <<  listOfMemoryPoolSizes[V_SgOmpSectionsStatement] << std::endl; 
     std::cout << "Memory pool size of SgOmpSingleStatement: " <<  listOfMemoryPoolSizes[V_SgOmpSingleStatement] << std::endl; 
     std::cout << "Memory pool size of SgOmpTaskStatement: " <<  listOfMemoryPoolSizes[V_SgOmpTaskStatement] << std::endl; 
     std::cout << "Memory pool size of SgOmpTaskwaitStatement: " <<  listOfMemoryPoolSizes[V_SgOmpTaskwaitStatement] << std::endl; 
     std::cout << "Memory pool size of SgOmpThreadprivateStatement: " <<  listOfMemoryPoolSizes[V_SgOmpThreadprivateStatement] << std::endl; 
     std::cout << "Memory pool size of SgOmpWorkshareStatement: " <<  listOfMemoryPoolSizes[V_SgOmpWorkshareStatement] << std::endl; 
     std::cout << "Memory pool size of SgOmpClause: " <<  listOfMemoryPoolSizes[V_SgOmpClause] << std::endl; 
     std::cout << "Memory pool size of SgOmpCollapseClause: " <<  listOfMemoryPoolSizes[V_SgOmpCollapseClause] << std::endl; 
     std::cout << "Memory pool size of SgOmpCopyinClause: " <<  listOfMemoryPoolSizes[V_SgOmpCopyinClause] << std::endl; 
     std::cout << "Memory pool size of SgOmpCopyprivateClause: " <<  listOfMemoryPoolSizes[V_SgOmpCopyprivateClause] << std::endl; 
     std::cout << "Memory pool size of SgOmpDefaultClause: " <<  listOfMemoryPoolSizes[V_SgOmpDefaultClause] << std::endl; 
     std::cout << "Memory pool size of SgOmpExpressionClause: " <<  listOfMemoryPoolSizes[V_SgOmpExpressionClause] << std::endl; 
     std::cout << "Memory pool size of SgOmpFirstprivateClause: " <<  listOfMemoryPoolSizes[V_SgOmpFirstprivateClause] << std::endl; 
     std::cout << "Memory pool size of SgOmpIfClause: " <<  listOfMemoryPoolSizes[V_SgOmpIfClause] << std::endl; 
     std::cout << "Memory pool size of SgOmpLastprivateClause: " <<  listOfMemoryPoolSizes[V_SgOmpLastprivateClause] << std::endl; 
     std::cout << "Memory pool size of SgOmpNowaitClause: " <<  listOfMemoryPoolSizes[V_SgOmpNowaitClause] << std::endl; 
     std::cout << "Memory pool size of SgOmpNumThreadsClause: " <<  listOfMemoryPoolSizes[V_SgOmpNumThreadsClause] << std::endl; 
     std::cout << "Memory pool size of SgOmpOrderedClause: " <<  listOfMemoryPoolSizes[V_SgOmpOrderedClause] << std::endl; 
     std::cout << "Memory pool size of SgOmpPrivateClause: " <<  listOfMemoryPoolSizes[V_SgOmpPrivateClause] << std::endl; 
     std::cout << "Memory pool size of SgOmpReductionClause: " <<  listOfMemoryPoolSizes[V_SgOmpReductionClause] << std::endl; 
     std::cout << "Memory pool size of SgOmpScheduleClause: " <<  listOfMemoryPoolSizes[V_SgOmpScheduleClause] << std::endl; 
     std::cout << "Memory pool size of SgOmpSharedClause: " <<  listOfMemoryPoolSizes[V_SgOmpSharedClause] << std::endl; 
     std::cout << "Memory pool size of SgOmpUntiedClause: " <<  listOfMemoryPoolSizes[V_SgOmpUntiedClause] << std::endl; 
     std::cout << "Memory pool size of SgOmpVariablesClause: " <<  listOfMemoryPoolSizes[V_SgOmpVariablesClause] << std::endl; 
     std::cout << "Memory pool size of SgOpenclAccessModeModifier: " <<  listOfMemoryPoolSizes[V_SgOpenclAccessModeModifier] << std::endl; 
     std::cout << "Memory pool size of SgOpenStatement: " <<  listOfMemoryPoolSizes[V_SgOpenStatement] << std::endl; 
     std::cout << "Memory pool size of SgOptions: " <<  listOfMemoryPoolSizes[V_SgOptions] << std::endl; 
     std::cout << "Memory pool size of SgOrOp: " <<  listOfMemoryPoolSizes[V_SgOrOp] << std::endl; 
     std::cout << "Memory pool size of SgParameterStatement: " <<  listOfMemoryPoolSizes[V_SgParameterStatement] << std::endl; 
     std::cout << "Memory pool size of SgPartialFunctionModifierType: " <<  listOfMemoryPoolSizes[V_SgPartialFunctionModifierType] << std::endl; 
     std::cout << "Memory pool size of SgPartialFunctionType: " <<  listOfMemoryPoolSizes[V_SgPartialFunctionType] << std::endl; 
     std::cout << "Memory pool size of SgPassStatement: " <<  listOfMemoryPoolSizes[V_SgPassStatement] << std::endl; 
     std::cout << "Memory pool size of SgPlusAssignOp: " <<  listOfMemoryPoolSizes[V_SgPlusAssignOp] << std::endl; 
     std::cout << "Memory pool size of SgPlusPlusOp: " <<  listOfMemoryPoolSizes[V_SgPlusPlusOp] << std::endl; 
     std::cout << "Memory pool size of SgPntrArrRefExp: " <<  listOfMemoryPoolSizes[V_SgPntrArrRefExp] << std::endl; 
     std::cout << "Memory pool size of SgPointerAssignOp: " <<  listOfMemoryPoolSizes[V_SgPointerAssignOp] << std::endl; 
     std::cout << "Memory pool size of SgPointerDerefExp: " <<  listOfMemoryPoolSizes[V_SgPointerDerefExp] << std::endl; 
     std::cout << "Memory pool size of SgPointerMemberType: " <<  listOfMemoryPoolSizes[V_SgPointerMemberType] << std::endl; 
     std::cout << "Memory pool size of SgPointerType: " <<  listOfMemoryPoolSizes[V_SgPointerType] << std::endl; 
     std::cout << "Memory pool size of SgPragma: " <<  listOfMemoryPoolSizes[V_SgPragma] << std::endl; 
     std::cout << "Memory pool size of SgPragmaDeclaration: " <<  listOfMemoryPoolSizes[V_SgPragmaDeclaration] << std::endl; 
     std::cout << "Memory pool size of SgPrintStatement: " <<  listOfMemoryPoolSizes[V_SgPrintStatement] << std::endl; 
     std::cout << "Memory pool size of SgProcedureHeaderStatement: " <<  listOfMemoryPoolSizes[V_SgProcedureHeaderStatement] << std::endl; 
     std::cout << "Memory pool size of SgProgramHeaderStatement: " <<  listOfMemoryPoolSizes[V_SgProgramHeaderStatement] << std::endl; 
     std::cout << "Memory pool size of SgProject: " <<  listOfMemoryPoolSizes[V_SgProject] << std::endl; 
     std::cout << "Memory pool size of SgPseudoDestructorRefExp: " <<  listOfMemoryPoolSizes[V_SgPseudoDestructorRefExp] << std::endl; 
     std::cout << "Memory pool size of SgPythonGlobalStmt: " <<  listOfMemoryPoolSizes[V_SgPythonGlobalStmt] << std::endl; 
     std::cout << "Memory pool size of SgPythonPrintStmt: " <<  listOfMemoryPoolSizes[V_SgPythonPrintStmt] << std::endl; 
     std::cout << "Memory pool size of SgQualifiedName: " <<  listOfMemoryPoolSizes[V_SgQualifiedName] << std::endl; 
     std::cout << "Memory pool size of SgQualifiedNameType: " <<  listOfMemoryPoolSizes[V_SgQualifiedNameType] << std::endl; 
     std::cout << "Memory pool size of SgReadStatement: " <<  listOfMemoryPoolSizes[V_SgReadStatement] << std::endl; 
     std::cout << "Memory pool size of SgRealPartOp: " <<  listOfMemoryPoolSizes[V_SgRealPartOp] << std::endl; 
     std::cout << "Memory pool size of SgRefExp: " <<  listOfMemoryPoolSizes[V_SgRefExp] << std::endl; 
     std::cout << "Memory pool size of SgReferenceType: " <<  listOfMemoryPoolSizes[V_SgReferenceType] << std::endl; 
     std::cout << "Memory pool size of SgRenamePair: " <<  listOfMemoryPoolSizes[V_SgRenamePair] << std::endl; 
     std::cout << "Memory pool size of SgRenameSymbol: " <<  listOfMemoryPoolSizes[V_SgRenameSymbol] << std::endl; 
     std::cout << "Memory pool size of SgReturnStmt: " <<  listOfMemoryPoolSizes[V_SgReturnStmt] << std::endl; 
     std::cout << "Memory pool size of SgRewindStatement: " <<  listOfMemoryPoolSizes[V_SgRewindStatement] << std::endl; 
     std::cout << "Memory pool size of SgRshiftAssignOp: " <<  listOfMemoryPoolSizes[V_SgRshiftAssignOp] << std::endl; 
     std::cout << "Memory pool size of SgRshiftOp: " <<  listOfMemoryPoolSizes[V_SgRshiftOp] << std::endl; 
     std::cout << "Memory pool size of SgJavaUnsignedRshiftAssignOp: " <<  listOfMemoryPoolSizes[V_SgJavaUnsignedRshiftAssignOp] << std::endl; 
     std::cout << "Memory pool size of SgJavaUnsignedRshiftOp: " <<  listOfMemoryPoolSizes[V_SgJavaUnsignedRshiftOp] << std::endl; 
     std::cout << "Memory pool size of SgScopeOp: " <<  listOfMemoryPoolSizes[V_SgScopeOp] << std::endl; 
     std::cout << "Memory pool size of SgScopeStatement: " <<  listOfMemoryPoolSizes[V_SgScopeStatement] << std::endl; 
     std::cout << "Memory pool size of SgSequenceStatement: " <<  listOfMemoryPoolSizes[V_SgSequenceStatement] << std::endl; 
     std::cout << "Memory pool size of SgSetComprehension: " <<  listOfMemoryPoolSizes[V_SgSetComprehension] << std::endl; 
     std::cout << "Memory pool size of SgShortVal: " <<  listOfMemoryPoolSizes[V_SgShortVal] << std::endl; 
     std::cout << "Memory pool size of SgSizeOfOp: " <<  listOfMemoryPoolSizes[V_SgSizeOfOp] << std::endl; 
     std::cout << "Memory pool size of SgJavaInstanceOfOp: " <<  listOfMemoryPoolSizes[V_SgJavaInstanceOfOp] << std::endl; 
     std::cout << "Memory pool size of SgSourceFile: " <<  listOfMemoryPoolSizes[V_SgSourceFile] << std::endl; 
     std::cout << "Memory pool size of SgSpawnStmt: " <<  listOfMemoryPoolSizes[V_SgSpawnStmt] << std::endl; 
     std::cout << "Memory pool size of SgJavaThrowStatement: " <<  listOfMemoryPoolSizes[V_SgJavaThrowStatement] << std::endl; 
     std::cout << "Memory pool size of SgJavaForEachStatement: " <<  listOfMemoryPoolSizes[V_SgJavaForEachStatement] << std::endl; 
     std::cout << "Memory pool size of SgJavaSynchronizedStatement: " <<  listOfMemoryPoolSizes[V_SgJavaSynchronizedStatement] << std::endl; 
     std::cout << "Memory pool size of SgJavaParameterizedType: " <<  listOfMemoryPoolSizes[V_SgJavaParameterizedType] << std::endl; 
     std::cout << "Memory pool size of SgSpecialFunctionModifier: " <<  listOfMemoryPoolSizes[V_SgSpecialFunctionModifier] << std::endl; 
     std::cout << "Memory pool size of SgStatement: " <<  listOfMemoryPoolSizes[V_SgStatement] << std::endl; 
     std::cout << "Memory pool size of SgStmtDeclarationStatement: " <<  listOfMemoryPoolSizes[V_SgStmtDeclarationStatement] << std::endl; 
     std::cout << "Memory pool size of SgStatementExpression: " <<  listOfMemoryPoolSizes[V_SgStatementExpression] << std::endl; 
     std::cout << "Memory pool size of SgStatementFunctionStatement: " <<  listOfMemoryPoolSizes[V_SgStatementFunctionStatement] << std::endl; 
     std::cout << "Memory pool size of SgStopOrPauseStatement: " <<  listOfMemoryPoolSizes[V_SgStopOrPauseStatement] << std::endl; 
     std::cout << "Memory pool size of SgStorageModifier: " <<  listOfMemoryPoolSizes[V_SgStorageModifier] << std::endl; 
     std::cout << "Memory pool size of SgStringConversion: " <<  listOfMemoryPoolSizes[V_SgStringConversion] << std::endl; 
     std::cout << "Memory pool size of SgStringKeyedBidirectionalGraph: " <<  listOfMemoryPoolSizes[V_SgStringKeyedBidirectionalGraph] << std::endl; 
     std::cout << "Memory pool size of SgStringVal: " <<  listOfMemoryPoolSizes[V_SgStringVal] << std::endl; 
     std::cout << "Memory pool size of SgSubscriptExpression: " <<  listOfMemoryPoolSizes[V_SgSubscriptExpression] << std::endl; 
     std::cout << "Memory pool size of SgSubtractOp: " <<  listOfMemoryPoolSizes[V_SgSubtractOp] << std::endl; 
     std::cout << "Memory pool size of SgSupport: " <<  listOfMemoryPoolSizes[V_SgSupport] << std::endl; 
     std::cout << "Memory pool size of SgSwitchStatement: " <<  listOfMemoryPoolSizes[V_SgSwitchStatement] << std::endl; 
     std::cout << "Memory pool size of SgSymbol: " <<  listOfMemoryPoolSizes[V_SgSymbol] << std::endl; 
     std::cout << "Memory pool size of SgSymbolTable: " <<  listOfMemoryPoolSizes[V_SgSymbolTable] << std::endl; 
     std::cout << "Memory pool size of SgTemplateArgument: " <<  listOfMemoryPoolSizes[V_SgTemplateArgument] << std::endl; 
     std::cout << "Memory pool size of SgTemplateArgumentList: " <<  listOfMemoryPoolSizes[V_SgTemplateArgumentList] << std::endl; 
     std::cout << "Memory pool size of SgTemplateDeclaration: " <<  listOfMemoryPoolSizes[V_SgTemplateDeclaration] << std::endl; 
     std::cout << "Memory pool size of SgTemplateClassDeclaration: " <<  listOfMemoryPoolSizes[V_SgTemplateClassDeclaration] << std::endl; 
     std::cout << "Memory pool size of SgTemplateFunctionDeclaration: " <<  listOfMemoryPoolSizes[V_SgTemplateFunctionDeclaration] << std::endl; 
     std::cout << "Memory pool size of SgTemplateMemberFunctionDeclaration: " <<  listOfMemoryPoolSizes[V_SgTemplateMemberFunctionDeclaration] << std::endl; 
     std::cout << "Memory pool size of SgTemplateClassDefinition: " <<  listOfMemoryPoolSizes[V_SgTemplateClassDefinition] << std::endl; 
     std::cout << "Memory pool size of SgTemplateFunctionDefinition: " <<  listOfMemoryPoolSizes[V_SgTemplateFunctionDefinition] << std::endl; 
     std::cout << "Memory pool size of SgTemplateInstantiationDecl: " <<  listOfMemoryPoolSizes[V_SgTemplateInstantiationDecl] << std::endl; 
     std::cout << "Memory pool size of SgTemplateInstantiationDefn: " <<  listOfMemoryPoolSizes[V_SgTemplateInstantiationDefn] << std::endl; 
     std::cout << "Memory pool size of SgTemplateInstantiationDirectiveStatement: " <<  listOfMemoryPoolSizes[V_SgTemplateInstantiationDirectiveStatement] << std::endl; 
     std::cout << "Memory pool size of SgTemplateInstantiationFunctionDecl: " <<  listOfMemoryPoolSizes[V_SgTemplateInstantiationFunctionDecl] << std::endl; 
     std::cout << "Memory pool size of SgTemplateInstantiationMemberFunctionDecl: " <<  listOfMemoryPoolSizes[V_SgTemplateInstantiationMemberFunctionDecl] << std::endl; 
     std::cout << "Memory pool size of SgTemplateParameter: " <<  listOfMemoryPoolSizes[V_SgTemplateParameter] << std::endl; 
     std::cout << "Memory pool size of SgTemplateParameterList: " <<  listOfMemoryPoolSizes[V_SgTemplateParameterList] << std::endl; 
     std::cout << "Memory pool size of SgTemplateSymbol: " <<  listOfMemoryPoolSizes[V_SgTemplateSymbol] << std::endl; 
     std::cout << "Memory pool size of SgTemplateType: " <<  listOfMemoryPoolSizes[V_SgTemplateType] << std::endl; 
     std::cout << "Memory pool size of SgThisExp: " <<  listOfMemoryPoolSizes[V_SgThisExp] << std::endl; 
     std::cout << "Memory pool size of SgSuperExp: " <<  listOfMemoryPoolSizes[V_SgSuperExp] << std::endl; 
     std::cout << "Memory pool size of SgThrowOp: " <<  listOfMemoryPoolSizes[V_SgThrowOp] << std::endl; 
     std::cout << "Memory pool size of SgToken: " <<  listOfMemoryPoolSizes[V_SgToken] << std::endl; 
     std::cout << "Memory pool size of SgTryStmt: " <<  listOfMemoryPoolSizes[V_SgTryStmt] << std::endl; 
     std::cout << "Memory pool size of SgTupleExp: " <<  listOfMemoryPoolSizes[V_SgTupleExp] << std::endl; 
     std::cout << "Memory pool size of SgType: " <<  listOfMemoryPoolSizes[V_SgType] << std::endl; 
     std::cout << "Memory pool size of SgTypeBool: " <<  listOfMemoryPoolSizes[V_SgTypeBool] << std::endl; 
     std::cout << "Memory pool size of SgTypeChar: " <<  listOfMemoryPoolSizes[V_SgTypeChar] << std::endl; 
     std::cout << "Memory pool size of SgTypeComplex: " <<  listOfMemoryPoolSizes[V_SgTypeComplex] << std::endl; 
     std::cout << "Memory pool size of SgTypeDefault: " <<  listOfMemoryPoolSizes[V_SgTypeDefault] << std::endl; 
     std::cout << "Memory pool size of SgTypeLabel: " <<  listOfMemoryPoolSizes[V_SgTypeLabel] << std::endl; 
     std::cout << "Memory pool size of SgTypeDouble: " <<  listOfMemoryPoolSizes[V_SgTypeDouble] << std::endl; 
     std::cout << "Memory pool size of SgTypeEllipse: " <<  listOfMemoryPoolSizes[V_SgTypeEllipse] << std::endl; 
     std::cout << "Memory pool size of SgTypeFloat: " <<  listOfMemoryPoolSizes[V_SgTypeFloat] << std::endl; 
     std::cout << "Memory pool size of SgTypeGlobalVoid: " <<  listOfMemoryPoolSizes[V_SgTypeGlobalVoid] << std::endl; 
     std::cout << "Memory pool size of SgTypeIdOp: " <<  listOfMemoryPoolSizes[V_SgTypeIdOp] << std::endl; 
     std::cout << "Memory pool size of SgTypeImaginary: " <<  listOfMemoryPoolSizes[V_SgTypeImaginary] << std::endl; 
     std::cout << "Memory pool size of SgTypeInt: " <<  listOfMemoryPoolSizes[V_SgTypeInt] << std::endl; 
     std::cout << "Memory pool size of SgTypeLong: " <<  listOfMemoryPoolSizes[V_SgTypeLong] << std::endl; 
     std::cout << "Memory pool size of SgTypeLongDouble: " <<  listOfMemoryPoolSizes[V_SgTypeLongDouble] << std::endl; 
     std::cout << "Memory pool size of SgTypeLongLong: " <<  listOfMemoryPoolSizes[V_SgTypeLongLong] << std::endl; 
     std::cout << "Memory pool size of SgTypeModifier: " <<  listOfMemoryPoolSizes[V_SgTypeModifier] << std::endl; 
     std::cout << "Memory pool size of SgTypeShort: " <<  listOfMemoryPoolSizes[V_SgTypeShort] << std::endl; 
     std::cout << "Memory pool size of SgTypeSignedChar: " <<  listOfMemoryPoolSizes[V_SgTypeSignedChar] << std::endl; 
     std::cout << "Memory pool size of SgTypeSignedInt: " <<  listOfMemoryPoolSizes[V_SgTypeSignedInt] << std::endl; 
     std::cout << "Memory pool size of SgTypeSignedLong: " <<  listOfMemoryPoolSizes[V_SgTypeSignedLong] << std::endl; 
     std::cout << "Memory pool size of SgTypeSignedLongLong: " <<  listOfMemoryPoolSizes[V_SgTypeSignedLongLong] << std::endl; 
     std::cout << "Memory pool size of SgTypeSignedShort: " <<  listOfMemoryPoolSizes[V_SgTypeSignedShort] << std::endl; 
     std::cout << "Memory pool size of SgTypeString: " <<  listOfMemoryPoolSizes[V_SgTypeString] << std::endl; 
     std::cout << "Memory pool size of SgTypeUnknown: " <<  listOfMemoryPoolSizes[V_SgTypeUnknown] << std::endl; 
     std::cout << "Memory pool size of SgTypeUnsignedChar: " <<  listOfMemoryPoolSizes[V_SgTypeUnsignedChar] << std::endl; 
     std::cout << "Memory pool size of SgTypeUnsignedInt: " <<  listOfMemoryPoolSizes[V_SgTypeUnsignedInt] << std::endl; 
     std::cout << "Memory pool size of SgTypeUnsignedLong: " <<  listOfMemoryPoolSizes[V_SgTypeUnsignedLong] << std::endl; 
     std::cout << "Memory pool size of SgTypeUnsignedLongLong: " <<  listOfMemoryPoolSizes[V_SgTypeUnsignedLongLong] << std::endl; 
     std::cout << "Memory pool size of SgTypeUnsignedShort: " <<  listOfMemoryPoolSizes[V_SgTypeUnsignedShort] << std::endl; 
     std::cout << "Memory pool size of SgTypeVoid: " <<  listOfMemoryPoolSizes[V_SgTypeVoid] << std::endl; 
     std::cout << "Memory pool size of SgTypeWchar: " <<  listOfMemoryPoolSizes[V_SgTypeWchar] << std::endl; 
     std::cout << "Memory pool size of SgTypedefDeclaration: " <<  listOfMemoryPoolSizes[V_SgTypedefDeclaration] << std::endl; 
     std::cout << "Memory pool size of SgTypedefSeq: " <<  listOfMemoryPoolSizes[V_SgTypedefSeq] << std::endl; 
     std::cout << "Memory pool size of SgTypedefSymbol: " <<  listOfMemoryPoolSizes[V_SgTypedefSymbol] << std::endl; 
     std::cout << "Memory pool size of SgTypedefType: " <<  listOfMemoryPoolSizes[V_SgTypedefType] << std::endl; 
     std::cout << "Memory pool size of SgUPC_AccessModifier: " <<  listOfMemoryPoolSizes[V_SgUPC_AccessModifier] << std::endl; 
     std::cout << "Memory pool size of SgUnaryAddOp: " <<  listOfMemoryPoolSizes[V_SgUnaryAddOp] << std::endl; 
     std::cout << "Memory pool size of SgUnaryOp: " <<  listOfMemoryPoolSizes[V_SgUnaryOp] << std::endl; 
     std::cout << "Memory pool size of SgUndefDirectiveStatement: " <<  listOfMemoryPoolSizes[V_SgUndefDirectiveStatement] << std::endl; 
     std::cout << "Memory pool size of SgUndirectedGraphEdge: " <<  listOfMemoryPoolSizes[V_SgUndirectedGraphEdge] << std::endl; 
     std::cout << "Memory pool size of SgUnknownArrayOrFunctionReference: " <<  listOfMemoryPoolSizes[V_SgUnknownArrayOrFunctionReference] << std::endl; 
     std::cout << "Memory pool size of SgUnknownFile: " <<  listOfMemoryPoolSizes[V_SgUnknownFile] << std::endl; 
     std::cout << "Memory pool size of SgUnparse_Info: " <<  listOfMemoryPoolSizes[V_SgUnparse_Info] << std::endl; 
     std::cout << "Memory pool size of SgUnsignedCharVal: " <<  listOfMemoryPoolSizes[V_SgUnsignedCharVal] << std::endl; 
     std::cout << "Memory pool size of SgUnsignedIntVal: " <<  listOfMemoryPoolSizes[V_SgUnsignedIntVal] << std::endl; 
     std::cout << "Memory pool size of SgUnsignedLongLongIntVal: " <<  listOfMemoryPoolSizes[V_SgUnsignedLongLongIntVal] << std::endl; 
     std::cout << "Memory pool size of SgUnsignedLongVal: " <<  listOfMemoryPoolSizes[V_SgUnsignedLongVal] << std::endl; 
     std::cout << "Memory pool size of SgUnsignedShortVal: " <<  listOfMemoryPoolSizes[V_SgUnsignedShortVal] << std::endl; 
     std::cout << "Memory pool size of SgUpcBarrierStatement: " <<  listOfMemoryPoolSizes[V_SgUpcBarrierStatement] << std::endl; 
     std::cout << "Memory pool size of SgUpcBlocksizeofExpression: " <<  listOfMemoryPoolSizes[V_SgUpcBlocksizeofExpression] << std::endl; 
     std::cout << "Memory pool size of SgUpcElemsizeofExpression: " <<  listOfMemoryPoolSizes[V_SgUpcElemsizeofExpression] << std::endl; 
     std::cout << "Memory pool size of SgUpcFenceStatement: " <<  listOfMemoryPoolSizes[V_SgUpcFenceStatement] << std::endl; 
     std::cout << "Memory pool size of SgUpcForAllStatement: " <<  listOfMemoryPoolSizes[V_SgUpcForAllStatement] << std::endl; 
     std::cout << "Memory pool size of SgUpcLocalsizeofExpression: " <<  listOfMemoryPoolSizes[V_SgUpcLocalsizeofExpression] << std::endl; 
     std::cout << "Memory pool size of SgUpcMythread: " <<  listOfMemoryPoolSizes[V_SgUpcMythread] << std::endl; 
     std::cout << "Memory pool size of SgUpcNotifyStatement: " <<  listOfMemoryPoolSizes[V_SgUpcNotifyStatement] << std::endl; 
     std::cout << "Memory pool size of SgUpcThreads: " <<  listOfMemoryPoolSizes[V_SgUpcThreads] << std::endl; 
     std::cout << "Memory pool size of SgUpcWaitStatement: " <<  listOfMemoryPoolSizes[V_SgUpcWaitStatement] << std::endl; 
     std::cout << "Memory pool size of SgUseStatement: " <<  listOfMemoryPoolSizes[V_SgUseStatement] << std::endl; 
     std::cout << "Memory pool size of SgUserDefinedBinaryOp: " <<  listOfMemoryPoolSizes[V_SgUserDefinedBinaryOp] << std::endl; 
     std::cout << "Memory pool size of SgUserDefinedUnaryOp: " <<  listOfMemoryPoolSizes[V_SgUserDefinedUnaryOp] << std::endl; 
     std::cout << "Memory pool size of SgUsingDeclarationStatement: " <<  listOfMemoryPoolSizes[V_SgUsingDeclarationStatement] << std::endl; 
     std::cout << "Memory pool size of SgUsingDirectiveStatement: " <<  listOfMemoryPoolSizes[V_SgUsingDirectiveStatement] << std::endl; 
     std::cout << "Memory pool size of SgValueExp: " <<  listOfMemoryPoolSizes[V_SgValueExp] << std::endl; 
     std::cout << "Memory pool size of SgVarArgCopyOp: " <<  listOfMemoryPoolSizes[V_SgVarArgCopyOp] << std::endl; 
     std::cout << "Memory pool size of SgVarArgEndOp: " <<  listOfMemoryPoolSizes[V_SgVarArgEndOp] << std::endl; 
     std::cout << "Memory pool size of SgVarArgOp: " <<  listOfMemoryPoolSizes[V_SgVarArgOp] << std::endl; 
     std::cout << "Memory pool size of SgVarArgStartOneOperandOp: " <<  listOfMemoryPoolSizes[V_SgVarArgStartOneOperandOp] << std::endl; 
     std::cout << "Memory pool size of SgVarArgStartOp: " <<  listOfMemoryPoolSizes[V_SgVarArgStartOp] << std::endl; 
     std::cout << "Memory pool size of SgVarRefExp: " <<  listOfMemoryPoolSizes[V_SgVarRefExp] << std::endl; 
     std::cout << "Memory pool size of SgVariableDeclaration: " <<  listOfMemoryPoolSizes[V_SgVariableDeclaration] << std::endl; 
     std::cout << "Memory pool size of SgVariableDefinition: " <<  listOfMemoryPoolSizes[V_SgVariableDefinition] << std::endl; 
     std::cout << "Memory pool size of SgVariableSymbol: " <<  listOfMemoryPoolSizes[V_SgVariableSymbol] << std::endl; 
     std::cout << "Memory pool size of SgVariantExpression: " <<  listOfMemoryPoolSizes[V_SgVariantExpression] << std::endl; 
     std::cout << "Memory pool size of SgVariantStatement: " <<  listOfMemoryPoolSizes[V_SgVariantStatement] << std::endl; 
     std::cout << "Memory pool size of SgWaitStatement: " <<  listOfMemoryPoolSizes[V_SgWaitStatement] << std::endl; 
     std::cout << "Memory pool size of SgWarningDirectiveStatement: " <<  listOfMemoryPoolSizes[V_SgWarningDirectiveStatement] << std::endl; 
     std::cout << "Memory pool size of SgWithStatement: " <<  listOfMemoryPoolSizes[V_SgWithStatement] << std::endl; 
     std::cout << "Memory pool size of SgWcharVal: " <<  listOfMemoryPoolSizes[V_SgWcharVal] << std::endl; 
     std::cout << "Memory pool size of SgWhereStatement: " <<  listOfMemoryPoolSizes[V_SgWhereStatement] << std::endl; 
     std::cout << "Memory pool size of SgWhileStmt: " <<  listOfMemoryPoolSizes[V_SgWhileStmt] << std::endl; 
     std::cout << "Memory pool size of SgWriteStatement: " <<  listOfMemoryPoolSizes[V_SgWriteStatement] << std::endl; 
     std::cout << "Memory pool size of SgXorAssignOp: " <<  listOfMemoryPoolSizes[V_SgXorAssignOp] << std::endl; 
     std::cout << "Memory pool size of SgYieldExpression: " <<  listOfMemoryPoolSizes[V_SgYieldExpression] << std::endl; 
     std::cout << "Memory pool size of Sg_File_Info: " <<  listOfMemoryPoolSizes[V_Sg_File_Info] << std::endl; 
     std::cout << "Memory pool size of SgTypeCAFTeam: " <<  listOfMemoryPoolSizes[V_SgTypeCAFTeam] << std::endl; 
     std::cout << "Memory pool size of SgCAFWithTeamStatement: " <<  listOfMemoryPoolSizes[V_SgCAFWithTeamStatement] << std::endl; 
     std::cout << "Memory pool size of SgCAFCoExpression: " <<  listOfMemoryPoolSizes[V_SgCAFCoExpression] << std::endl; 
     std::cout << "Memory pool size of SgCallExpression: " <<  listOfMemoryPoolSizes[V_SgCallExpression] << std::endl; 
     std::cout << "Memory pool size of SgTypeCrayPointer: " <<  listOfMemoryPoolSizes[V_SgTypeCrayPointer] << std::endl; 
     std::cout << "Memory pool size of SgJavaImportStatement: " <<  listOfMemoryPoolSizes[V_SgJavaImportStatement] << std::endl; 

/* #line 540 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarAST_FileIoSource.code" */
     std::cout << " Total number of IR nodes in contained in the memory pools: "  
               << listOfMemoryPoolSizes[totalNumberOfIRNodes] << std::endl << std::endl;
     return;
   }


void 
AST_FILE_IO::printListOfPoolSizesOfAst (int index)
   {
     std::cout << "Memory pool size of SgAccessModifier: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAccessModifier) << std::endl; 
     std::cout << "Memory pool size of SgActualArgumentExpression: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgActualArgumentExpression) << std::endl; 
     std::cout << "Memory pool size of SgAddOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAddOp) << std::endl; 
     std::cout << "Memory pool size of SgAddressOfOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAddressOfOp) << std::endl; 
     std::cout << "Memory pool size of SgAggregateInitializer: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAggregateInitializer) << std::endl; 
     std::cout << "Memory pool size of SgAliasSymbol: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAliasSymbol) << std::endl; 
     std::cout << "Memory pool size of SgAllocateStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAllocateStatement) << std::endl; 
     std::cout << "Memory pool size of SgAndAssignOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAndAssignOp) << std::endl; 
     std::cout << "Memory pool size of SgAndOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAndOp) << std::endl; 
     std::cout << "Memory pool size of SgArithmeticIfStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgArithmeticIfStatement) << std::endl; 
     std::cout << "Memory pool size of SgArrayType: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgArrayType) << std::endl; 
     std::cout << "Memory pool size of SgArrowExp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgArrowExp) << std::endl; 
     std::cout << "Memory pool size of SgArrowStarOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgArrowStarOp) << std::endl; 
     std::cout << "Memory pool size of SgAsmArmInstruction: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmArmInstruction) << std::endl; 
     std::cout << "Memory pool size of SgAsmArmRegisterReferenceExpression: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmArmRegisterReferenceExpression) << std::endl; 
     std::cout << "Memory pool size of SgAsmBasicString: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmBasicString) << std::endl; 
     std::cout << "Memory pool size of SgAsmBinaryAdd: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmBinaryAdd) << std::endl; 
     std::cout << "Memory pool size of SgAsmBinaryAddPostupdate: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmBinaryAddPostupdate) << std::endl; 
     std::cout << "Memory pool size of SgAsmBinaryAddPreupdate: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmBinaryAddPreupdate) << std::endl; 
     std::cout << "Memory pool size of SgAsmBinaryAsr: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmBinaryAsr) << std::endl; 
     std::cout << "Memory pool size of SgAsmBinaryDivide: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmBinaryDivide) << std::endl; 
     std::cout << "Memory pool size of SgAsmBinaryExpression: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmBinaryExpression) << std::endl; 
     std::cout << "Memory pool size of SgAsmBinaryLsl: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmBinaryLsl) << std::endl; 
     std::cout << "Memory pool size of SgAsmBinaryLsr: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmBinaryLsr) << std::endl; 
     std::cout << "Memory pool size of SgAsmBinaryMod: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmBinaryMod) << std::endl; 
     std::cout << "Memory pool size of SgAsmBinaryMultiply: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmBinaryMultiply) << std::endl; 
     std::cout << "Memory pool size of SgAsmBinaryRor: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmBinaryRor) << std::endl; 
     std::cout << "Memory pool size of SgAsmBinarySubtract: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmBinarySubtract) << std::endl; 
     std::cout << "Memory pool size of SgAsmBinarySubtractPostupdate: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmBinarySubtractPostupdate) << std::endl; 
     std::cout << "Memory pool size of SgAsmBinarySubtractPreupdate: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmBinarySubtractPreupdate) << std::endl; 
     std::cout << "Memory pool size of SgAsmBlock: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmBlock) << std::endl; 
     std::cout << "Memory pool size of SgAsmByteValueExpression: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmByteValueExpression) << std::endl; 
     std::cout << "Memory pool size of SgAsmCoffStrtab: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmCoffStrtab) << std::endl; 
     std::cout << "Memory pool size of SgAsmCoffSymbol: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmCoffSymbol) << std::endl; 
     std::cout << "Memory pool size of SgAsmCoffSymbolList: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmCoffSymbolList) << std::endl; 
     std::cout << "Memory pool size of SgAsmCoffSymbolTable: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmCoffSymbolTable) << std::endl; 
     std::cout << "Memory pool size of SgAsmCommonSubExpression: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmCommonSubExpression) << std::endl; 
     std::cout << "Memory pool size of SgAsmControlFlagsExpression: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmControlFlagsExpression) << std::endl; 
     std::cout << "Memory pool size of SgAsmDOSExtendedHeader: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDOSExtendedHeader) << std::endl; 
     std::cout << "Memory pool size of SgAsmDOSFileHeader: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDOSFileHeader) << std::endl; 
     std::cout << "Memory pool size of SgAsmDoubleFloatValueExpression: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDoubleFloatValueExpression) << std::endl; 
     std::cout << "Memory pool size of SgAsmDoubleWordValueExpression: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDoubleWordValueExpression) << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfAccessDeclaration: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDwarfAccessDeclaration) << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfArrayType: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDwarfArrayType) << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfBaseType: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDwarfBaseType) << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfCatchBlock: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDwarfCatchBlock) << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfClassTemplate: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDwarfClassTemplate) << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfClassType: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDwarfClassType) << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfCommonBlock: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDwarfCommonBlock) << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfCommonInclusion: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDwarfCommonInclusion) << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfCompilationUnit: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDwarfCompilationUnit) << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfCompilationUnitList: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDwarfCompilationUnitList) << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfCondition: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDwarfCondition) << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfConstType: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDwarfConstType) << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfConstant: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDwarfConstant) << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfConstruct: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDwarfConstruct) << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfConstructList: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDwarfConstructList) << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfDwarfProcedure: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDwarfDwarfProcedure) << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfEntryPoint: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDwarfEntryPoint) << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfEnumerationType: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDwarfEnumerationType) << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfEnumerator: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDwarfEnumerator) << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfFileType: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDwarfFileType) << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfFormalParameter: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDwarfFormalParameter) << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfFormatLabel: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDwarfFormatLabel) << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfFriend: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDwarfFriend) << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfFunctionTemplate: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDwarfFunctionTemplate) << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfImportedDeclaration: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDwarfImportedDeclaration) << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfImportedModule: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDwarfImportedModule) << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfImportedUnit: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDwarfImportedUnit) << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfInformation: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDwarfInformation) << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfInheritance: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDwarfInheritance) << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfInlinedSubroutine: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDwarfInlinedSubroutine) << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfInterfaceType: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDwarfInterfaceType) << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfLabel: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDwarfLabel) << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfLexicalBlock: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDwarfLexicalBlock) << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfLine: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDwarfLine) << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfLineList: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDwarfLineList) << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfMacro: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDwarfMacro) << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfMacroList: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDwarfMacroList) << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfMember: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDwarfMember) << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfModule: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDwarfModule) << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfMutableType: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDwarfMutableType) << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfNamelist: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDwarfNamelist) << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfNamelistItem: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDwarfNamelistItem) << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfNamespace: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDwarfNamespace) << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfPackedType: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDwarfPackedType) << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfPartialUnit: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDwarfPartialUnit) << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfPointerType: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDwarfPointerType) << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfPtrToMemberType: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDwarfPtrToMemberType) << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfReferenceType: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDwarfReferenceType) << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfRestrictType: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDwarfRestrictType) << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfSetType: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDwarfSetType) << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfSharedType: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDwarfSharedType) << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfStringType: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDwarfStringType) << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfStructureType: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDwarfStructureType) << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfSubprogram: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDwarfSubprogram) << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfSubrangeType: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDwarfSubrangeType) << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfSubroutineType: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDwarfSubroutineType) << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfTemplateTypeParameter: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDwarfTemplateTypeParameter) << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfTemplateValueParameter: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDwarfTemplateValueParameter) << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfThrownType: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDwarfThrownType) << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfTryBlock: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDwarfTryBlock) << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfTypedef: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDwarfTypedef) << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfUnionType: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDwarfUnionType) << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfUnknownConstruct: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDwarfUnknownConstruct) << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfUnspecifiedParameters: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDwarfUnspecifiedParameters) << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfUnspecifiedType: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDwarfUnspecifiedType) << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfUpcRelaxedType: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDwarfUpcRelaxedType) << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfUpcSharedType: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDwarfUpcSharedType) << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfUpcStrictType: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDwarfUpcStrictType) << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfVariable: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDwarfVariable) << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfVariant: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDwarfVariant) << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfVariantPart: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDwarfVariantPart) << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfVolatileType: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDwarfVolatileType) << std::endl; 
     std::cout << "Memory pool size of SgAsmDwarfWithStmt: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmDwarfWithStmt) << std::endl; 
     std::cout << "Memory pool size of SgAsmElfDynamicEntry: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmElfDynamicEntry) << std::endl; 
     std::cout << "Memory pool size of SgAsmElfDynamicEntryList: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmElfDynamicEntryList) << std::endl; 
     std::cout << "Memory pool size of SgAsmElfDynamicSection: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmElfDynamicSection) << std::endl; 
     std::cout << "Memory pool size of SgAsmElfEHFrameEntryCI: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmElfEHFrameEntryCI) << std::endl; 
     std::cout << "Memory pool size of SgAsmElfEHFrameEntryCIList: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmElfEHFrameEntryCIList) << std::endl; 
     std::cout << "Memory pool size of SgAsmElfEHFrameEntryFD: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmElfEHFrameEntryFD) << std::endl; 
     std::cout << "Memory pool size of SgAsmElfEHFrameEntryFDList: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmElfEHFrameEntryFDList) << std::endl; 
     std::cout << "Memory pool size of SgAsmElfEHFrameSection: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmElfEHFrameSection) << std::endl; 
     std::cout << "Memory pool size of SgAsmElfFileHeader: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmElfFileHeader) << std::endl; 
     std::cout << "Memory pool size of SgAsmElfNoteEntry: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmElfNoteEntry) << std::endl; 
     std::cout << "Memory pool size of SgAsmElfNoteEntryList: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmElfNoteEntryList) << std::endl; 
     std::cout << "Memory pool size of SgAsmElfNoteSection: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmElfNoteSection) << std::endl; 
     std::cout << "Memory pool size of SgAsmElfRelocEntry: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmElfRelocEntry) << std::endl; 
     std::cout << "Memory pool size of SgAsmElfRelocEntryList: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmElfRelocEntryList) << std::endl; 
     std::cout << "Memory pool size of SgAsmElfRelocSection: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmElfRelocSection) << std::endl; 
     std::cout << "Memory pool size of SgAsmElfSection: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmElfSection) << std::endl; 
     std::cout << "Memory pool size of SgAsmElfSectionTable: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmElfSectionTable) << std::endl; 
     std::cout << "Memory pool size of SgAsmElfSectionTableEntry: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmElfSectionTableEntry) << std::endl; 
     std::cout << "Memory pool size of SgAsmElfSegmentTable: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmElfSegmentTable) << std::endl; 
     std::cout << "Memory pool size of SgAsmElfSegmentTableEntry: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmElfSegmentTableEntry) << std::endl; 
     std::cout << "Memory pool size of SgAsmElfSegmentTableEntryList: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmElfSegmentTableEntryList) << std::endl; 
     std::cout << "Memory pool size of SgAsmElfStringSection: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmElfStringSection) << std::endl; 
     std::cout << "Memory pool size of SgAsmElfStrtab: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmElfStrtab) << std::endl; 
     std::cout << "Memory pool size of SgAsmElfSymbol: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmElfSymbol) << std::endl; 
     std::cout << "Memory pool size of SgAsmElfSymbolList: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmElfSymbolList) << std::endl; 
     std::cout << "Memory pool size of SgAsmElfSymbolSection: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmElfSymbolSection) << std::endl; 
     std::cout << "Memory pool size of SgAsmElfSymverDefinedAux: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmElfSymverDefinedAux) << std::endl; 
     std::cout << "Memory pool size of SgAsmElfSymverDefinedAuxList: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmElfSymverDefinedAuxList) << std::endl; 
     std::cout << "Memory pool size of SgAsmElfSymverDefinedEntry: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmElfSymverDefinedEntry) << std::endl; 
     std::cout << "Memory pool size of SgAsmElfSymverDefinedEntryList: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmElfSymverDefinedEntryList) << std::endl; 
     std::cout << "Memory pool size of SgAsmElfSymverDefinedSection: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmElfSymverDefinedSection) << std::endl; 
     std::cout << "Memory pool size of SgAsmElfSymverEntry: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmElfSymverEntry) << std::endl; 
     std::cout << "Memory pool size of SgAsmElfSymverEntryList: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmElfSymverEntryList) << std::endl; 
     std::cout << "Memory pool size of SgAsmElfSymverNeededAux: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmElfSymverNeededAux) << std::endl; 
     std::cout << "Memory pool size of SgAsmElfSymverNeededAuxList: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmElfSymverNeededAuxList) << std::endl; 
     std::cout << "Memory pool size of SgAsmElfSymverNeededEntry: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmElfSymverNeededEntry) << std::endl; 
     std::cout << "Memory pool size of SgAsmElfSymverNeededEntryList: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmElfSymverNeededEntryList) << std::endl; 
     std::cout << "Memory pool size of SgAsmElfSymverNeededSection: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmElfSymverNeededSection) << std::endl; 
     std::cout << "Memory pool size of SgAsmElfSymverSection: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmElfSymverSection) << std::endl; 
     std::cout << "Memory pool size of SgAsmExecutableFileFormat: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmExecutableFileFormat) << std::endl; 
     std::cout << "Memory pool size of SgAsmExprListExp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmExprListExp) << std::endl; 
     std::cout << "Memory pool size of SgAsmExpression: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmExpression) << std::endl; 
     std::cout << "Memory pool size of SgAsmFunction: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmFunction) << std::endl; 
     std::cout << "Memory pool size of SgAsmGenericDLL: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmGenericDLL) << std::endl; 
     std::cout << "Memory pool size of SgAsmGenericDLLList: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmGenericDLLList) << std::endl; 
     std::cout << "Memory pool size of SgAsmGenericFile: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmGenericFile) << std::endl; 
     std::cout << "Memory pool size of SgAsmGenericFileList: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmGenericFileList) << std::endl; 
     std::cout << "Memory pool size of SgAsmGenericFormat: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmGenericFormat) << std::endl; 
     std::cout << "Memory pool size of SgAsmGenericHeader: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmGenericHeader) << std::endl; 
     std::cout << "Memory pool size of SgAsmGenericHeaderList: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmGenericHeaderList) << std::endl; 
     std::cout << "Memory pool size of SgAsmGenericSection: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmGenericSection) << std::endl; 
     std::cout << "Memory pool size of SgAsmGenericSectionList: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmGenericSectionList) << std::endl; 
     std::cout << "Memory pool size of SgAsmGenericString: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmGenericString) << std::endl; 
     std::cout << "Memory pool size of SgAsmGenericStrtab: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmGenericStrtab) << std::endl; 
     std::cout << "Memory pool size of SgAsmGenericSymbol: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmGenericSymbol) << std::endl; 
     std::cout << "Memory pool size of SgAsmGenericSymbolList: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmGenericSymbolList) << std::endl; 
     std::cout << "Memory pool size of SgAsmInstruction: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmInstruction) << std::endl; 
     std::cout << "Memory pool size of SgAsmIntegerValueExpression: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmIntegerValueExpression) << std::endl; 
     std::cout << "Memory pool size of SgAsmInterpretation: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmInterpretation) << std::endl; 
     std::cout << "Memory pool size of SgAsmInterpretationList: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmInterpretationList) << std::endl; 
     std::cout << "Memory pool size of SgAsmLEEntryPoint: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmLEEntryPoint) << std::endl; 
     std::cout << "Memory pool size of SgAsmLEEntryTable: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmLEEntryTable) << std::endl; 
     std::cout << "Memory pool size of SgAsmLEFileHeader: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmLEFileHeader) << std::endl; 
     std::cout << "Memory pool size of SgAsmLENameTable: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmLENameTable) << std::endl; 
     std::cout << "Memory pool size of SgAsmLEPageTable: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmLEPageTable) << std::endl; 
     std::cout << "Memory pool size of SgAsmLEPageTableEntry: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmLEPageTableEntry) << std::endl; 
     std::cout << "Memory pool size of SgAsmLERelocTable: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmLERelocTable) << std::endl; 
     std::cout << "Memory pool size of SgAsmLESection: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmLESection) << std::endl; 
     std::cout << "Memory pool size of SgAsmLESectionTable: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmLESectionTable) << std::endl; 
     std::cout << "Memory pool size of SgAsmLESectionTableEntry: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmLESectionTableEntry) << std::endl; 
     std::cout << "Memory pool size of SgAsmMemoryReferenceExpression: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmMemoryReferenceExpression) << std::endl; 
     std::cout << "Memory pool size of SgAsmNEEntryPoint: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmNEEntryPoint) << std::endl; 
     std::cout << "Memory pool size of SgAsmNEEntryTable: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmNEEntryTable) << std::endl; 
     std::cout << "Memory pool size of SgAsmNEFileHeader: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmNEFileHeader) << std::endl; 
     std::cout << "Memory pool size of SgAsmNEModuleTable: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmNEModuleTable) << std::endl; 
     std::cout << "Memory pool size of SgAsmNENameTable: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmNENameTable) << std::endl; 
     std::cout << "Memory pool size of SgAsmNERelocEntry: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmNERelocEntry) << std::endl; 
     std::cout << "Memory pool size of SgAsmNERelocTable: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmNERelocTable) << std::endl; 
     std::cout << "Memory pool size of SgAsmNESection: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmNESection) << std::endl; 
     std::cout << "Memory pool size of SgAsmNESectionTable: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmNESectionTable) << std::endl; 
     std::cout << "Memory pool size of SgAsmNESectionTableEntry: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmNESectionTableEntry) << std::endl; 
     std::cout << "Memory pool size of SgAsmNEStringTable: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmNEStringTable) << std::endl; 
     std::cout << "Memory pool size of SgAsmNode: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmNode) << std::endl; 
     std::cout << "Memory pool size of SgAsmOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmOp) << std::endl; 
     std::cout << "Memory pool size of SgAsmOperandList: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmOperandList) << std::endl; 
     std::cout << "Memory pool size of SgAsmPEExportDirectory: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmPEExportDirectory) << std::endl; 
     std::cout << "Memory pool size of SgAsmPEExportEntry: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmPEExportEntry) << std::endl; 
     std::cout << "Memory pool size of SgAsmPEExportEntryList: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmPEExportEntryList) << std::endl; 
     std::cout << "Memory pool size of SgAsmPEExportSection: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmPEExportSection) << std::endl; 
     std::cout << "Memory pool size of SgAsmPEFileHeader: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmPEFileHeader) << std::endl; 
     std::cout << "Memory pool size of SgAsmPEImportDirectory: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmPEImportDirectory) << std::endl; 
     std::cout << "Memory pool size of SgAsmPEImportDirectoryList: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmPEImportDirectoryList) << std::endl; 
     std::cout << "Memory pool size of SgAsmPEImportItem: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmPEImportItem) << std::endl; 
     std::cout << "Memory pool size of SgAsmPEImportItemList: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmPEImportItemList) << std::endl; 
     std::cout << "Memory pool size of SgAsmPEImportSection: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmPEImportSection) << std::endl; 
     std::cout << "Memory pool size of SgAsmPERVASizePair: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmPERVASizePair) << std::endl; 
     std::cout << "Memory pool size of SgAsmPERVASizePairList: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmPERVASizePairList) << std::endl; 
     std::cout << "Memory pool size of SgAsmPESection: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmPESection) << std::endl; 
     std::cout << "Memory pool size of SgAsmPESectionTable: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmPESectionTable) << std::endl; 
     std::cout << "Memory pool size of SgAsmPESectionTableEntry: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmPESectionTableEntry) << std::endl; 
     std::cout << "Memory pool size of SgAsmPEStringSection: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmPEStringSection) << std::endl; 
     std::cout << "Memory pool size of SgAsmPowerpcInstruction: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmPowerpcInstruction) << std::endl; 
     std::cout << "Memory pool size of SgAsmPowerpcRegisterReferenceExpression: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmPowerpcRegisterReferenceExpression) << std::endl; 
     std::cout << "Memory pool size of SgAsmQuadWordValueExpression: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmQuadWordValueExpression) << std::endl; 
     std::cout << "Memory pool size of SgAsmRegisterReferenceExpression: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmRegisterReferenceExpression) << std::endl; 
     std::cout << "Memory pool size of SgAsmSingleFloatValueExpression: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmSingleFloatValueExpression) << std::endl; 
     std::cout << "Memory pool size of SgAsmStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmStatement) << std::endl; 
     std::cout << "Memory pool size of SgAsmStaticData: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmStaticData) << std::endl; 
     std::cout << "Memory pool size of SgAsmStmt: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmStmt) << std::endl; 
     std::cout << "Memory pool size of SgAsmStoredString: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmStoredString) << std::endl; 
     std::cout << "Memory pool size of SgAsmStringStorage: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmStringStorage) << std::endl; 
     std::cout << "Memory pool size of SgAsmType: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmType) << std::endl; 
     std::cout << "Memory pool size of SgAsmType128bitFloat: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmType128bitFloat) << std::endl; 
     std::cout << "Memory pool size of SgAsmType80bitFloat: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmType80bitFloat) << std::endl; 
     std::cout << "Memory pool size of SgAsmTypeByte: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmTypeByte) << std::endl; 
     std::cout << "Memory pool size of SgAsmTypeDoubleFloat: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmTypeDoubleFloat) << std::endl; 
     std::cout << "Memory pool size of SgAsmTypeDoubleQuadWord: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmTypeDoubleQuadWord) << std::endl; 
     std::cout << "Memory pool size of SgAsmTypeDoubleWord: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmTypeDoubleWord) << std::endl; 
     std::cout << "Memory pool size of SgAsmTypeQuadWord: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmTypeQuadWord) << std::endl; 
     std::cout << "Memory pool size of SgAsmTypeSingleFloat: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmTypeSingleFloat) << std::endl; 
     std::cout << "Memory pool size of SgAsmTypeVector: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmTypeVector) << std::endl; 
     std::cout << "Memory pool size of SgAsmTypeWord: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmTypeWord) << std::endl; 
     std::cout << "Memory pool size of SgAsmUnaryArmSpecialRegisterList: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmUnaryArmSpecialRegisterList) << std::endl; 
     std::cout << "Memory pool size of SgAsmUnaryExpression: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmUnaryExpression) << std::endl; 
     std::cout << "Memory pool size of SgAsmUnaryMinus: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmUnaryMinus) << std::endl; 
     std::cout << "Memory pool size of SgAsmUnaryPlus: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmUnaryPlus) << std::endl; 
     std::cout << "Memory pool size of SgAsmUnaryRrx: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmUnaryRrx) << std::endl; 
     std::cout << "Memory pool size of SgAsmValueExpression: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmValueExpression) << std::endl; 
     std::cout << "Memory pool size of SgAsmVectorValueExpression: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmVectorValueExpression) << std::endl; 
     std::cout << "Memory pool size of SgAsmWordValueExpression: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmWordValueExpression) << std::endl; 
     std::cout << "Memory pool size of SgAsmx86Instruction: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmx86Instruction) << std::endl; 
     std::cout << "Memory pool size of SgAsmx86RegisterReferenceExpression: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmx86RegisterReferenceExpression) << std::endl; 
     std::cout << "Memory pool size of SgAsmBinaryAddressSymbol: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmBinaryAddressSymbol) << std::endl; 
     std::cout << "Memory pool size of SgAsmBinaryDataSymbol: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsmBinaryDataSymbol) << std::endl; 
     std::cout << "Memory pool size of SgAssertStmt: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAssertStmt) << std::endl; 
     std::cout << "Memory pool size of SgAssignInitializer: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAssignInitializer) << std::endl; 
     std::cout << "Memory pool size of SgAssignOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAssignOp) << std::endl; 
     std::cout << "Memory pool size of SgAssignStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAssignStatement) << std::endl; 
     std::cout << "Memory pool size of SgAssignedGotoStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAssignedGotoStatement) << std::endl; 
     std::cout << "Memory pool size of SgAssociateStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAssociateStatement) << std::endl; 
     std::cout << "Memory pool size of SgAsteriskShapeExp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAsteriskShapeExp) << std::endl; 
     std::cout << "Memory pool size of SgAttribute: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAttribute) << std::endl; 
     std::cout << "Memory pool size of SgAttributeSpecificationStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgAttributeSpecificationStatement) << std::endl; 
     std::cout << "Memory pool size of SgBackspaceStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgBackspaceStatement) << std::endl; 
     std::cout << "Memory pool size of SgBaseClass: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgBaseClass) << std::endl; 
     std::cout << "Memory pool size of SgExpBaseClass: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgExpBaseClass) << std::endl; 
     std::cout << "Memory pool size of SgBaseClassModifier: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgBaseClassModifier) << std::endl; 
     std::cout << "Memory pool size of SgBasicBlock: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgBasicBlock) << std::endl; 
     std::cout << "Memory pool size of SgBidirectionalGraph: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgBidirectionalGraph) << std::endl; 
     std::cout << "Memory pool size of SgBinaryComposite: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgBinaryComposite) << std::endl; 
     std::cout << "Memory pool size of SgBinaryOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgBinaryOp) << std::endl; 
     std::cout << "Memory pool size of SgBitAndOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgBitAndOp) << std::endl; 
     std::cout << "Memory pool size of SgBitAttribute: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgBitAttribute) << std::endl; 
     std::cout << "Memory pool size of SgBitComplementOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgBitComplementOp) << std::endl; 
     std::cout << "Memory pool size of SgBitOrOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgBitOrOp) << std::endl; 
     std::cout << "Memory pool size of SgBitXorOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgBitXorOp) << std::endl; 
     std::cout << "Memory pool size of SgBlockDataStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgBlockDataStatement) << std::endl; 
     std::cout << "Memory pool size of SgBoolValExp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgBoolValExp) << std::endl; 
     std::cout << "Memory pool size of SgBreakStmt: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgBreakStmt) << std::endl; 
     std::cout << "Memory pool size of SgC_PreprocessorDirectiveStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgC_PreprocessorDirectiveStatement) << std::endl; 
     std::cout << "Memory pool size of SgCaseOptionStmt: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgCaseOptionStmt) << std::endl; 
     std::cout << "Memory pool size of SgCastExp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgCastExp) << std::endl; 
     std::cout << "Memory pool size of SgCatchOptionStmt: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgCatchOptionStmt) << std::endl; 
     std::cout << "Memory pool size of SgCatchStatementSeq: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgCatchStatementSeq) << std::endl; 
     std::cout << "Memory pool size of SgCharVal: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgCharVal) << std::endl; 
     std::cout << "Memory pool size of SgClassDecl_attr: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgClassDecl_attr) << std::endl; 
     std::cout << "Memory pool size of SgClassDeclaration: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgClassDeclaration) << std::endl; 
     std::cout << "Memory pool size of SgClassDefinition: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgClassDefinition) << std::endl; 
     std::cout << "Memory pool size of SgClassNameRefExp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgClassNameRefExp) << std::endl; 
     std::cout << "Memory pool size of SgClassSymbol: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgClassSymbol) << std::endl; 
     std::cout << "Memory pool size of SgClassType: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgClassType) << std::endl; 
     std::cout << "Memory pool size of SgClinkageDeclarationStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgClinkageDeclarationStatement) << std::endl; 
     std::cout << "Memory pool size of SgClinkageEndStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgClinkageEndStatement) << std::endl; 
     std::cout << "Memory pool size of SgClinkageStartStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgClinkageStartStatement) << std::endl; 
     std::cout << "Memory pool size of SgCloseStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgCloseStatement) << std::endl; 
     std::cout << "Memory pool size of SgColonShapeExp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgColonShapeExp) << std::endl; 
     std::cout << "Memory pool size of SgCommaOpExp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgCommaOpExp) << std::endl; 
     std::cout << "Memory pool size of SgCommonBlock: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgCommonBlock) << std::endl; 
     std::cout << "Memory pool size of SgCommonBlockObject: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgCommonBlockObject) << std::endl; 
     std::cout << "Memory pool size of SgCommonSymbol: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgCommonSymbol) << std::endl; 
     std::cout << "Memory pool size of SgComplexVal: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgComplexVal) << std::endl; 
     std::cout << "Memory pool size of SgComprehension: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgComprehension) << std::endl; 
     std::cout << "Memory pool size of SgCompoundAssignOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgCompoundAssignOp) << std::endl; 
     std::cout << "Memory pool size of SgCompoundInitializer: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgCompoundInitializer) << std::endl; 
     std::cout << "Memory pool size of SgComputedGotoStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgComputedGotoStatement) << std::endl; 
     std::cout << "Memory pool size of SgConcatenationOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgConcatenationOp) << std::endl; 
     std::cout << "Memory pool size of SgConditionalExp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgConditionalExp) << std::endl; 
     std::cout << "Memory pool size of SgConjugateOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgConjugateOp) << std::endl; 
     std::cout << "Memory pool size of SgConstVolatileModifier: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgConstVolatileModifier) << std::endl; 
     std::cout << "Memory pool size of SgConstructorInitializer: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgConstructorInitializer) << std::endl; 
     std::cout << "Memory pool size of SgContainsStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgContainsStatement) << std::endl; 
     std::cout << "Memory pool size of SgContinueStmt: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgContinueStmt) << std::endl; 
     std::cout << "Memory pool size of SgCtorInitializerList: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgCtorInitializerList) << std::endl; 
     std::cout << "Memory pool size of SgDataStatementGroup: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgDataStatementGroup) << std::endl; 
     std::cout << "Memory pool size of SgDataStatementObject: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgDataStatementObject) << std::endl; 
     std::cout << "Memory pool size of SgDataStatementValue: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgDataStatementValue) << std::endl; 
     std::cout << "Memory pool size of SgDeadIfDirectiveStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgDeadIfDirectiveStatement) << std::endl; 
     std::cout << "Memory pool size of SgDeallocateStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgDeallocateStatement) << std::endl; 
     std::cout << "Memory pool size of SgDeclarationModifier: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgDeclarationModifier) << std::endl; 
     std::cout << "Memory pool size of SgDeclarationStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgDeclarationStatement) << std::endl; 
     std::cout << "Memory pool size of SgDefaultOptionStmt: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgDefaultOptionStmt) << std::endl; 
     std::cout << "Memory pool size of SgDefaultSymbol: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgDefaultSymbol) << std::endl; 
     std::cout << "Memory pool size of SgDefineDirectiveStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgDefineDirectiveStatement) << std::endl; 
     std::cout << "Memory pool size of SgDeleteExp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgDeleteExp) << std::endl; 
     std::cout << "Memory pool size of SgDerivedTypeStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgDerivedTypeStatement) << std::endl; 
     std::cout << "Memory pool size of SgDesignatedInitializer: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgDesignatedInitializer) << std::endl; 
     std::cout << "Memory pool size of SgDictionaryComprehension: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgDictionaryComprehension) << std::endl; 
     std::cout << "Memory pool size of SgDictionaryExp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgDictionaryExp) << std::endl; 
     std::cout << "Memory pool size of SgDimensionObject: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgDimensionObject) << std::endl; 
     std::cout << "Memory pool size of SgDirectedGraphEdge: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgDirectedGraphEdge) << std::endl; 
     std::cout << "Memory pool size of SgDirectory: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgDirectory) << std::endl; 
     std::cout << "Memory pool size of SgDirectoryList: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgDirectoryList) << std::endl; 
     std::cout << "Memory pool size of SgDivAssignOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgDivAssignOp) << std::endl; 
     std::cout << "Memory pool size of SgDivideOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgDivideOp) << std::endl; 
     std::cout << "Memory pool size of SgDoWhileStmt: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgDoWhileStmt) << std::endl; 
     std::cout << "Memory pool size of SgDotExp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgDotExp) << std::endl; 
     std::cout << "Memory pool size of SgDotStarOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgDotStarOp) << std::endl; 
     std::cout << "Memory pool size of SgDoubleVal: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgDoubleVal) << std::endl; 
     std::cout << "Memory pool size of SgElaboratedTypeModifier: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgElaboratedTypeModifier) << std::endl; 
     std::cout << "Memory pool size of SgElseDirectiveStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgElseDirectiveStatement) << std::endl; 
     std::cout << "Memory pool size of SgElseWhereStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgElseWhereStatement) << std::endl; 
     std::cout << "Memory pool size of SgElseifDirectiveStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgElseifDirectiveStatement) << std::endl; 
     std::cout << "Memory pool size of SgEmptyDirectiveStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgEmptyDirectiveStatement) << std::endl; 
     std::cout << "Memory pool size of SgEndfileStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgEndfileStatement) << std::endl; 
     std::cout << "Memory pool size of SgEndifDirectiveStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgEndifDirectiveStatement) << std::endl; 
     std::cout << "Memory pool size of SgEntryStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgEntryStatement) << std::endl; 
     std::cout << "Memory pool size of SgEnumDeclaration: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgEnumDeclaration) << std::endl; 
     std::cout << "Memory pool size of SgEnumFieldSymbol: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgEnumFieldSymbol) << std::endl; 
     std::cout << "Memory pool size of SgEnumSymbol: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgEnumSymbol) << std::endl; 
     std::cout << "Memory pool size of SgEnumType: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgEnumType) << std::endl; 
     std::cout << "Memory pool size of SgEnumVal: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgEnumVal) << std::endl; 
     std::cout << "Memory pool size of SgEqualityOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgEqualityOp) << std::endl; 
     std::cout << "Memory pool size of SgEquivalenceStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgEquivalenceStatement) << std::endl; 
     std::cout << "Memory pool size of SgErrorDirectiveStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgErrorDirectiveStatement) << std::endl; 
     std::cout << "Memory pool size of SgExecStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgExecStatement) << std::endl; 
     std::cout << "Memory pool size of SgExponentiationOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgExponentiationOp) << std::endl; 
     std::cout << "Memory pool size of SgExponentiationAssignOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgExponentiationAssignOp) << std::endl; 
     std::cout << "Memory pool size of SgExprListExp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgExprListExp) << std::endl; 
     std::cout << "Memory pool size of SgExprStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgExprStatement) << std::endl; 
     std::cout << "Memory pool size of SgExpression: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgExpression) << std::endl; 
     std::cout << "Memory pool size of SgExpressionRoot: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgExpressionRoot) << std::endl; 
     std::cout << "Memory pool size of SgFile: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgFile) << std::endl; 
     std::cout << "Memory pool size of SgFileList: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgFileList) << std::endl; 
     std::cout << "Memory pool size of SgFloatVal: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgFloatVal) << std::endl; 
     std::cout << "Memory pool size of SgFlushStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgFlushStatement) << std::endl; 
     std::cout << "Memory pool size of SgForAllStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgForAllStatement) << std::endl; 
     std::cout << "Memory pool size of SgForInitStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgForInitStatement) << std::endl; 
     std::cout << "Memory pool size of SgForStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgForStatement) << std::endl; 
     std::cout << "Memory pool size of SgFormatItem: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgFormatItem) << std::endl; 
     std::cout << "Memory pool size of SgFormatItemList: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgFormatItemList) << std::endl; 
     std::cout << "Memory pool size of SgFormatStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgFormatStatement) << std::endl; 
     std::cout << "Memory pool size of SgFortranDo: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgFortranDo) << std::endl; 
     std::cout << "Memory pool size of SgFortranIncludeLine: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgFortranIncludeLine) << std::endl; 
     std::cout << "Memory pool size of SgFortranNonblockedDo: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgFortranNonblockedDo) << std::endl; 
     std::cout << "Memory pool size of SgFuncDecl_attr: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgFuncDecl_attr) << std::endl; 
     std::cout << "Memory pool size of SgFunctionCallExp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgFunctionCallExp) << std::endl; 
     std::cout << "Memory pool size of SgFunctionDeclaration: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgFunctionDeclaration) << std::endl; 
     std::cout << "Memory pool size of SgFunctionDefinition: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgFunctionDefinition) << std::endl; 
     std::cout << "Memory pool size of SgFunctionModifier: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgFunctionModifier) << std::endl; 
     std::cout << "Memory pool size of SgFunctionParameterList: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgFunctionParameterList) << std::endl; 
     std::cout << "Memory pool size of SgFunctionParameterTypeList: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgFunctionParameterTypeList) << std::endl; 
     std::cout << "Memory pool size of SgFunctionRefExp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgFunctionRefExp) << std::endl; 
     std::cout << "Memory pool size of SgFunctionSymbol: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgFunctionSymbol) << std::endl; 
     std::cout << "Memory pool size of SgFunctionType: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgFunctionType) << std::endl; 
     std::cout << "Memory pool size of SgFunctionTypeSymbol: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgFunctionTypeSymbol) << std::endl; 
     std::cout << "Memory pool size of SgFunctionTypeTable: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgFunctionTypeTable) << std::endl; 
     std::cout << "Memory pool size of SgTypeTable: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgTypeTable) << std::endl; 
     std::cout << "Memory pool size of SgGlobal: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgGlobal) << std::endl; 
     std::cout << "Memory pool size of SgGotoStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgGotoStatement) << std::endl; 
     std::cout << "Memory pool size of SgGraph: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgGraph) << std::endl; 
     std::cout << "Memory pool size of SgGraphEdge: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgGraphEdge) << std::endl; 
     std::cout << "Memory pool size of SgGraphEdgeList: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgGraphEdgeList) << std::endl; 
     std::cout << "Memory pool size of SgGraphNode: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgGraphNode) << std::endl; 
     std::cout << "Memory pool size of SgGraphNodeList: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgGraphNodeList) << std::endl; 
     std::cout << "Memory pool size of SgGreaterOrEqualOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgGreaterOrEqualOp) << std::endl; 
     std::cout << "Memory pool size of SgGreaterThanOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgGreaterThanOp) << std::endl; 
     std::cout << "Memory pool size of SgIOItemExpression: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgIOItemExpression) << std::endl; 
     std::cout << "Memory pool size of SgIOStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgIOStatement) << std::endl; 
     std::cout << "Memory pool size of SgIdentDirectiveStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgIdentDirectiveStatement) << std::endl; 
     std::cout << "Memory pool size of SgIfDirectiveStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgIfDirectiveStatement) << std::endl; 
     std::cout << "Memory pool size of SgIfStmt: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgIfStmt) << std::endl; 
     std::cout << "Memory pool size of SgIfdefDirectiveStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgIfdefDirectiveStatement) << std::endl; 
     std::cout << "Memory pool size of SgIfndefDirectiveStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgIfndefDirectiveStatement) << std::endl; 
     std::cout << "Memory pool size of SgImagPartOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgImagPartOp) << std::endl; 
     std::cout << "Memory pool size of SgImplicitStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgImplicitStatement) << std::endl; 
     std::cout << "Memory pool size of SgImpliedDo: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgImpliedDo) << std::endl; 
     std::cout << "Memory pool size of SgImportStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgImportStatement) << std::endl; 
     std::cout << "Memory pool size of SgIncidenceDirectedGraph: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgIncidenceDirectedGraph) << std::endl; 
     std::cout << "Memory pool size of SgIncidenceUndirectedGraph: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgIncidenceUndirectedGraph) << std::endl; 
     std::cout << "Memory pool size of SgIncludeDirectiveStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgIncludeDirectiveStatement) << std::endl; 
     std::cout << "Memory pool size of SgIncludeNextDirectiveStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgIncludeNextDirectiveStatement) << std::endl; 
     std::cout << "Memory pool size of SgInitializedName: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgInitializedName) << std::endl; 
     std::cout << "Memory pool size of SgInitializer: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgInitializer) << std::endl; 
     std::cout << "Memory pool size of SgInquireStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgInquireStatement) << std::endl; 
     std::cout << "Memory pool size of SgIntKeyedBidirectionalGraph: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgIntKeyedBidirectionalGraph) << std::endl; 
     std::cout << "Memory pool size of SgIntVal: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgIntVal) << std::endl; 
     std::cout << "Memory pool size of SgIntegerDivideOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgIntegerDivideOp) << std::endl; 
     std::cout << "Memory pool size of SgIntegerDivideAssignOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgIntegerDivideAssignOp) << std::endl; 
     std::cout << "Memory pool size of SgInterfaceBody: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgInterfaceBody) << std::endl; 
     std::cout << "Memory pool size of SgHeaderFileBody: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgHeaderFileBody) << std::endl; 
     std::cout << "Memory pool size of SgInterfaceStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgInterfaceStatement) << std::endl; 
     std::cout << "Memory pool size of SgInterfaceSymbol: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgInterfaceSymbol) << std::endl; 
     std::cout << "Memory pool size of SgIntrinsicSymbol: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgIntrinsicSymbol) << std::endl; 
     std::cout << "Memory pool size of SgIsOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgIsOp) << std::endl; 
     std::cout << "Memory pool size of SgIsNotOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgIsNotOp) << std::endl; 
     std::cout << "Memory pool size of SgIorAssignOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgIorAssignOp) << std::endl; 
     std::cout << "Memory pool size of SgKeyDatumPair: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgKeyDatumPair) << std::endl; 
     std::cout << "Memory pool size of SgCudaKernelExecConfig: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgCudaKernelExecConfig) << std::endl; 
     std::cout << "Memory pool size of SgCudaKernelCallExp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgCudaKernelCallExp) << std::endl; 
     std::cout << "Memory pool size of SgLabelRefExp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgLabelRefExp) << std::endl; 
     std::cout << "Memory pool size of SgLabelStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgLabelStatement) << std::endl; 
     std::cout << "Memory pool size of SgJavaLabelStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgJavaLabelStatement) << std::endl; 
     std::cout << "Memory pool size of SgLabelSymbol: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgLabelSymbol) << std::endl; 
     std::cout << "Memory pool size of SgJavaLabelSymbol: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgJavaLabelSymbol) << std::endl; 
     std::cout << "Memory pool size of SgLambdaRefExp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgLambdaRefExp) << std::endl; 
     std::cout << "Memory pool size of SgLessOrEqualOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgLessOrEqualOp) << std::endl; 
     std::cout << "Memory pool size of SgLessThanOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgLessThanOp) << std::endl; 
     std::cout << "Memory pool size of SgLineDirectiveStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgLineDirectiveStatement) << std::endl; 
     std::cout << "Memory pool size of SgLinemarkerDirectiveStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgLinemarkerDirectiveStatement) << std::endl; 
     std::cout << "Memory pool size of SgLinkageModifier: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgLinkageModifier) << std::endl; 
     std::cout << "Memory pool size of SgListComprehension: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgListComprehension) << std::endl; 
     std::cout << "Memory pool size of SgListExp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgListExp) << std::endl; 
     std::cout << "Memory pool size of SgLocatedNode: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgLocatedNode) << std::endl; 
     std::cout << "Memory pool size of SgLocatedNodeSupport: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgLocatedNodeSupport) << std::endl; 
     std::cout << "Memory pool size of SgLongDoubleVal: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgLongDoubleVal) << std::endl; 
     std::cout << "Memory pool size of SgLongIntVal: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgLongIntVal) << std::endl; 
     std::cout << "Memory pool size of SgLongLongIntVal: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgLongLongIntVal) << std::endl; 
     std::cout << "Memory pool size of SgLshiftAssignOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgLshiftAssignOp) << std::endl; 
     std::cout << "Memory pool size of SgLshiftOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgLshiftOp) << std::endl; 
     std::cout << "Memory pool size of SgMemberFunctionDeclaration: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgMemberFunctionDeclaration) << std::endl; 
     std::cout << "Memory pool size of SgMemberFunctionRefExp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgMemberFunctionRefExp) << std::endl; 
     std::cout << "Memory pool size of SgMemberFunctionSymbol: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgMemberFunctionSymbol) << std::endl; 
     std::cout << "Memory pool size of SgMemberFunctionType: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgMemberFunctionType) << std::endl; 
     std::cout << "Memory pool size of SgMembershipOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgMembershipOp) << std::endl; 
     std::cout << "Memory pool size of SgMinusAssignOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgMinusAssignOp) << std::endl; 
     std::cout << "Memory pool size of SgMinusMinusOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgMinusMinusOp) << std::endl; 
     std::cout << "Memory pool size of SgMinusOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgMinusOp) << std::endl; 
     std::cout << "Memory pool size of SgModAssignOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgModAssignOp) << std::endl; 
     std::cout << "Memory pool size of SgModOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgModOp) << std::endl; 
     std::cout << "Memory pool size of SgModifier: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgModifier) << std::endl; 
     std::cout << "Memory pool size of SgModifierNodes: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgModifierNodes) << std::endl; 
     std::cout << "Memory pool size of SgModifierType: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgModifierType) << std::endl; 
     std::cout << "Memory pool size of SgModuleStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgModuleStatement) << std::endl; 
     std::cout << "Memory pool size of SgModuleSymbol: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgModuleSymbol) << std::endl; 
     std::cout << "Memory pool size of SgMultAssignOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgMultAssignOp) << std::endl; 
     std::cout << "Memory pool size of SgMultiplyOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgMultiplyOp) << std::endl; 
     std::cout << "Memory pool size of SgName: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgName) << std::endl; 
     std::cout << "Memory pool size of SgNameGroup: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgNameGroup) << std::endl; 
     std::cout << "Memory pool size of SgNamedType: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgNamedType) << std::endl; 
     std::cout << "Memory pool size of SgNamelistStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgNamelistStatement) << std::endl; 
     std::cout << "Memory pool size of SgNamespaceAliasDeclarationStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgNamespaceAliasDeclarationStatement) << std::endl; 
     std::cout << "Memory pool size of SgNamespaceDeclarationStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgNamespaceDeclarationStatement) << std::endl; 
     std::cout << "Memory pool size of SgNamespaceDefinitionStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgNamespaceDefinitionStatement) << std::endl; 
     std::cout << "Memory pool size of SgNamespaceSymbol: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgNamespaceSymbol) << std::endl; 
     std::cout << "Memory pool size of SgNaryOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgNaryOp) << std::endl; 
     std::cout << "Memory pool size of SgNaryBooleanOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgNaryBooleanOp) << std::endl; 
     std::cout << "Memory pool size of SgNaryComparisonOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgNaryComparisonOp) << std::endl; 
     std::cout << "Memory pool size of SgNewExp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgNewExp) << std::endl; 
     std::cout << "Memory pool size of SgNode: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgNode) << std::endl; 
     std::cout << "Memory pool size of SgNotEqualOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgNotEqualOp) << std::endl; 
     std::cout << "Memory pool size of SgNotOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgNotOp) << std::endl; 
     std::cout << "Memory pool size of SgNonMembershipOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgNonMembershipOp) << std::endl; 
     std::cout << "Memory pool size of SgNullExpression: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgNullExpression) << std::endl; 
     std::cout << "Memory pool size of SgNullStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgNullStatement) << std::endl; 
     std::cout << "Memory pool size of SgNullifyStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgNullifyStatement) << std::endl; 
     std::cout << "Memory pool size of SgOmpAtomicStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgOmpAtomicStatement) << std::endl; 
     std::cout << "Memory pool size of SgOmpBarrierStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgOmpBarrierStatement) << std::endl; 
     std::cout << "Memory pool size of SgOmpCriticalStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgOmpCriticalStatement) << std::endl; 
     std::cout << "Memory pool size of SgOmpClauseBodyStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgOmpClauseBodyStatement) << std::endl; 
     std::cout << "Memory pool size of SgOmpBodyStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgOmpBodyStatement) << std::endl; 
     std::cout << "Memory pool size of SgOmpDoStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgOmpDoStatement) << std::endl; 
     std::cout << "Memory pool size of SgOmpFlushStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgOmpFlushStatement) << std::endl; 
     std::cout << "Memory pool size of SgOmpForStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgOmpForStatement) << std::endl; 
     std::cout << "Memory pool size of SgOmpMasterStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgOmpMasterStatement) << std::endl; 
     std::cout << "Memory pool size of SgOmpOrderedStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgOmpOrderedStatement) << std::endl; 
     std::cout << "Memory pool size of SgOmpParallelStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgOmpParallelStatement) << std::endl; 
     std::cout << "Memory pool size of SgOmpSectionStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgOmpSectionStatement) << std::endl; 
     std::cout << "Memory pool size of SgOmpSectionsStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgOmpSectionsStatement) << std::endl; 
     std::cout << "Memory pool size of SgOmpSingleStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgOmpSingleStatement) << std::endl; 
     std::cout << "Memory pool size of SgOmpTaskStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgOmpTaskStatement) << std::endl; 
     std::cout << "Memory pool size of SgOmpTaskwaitStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgOmpTaskwaitStatement) << std::endl; 
     std::cout << "Memory pool size of SgOmpThreadprivateStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgOmpThreadprivateStatement) << std::endl; 
     std::cout << "Memory pool size of SgOmpWorkshareStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgOmpWorkshareStatement) << std::endl; 
     std::cout << "Memory pool size of SgOmpClause: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgOmpClause) << std::endl; 
     std::cout << "Memory pool size of SgOmpCollapseClause: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgOmpCollapseClause) << std::endl; 
     std::cout << "Memory pool size of SgOmpCopyinClause: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgOmpCopyinClause) << std::endl; 
     std::cout << "Memory pool size of SgOmpCopyprivateClause: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgOmpCopyprivateClause) << std::endl; 
     std::cout << "Memory pool size of SgOmpDefaultClause: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgOmpDefaultClause) << std::endl; 
     std::cout << "Memory pool size of SgOmpExpressionClause: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgOmpExpressionClause) << std::endl; 
     std::cout << "Memory pool size of SgOmpFirstprivateClause: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgOmpFirstprivateClause) << std::endl; 
     std::cout << "Memory pool size of SgOmpIfClause: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgOmpIfClause) << std::endl; 
     std::cout << "Memory pool size of SgOmpLastprivateClause: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgOmpLastprivateClause) << std::endl; 
     std::cout << "Memory pool size of SgOmpNowaitClause: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgOmpNowaitClause) << std::endl; 
     std::cout << "Memory pool size of SgOmpNumThreadsClause: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgOmpNumThreadsClause) << std::endl; 
     std::cout << "Memory pool size of SgOmpOrderedClause: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgOmpOrderedClause) << std::endl; 
     std::cout << "Memory pool size of SgOmpPrivateClause: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgOmpPrivateClause) << std::endl; 
     std::cout << "Memory pool size of SgOmpReductionClause: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgOmpReductionClause) << std::endl; 
     std::cout << "Memory pool size of SgOmpScheduleClause: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgOmpScheduleClause) << std::endl; 
     std::cout << "Memory pool size of SgOmpSharedClause: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgOmpSharedClause) << std::endl; 
     std::cout << "Memory pool size of SgOmpUntiedClause: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgOmpUntiedClause) << std::endl; 
     std::cout << "Memory pool size of SgOmpVariablesClause: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgOmpVariablesClause) << std::endl; 
     std::cout << "Memory pool size of SgOpenclAccessModeModifier: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgOpenclAccessModeModifier) << std::endl; 
     std::cout << "Memory pool size of SgOpenStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgOpenStatement) << std::endl; 
     std::cout << "Memory pool size of SgOptions: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgOptions) << std::endl; 
     std::cout << "Memory pool size of SgOrOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgOrOp) << std::endl; 
     std::cout << "Memory pool size of SgParameterStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgParameterStatement) << std::endl; 
     std::cout << "Memory pool size of SgPartialFunctionModifierType: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgPartialFunctionModifierType) << std::endl; 
     std::cout << "Memory pool size of SgPartialFunctionType: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgPartialFunctionType) << std::endl; 
     std::cout << "Memory pool size of SgPassStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgPassStatement) << std::endl; 
     std::cout << "Memory pool size of SgPlusAssignOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgPlusAssignOp) << std::endl; 
     std::cout << "Memory pool size of SgPlusPlusOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgPlusPlusOp) << std::endl; 
     std::cout << "Memory pool size of SgPntrArrRefExp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgPntrArrRefExp) << std::endl; 
     std::cout << "Memory pool size of SgPointerAssignOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgPointerAssignOp) << std::endl; 
     std::cout << "Memory pool size of SgPointerDerefExp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgPointerDerefExp) << std::endl; 
     std::cout << "Memory pool size of SgPointerMemberType: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgPointerMemberType) << std::endl; 
     std::cout << "Memory pool size of SgPointerType: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgPointerType) << std::endl; 
     std::cout << "Memory pool size of SgPragma: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgPragma) << std::endl; 
     std::cout << "Memory pool size of SgPragmaDeclaration: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgPragmaDeclaration) << std::endl; 
     std::cout << "Memory pool size of SgPrintStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgPrintStatement) << std::endl; 
     std::cout << "Memory pool size of SgProcedureHeaderStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgProcedureHeaderStatement) << std::endl; 
     std::cout << "Memory pool size of SgProgramHeaderStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgProgramHeaderStatement) << std::endl; 
     std::cout << "Memory pool size of SgProject: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgProject) << std::endl; 
     std::cout << "Memory pool size of SgPseudoDestructorRefExp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgPseudoDestructorRefExp) << std::endl; 
     std::cout << "Memory pool size of SgPythonGlobalStmt: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgPythonGlobalStmt) << std::endl; 
     std::cout << "Memory pool size of SgPythonPrintStmt: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgPythonPrintStmt) << std::endl; 
     std::cout << "Memory pool size of SgQualifiedName: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgQualifiedName) << std::endl; 
     std::cout << "Memory pool size of SgQualifiedNameType: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgQualifiedNameType) << std::endl; 
     std::cout << "Memory pool size of SgReadStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgReadStatement) << std::endl; 
     std::cout << "Memory pool size of SgRealPartOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgRealPartOp) << std::endl; 
     std::cout << "Memory pool size of SgRefExp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgRefExp) << std::endl; 
     std::cout << "Memory pool size of SgReferenceType: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgReferenceType) << std::endl; 
     std::cout << "Memory pool size of SgRenamePair: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgRenamePair) << std::endl; 
     std::cout << "Memory pool size of SgRenameSymbol: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgRenameSymbol) << std::endl; 
     std::cout << "Memory pool size of SgReturnStmt: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgReturnStmt) << std::endl; 
     std::cout << "Memory pool size of SgRewindStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgRewindStatement) << std::endl; 
     std::cout << "Memory pool size of SgRshiftAssignOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgRshiftAssignOp) << std::endl; 
     std::cout << "Memory pool size of SgRshiftOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgRshiftOp) << std::endl; 
     std::cout << "Memory pool size of SgJavaUnsignedRshiftAssignOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgJavaUnsignedRshiftAssignOp) << std::endl; 
     std::cout << "Memory pool size of SgJavaUnsignedRshiftOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgJavaUnsignedRshiftOp) << std::endl; 
     std::cout << "Memory pool size of SgScopeOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgScopeOp) << std::endl; 
     std::cout << "Memory pool size of SgScopeStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgScopeStatement) << std::endl; 
     std::cout << "Memory pool size of SgSequenceStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgSequenceStatement) << std::endl; 
     std::cout << "Memory pool size of SgSetComprehension: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgSetComprehension) << std::endl; 
     std::cout << "Memory pool size of SgShortVal: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgShortVal) << std::endl; 
     std::cout << "Memory pool size of SgSizeOfOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgSizeOfOp) << std::endl; 
     std::cout << "Memory pool size of SgJavaInstanceOfOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgJavaInstanceOfOp) << std::endl; 
     std::cout << "Memory pool size of SgSourceFile: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgSourceFile) << std::endl; 
     std::cout << "Memory pool size of SgSpawnStmt: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgSpawnStmt) << std::endl; 
     std::cout << "Memory pool size of SgJavaThrowStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgJavaThrowStatement) << std::endl; 
     std::cout << "Memory pool size of SgJavaForEachStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgJavaForEachStatement) << std::endl; 
     std::cout << "Memory pool size of SgJavaSynchronizedStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgJavaSynchronizedStatement) << std::endl; 
     std::cout << "Memory pool size of SgJavaParameterizedType: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgJavaParameterizedType) << std::endl; 
     std::cout << "Memory pool size of SgSpecialFunctionModifier: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgSpecialFunctionModifier) << std::endl; 
     std::cout << "Memory pool size of SgStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgStatement) << std::endl; 
     std::cout << "Memory pool size of SgStmtDeclarationStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgStmtDeclarationStatement) << std::endl; 
     std::cout << "Memory pool size of SgStatementExpression: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgStatementExpression) << std::endl; 
     std::cout << "Memory pool size of SgStatementFunctionStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgStatementFunctionStatement) << std::endl; 
     std::cout << "Memory pool size of SgStopOrPauseStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgStopOrPauseStatement) << std::endl; 
     std::cout << "Memory pool size of SgStorageModifier: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgStorageModifier) << std::endl; 
     std::cout << "Memory pool size of SgStringConversion: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgStringConversion) << std::endl; 
     std::cout << "Memory pool size of SgStringKeyedBidirectionalGraph: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgStringKeyedBidirectionalGraph) << std::endl; 
     std::cout << "Memory pool size of SgStringVal: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgStringVal) << std::endl; 
     std::cout << "Memory pool size of SgSubscriptExpression: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgSubscriptExpression) << std::endl; 
     std::cout << "Memory pool size of SgSubtractOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgSubtractOp) << std::endl; 
     std::cout << "Memory pool size of SgSupport: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgSupport) << std::endl; 
     std::cout << "Memory pool size of SgSwitchStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgSwitchStatement) << std::endl; 
     std::cout << "Memory pool size of SgSymbol: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgSymbol) << std::endl; 
     std::cout << "Memory pool size of SgSymbolTable: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgSymbolTable) << std::endl; 
     std::cout << "Memory pool size of SgTemplateArgument: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgTemplateArgument) << std::endl; 
     std::cout << "Memory pool size of SgTemplateArgumentList: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgTemplateArgumentList) << std::endl; 
     std::cout << "Memory pool size of SgTemplateDeclaration: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgTemplateDeclaration) << std::endl; 
     std::cout << "Memory pool size of SgTemplateClassDeclaration: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgTemplateClassDeclaration) << std::endl; 
     std::cout << "Memory pool size of SgTemplateFunctionDeclaration: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgTemplateFunctionDeclaration) << std::endl; 
     std::cout << "Memory pool size of SgTemplateMemberFunctionDeclaration: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgTemplateMemberFunctionDeclaration) << std::endl; 
     std::cout << "Memory pool size of SgTemplateClassDefinition: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgTemplateClassDefinition) << std::endl; 
     std::cout << "Memory pool size of SgTemplateFunctionDefinition: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgTemplateFunctionDefinition) << std::endl; 
     std::cout << "Memory pool size of SgTemplateInstantiationDecl: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgTemplateInstantiationDecl) << std::endl; 
     std::cout << "Memory pool size of SgTemplateInstantiationDefn: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgTemplateInstantiationDefn) << std::endl; 
     std::cout << "Memory pool size of SgTemplateInstantiationDirectiveStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgTemplateInstantiationDirectiveStatement) << std::endl; 
     std::cout << "Memory pool size of SgTemplateInstantiationFunctionDecl: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgTemplateInstantiationFunctionDecl) << std::endl; 
     std::cout << "Memory pool size of SgTemplateInstantiationMemberFunctionDecl: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgTemplateInstantiationMemberFunctionDecl) << std::endl; 
     std::cout << "Memory pool size of SgTemplateParameter: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgTemplateParameter) << std::endl; 
     std::cout << "Memory pool size of SgTemplateParameterList: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgTemplateParameterList) << std::endl; 
     std::cout << "Memory pool size of SgTemplateSymbol: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgTemplateSymbol) << std::endl; 
     std::cout << "Memory pool size of SgTemplateType: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgTemplateType) << std::endl; 
     std::cout << "Memory pool size of SgThisExp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgThisExp) << std::endl; 
     std::cout << "Memory pool size of SgSuperExp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgSuperExp) << std::endl; 
     std::cout << "Memory pool size of SgThrowOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgThrowOp) << std::endl; 
     std::cout << "Memory pool size of SgToken: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgToken) << std::endl; 
     std::cout << "Memory pool size of SgTryStmt: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgTryStmt) << std::endl; 
     std::cout << "Memory pool size of SgTupleExp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgTupleExp) << std::endl; 
     std::cout << "Memory pool size of SgType: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgType) << std::endl; 
     std::cout << "Memory pool size of SgTypeBool: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgTypeBool) << std::endl; 
     std::cout << "Memory pool size of SgTypeChar: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgTypeChar) << std::endl; 
     std::cout << "Memory pool size of SgTypeComplex: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgTypeComplex) << std::endl; 
     std::cout << "Memory pool size of SgTypeDefault: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgTypeDefault) << std::endl; 
     std::cout << "Memory pool size of SgTypeLabel: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgTypeLabel) << std::endl; 
     std::cout << "Memory pool size of SgTypeDouble: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgTypeDouble) << std::endl; 
     std::cout << "Memory pool size of SgTypeEllipse: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgTypeEllipse) << std::endl; 
     std::cout << "Memory pool size of SgTypeFloat: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgTypeFloat) << std::endl; 
     std::cout << "Memory pool size of SgTypeGlobalVoid: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgTypeGlobalVoid) << std::endl; 
     std::cout << "Memory pool size of SgTypeIdOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgTypeIdOp) << std::endl; 
     std::cout << "Memory pool size of SgTypeImaginary: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgTypeImaginary) << std::endl; 
     std::cout << "Memory pool size of SgTypeInt: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgTypeInt) << std::endl; 
     std::cout << "Memory pool size of SgTypeLong: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgTypeLong) << std::endl; 
     std::cout << "Memory pool size of SgTypeLongDouble: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgTypeLongDouble) << std::endl; 
     std::cout << "Memory pool size of SgTypeLongLong: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgTypeLongLong) << std::endl; 
     std::cout << "Memory pool size of SgTypeModifier: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgTypeModifier) << std::endl; 
     std::cout << "Memory pool size of SgTypeShort: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgTypeShort) << std::endl; 
     std::cout << "Memory pool size of SgTypeSignedChar: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgTypeSignedChar) << std::endl; 
     std::cout << "Memory pool size of SgTypeSignedInt: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgTypeSignedInt) << std::endl; 
     std::cout << "Memory pool size of SgTypeSignedLong: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgTypeSignedLong) << std::endl; 
     std::cout << "Memory pool size of SgTypeSignedLongLong: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgTypeSignedLongLong) << std::endl; 
     std::cout << "Memory pool size of SgTypeSignedShort: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgTypeSignedShort) << std::endl; 
     std::cout << "Memory pool size of SgTypeString: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgTypeString) << std::endl; 
     std::cout << "Memory pool size of SgTypeUnknown: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgTypeUnknown) << std::endl; 
     std::cout << "Memory pool size of SgTypeUnsignedChar: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgTypeUnsignedChar) << std::endl; 
     std::cout << "Memory pool size of SgTypeUnsignedInt: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgTypeUnsignedInt) << std::endl; 
     std::cout << "Memory pool size of SgTypeUnsignedLong: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgTypeUnsignedLong) << std::endl; 
     std::cout << "Memory pool size of SgTypeUnsignedLongLong: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgTypeUnsignedLongLong) << std::endl; 
     std::cout << "Memory pool size of SgTypeUnsignedShort: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgTypeUnsignedShort) << std::endl; 
     std::cout << "Memory pool size of SgTypeVoid: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgTypeVoid) << std::endl; 
     std::cout << "Memory pool size of SgTypeWchar: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgTypeWchar) << std::endl; 
     std::cout << "Memory pool size of SgTypedefDeclaration: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgTypedefDeclaration) << std::endl; 
     std::cout << "Memory pool size of SgTypedefSeq: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgTypedefSeq) << std::endl; 
     std::cout << "Memory pool size of SgTypedefSymbol: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgTypedefSymbol) << std::endl; 
     std::cout << "Memory pool size of SgTypedefType: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgTypedefType) << std::endl; 
     std::cout << "Memory pool size of SgUPC_AccessModifier: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgUPC_AccessModifier) << std::endl; 
     std::cout << "Memory pool size of SgUnaryAddOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgUnaryAddOp) << std::endl; 
     std::cout << "Memory pool size of SgUnaryOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgUnaryOp) << std::endl; 
     std::cout << "Memory pool size of SgUndefDirectiveStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgUndefDirectiveStatement) << std::endl; 
     std::cout << "Memory pool size of SgUndirectedGraphEdge: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgUndirectedGraphEdge) << std::endl; 
     std::cout << "Memory pool size of SgUnknownArrayOrFunctionReference: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgUnknownArrayOrFunctionReference) << std::endl; 
     std::cout << "Memory pool size of SgUnknownFile: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgUnknownFile) << std::endl; 
     std::cout << "Memory pool size of SgUnparse_Info: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgUnparse_Info) << std::endl; 
     std::cout << "Memory pool size of SgUnsignedCharVal: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgUnsignedCharVal) << std::endl; 
     std::cout << "Memory pool size of SgUnsignedIntVal: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgUnsignedIntVal) << std::endl; 
     std::cout << "Memory pool size of SgUnsignedLongLongIntVal: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgUnsignedLongLongIntVal) << std::endl; 
     std::cout << "Memory pool size of SgUnsignedLongVal: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgUnsignedLongVal) << std::endl; 
     std::cout << "Memory pool size of SgUnsignedShortVal: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgUnsignedShortVal) << std::endl; 
     std::cout << "Memory pool size of SgUpcBarrierStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgUpcBarrierStatement) << std::endl; 
     std::cout << "Memory pool size of SgUpcBlocksizeofExpression: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgUpcBlocksizeofExpression) << std::endl; 
     std::cout << "Memory pool size of SgUpcElemsizeofExpression: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgUpcElemsizeofExpression) << std::endl; 
     std::cout << "Memory pool size of SgUpcFenceStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgUpcFenceStatement) << std::endl; 
     std::cout << "Memory pool size of SgUpcForAllStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgUpcForAllStatement) << std::endl; 
     std::cout << "Memory pool size of SgUpcLocalsizeofExpression: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgUpcLocalsizeofExpression) << std::endl; 
     std::cout << "Memory pool size of SgUpcMythread: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgUpcMythread) << std::endl; 
     std::cout << "Memory pool size of SgUpcNotifyStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgUpcNotifyStatement) << std::endl; 
     std::cout << "Memory pool size of SgUpcThreads: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgUpcThreads) << std::endl; 
     std::cout << "Memory pool size of SgUpcWaitStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgUpcWaitStatement) << std::endl; 
     std::cout << "Memory pool size of SgUseStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgUseStatement) << std::endl; 
     std::cout << "Memory pool size of SgUserDefinedBinaryOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgUserDefinedBinaryOp) << std::endl; 
     std::cout << "Memory pool size of SgUserDefinedUnaryOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgUserDefinedUnaryOp) << std::endl; 
     std::cout << "Memory pool size of SgUsingDeclarationStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgUsingDeclarationStatement) << std::endl; 
     std::cout << "Memory pool size of SgUsingDirectiveStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgUsingDirectiveStatement) << std::endl; 
     std::cout << "Memory pool size of SgValueExp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgValueExp) << std::endl; 
     std::cout << "Memory pool size of SgVarArgCopyOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgVarArgCopyOp) << std::endl; 
     std::cout << "Memory pool size of SgVarArgEndOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgVarArgEndOp) << std::endl; 
     std::cout << "Memory pool size of SgVarArgOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgVarArgOp) << std::endl; 
     std::cout << "Memory pool size of SgVarArgStartOneOperandOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgVarArgStartOneOperandOp) << std::endl; 
     std::cout << "Memory pool size of SgVarArgStartOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgVarArgStartOp) << std::endl; 
     std::cout << "Memory pool size of SgVarRefExp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgVarRefExp) << std::endl; 
     std::cout << "Memory pool size of SgVariableDeclaration: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgVariableDeclaration) << std::endl; 
     std::cout << "Memory pool size of SgVariableDefinition: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgVariableDefinition) << std::endl; 
     std::cout << "Memory pool size of SgVariableSymbol: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgVariableSymbol) << std::endl; 
     std::cout << "Memory pool size of SgVariantExpression: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgVariantExpression) << std::endl; 
     std::cout << "Memory pool size of SgVariantStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgVariantStatement) << std::endl; 
     std::cout << "Memory pool size of SgWaitStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgWaitStatement) << std::endl; 
     std::cout << "Memory pool size of SgWarningDirectiveStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgWarningDirectiveStatement) << std::endl; 
     std::cout << "Memory pool size of SgWithStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgWithStatement) << std::endl; 
     std::cout << "Memory pool size of SgWcharVal: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgWcharVal) << std::endl; 
     std::cout << "Memory pool size of SgWhereStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgWhereStatement) << std::endl; 
     std::cout << "Memory pool size of SgWhileStmt: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgWhileStmt) << std::endl; 
     std::cout << "Memory pool size of SgWriteStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgWriteStatement) << std::endl; 
     std::cout << "Memory pool size of SgXorAssignOp: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgXorAssignOp) << std::endl; 
     std::cout << "Memory pool size of SgYieldExpression: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgYieldExpression) << std::endl; 
     std::cout << "Memory pool size of Sg_File_Info: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_Sg_File_Info) << std::endl; 
     std::cout << "Memory pool size of SgTypeCAFTeam: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgTypeCAFTeam) << std::endl; 
     std::cout << "Memory pool size of SgCAFWithTeamStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgCAFWithTeamStatement) << std::endl; 
     std::cout << "Memory pool size of SgCAFCoExpression: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgCAFCoExpression) << std::endl; 
     std::cout << "Memory pool size of SgCallExpression: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgCallExpression) << std::endl; 
     std::cout << "Memory pool size of SgTypeCrayPointer: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgTypeCrayPointer) << std::endl; 
     std::cout << "Memory pool size of SgJavaImportStatement: " <<  vectorOfASTs[index]->getMemoryPoolSize(V_SgJavaImportStatement) << std::endl; 

/* #line 550 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarAST_FileIoSource.code" */
     std::cout << " Total number of IR nodes in contained in the memory pools: "  
               << vectorOfASTs[index]->getTotalNumberOfASTIRNodes() << std::endl << std::endl;
     return;
   }


AstData* 
AST_FILE_IO::getAst (int index)
   {
     assert( index <= (int)vectorOfASTs.size() );
     return vectorOfASTs[index];
   }


AstData* 
AST_FILE_IO::getAstWithRoot (SgProject* root)
   {
     std::vector<AstSpecificDataManagingClass*>:: iterator astIter = vectorOfASTs.begin();
     while ( astIter != vectorOfASTs.end() && (*astIter)->getRootOfAst() != root )
        {
          astIter++;
        }
     assert( astIter!= vectorOfASTs.end() );
     return *astIter;
   }


/* JW (06/21/2006) Refactored this to have a write-to-stream function so
 * stringstreams can be used */
void
AST_FILE_IO :: writeASTToStream ( std::ostream& out) {
  // DQ (4/22/2006): Added timer information for AST File I/O
     TimingPerformance timer ("AST_FILE_IO::writeASTToFile():");
 
     assert ( freepointersOfCurrentAstAreSetToGlobalIndices == true );
     assert ( 0 < getTotalNumberOfNodesOfAstInMemoryPool() );
     std::string startString = "ROSE_AST_BINARY_START";
     out.write ( startString.c_str(), startString.size() );

  // 1. Write the accumulatedPoolSizesOfAstInMemoryPool 
     AstDataStorageClass staticTemp;
     staticTemp.pickOutIRNodeData(actualRebuildAst);
     
     {
  // DQ (4/22/2006): Added timer information for AST File I/O
     TimingPerformance timer ("AST_FILE_IO::writeASTToFile() raw file write part 1 (memory pool data):"); 
     out.write ( (char*)(&staticTemp) , sizeof(AstDataStorageClass) );
     }
     {
  // DQ (4/22/2006): Added timer information for AST File I/O
     TimingPerformance timer ("AST_FILE_IO::writeASTToFile() raw file write part 2 (easy storage data):");
     AstDataStorageClass::writeEasyStorageDataToFile(out);
     }
     
  // 1.a Introducing a marker to check the right position in the file     

     std::string markString = "#########";
     out.write ( markString.c_str(), markString.size() );

  // 2. Initialize the StorageClass and write

     int sizeOfActualPool = 0;
     long storageClassIndex = 0 ;

     {
  // DQ (4/22/2006): Added timer information for AST File I/O
     TimingPerformance timer ("AST_FILE_IO::writeASTToFile() raw file write part 3 (rest of AST data):");

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAccessModifier ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAccessModifierStorageClass* storageArray = new SgAccessModifierStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAccessModifier_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAccessModifierStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgActualArgumentExpression ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgActualArgumentExpressionStorageClass* storageArray = new SgActualArgumentExpressionStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgActualArgumentExpression_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgActualArgumentExpressionStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgActualArgumentExpressionStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAddOp ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAddOpStorageClass* storageArray = new SgAddOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAddOp_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAddOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAddOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAddressOfOp ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAddressOfOpStorageClass* storageArray = new SgAddressOfOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAddressOfOp_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAddressOfOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAddressOfOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAggregateInitializer ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAggregateInitializerStorageClass* storageArray = new SgAggregateInitializerStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAggregateInitializer_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAggregateInitializerStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAggregateInitializerStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAliasSymbol ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAliasSymbolStorageClass* storageArray = new SgAliasSymbolStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAliasSymbol_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAliasSymbolStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAliasSymbolStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAllocateStatement ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAllocateStatementStorageClass* storageArray = new SgAllocateStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAllocateStatement_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAllocateStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAllocateStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAndAssignOp ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAndAssignOpStorageClass* storageArray = new SgAndAssignOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAndAssignOp_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAndAssignOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAndAssignOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAndOp ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAndOpStorageClass* storageArray = new SgAndOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAndOp_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAndOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAndOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgArithmeticIfStatement ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgArithmeticIfStatementStorageClass* storageArray = new SgArithmeticIfStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgArithmeticIfStatement_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgArithmeticIfStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgArithmeticIfStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgArrayType ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgArrayTypeStorageClass* storageArray = new SgArrayTypeStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgArrayType_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgArrayTypeStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgArrayTypeStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgArrowExp ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgArrowExpStorageClass* storageArray = new SgArrowExpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgArrowExp_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgArrowExpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgArrowExpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgArrowStarOp ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgArrowStarOpStorageClass* storageArray = new SgArrowStarOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgArrowStarOp_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgArrowStarOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgArrowStarOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmArmInstruction ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmArmInstructionStorageClass* storageArray = new SgAsmArmInstructionStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmArmInstruction_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmArmInstructionStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmArmInstructionStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmArmRegisterReferenceExpression ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmArmRegisterReferenceExpressionStorageClass* storageArray = new SgAsmArmRegisterReferenceExpressionStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmArmRegisterReferenceExpression_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmArmRegisterReferenceExpressionStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmArmRegisterReferenceExpressionStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmBasicString ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmBasicStringStorageClass* storageArray = new SgAsmBasicStringStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmBasicString_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmBasicStringStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmBasicStringStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmBinaryAdd ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmBinaryAddStorageClass* storageArray = new SgAsmBinaryAddStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmBinaryAdd_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmBinaryAddStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmBinaryAddStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmBinaryAddPostupdate ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmBinaryAddPostupdateStorageClass* storageArray = new SgAsmBinaryAddPostupdateStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmBinaryAddPostupdate_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmBinaryAddPostupdateStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmBinaryAddPostupdateStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmBinaryAddPreupdate ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmBinaryAddPreupdateStorageClass* storageArray = new SgAsmBinaryAddPreupdateStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmBinaryAddPreupdate_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmBinaryAddPreupdateStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmBinaryAddPreupdateStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmBinaryAsr ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmBinaryAsrStorageClass* storageArray = new SgAsmBinaryAsrStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmBinaryAsr_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmBinaryAsrStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmBinaryAsrStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmBinaryDivide ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmBinaryDivideStorageClass* storageArray = new SgAsmBinaryDivideStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmBinaryDivide_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmBinaryDivideStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmBinaryDivideStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmBinaryExpression ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmBinaryExpressionStorageClass* storageArray = new SgAsmBinaryExpressionStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmBinaryExpression_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmBinaryExpressionStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmBinaryExpressionStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmBinaryLsl ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmBinaryLslStorageClass* storageArray = new SgAsmBinaryLslStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmBinaryLsl_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmBinaryLslStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmBinaryLslStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmBinaryLsr ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmBinaryLsrStorageClass* storageArray = new SgAsmBinaryLsrStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmBinaryLsr_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmBinaryLsrStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmBinaryLsrStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmBinaryMod ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmBinaryModStorageClass* storageArray = new SgAsmBinaryModStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmBinaryMod_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmBinaryModStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmBinaryModStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmBinaryMultiply ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmBinaryMultiplyStorageClass* storageArray = new SgAsmBinaryMultiplyStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmBinaryMultiply_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmBinaryMultiplyStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmBinaryMultiplyStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmBinaryRor ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmBinaryRorStorageClass* storageArray = new SgAsmBinaryRorStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmBinaryRor_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmBinaryRorStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmBinaryRorStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmBinarySubtract ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmBinarySubtractStorageClass* storageArray = new SgAsmBinarySubtractStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmBinarySubtract_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmBinarySubtractStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmBinarySubtractStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmBinarySubtractPostupdate ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmBinarySubtractPostupdateStorageClass* storageArray = new SgAsmBinarySubtractPostupdateStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmBinarySubtractPostupdate_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmBinarySubtractPostupdateStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmBinarySubtractPostupdateStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmBinarySubtractPreupdate ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmBinarySubtractPreupdateStorageClass* storageArray = new SgAsmBinarySubtractPreupdateStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmBinarySubtractPreupdate_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmBinarySubtractPreupdateStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmBinarySubtractPreupdateStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmBlock ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmBlockStorageClass* storageArray = new SgAsmBlockStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmBlock_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmBlockStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmBlockStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmByteValueExpression ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmByteValueExpressionStorageClass* storageArray = new SgAsmByteValueExpressionStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmByteValueExpression_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmByteValueExpressionStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmByteValueExpressionStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmCoffStrtab ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCoffStrtabStorageClass* storageArray = new SgAsmCoffStrtabStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmCoffStrtab_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmCoffStrtabStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmCoffStrtabStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmCoffSymbol ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCoffSymbolStorageClass* storageArray = new SgAsmCoffSymbolStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmCoffSymbol_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmCoffSymbolStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmCoffSymbolStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmCoffSymbolList ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCoffSymbolListStorageClass* storageArray = new SgAsmCoffSymbolListStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmCoffSymbolList_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmCoffSymbolListStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmCoffSymbolListStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmCoffSymbolTable ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCoffSymbolTableStorageClass* storageArray = new SgAsmCoffSymbolTableStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmCoffSymbolTable_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmCoffSymbolTableStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmCoffSymbolTableStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmCommonSubExpression ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmCommonSubExpressionStorageClass* storageArray = new SgAsmCommonSubExpressionStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmCommonSubExpression_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmCommonSubExpressionStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmCommonSubExpressionStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmControlFlagsExpression ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmControlFlagsExpressionStorageClass* storageArray = new SgAsmControlFlagsExpressionStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmControlFlagsExpression_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmControlFlagsExpressionStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmControlFlagsExpressionStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDOSExtendedHeader ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDOSExtendedHeaderStorageClass* storageArray = new SgAsmDOSExtendedHeaderStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDOSExtendedHeader_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDOSExtendedHeaderStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDOSExtendedHeaderStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDOSFileHeader ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDOSFileHeaderStorageClass* storageArray = new SgAsmDOSFileHeaderStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDOSFileHeader_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDOSFileHeaderStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDOSFileHeaderStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDoubleFloatValueExpression ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDoubleFloatValueExpressionStorageClass* storageArray = new SgAsmDoubleFloatValueExpressionStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDoubleFloatValueExpression_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDoubleFloatValueExpressionStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDoubleFloatValueExpressionStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDoubleWordValueExpression ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDoubleWordValueExpressionStorageClass* storageArray = new SgAsmDoubleWordValueExpressionStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDoubleWordValueExpression_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDoubleWordValueExpressionStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDoubleWordValueExpressionStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDwarfAccessDeclaration ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfAccessDeclarationStorageClass* storageArray = new SgAsmDwarfAccessDeclarationStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDwarfAccessDeclaration_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDwarfAccessDeclarationStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDwarfAccessDeclarationStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDwarfArrayType ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfArrayTypeStorageClass* storageArray = new SgAsmDwarfArrayTypeStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDwarfArrayType_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDwarfArrayTypeStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDwarfArrayTypeStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDwarfBaseType ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfBaseTypeStorageClass* storageArray = new SgAsmDwarfBaseTypeStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDwarfBaseType_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDwarfBaseTypeStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDwarfBaseTypeStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDwarfCatchBlock ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfCatchBlockStorageClass* storageArray = new SgAsmDwarfCatchBlockStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDwarfCatchBlock_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDwarfCatchBlockStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDwarfCatchBlockStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDwarfClassTemplate ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfClassTemplateStorageClass* storageArray = new SgAsmDwarfClassTemplateStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDwarfClassTemplate_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDwarfClassTemplateStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDwarfClassTemplateStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDwarfClassType ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfClassTypeStorageClass* storageArray = new SgAsmDwarfClassTypeStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDwarfClassType_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDwarfClassTypeStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDwarfClassTypeStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDwarfCommonBlock ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfCommonBlockStorageClass* storageArray = new SgAsmDwarfCommonBlockStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDwarfCommonBlock_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDwarfCommonBlockStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDwarfCommonBlockStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDwarfCommonInclusion ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfCommonInclusionStorageClass* storageArray = new SgAsmDwarfCommonInclusionStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDwarfCommonInclusion_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDwarfCommonInclusionStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDwarfCommonInclusionStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDwarfCompilationUnit ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfCompilationUnitStorageClass* storageArray = new SgAsmDwarfCompilationUnitStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDwarfCompilationUnit_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDwarfCompilationUnitStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDwarfCompilationUnitStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDwarfCompilationUnitList ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfCompilationUnitListStorageClass* storageArray = new SgAsmDwarfCompilationUnitListStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDwarfCompilationUnitList_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDwarfCompilationUnitListStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDwarfCompilationUnitListStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDwarfCondition ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfConditionStorageClass* storageArray = new SgAsmDwarfConditionStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDwarfCondition_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDwarfConditionStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDwarfConditionStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDwarfConstType ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfConstTypeStorageClass* storageArray = new SgAsmDwarfConstTypeStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDwarfConstType_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDwarfConstTypeStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDwarfConstTypeStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDwarfConstant ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfConstantStorageClass* storageArray = new SgAsmDwarfConstantStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDwarfConstant_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDwarfConstantStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDwarfConstantStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDwarfConstruct ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfConstructStorageClass* storageArray = new SgAsmDwarfConstructStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDwarfConstruct_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDwarfConstructStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDwarfConstructStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDwarfConstructList ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfConstructListStorageClass* storageArray = new SgAsmDwarfConstructListStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDwarfConstructList_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDwarfConstructListStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDwarfConstructListStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDwarfDwarfProcedure ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfDwarfProcedureStorageClass* storageArray = new SgAsmDwarfDwarfProcedureStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDwarfDwarfProcedure_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDwarfDwarfProcedureStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDwarfDwarfProcedureStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDwarfEntryPoint ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfEntryPointStorageClass* storageArray = new SgAsmDwarfEntryPointStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDwarfEntryPoint_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDwarfEntryPointStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDwarfEntryPointStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDwarfEnumerationType ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfEnumerationTypeStorageClass* storageArray = new SgAsmDwarfEnumerationTypeStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDwarfEnumerationType_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDwarfEnumerationTypeStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDwarfEnumerationTypeStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDwarfEnumerator ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfEnumeratorStorageClass* storageArray = new SgAsmDwarfEnumeratorStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDwarfEnumerator_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDwarfEnumeratorStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDwarfEnumeratorStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDwarfFileType ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfFileTypeStorageClass* storageArray = new SgAsmDwarfFileTypeStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDwarfFileType_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDwarfFileTypeStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDwarfFileTypeStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDwarfFormalParameter ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfFormalParameterStorageClass* storageArray = new SgAsmDwarfFormalParameterStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDwarfFormalParameter_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDwarfFormalParameterStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDwarfFormalParameterStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDwarfFormatLabel ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfFormatLabelStorageClass* storageArray = new SgAsmDwarfFormatLabelStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDwarfFormatLabel_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDwarfFormatLabelStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDwarfFormatLabelStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDwarfFriend ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfFriendStorageClass* storageArray = new SgAsmDwarfFriendStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDwarfFriend_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDwarfFriendStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDwarfFriendStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDwarfFunctionTemplate ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfFunctionTemplateStorageClass* storageArray = new SgAsmDwarfFunctionTemplateStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDwarfFunctionTemplate_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDwarfFunctionTemplateStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDwarfFunctionTemplateStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDwarfImportedDeclaration ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfImportedDeclarationStorageClass* storageArray = new SgAsmDwarfImportedDeclarationStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDwarfImportedDeclaration_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDwarfImportedDeclarationStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDwarfImportedDeclarationStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDwarfImportedModule ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfImportedModuleStorageClass* storageArray = new SgAsmDwarfImportedModuleStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDwarfImportedModule_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDwarfImportedModuleStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDwarfImportedModuleStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDwarfImportedUnit ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfImportedUnitStorageClass* storageArray = new SgAsmDwarfImportedUnitStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDwarfImportedUnit_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDwarfImportedUnitStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDwarfImportedUnitStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDwarfInformation ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfInformationStorageClass* storageArray = new SgAsmDwarfInformationStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDwarfInformation_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDwarfInformationStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDwarfInformationStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDwarfInheritance ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfInheritanceStorageClass* storageArray = new SgAsmDwarfInheritanceStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDwarfInheritance_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDwarfInheritanceStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDwarfInheritanceStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDwarfInlinedSubroutine ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfInlinedSubroutineStorageClass* storageArray = new SgAsmDwarfInlinedSubroutineStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDwarfInlinedSubroutine_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDwarfInlinedSubroutineStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDwarfInlinedSubroutineStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDwarfInterfaceType ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfInterfaceTypeStorageClass* storageArray = new SgAsmDwarfInterfaceTypeStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDwarfInterfaceType_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDwarfInterfaceTypeStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDwarfInterfaceTypeStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDwarfLabel ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfLabelStorageClass* storageArray = new SgAsmDwarfLabelStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDwarfLabel_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDwarfLabelStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDwarfLabelStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDwarfLexicalBlock ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfLexicalBlockStorageClass* storageArray = new SgAsmDwarfLexicalBlockStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDwarfLexicalBlock_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDwarfLexicalBlockStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDwarfLexicalBlockStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDwarfLine ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfLineStorageClass* storageArray = new SgAsmDwarfLineStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDwarfLine_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDwarfLineStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDwarfLineStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDwarfLineList ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfLineListStorageClass* storageArray = new SgAsmDwarfLineListStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDwarfLineList_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDwarfLineListStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDwarfLineListStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDwarfMacro ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfMacroStorageClass* storageArray = new SgAsmDwarfMacroStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDwarfMacro_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDwarfMacroStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDwarfMacroStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDwarfMacroList ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfMacroListStorageClass* storageArray = new SgAsmDwarfMacroListStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDwarfMacroList_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDwarfMacroListStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDwarfMacroListStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDwarfMember ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfMemberStorageClass* storageArray = new SgAsmDwarfMemberStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDwarfMember_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDwarfMemberStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDwarfMemberStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDwarfModule ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfModuleStorageClass* storageArray = new SgAsmDwarfModuleStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDwarfModule_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDwarfModuleStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDwarfModuleStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDwarfMutableType ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfMutableTypeStorageClass* storageArray = new SgAsmDwarfMutableTypeStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDwarfMutableType_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDwarfMutableTypeStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDwarfMutableTypeStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDwarfNamelist ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfNamelistStorageClass* storageArray = new SgAsmDwarfNamelistStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDwarfNamelist_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDwarfNamelistStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDwarfNamelistStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDwarfNamelistItem ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfNamelistItemStorageClass* storageArray = new SgAsmDwarfNamelistItemStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDwarfNamelistItem_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDwarfNamelistItemStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDwarfNamelistItemStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDwarfNamespace ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfNamespaceStorageClass* storageArray = new SgAsmDwarfNamespaceStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDwarfNamespace_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDwarfNamespaceStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDwarfNamespaceStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDwarfPackedType ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfPackedTypeStorageClass* storageArray = new SgAsmDwarfPackedTypeStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDwarfPackedType_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDwarfPackedTypeStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDwarfPackedTypeStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDwarfPartialUnit ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfPartialUnitStorageClass* storageArray = new SgAsmDwarfPartialUnitStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDwarfPartialUnit_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDwarfPartialUnitStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDwarfPartialUnitStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDwarfPointerType ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfPointerTypeStorageClass* storageArray = new SgAsmDwarfPointerTypeStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDwarfPointerType_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDwarfPointerTypeStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDwarfPointerTypeStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDwarfPtrToMemberType ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfPtrToMemberTypeStorageClass* storageArray = new SgAsmDwarfPtrToMemberTypeStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDwarfPtrToMemberType_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDwarfPtrToMemberTypeStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDwarfPtrToMemberTypeStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDwarfReferenceType ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfReferenceTypeStorageClass* storageArray = new SgAsmDwarfReferenceTypeStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDwarfReferenceType_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDwarfReferenceTypeStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDwarfReferenceTypeStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDwarfRestrictType ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfRestrictTypeStorageClass* storageArray = new SgAsmDwarfRestrictTypeStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDwarfRestrictType_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDwarfRestrictTypeStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDwarfRestrictTypeStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDwarfSetType ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfSetTypeStorageClass* storageArray = new SgAsmDwarfSetTypeStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDwarfSetType_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDwarfSetTypeStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDwarfSetTypeStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDwarfSharedType ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfSharedTypeStorageClass* storageArray = new SgAsmDwarfSharedTypeStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDwarfSharedType_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDwarfSharedTypeStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDwarfSharedTypeStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDwarfStringType ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfStringTypeStorageClass* storageArray = new SgAsmDwarfStringTypeStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDwarfStringType_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDwarfStringTypeStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDwarfStringTypeStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDwarfStructureType ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfStructureTypeStorageClass* storageArray = new SgAsmDwarfStructureTypeStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDwarfStructureType_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDwarfStructureTypeStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDwarfStructureTypeStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDwarfSubprogram ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfSubprogramStorageClass* storageArray = new SgAsmDwarfSubprogramStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDwarfSubprogram_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDwarfSubprogramStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDwarfSubprogramStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDwarfSubrangeType ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfSubrangeTypeStorageClass* storageArray = new SgAsmDwarfSubrangeTypeStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDwarfSubrangeType_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDwarfSubrangeTypeStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDwarfSubrangeTypeStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDwarfSubroutineType ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfSubroutineTypeStorageClass* storageArray = new SgAsmDwarfSubroutineTypeStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDwarfSubroutineType_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDwarfSubroutineTypeStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDwarfSubroutineTypeStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDwarfTemplateTypeParameter ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfTemplateTypeParameterStorageClass* storageArray = new SgAsmDwarfTemplateTypeParameterStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDwarfTemplateTypeParameter_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDwarfTemplateTypeParameterStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDwarfTemplateTypeParameterStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDwarfTemplateValueParameter ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfTemplateValueParameterStorageClass* storageArray = new SgAsmDwarfTemplateValueParameterStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDwarfTemplateValueParameter_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDwarfTemplateValueParameterStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDwarfTemplateValueParameterStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDwarfThrownType ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfThrownTypeStorageClass* storageArray = new SgAsmDwarfThrownTypeStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDwarfThrownType_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDwarfThrownTypeStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDwarfThrownTypeStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDwarfTryBlock ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfTryBlockStorageClass* storageArray = new SgAsmDwarfTryBlockStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDwarfTryBlock_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDwarfTryBlockStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDwarfTryBlockStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDwarfTypedef ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfTypedefStorageClass* storageArray = new SgAsmDwarfTypedefStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDwarfTypedef_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDwarfTypedefStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDwarfTypedefStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDwarfUnionType ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfUnionTypeStorageClass* storageArray = new SgAsmDwarfUnionTypeStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDwarfUnionType_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDwarfUnionTypeStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDwarfUnionTypeStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDwarfUnknownConstruct ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfUnknownConstructStorageClass* storageArray = new SgAsmDwarfUnknownConstructStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDwarfUnknownConstruct_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDwarfUnknownConstructStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDwarfUnknownConstructStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDwarfUnspecifiedParameters ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfUnspecifiedParametersStorageClass* storageArray = new SgAsmDwarfUnspecifiedParametersStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDwarfUnspecifiedParameters_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDwarfUnspecifiedParametersStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDwarfUnspecifiedParametersStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDwarfUnspecifiedType ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfUnspecifiedTypeStorageClass* storageArray = new SgAsmDwarfUnspecifiedTypeStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDwarfUnspecifiedType_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDwarfUnspecifiedTypeStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDwarfUnspecifiedTypeStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDwarfUpcRelaxedType ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfUpcRelaxedTypeStorageClass* storageArray = new SgAsmDwarfUpcRelaxedTypeStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDwarfUpcRelaxedType_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDwarfUpcRelaxedTypeStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDwarfUpcRelaxedTypeStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDwarfUpcSharedType ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfUpcSharedTypeStorageClass* storageArray = new SgAsmDwarfUpcSharedTypeStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDwarfUpcSharedType_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDwarfUpcSharedTypeStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDwarfUpcSharedTypeStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDwarfUpcStrictType ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfUpcStrictTypeStorageClass* storageArray = new SgAsmDwarfUpcStrictTypeStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDwarfUpcStrictType_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDwarfUpcStrictTypeStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDwarfUpcStrictTypeStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDwarfVariable ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfVariableStorageClass* storageArray = new SgAsmDwarfVariableStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDwarfVariable_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDwarfVariableStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDwarfVariableStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDwarfVariant ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfVariantStorageClass* storageArray = new SgAsmDwarfVariantStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDwarfVariant_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDwarfVariantStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDwarfVariantStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDwarfVariantPart ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfVariantPartStorageClass* storageArray = new SgAsmDwarfVariantPartStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDwarfVariantPart_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDwarfVariantPartStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDwarfVariantPartStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDwarfVolatileType ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfVolatileTypeStorageClass* storageArray = new SgAsmDwarfVolatileTypeStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDwarfVolatileType_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDwarfVolatileTypeStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDwarfVolatileTypeStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmDwarfWithStmt ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmDwarfWithStmtStorageClass* storageArray = new SgAsmDwarfWithStmtStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmDwarfWithStmt_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmDwarfWithStmtStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmDwarfWithStmtStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmElfDynamicEntry ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfDynamicEntryStorageClass* storageArray = new SgAsmElfDynamicEntryStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmElfDynamicEntry_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmElfDynamicEntryStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmElfDynamicEntryStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmElfDynamicEntryList ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfDynamicEntryListStorageClass* storageArray = new SgAsmElfDynamicEntryListStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmElfDynamicEntryList_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmElfDynamicEntryListStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmElfDynamicEntryListStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmElfDynamicSection ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfDynamicSectionStorageClass* storageArray = new SgAsmElfDynamicSectionStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmElfDynamicSection_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmElfDynamicSectionStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmElfDynamicSectionStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmElfEHFrameEntryCI ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfEHFrameEntryCIStorageClass* storageArray = new SgAsmElfEHFrameEntryCIStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmElfEHFrameEntryCI_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmElfEHFrameEntryCIStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmElfEHFrameEntryCIStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmElfEHFrameEntryCIList ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfEHFrameEntryCIListStorageClass* storageArray = new SgAsmElfEHFrameEntryCIListStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmElfEHFrameEntryCIList_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmElfEHFrameEntryCIListStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmElfEHFrameEntryCIListStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmElfEHFrameEntryFD ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfEHFrameEntryFDStorageClass* storageArray = new SgAsmElfEHFrameEntryFDStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmElfEHFrameEntryFD_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmElfEHFrameEntryFDStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmElfEHFrameEntryFDStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmElfEHFrameEntryFDList ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfEHFrameEntryFDListStorageClass* storageArray = new SgAsmElfEHFrameEntryFDListStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmElfEHFrameEntryFDList_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmElfEHFrameEntryFDListStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmElfEHFrameEntryFDListStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmElfEHFrameSection ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfEHFrameSectionStorageClass* storageArray = new SgAsmElfEHFrameSectionStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmElfEHFrameSection_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmElfEHFrameSectionStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmElfEHFrameSectionStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmElfFileHeader ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfFileHeaderStorageClass* storageArray = new SgAsmElfFileHeaderStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmElfFileHeader_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmElfFileHeaderStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmElfFileHeaderStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmElfNoteEntry ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfNoteEntryStorageClass* storageArray = new SgAsmElfNoteEntryStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmElfNoteEntry_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmElfNoteEntryStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmElfNoteEntryStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmElfNoteEntryList ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfNoteEntryListStorageClass* storageArray = new SgAsmElfNoteEntryListStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmElfNoteEntryList_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmElfNoteEntryListStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmElfNoteEntryListStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmElfNoteSection ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfNoteSectionStorageClass* storageArray = new SgAsmElfNoteSectionStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmElfNoteSection_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmElfNoteSectionStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmElfNoteSectionStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmElfRelocEntry ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfRelocEntryStorageClass* storageArray = new SgAsmElfRelocEntryStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmElfRelocEntry_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmElfRelocEntryStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmElfRelocEntryStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmElfRelocEntryList ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfRelocEntryListStorageClass* storageArray = new SgAsmElfRelocEntryListStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmElfRelocEntryList_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmElfRelocEntryListStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmElfRelocEntryListStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmElfRelocSection ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfRelocSectionStorageClass* storageArray = new SgAsmElfRelocSectionStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmElfRelocSection_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmElfRelocSectionStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmElfRelocSectionStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmElfSection ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfSectionStorageClass* storageArray = new SgAsmElfSectionStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmElfSection_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmElfSectionStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmElfSectionStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmElfSectionTable ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfSectionTableStorageClass* storageArray = new SgAsmElfSectionTableStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmElfSectionTable_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmElfSectionTableStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmElfSectionTableStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmElfSectionTableEntry ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfSectionTableEntryStorageClass* storageArray = new SgAsmElfSectionTableEntryStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmElfSectionTableEntry_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmElfSectionTableEntryStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmElfSectionTableEntryStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmElfSegmentTable ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfSegmentTableStorageClass* storageArray = new SgAsmElfSegmentTableStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmElfSegmentTable_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmElfSegmentTableStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmElfSegmentTableStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmElfSegmentTableEntry ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfSegmentTableEntryStorageClass* storageArray = new SgAsmElfSegmentTableEntryStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmElfSegmentTableEntry_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmElfSegmentTableEntryStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmElfSegmentTableEntryStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmElfSegmentTableEntryList ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfSegmentTableEntryListStorageClass* storageArray = new SgAsmElfSegmentTableEntryListStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmElfSegmentTableEntryList_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmElfSegmentTableEntryListStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmElfSegmentTableEntryListStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmElfStringSection ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfStringSectionStorageClass* storageArray = new SgAsmElfStringSectionStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmElfStringSection_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmElfStringSectionStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmElfStringSectionStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmElfStrtab ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfStrtabStorageClass* storageArray = new SgAsmElfStrtabStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmElfStrtab_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmElfStrtabStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmElfStrtabStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmElfSymbol ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfSymbolStorageClass* storageArray = new SgAsmElfSymbolStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmElfSymbol_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmElfSymbolStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmElfSymbolStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmElfSymbolList ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfSymbolListStorageClass* storageArray = new SgAsmElfSymbolListStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmElfSymbolList_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmElfSymbolListStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmElfSymbolListStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmElfSymbolSection ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfSymbolSectionStorageClass* storageArray = new SgAsmElfSymbolSectionStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmElfSymbolSection_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmElfSymbolSectionStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmElfSymbolSectionStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmElfSymverDefinedAux ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfSymverDefinedAuxStorageClass* storageArray = new SgAsmElfSymverDefinedAuxStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmElfSymverDefinedAux_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmElfSymverDefinedAuxStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmElfSymverDefinedAuxStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmElfSymverDefinedAuxList ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfSymverDefinedAuxListStorageClass* storageArray = new SgAsmElfSymverDefinedAuxListStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmElfSymverDefinedAuxList_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmElfSymverDefinedAuxListStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmElfSymverDefinedAuxListStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmElfSymverDefinedEntry ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfSymverDefinedEntryStorageClass* storageArray = new SgAsmElfSymverDefinedEntryStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmElfSymverDefinedEntry_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmElfSymverDefinedEntryStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmElfSymverDefinedEntryStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmElfSymverDefinedEntryList ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfSymverDefinedEntryListStorageClass* storageArray = new SgAsmElfSymverDefinedEntryListStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmElfSymverDefinedEntryList_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmElfSymverDefinedEntryListStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmElfSymverDefinedEntryListStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmElfSymverDefinedSection ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfSymverDefinedSectionStorageClass* storageArray = new SgAsmElfSymverDefinedSectionStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmElfSymverDefinedSection_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmElfSymverDefinedSectionStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmElfSymverDefinedSectionStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmElfSymverEntry ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfSymverEntryStorageClass* storageArray = new SgAsmElfSymverEntryStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmElfSymverEntry_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmElfSymverEntryStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmElfSymverEntryStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmElfSymverEntryList ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfSymverEntryListStorageClass* storageArray = new SgAsmElfSymverEntryListStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmElfSymverEntryList_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmElfSymverEntryListStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmElfSymverEntryListStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmElfSymverNeededAux ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfSymverNeededAuxStorageClass* storageArray = new SgAsmElfSymverNeededAuxStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmElfSymverNeededAux_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmElfSymverNeededAuxStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmElfSymverNeededAuxStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmElfSymverNeededAuxList ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfSymverNeededAuxListStorageClass* storageArray = new SgAsmElfSymverNeededAuxListStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmElfSymverNeededAuxList_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmElfSymverNeededAuxListStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmElfSymverNeededAuxListStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmElfSymverNeededEntry ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfSymverNeededEntryStorageClass* storageArray = new SgAsmElfSymverNeededEntryStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmElfSymverNeededEntry_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmElfSymverNeededEntryStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmElfSymverNeededEntryStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmElfSymverNeededEntryList ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfSymverNeededEntryListStorageClass* storageArray = new SgAsmElfSymverNeededEntryListStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmElfSymverNeededEntryList_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmElfSymverNeededEntryListStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmElfSymverNeededEntryListStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmElfSymverNeededSection ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfSymverNeededSectionStorageClass* storageArray = new SgAsmElfSymverNeededSectionStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmElfSymverNeededSection_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmElfSymverNeededSectionStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmElfSymverNeededSectionStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmElfSymverSection ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmElfSymverSectionStorageClass* storageArray = new SgAsmElfSymverSectionStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmElfSymverSection_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmElfSymverSectionStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmElfSymverSectionStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmExecutableFileFormat ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmExecutableFileFormatStorageClass* storageArray = new SgAsmExecutableFileFormatStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmExecutableFileFormat_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmExecutableFileFormatStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmExecutableFileFormatStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmExprListExp ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmExprListExpStorageClass* storageArray = new SgAsmExprListExpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmExprListExp_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmExprListExpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmExprListExpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmExpression ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmExpressionStorageClass* storageArray = new SgAsmExpressionStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmExpression_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmExpressionStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmExpressionStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmFunction ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmFunctionStorageClass* storageArray = new SgAsmFunctionStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmFunction_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmFunctionStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmFunctionStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmGenericDLL ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmGenericDLLStorageClass* storageArray = new SgAsmGenericDLLStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmGenericDLL_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmGenericDLLStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmGenericDLLStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmGenericDLLList ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmGenericDLLListStorageClass* storageArray = new SgAsmGenericDLLListStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmGenericDLLList_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmGenericDLLListStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmGenericDLLListStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmGenericFile ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmGenericFileStorageClass* storageArray = new SgAsmGenericFileStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmGenericFile_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmGenericFileStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmGenericFileStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmGenericFileList ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmGenericFileListStorageClass* storageArray = new SgAsmGenericFileListStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmGenericFileList_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmGenericFileListStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmGenericFileListStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmGenericFormat ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmGenericFormatStorageClass* storageArray = new SgAsmGenericFormatStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmGenericFormat_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmGenericFormatStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmGenericFormatStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmGenericHeader ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmGenericHeaderStorageClass* storageArray = new SgAsmGenericHeaderStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmGenericHeader_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmGenericHeaderStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmGenericHeaderStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmGenericHeaderList ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmGenericHeaderListStorageClass* storageArray = new SgAsmGenericHeaderListStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmGenericHeaderList_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmGenericHeaderListStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmGenericHeaderListStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmGenericSection ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmGenericSectionStorageClass* storageArray = new SgAsmGenericSectionStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmGenericSection_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmGenericSectionStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmGenericSectionStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmGenericSectionList ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmGenericSectionListStorageClass* storageArray = new SgAsmGenericSectionListStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmGenericSectionList_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmGenericSectionListStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmGenericSectionListStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmGenericString ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmGenericStringStorageClass* storageArray = new SgAsmGenericStringStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmGenericString_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmGenericStringStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmGenericStringStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmGenericStrtab ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmGenericStrtabStorageClass* storageArray = new SgAsmGenericStrtabStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmGenericStrtab_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmGenericStrtabStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmGenericStrtabStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmGenericSymbol ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmGenericSymbolStorageClass* storageArray = new SgAsmGenericSymbolStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmGenericSymbol_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmGenericSymbolStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmGenericSymbolStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmGenericSymbolList ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmGenericSymbolListStorageClass* storageArray = new SgAsmGenericSymbolListStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmGenericSymbolList_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmGenericSymbolListStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmGenericSymbolListStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmInstruction ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmInstructionStorageClass* storageArray = new SgAsmInstructionStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmInstruction_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmInstructionStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmInstructionStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmIntegerValueExpression ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmIntegerValueExpressionStorageClass* storageArray = new SgAsmIntegerValueExpressionStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmIntegerValueExpression_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmIntegerValueExpressionStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmIntegerValueExpressionStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmInterpretation ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmInterpretationStorageClass* storageArray = new SgAsmInterpretationStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmInterpretation_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmInterpretationStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmInterpretationStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmInterpretationList ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmInterpretationListStorageClass* storageArray = new SgAsmInterpretationListStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmInterpretationList_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmInterpretationListStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmInterpretationListStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmLEEntryPoint ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmLEEntryPointStorageClass* storageArray = new SgAsmLEEntryPointStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmLEEntryPoint_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmLEEntryPointStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmLEEntryPointStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmLEEntryTable ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmLEEntryTableStorageClass* storageArray = new SgAsmLEEntryTableStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmLEEntryTable_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmLEEntryTableStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmLEEntryTableStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmLEFileHeader ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmLEFileHeaderStorageClass* storageArray = new SgAsmLEFileHeaderStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmLEFileHeader_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmLEFileHeaderStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmLEFileHeaderStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmLENameTable ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmLENameTableStorageClass* storageArray = new SgAsmLENameTableStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmLENameTable_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmLENameTableStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmLENameTableStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmLEPageTable ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmLEPageTableStorageClass* storageArray = new SgAsmLEPageTableStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmLEPageTable_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmLEPageTableStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmLEPageTableStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmLEPageTableEntry ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmLEPageTableEntryStorageClass* storageArray = new SgAsmLEPageTableEntryStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmLEPageTableEntry_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmLEPageTableEntryStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmLEPageTableEntryStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmLERelocTable ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmLERelocTableStorageClass* storageArray = new SgAsmLERelocTableStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmLERelocTable_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmLERelocTableStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmLERelocTableStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmLESection ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmLESectionStorageClass* storageArray = new SgAsmLESectionStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmLESection_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmLESectionStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmLESectionStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmLESectionTable ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmLESectionTableStorageClass* storageArray = new SgAsmLESectionTableStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmLESectionTable_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmLESectionTableStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmLESectionTableStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmLESectionTableEntry ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmLESectionTableEntryStorageClass* storageArray = new SgAsmLESectionTableEntryStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmLESectionTableEntry_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmLESectionTableEntryStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmLESectionTableEntryStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmMemoryReferenceExpression ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmMemoryReferenceExpressionStorageClass* storageArray = new SgAsmMemoryReferenceExpressionStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmMemoryReferenceExpression_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmMemoryReferenceExpressionStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmMemoryReferenceExpressionStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmNEEntryPoint ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmNEEntryPointStorageClass* storageArray = new SgAsmNEEntryPointStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmNEEntryPoint_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmNEEntryPointStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmNEEntryPointStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmNEEntryTable ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmNEEntryTableStorageClass* storageArray = new SgAsmNEEntryTableStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmNEEntryTable_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmNEEntryTableStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmNEEntryTableStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmNEFileHeader ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmNEFileHeaderStorageClass* storageArray = new SgAsmNEFileHeaderStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmNEFileHeader_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmNEFileHeaderStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmNEFileHeaderStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmNEModuleTable ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmNEModuleTableStorageClass* storageArray = new SgAsmNEModuleTableStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmNEModuleTable_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmNEModuleTableStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmNEModuleTableStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmNENameTable ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmNENameTableStorageClass* storageArray = new SgAsmNENameTableStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmNENameTable_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmNENameTableStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmNENameTableStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmNERelocEntry ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmNERelocEntryStorageClass* storageArray = new SgAsmNERelocEntryStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmNERelocEntry_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmNERelocEntryStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmNERelocEntryStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmNERelocTable ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmNERelocTableStorageClass* storageArray = new SgAsmNERelocTableStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmNERelocTable_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmNERelocTableStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmNERelocTableStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmNESection ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmNESectionStorageClass* storageArray = new SgAsmNESectionStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmNESection_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmNESectionStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmNESectionStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmNESectionTable ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmNESectionTableStorageClass* storageArray = new SgAsmNESectionTableStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmNESectionTable_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmNESectionTableStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmNESectionTableStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmNESectionTableEntry ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmNESectionTableEntryStorageClass* storageArray = new SgAsmNESectionTableEntryStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmNESectionTableEntry_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmNESectionTableEntryStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmNESectionTableEntryStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmNEStringTable ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmNEStringTableStorageClass* storageArray = new SgAsmNEStringTableStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmNEStringTable_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmNEStringTableStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmNEStringTableStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmNode ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmNodeStorageClass* storageArray = new SgAsmNodeStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmNode_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmNodeStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmNodeStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmOp ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmOpStorageClass* storageArray = new SgAsmOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmOp_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmOperandList ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmOperandListStorageClass* storageArray = new SgAsmOperandListStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmOperandList_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmOperandListStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmOperandListStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmPEExportDirectory ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmPEExportDirectoryStorageClass* storageArray = new SgAsmPEExportDirectoryStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmPEExportDirectory_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmPEExportDirectoryStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmPEExportDirectoryStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmPEExportEntry ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmPEExportEntryStorageClass* storageArray = new SgAsmPEExportEntryStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmPEExportEntry_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmPEExportEntryStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmPEExportEntryStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmPEExportEntryList ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmPEExportEntryListStorageClass* storageArray = new SgAsmPEExportEntryListStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmPEExportEntryList_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmPEExportEntryListStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmPEExportEntryListStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmPEExportSection ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmPEExportSectionStorageClass* storageArray = new SgAsmPEExportSectionStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmPEExportSection_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmPEExportSectionStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmPEExportSectionStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmPEFileHeader ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmPEFileHeaderStorageClass* storageArray = new SgAsmPEFileHeaderStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmPEFileHeader_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmPEFileHeaderStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmPEFileHeaderStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmPEImportDirectory ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmPEImportDirectoryStorageClass* storageArray = new SgAsmPEImportDirectoryStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmPEImportDirectory_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmPEImportDirectoryStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmPEImportDirectoryStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmPEImportDirectoryList ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmPEImportDirectoryListStorageClass* storageArray = new SgAsmPEImportDirectoryListStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmPEImportDirectoryList_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmPEImportDirectoryListStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmPEImportDirectoryListStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmPEImportItem ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmPEImportItemStorageClass* storageArray = new SgAsmPEImportItemStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmPEImportItem_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmPEImportItemStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmPEImportItemStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmPEImportItemList ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmPEImportItemListStorageClass* storageArray = new SgAsmPEImportItemListStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmPEImportItemList_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmPEImportItemListStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmPEImportItemListStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmPEImportSection ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmPEImportSectionStorageClass* storageArray = new SgAsmPEImportSectionStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmPEImportSection_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmPEImportSectionStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmPEImportSectionStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmPERVASizePair ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmPERVASizePairStorageClass* storageArray = new SgAsmPERVASizePairStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmPERVASizePair_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmPERVASizePairStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmPERVASizePairStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmPERVASizePairList ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmPERVASizePairListStorageClass* storageArray = new SgAsmPERVASizePairListStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmPERVASizePairList_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmPERVASizePairListStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmPERVASizePairListStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmPESection ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmPESectionStorageClass* storageArray = new SgAsmPESectionStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmPESection_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmPESectionStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmPESectionStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmPESectionTable ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmPESectionTableStorageClass* storageArray = new SgAsmPESectionTableStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmPESectionTable_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmPESectionTableStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmPESectionTableStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmPESectionTableEntry ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmPESectionTableEntryStorageClass* storageArray = new SgAsmPESectionTableEntryStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmPESectionTableEntry_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmPESectionTableEntryStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmPESectionTableEntryStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmPEStringSection ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmPEStringSectionStorageClass* storageArray = new SgAsmPEStringSectionStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmPEStringSection_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmPEStringSectionStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmPEStringSectionStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmPowerpcInstruction ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmPowerpcInstructionStorageClass* storageArray = new SgAsmPowerpcInstructionStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmPowerpcInstruction_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmPowerpcInstructionStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmPowerpcInstructionStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmPowerpcRegisterReferenceExpression ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmPowerpcRegisterReferenceExpressionStorageClass* storageArray = new SgAsmPowerpcRegisterReferenceExpressionStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmPowerpcRegisterReferenceExpression_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmPowerpcRegisterReferenceExpressionStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmPowerpcRegisterReferenceExpressionStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmQuadWordValueExpression ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmQuadWordValueExpressionStorageClass* storageArray = new SgAsmQuadWordValueExpressionStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmQuadWordValueExpression_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmQuadWordValueExpressionStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmQuadWordValueExpressionStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmRegisterReferenceExpression ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmRegisterReferenceExpressionStorageClass* storageArray = new SgAsmRegisterReferenceExpressionStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmRegisterReferenceExpression_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmRegisterReferenceExpressionStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmRegisterReferenceExpressionStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmSingleFloatValueExpression ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmSingleFloatValueExpressionStorageClass* storageArray = new SgAsmSingleFloatValueExpressionStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmSingleFloatValueExpression_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmSingleFloatValueExpressionStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmSingleFloatValueExpressionStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmStatement ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmStatementStorageClass* storageArray = new SgAsmStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmStatement_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmStaticData ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmStaticDataStorageClass* storageArray = new SgAsmStaticDataStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmStaticData_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmStaticDataStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmStaticDataStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmStmt ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmStmtStorageClass* storageArray = new SgAsmStmtStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmStmt_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmStmtStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmStmtStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmStoredString ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmStoredStringStorageClass* storageArray = new SgAsmStoredStringStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmStoredString_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmStoredStringStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmStoredStringStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmStringStorage ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmStringStorageStorageClass* storageArray = new SgAsmStringStorageStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmStringStorage_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmStringStorageStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmStringStorageStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmType ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmTypeStorageClass* storageArray = new SgAsmTypeStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmType_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmTypeStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmTypeStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmType128bitFloat ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmType128bitFloatStorageClass* storageArray = new SgAsmType128bitFloatStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmType128bitFloat_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmType128bitFloatStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmType128bitFloatStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmType80bitFloat ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmType80bitFloatStorageClass* storageArray = new SgAsmType80bitFloatStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmType80bitFloat_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmType80bitFloatStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmType80bitFloatStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmTypeByte ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmTypeByteStorageClass* storageArray = new SgAsmTypeByteStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmTypeByte_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmTypeByteStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmTypeByteStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmTypeDoubleFloat ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmTypeDoubleFloatStorageClass* storageArray = new SgAsmTypeDoubleFloatStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmTypeDoubleFloat_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmTypeDoubleFloatStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmTypeDoubleFloatStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmTypeDoubleQuadWord ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmTypeDoubleQuadWordStorageClass* storageArray = new SgAsmTypeDoubleQuadWordStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmTypeDoubleQuadWord_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmTypeDoubleQuadWordStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmTypeDoubleQuadWordStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmTypeDoubleWord ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmTypeDoubleWordStorageClass* storageArray = new SgAsmTypeDoubleWordStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmTypeDoubleWord_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmTypeDoubleWordStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmTypeDoubleWordStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmTypeQuadWord ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmTypeQuadWordStorageClass* storageArray = new SgAsmTypeQuadWordStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmTypeQuadWord_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmTypeQuadWordStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmTypeQuadWordStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmTypeSingleFloat ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmTypeSingleFloatStorageClass* storageArray = new SgAsmTypeSingleFloatStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmTypeSingleFloat_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmTypeSingleFloatStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmTypeSingleFloatStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmTypeVector ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmTypeVectorStorageClass* storageArray = new SgAsmTypeVectorStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmTypeVector_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmTypeVectorStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmTypeVectorStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmTypeWord ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmTypeWordStorageClass* storageArray = new SgAsmTypeWordStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmTypeWord_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmTypeWordStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmTypeWordStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmUnaryArmSpecialRegisterList ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmUnaryArmSpecialRegisterListStorageClass* storageArray = new SgAsmUnaryArmSpecialRegisterListStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmUnaryArmSpecialRegisterList_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmUnaryArmSpecialRegisterListStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmUnaryArmSpecialRegisterListStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmUnaryExpression ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmUnaryExpressionStorageClass* storageArray = new SgAsmUnaryExpressionStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmUnaryExpression_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmUnaryExpressionStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmUnaryExpressionStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmUnaryMinus ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmUnaryMinusStorageClass* storageArray = new SgAsmUnaryMinusStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmUnaryMinus_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmUnaryMinusStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmUnaryMinusStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmUnaryPlus ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmUnaryPlusStorageClass* storageArray = new SgAsmUnaryPlusStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmUnaryPlus_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmUnaryPlusStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmUnaryPlusStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmUnaryRrx ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmUnaryRrxStorageClass* storageArray = new SgAsmUnaryRrxStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmUnaryRrx_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmUnaryRrxStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmUnaryRrxStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmValueExpression ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmValueExpressionStorageClass* storageArray = new SgAsmValueExpressionStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmValueExpression_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmValueExpressionStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmValueExpressionStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmVectorValueExpression ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmVectorValueExpressionStorageClass* storageArray = new SgAsmVectorValueExpressionStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmVectorValueExpression_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmVectorValueExpressionStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmVectorValueExpressionStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmWordValueExpression ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmWordValueExpressionStorageClass* storageArray = new SgAsmWordValueExpressionStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmWordValueExpression_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmWordValueExpressionStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmWordValueExpressionStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmx86Instruction ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmx86InstructionStorageClass* storageArray = new SgAsmx86InstructionStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmx86Instruction_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmx86InstructionStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmx86InstructionStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmx86RegisterReferenceExpression ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmx86RegisterReferenceExpressionStorageClass* storageArray = new SgAsmx86RegisterReferenceExpressionStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmx86RegisterReferenceExpression_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmx86RegisterReferenceExpressionStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmx86RegisterReferenceExpressionStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmBinaryAddressSymbol ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmBinaryAddressSymbolStorageClass* storageArray = new SgAsmBinaryAddressSymbolStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmBinaryAddressSymbol_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmBinaryAddressSymbolStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmBinaryAddressSymbolStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsmBinaryDataSymbol ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsmBinaryDataSymbolStorageClass* storageArray = new SgAsmBinaryDataSymbolStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsmBinaryDataSymbol_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsmBinaryDataSymbolStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsmBinaryDataSymbolStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAssertStmt ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAssertStmtStorageClass* storageArray = new SgAssertStmtStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAssertStmt_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAssertStmtStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAssertStmtStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAssignInitializer ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAssignInitializerStorageClass* storageArray = new SgAssignInitializerStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAssignInitializer_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAssignInitializerStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAssignInitializerStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAssignOp ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAssignOpStorageClass* storageArray = new SgAssignOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAssignOp_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAssignOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAssignOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAssignStatement ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAssignStatementStorageClass* storageArray = new SgAssignStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAssignStatement_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAssignStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAssignStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAssignedGotoStatement ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAssignedGotoStatementStorageClass* storageArray = new SgAssignedGotoStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAssignedGotoStatement_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAssignedGotoStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAssignedGotoStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAssociateStatement ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAssociateStatementStorageClass* storageArray = new SgAssociateStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAssociateStatement_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAssociateStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAssociateStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAsteriskShapeExp ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAsteriskShapeExpStorageClass* storageArray = new SgAsteriskShapeExpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAsteriskShapeExp_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAsteriskShapeExpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAsteriskShapeExpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAttribute ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAttributeStorageClass* storageArray = new SgAttributeStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAttribute_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAttributeStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAttributeStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgAttributeSpecificationStatement ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgAttributeSpecificationStatementStorageClass* storageArray = new SgAttributeSpecificationStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgAttributeSpecificationStatement_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgAttributeSpecificationStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgAttributeSpecificationStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgBackspaceStatement ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgBackspaceStatementStorageClass* storageArray = new SgBackspaceStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgBackspaceStatement_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgBackspaceStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgBackspaceStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgBaseClass ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgBaseClassStorageClass* storageArray = new SgBaseClassStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgBaseClass_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgBaseClassStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgExpBaseClass ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgExpBaseClassStorageClass* storageArray = new SgExpBaseClassStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgExpBaseClass_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgExpBaseClassStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgBaseClassModifier ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgBaseClassModifierStorageClass* storageArray = new SgBaseClassModifierStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgBaseClassModifier_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgBaseClassModifierStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgBaseClassModifierStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgBasicBlock ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgBasicBlockStorageClass* storageArray = new SgBasicBlockStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgBasicBlock_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgBasicBlockStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgBasicBlockStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgBidirectionalGraph ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgBidirectionalGraphStorageClass* storageArray = new SgBidirectionalGraphStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgBidirectionalGraph_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgBidirectionalGraphStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgBidirectionalGraphStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgBinaryComposite ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgBinaryCompositeStorageClass* storageArray = new SgBinaryCompositeStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgBinaryComposite_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgBinaryCompositeStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgBinaryCompositeStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgBinaryOp ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgBinaryOpStorageClass* storageArray = new SgBinaryOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgBinaryOp_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgBinaryOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgBinaryOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgBitAndOp ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgBitAndOpStorageClass* storageArray = new SgBitAndOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgBitAndOp_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgBitAndOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgBitAndOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgBitAttribute ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgBitAttributeStorageClass* storageArray = new SgBitAttributeStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgBitAttribute_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgBitAttributeStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgBitAttributeStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgBitComplementOp ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgBitComplementOpStorageClass* storageArray = new SgBitComplementOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgBitComplementOp_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgBitComplementOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgBitComplementOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgBitOrOp ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgBitOrOpStorageClass* storageArray = new SgBitOrOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgBitOrOp_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgBitOrOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgBitOrOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgBitXorOp ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgBitXorOpStorageClass* storageArray = new SgBitXorOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgBitXorOp_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgBitXorOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgBitXorOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgBlockDataStatement ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgBlockDataStatementStorageClass* storageArray = new SgBlockDataStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgBlockDataStatement_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgBlockDataStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgBlockDataStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgBoolValExp ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgBoolValExpStorageClass* storageArray = new SgBoolValExpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgBoolValExp_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgBoolValExpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgBoolValExpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgBreakStmt ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgBreakStmtStorageClass* storageArray = new SgBreakStmtStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgBreakStmt_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgBreakStmtStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgBreakStmtStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgC_PreprocessorDirectiveStatement ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgC_PreprocessorDirectiveStatementStorageClass* storageArray = new SgC_PreprocessorDirectiveStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgC_PreprocessorDirectiveStatement_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgC_PreprocessorDirectiveStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgC_PreprocessorDirectiveStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgCaseOptionStmt ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgCaseOptionStmtStorageClass* storageArray = new SgCaseOptionStmtStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgCaseOptionStmt_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgCaseOptionStmtStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgCaseOptionStmtStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgCastExp ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgCastExpStorageClass* storageArray = new SgCastExpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgCastExp_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgCastExpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgCastExpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgCatchOptionStmt ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgCatchOptionStmtStorageClass* storageArray = new SgCatchOptionStmtStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgCatchOptionStmt_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgCatchOptionStmtStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgCatchOptionStmtStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgCatchStatementSeq ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgCatchStatementSeqStorageClass* storageArray = new SgCatchStatementSeqStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgCatchStatementSeq_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgCatchStatementSeqStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgCatchStatementSeqStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgCharVal ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgCharValStorageClass* storageArray = new SgCharValStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgCharVal_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgCharValStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgCharValStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgClassDecl_attr ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgClassDecl_attrStorageClass* storageArray = new SgClassDecl_attrStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgClassDecl_attr_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgClassDecl_attrStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgClassDecl_attrStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgClassDeclaration ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgClassDeclarationStorageClass* storageArray = new SgClassDeclarationStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgClassDeclaration_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgClassDeclarationStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgClassDeclarationStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgClassDefinition ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgClassDefinitionStorageClass* storageArray = new SgClassDefinitionStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgClassDefinition_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgClassDefinitionStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgClassDefinitionStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgClassNameRefExp ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgClassNameRefExpStorageClass* storageArray = new SgClassNameRefExpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgClassNameRefExp_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgClassNameRefExpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgClassNameRefExpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgClassSymbol ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgClassSymbolStorageClass* storageArray = new SgClassSymbolStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgClassSymbol_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgClassSymbolStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgClassSymbolStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgClassType ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgClassTypeStorageClass* storageArray = new SgClassTypeStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgClassType_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgClassTypeStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgClassTypeStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgClinkageDeclarationStatement ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgClinkageDeclarationStatementStorageClass* storageArray = new SgClinkageDeclarationStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgClinkageDeclarationStatement_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgClinkageDeclarationStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgClinkageDeclarationStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgClinkageEndStatement ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgClinkageEndStatementStorageClass* storageArray = new SgClinkageEndStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgClinkageEndStatement_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgClinkageEndStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgClinkageEndStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgClinkageStartStatement ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgClinkageStartStatementStorageClass* storageArray = new SgClinkageStartStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgClinkageStartStatement_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgClinkageStartStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgClinkageStartStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgCloseStatement ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgCloseStatementStorageClass* storageArray = new SgCloseStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgCloseStatement_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgCloseStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgCloseStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgColonShapeExp ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgColonShapeExpStorageClass* storageArray = new SgColonShapeExpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgColonShapeExp_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgColonShapeExpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgColonShapeExpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgCommaOpExp ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgCommaOpExpStorageClass* storageArray = new SgCommaOpExpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgCommaOpExp_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgCommaOpExpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgCommaOpExpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgCommonBlock ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgCommonBlockStorageClass* storageArray = new SgCommonBlockStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgCommonBlock_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgCommonBlockStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgCommonBlockStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgCommonBlockObject ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgCommonBlockObjectStorageClass* storageArray = new SgCommonBlockObjectStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgCommonBlockObject_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgCommonBlockObjectStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgCommonBlockObjectStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgCommonSymbol ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgCommonSymbolStorageClass* storageArray = new SgCommonSymbolStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgCommonSymbol_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgCommonSymbolStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgCommonSymbolStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgComplexVal ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgComplexValStorageClass* storageArray = new SgComplexValStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgComplexVal_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgComplexValStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgComplexValStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgComprehension ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgComprehensionStorageClass* storageArray = new SgComprehensionStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgComprehension_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgComprehensionStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgComprehensionStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgCompoundAssignOp ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgCompoundAssignOpStorageClass* storageArray = new SgCompoundAssignOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgCompoundAssignOp_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgCompoundAssignOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgCompoundAssignOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgCompoundInitializer ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgCompoundInitializerStorageClass* storageArray = new SgCompoundInitializerStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgCompoundInitializer_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgCompoundInitializerStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgCompoundInitializerStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgComputedGotoStatement ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgComputedGotoStatementStorageClass* storageArray = new SgComputedGotoStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgComputedGotoStatement_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgComputedGotoStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgComputedGotoStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgConcatenationOp ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgConcatenationOpStorageClass* storageArray = new SgConcatenationOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgConcatenationOp_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgConcatenationOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgConcatenationOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgConditionalExp ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgConditionalExpStorageClass* storageArray = new SgConditionalExpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgConditionalExp_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgConditionalExpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgConditionalExpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgConjugateOp ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgConjugateOpStorageClass* storageArray = new SgConjugateOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgConjugateOp_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgConjugateOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgConjugateOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgConstVolatileModifier ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgConstVolatileModifierStorageClass* storageArray = new SgConstVolatileModifierStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgConstVolatileModifier_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgConstVolatileModifierStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgConstructorInitializer ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgConstructorInitializerStorageClass* storageArray = new SgConstructorInitializerStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgConstructorInitializer_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgConstructorInitializerStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgConstructorInitializerStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgContainsStatement ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgContainsStatementStorageClass* storageArray = new SgContainsStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgContainsStatement_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgContainsStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgContainsStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgContinueStmt ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgContinueStmtStorageClass* storageArray = new SgContinueStmtStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgContinueStmt_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgContinueStmtStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgContinueStmtStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgCtorInitializerList ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgCtorInitializerListStorageClass* storageArray = new SgCtorInitializerListStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgCtorInitializerList_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgCtorInitializerListStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgCtorInitializerListStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgDataStatementGroup ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgDataStatementGroupStorageClass* storageArray = new SgDataStatementGroupStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgDataStatementGroup_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgDataStatementGroupStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgDataStatementGroupStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgDataStatementObject ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgDataStatementObjectStorageClass* storageArray = new SgDataStatementObjectStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgDataStatementObject_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgDataStatementObjectStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgDataStatementValue ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgDataStatementValueStorageClass* storageArray = new SgDataStatementValueStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgDataStatementValue_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgDataStatementValueStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgDeadIfDirectiveStatement ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgDeadIfDirectiveStatementStorageClass* storageArray = new SgDeadIfDirectiveStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgDeadIfDirectiveStatement_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgDeadIfDirectiveStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgDeadIfDirectiveStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgDeallocateStatement ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgDeallocateStatementStorageClass* storageArray = new SgDeallocateStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgDeallocateStatement_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgDeallocateStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgDeallocateStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgDeclarationModifier ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgDeclarationModifierStorageClass* storageArray = new SgDeclarationModifierStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgDeclarationModifier_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgDeclarationModifierStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgDeclarationStatement ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgDeclarationStatementStorageClass* storageArray = new SgDeclarationStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgDeclarationStatement_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgDeclarationStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgDeclarationStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgDefaultOptionStmt ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgDefaultOptionStmtStorageClass* storageArray = new SgDefaultOptionStmtStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgDefaultOptionStmt_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgDefaultOptionStmtStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgDefaultOptionStmtStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgDefaultSymbol ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgDefaultSymbolStorageClass* storageArray = new SgDefaultSymbolStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgDefaultSymbol_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgDefaultSymbolStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgDefaultSymbolStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgDefineDirectiveStatement ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgDefineDirectiveStatementStorageClass* storageArray = new SgDefineDirectiveStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgDefineDirectiveStatement_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgDefineDirectiveStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgDefineDirectiveStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgDeleteExp ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgDeleteExpStorageClass* storageArray = new SgDeleteExpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgDeleteExp_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgDeleteExpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgDeleteExpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgDerivedTypeStatement ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgDerivedTypeStatementStorageClass* storageArray = new SgDerivedTypeStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgDerivedTypeStatement_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgDerivedTypeStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgDerivedTypeStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgDesignatedInitializer ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgDesignatedInitializerStorageClass* storageArray = new SgDesignatedInitializerStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgDesignatedInitializer_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgDesignatedInitializerStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgDesignatedInitializerStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgDictionaryComprehension ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgDictionaryComprehensionStorageClass* storageArray = new SgDictionaryComprehensionStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgDictionaryComprehension_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgDictionaryComprehensionStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgDictionaryComprehensionStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgDictionaryExp ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgDictionaryExpStorageClass* storageArray = new SgDictionaryExpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgDictionaryExp_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgDictionaryExpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgDictionaryExpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgDimensionObject ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgDimensionObjectStorageClass* storageArray = new SgDimensionObjectStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgDimensionObject_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgDimensionObjectStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgDirectedGraphEdge ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgDirectedGraphEdgeStorageClass* storageArray = new SgDirectedGraphEdgeStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgDirectedGraphEdge_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgDirectedGraphEdgeStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgDirectedGraphEdgeStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgDirectory ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgDirectoryStorageClass* storageArray = new SgDirectoryStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgDirectory_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgDirectoryStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgDirectoryStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgDirectoryList ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgDirectoryListStorageClass* storageArray = new SgDirectoryListStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgDirectoryList_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgDirectoryListStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgDirectoryListStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgDivAssignOp ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgDivAssignOpStorageClass* storageArray = new SgDivAssignOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgDivAssignOp_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgDivAssignOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgDivAssignOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgDivideOp ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgDivideOpStorageClass* storageArray = new SgDivideOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgDivideOp_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgDivideOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgDivideOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgDoWhileStmt ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgDoWhileStmtStorageClass* storageArray = new SgDoWhileStmtStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgDoWhileStmt_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgDoWhileStmtStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgDoWhileStmtStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgDotExp ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgDotExpStorageClass* storageArray = new SgDotExpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgDotExp_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgDotExpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgDotExpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgDotStarOp ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgDotStarOpStorageClass* storageArray = new SgDotStarOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgDotStarOp_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgDotStarOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgDotStarOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgDoubleVal ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgDoubleValStorageClass* storageArray = new SgDoubleValStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgDoubleVal_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgDoubleValStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgDoubleValStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgElaboratedTypeModifier ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgElaboratedTypeModifierStorageClass* storageArray = new SgElaboratedTypeModifierStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgElaboratedTypeModifier_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgElaboratedTypeModifierStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgElseDirectiveStatement ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgElseDirectiveStatementStorageClass* storageArray = new SgElseDirectiveStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgElseDirectiveStatement_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgElseDirectiveStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgElseDirectiveStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgElseWhereStatement ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgElseWhereStatementStorageClass* storageArray = new SgElseWhereStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgElseWhereStatement_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgElseWhereStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgElseWhereStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgElseifDirectiveStatement ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgElseifDirectiveStatementStorageClass* storageArray = new SgElseifDirectiveStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgElseifDirectiveStatement_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgElseifDirectiveStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgElseifDirectiveStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgEmptyDirectiveStatement ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgEmptyDirectiveStatementStorageClass* storageArray = new SgEmptyDirectiveStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgEmptyDirectiveStatement_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgEmptyDirectiveStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgEmptyDirectiveStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgEndfileStatement ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgEndfileStatementStorageClass* storageArray = new SgEndfileStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgEndfileStatement_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgEndfileStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgEndfileStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgEndifDirectiveStatement ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgEndifDirectiveStatementStorageClass* storageArray = new SgEndifDirectiveStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgEndifDirectiveStatement_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgEndifDirectiveStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgEndifDirectiveStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgEntryStatement ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgEntryStatementStorageClass* storageArray = new SgEntryStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgEntryStatement_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgEntryStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgEntryStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgEnumDeclaration ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgEnumDeclarationStorageClass* storageArray = new SgEnumDeclarationStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgEnumDeclaration_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgEnumDeclarationStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgEnumDeclarationStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgEnumFieldSymbol ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgEnumFieldSymbolStorageClass* storageArray = new SgEnumFieldSymbolStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgEnumFieldSymbol_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgEnumFieldSymbolStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgEnumFieldSymbolStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgEnumSymbol ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgEnumSymbolStorageClass* storageArray = new SgEnumSymbolStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgEnumSymbol_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgEnumSymbolStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgEnumSymbolStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgEnumType ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgEnumTypeStorageClass* storageArray = new SgEnumTypeStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgEnumType_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgEnumTypeStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgEnumTypeStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgEnumVal ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgEnumValStorageClass* storageArray = new SgEnumValStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgEnumVal_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgEnumValStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgEnumValStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgEqualityOp ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgEqualityOpStorageClass* storageArray = new SgEqualityOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgEqualityOp_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgEqualityOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgEqualityOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgEquivalenceStatement ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgEquivalenceStatementStorageClass* storageArray = new SgEquivalenceStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgEquivalenceStatement_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgEquivalenceStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgEquivalenceStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgErrorDirectiveStatement ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgErrorDirectiveStatementStorageClass* storageArray = new SgErrorDirectiveStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgErrorDirectiveStatement_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgErrorDirectiveStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgErrorDirectiveStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgExecStatement ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgExecStatementStorageClass* storageArray = new SgExecStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgExecStatement_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgExecStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgExecStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgExponentiationOp ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgExponentiationOpStorageClass* storageArray = new SgExponentiationOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgExponentiationOp_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgExponentiationOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgExponentiationOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgExponentiationAssignOp ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgExponentiationAssignOpStorageClass* storageArray = new SgExponentiationAssignOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgExponentiationAssignOp_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgExponentiationAssignOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgExponentiationAssignOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgExprListExp ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgExprListExpStorageClass* storageArray = new SgExprListExpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgExprListExp_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgExprListExpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgExprListExpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgExprStatement ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgExprStatementStorageClass* storageArray = new SgExprStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgExprStatement_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgExprStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgExprStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgExpression ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgExpressionStorageClass* storageArray = new SgExpressionStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgExpression_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgExpressionStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgExpressionStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgExpressionRoot ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgExpressionRootStorageClass* storageArray = new SgExpressionRootStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgExpressionRoot_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgExpressionRootStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgExpressionRootStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgFile ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgFileStorageClass* storageArray = new SgFileStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgFile_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgFileStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgFileStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgFileList ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgFileListStorageClass* storageArray = new SgFileListStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgFileList_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgFileListStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgFileListStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgFloatVal ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgFloatValStorageClass* storageArray = new SgFloatValStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgFloatVal_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgFloatValStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgFloatValStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgFlushStatement ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgFlushStatementStorageClass* storageArray = new SgFlushStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgFlushStatement_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgFlushStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgFlushStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgForAllStatement ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgForAllStatementStorageClass* storageArray = new SgForAllStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgForAllStatement_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgForAllStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgForAllStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgForInitStatement ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgForInitStatementStorageClass* storageArray = new SgForInitStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgForInitStatement_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgForInitStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgForInitStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgForStatement ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgForStatementStorageClass* storageArray = new SgForStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgForStatement_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgForStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgForStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgFormatItem ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgFormatItemStorageClass* storageArray = new SgFormatItemStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgFormatItem_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgFormatItemStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgFormatItemList ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgFormatItemListStorageClass* storageArray = new SgFormatItemListStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgFormatItemList_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgFormatItemListStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgFormatItemListStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgFormatStatement ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgFormatStatementStorageClass* storageArray = new SgFormatStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgFormatStatement_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgFormatStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgFormatStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgFortranDo ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgFortranDoStorageClass* storageArray = new SgFortranDoStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgFortranDo_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgFortranDoStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgFortranDoStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgFortranIncludeLine ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgFortranIncludeLineStorageClass* storageArray = new SgFortranIncludeLineStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgFortranIncludeLine_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgFortranIncludeLineStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgFortranIncludeLineStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgFortranNonblockedDo ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgFortranNonblockedDoStorageClass* storageArray = new SgFortranNonblockedDoStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgFortranNonblockedDo_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgFortranNonblockedDoStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgFortranNonblockedDoStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgFuncDecl_attr ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgFuncDecl_attrStorageClass* storageArray = new SgFuncDecl_attrStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgFuncDecl_attr_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgFuncDecl_attrStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgFuncDecl_attrStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgFunctionCallExp ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgFunctionCallExpStorageClass* storageArray = new SgFunctionCallExpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgFunctionCallExp_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgFunctionCallExpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgFunctionCallExpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgFunctionDeclaration ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgFunctionDeclarationStorageClass* storageArray = new SgFunctionDeclarationStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgFunctionDeclaration_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgFunctionDeclarationStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgFunctionDeclarationStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgFunctionDefinition ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgFunctionDefinitionStorageClass* storageArray = new SgFunctionDefinitionStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgFunctionDefinition_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgFunctionDefinitionStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgFunctionDefinitionStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgFunctionModifier ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgFunctionModifierStorageClass* storageArray = new SgFunctionModifierStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgFunctionModifier_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgFunctionModifierStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgFunctionModifierStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgFunctionParameterList ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgFunctionParameterListStorageClass* storageArray = new SgFunctionParameterListStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgFunctionParameterList_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgFunctionParameterListStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgFunctionParameterListStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgFunctionParameterTypeList ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgFunctionParameterTypeListStorageClass* storageArray = new SgFunctionParameterTypeListStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgFunctionParameterTypeList_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgFunctionParameterTypeListStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgFunctionParameterTypeListStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgFunctionRefExp ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgFunctionRefExpStorageClass* storageArray = new SgFunctionRefExpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgFunctionRefExp_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgFunctionRefExpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgFunctionRefExpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgFunctionSymbol ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgFunctionSymbolStorageClass* storageArray = new SgFunctionSymbolStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgFunctionSymbol_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgFunctionSymbolStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgFunctionSymbolStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgFunctionType ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgFunctionTypeStorageClass* storageArray = new SgFunctionTypeStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgFunctionType_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgFunctionTypeStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgFunctionTypeStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgFunctionTypeSymbol ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgFunctionTypeSymbolStorageClass* storageArray = new SgFunctionTypeSymbolStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgFunctionTypeSymbol_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgFunctionTypeSymbolStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgFunctionTypeSymbolStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgFunctionTypeTable ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgFunctionTypeTableStorageClass* storageArray = new SgFunctionTypeTableStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgFunctionTypeTable_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgFunctionTypeTableStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgFunctionTypeTableStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgTypeTable ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeTableStorageClass* storageArray = new SgTypeTableStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgTypeTable_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgTypeTableStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgGlobal ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgGlobalStorageClass* storageArray = new SgGlobalStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgGlobal_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgGlobalStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgGlobalStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgGotoStatement ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgGotoStatementStorageClass* storageArray = new SgGotoStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgGotoStatement_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgGotoStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgGotoStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgGraph ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgGraphStorageClass* storageArray = new SgGraphStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgGraph_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgGraphStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgGraphStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgGraphEdge ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgGraphEdgeStorageClass* storageArray = new SgGraphEdgeStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgGraphEdge_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgGraphEdgeStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgGraphEdgeStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgGraphEdgeList ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgGraphEdgeListStorageClass* storageArray = new SgGraphEdgeListStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgGraphEdgeList_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgGraphEdgeListStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgGraphNode ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgGraphNodeStorageClass* storageArray = new SgGraphNodeStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgGraphNode_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgGraphNodeStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgGraphNodeStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgGraphNodeList ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgGraphNodeListStorageClass* storageArray = new SgGraphNodeListStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgGraphNodeList_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgGraphNodeListStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgGreaterOrEqualOp ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgGreaterOrEqualOpStorageClass* storageArray = new SgGreaterOrEqualOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgGreaterOrEqualOp_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgGreaterOrEqualOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgGreaterOrEqualOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgGreaterThanOp ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgGreaterThanOpStorageClass* storageArray = new SgGreaterThanOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgGreaterThanOp_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgGreaterThanOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgGreaterThanOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgIOItemExpression ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgIOItemExpressionStorageClass* storageArray = new SgIOItemExpressionStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgIOItemExpression_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgIOItemExpressionStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgIOItemExpressionStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgIOStatement ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgIOStatementStorageClass* storageArray = new SgIOStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgIOStatement_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgIOStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgIOStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgIdentDirectiveStatement ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgIdentDirectiveStatementStorageClass* storageArray = new SgIdentDirectiveStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgIdentDirectiveStatement_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgIdentDirectiveStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgIdentDirectiveStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgIfDirectiveStatement ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgIfDirectiveStatementStorageClass* storageArray = new SgIfDirectiveStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgIfDirectiveStatement_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgIfDirectiveStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgIfDirectiveStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgIfStmt ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgIfStmtStorageClass* storageArray = new SgIfStmtStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgIfStmt_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgIfStmtStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgIfStmtStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgIfdefDirectiveStatement ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgIfdefDirectiveStatementStorageClass* storageArray = new SgIfdefDirectiveStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgIfdefDirectiveStatement_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgIfdefDirectiveStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgIfdefDirectiveStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgIfndefDirectiveStatement ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgIfndefDirectiveStatementStorageClass* storageArray = new SgIfndefDirectiveStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgIfndefDirectiveStatement_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgIfndefDirectiveStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgIfndefDirectiveStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgImagPartOp ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgImagPartOpStorageClass* storageArray = new SgImagPartOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgImagPartOp_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgImagPartOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgImagPartOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgImplicitStatement ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgImplicitStatementStorageClass* storageArray = new SgImplicitStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgImplicitStatement_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgImplicitStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgImplicitStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgImpliedDo ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgImpliedDoStorageClass* storageArray = new SgImpliedDoStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgImpliedDo_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgImpliedDoStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgImpliedDoStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgImportStatement ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgImportStatementStorageClass* storageArray = new SgImportStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgImportStatement_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgImportStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgImportStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgIncidenceDirectedGraph ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgIncidenceDirectedGraphStorageClass* storageArray = new SgIncidenceDirectedGraphStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgIncidenceDirectedGraph_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgIncidenceDirectedGraphStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgIncidenceDirectedGraphStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgIncidenceUndirectedGraph ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgIncidenceUndirectedGraphStorageClass* storageArray = new SgIncidenceUndirectedGraphStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgIncidenceUndirectedGraph_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgIncidenceUndirectedGraphStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgIncidenceUndirectedGraphStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgIncludeDirectiveStatement ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgIncludeDirectiveStatementStorageClass* storageArray = new SgIncludeDirectiveStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgIncludeDirectiveStatement_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgIncludeDirectiveStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgIncludeDirectiveStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgIncludeNextDirectiveStatement ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgIncludeNextDirectiveStatementStorageClass* storageArray = new SgIncludeNextDirectiveStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgIncludeNextDirectiveStatement_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgIncludeNextDirectiveStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgIncludeNextDirectiveStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgInitializedName ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgInitializedNameStorageClass* storageArray = new SgInitializedNameStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgInitializedName_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgInitializedNameStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgInitializedNameStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgInitializer ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgInitializerStorageClass* storageArray = new SgInitializerStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgInitializer_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgInitializerStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgInitializerStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgInquireStatement ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgInquireStatementStorageClass* storageArray = new SgInquireStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgInquireStatement_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgInquireStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgInquireStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgIntKeyedBidirectionalGraph ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgIntKeyedBidirectionalGraphStorageClass* storageArray = new SgIntKeyedBidirectionalGraphStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgIntKeyedBidirectionalGraph_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgIntKeyedBidirectionalGraphStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgIntKeyedBidirectionalGraphStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgIntVal ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgIntValStorageClass* storageArray = new SgIntValStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgIntVal_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgIntValStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgIntValStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgIntegerDivideOp ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgIntegerDivideOpStorageClass* storageArray = new SgIntegerDivideOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgIntegerDivideOp_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgIntegerDivideOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgIntegerDivideOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgIntegerDivideAssignOp ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgIntegerDivideAssignOpStorageClass* storageArray = new SgIntegerDivideAssignOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgIntegerDivideAssignOp_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgIntegerDivideAssignOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgIntegerDivideAssignOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgInterfaceBody ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgInterfaceBodyStorageClass* storageArray = new SgInterfaceBodyStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgInterfaceBody_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgInterfaceBodyStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgInterfaceBodyStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgHeaderFileBody ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgHeaderFileBodyStorageClass* storageArray = new SgHeaderFileBodyStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgHeaderFileBody_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgHeaderFileBodyStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgHeaderFileBodyStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgInterfaceStatement ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgInterfaceStatementStorageClass* storageArray = new SgInterfaceStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgInterfaceStatement_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgInterfaceStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgInterfaceStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgInterfaceSymbol ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgInterfaceSymbolStorageClass* storageArray = new SgInterfaceSymbolStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgInterfaceSymbol_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgInterfaceSymbolStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgInterfaceSymbolStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgIntrinsicSymbol ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgIntrinsicSymbolStorageClass* storageArray = new SgIntrinsicSymbolStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgIntrinsicSymbol_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgIntrinsicSymbolStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgIntrinsicSymbolStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgIsOp ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgIsOpStorageClass* storageArray = new SgIsOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgIsOp_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgIsOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgIsOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgIsNotOp ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgIsNotOpStorageClass* storageArray = new SgIsNotOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgIsNotOp_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgIsNotOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgIsNotOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgIorAssignOp ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgIorAssignOpStorageClass* storageArray = new SgIorAssignOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgIorAssignOp_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgIorAssignOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgIorAssignOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgKeyDatumPair ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgKeyDatumPairStorageClass* storageArray = new SgKeyDatumPairStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgKeyDatumPair_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgKeyDatumPairStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgKeyDatumPairStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgCudaKernelExecConfig ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgCudaKernelExecConfigStorageClass* storageArray = new SgCudaKernelExecConfigStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgCudaKernelExecConfig_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgCudaKernelExecConfigStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgCudaKernelExecConfigStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgCudaKernelCallExp ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgCudaKernelCallExpStorageClass* storageArray = new SgCudaKernelCallExpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgCudaKernelCallExp_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgCudaKernelCallExpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgCudaKernelCallExpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgLabelRefExp ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgLabelRefExpStorageClass* storageArray = new SgLabelRefExpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgLabelRefExp_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgLabelRefExpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgLabelRefExpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgLabelStatement ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgLabelStatementStorageClass* storageArray = new SgLabelStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgLabelStatement_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgLabelStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgLabelStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgJavaLabelStatement ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgJavaLabelStatementStorageClass* storageArray = new SgJavaLabelStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgJavaLabelStatement_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgJavaLabelStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgJavaLabelStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgLabelSymbol ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgLabelSymbolStorageClass* storageArray = new SgLabelSymbolStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgLabelSymbol_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgLabelSymbolStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgLabelSymbolStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgJavaLabelSymbol ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgJavaLabelSymbolStorageClass* storageArray = new SgJavaLabelSymbolStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgJavaLabelSymbol_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgJavaLabelSymbolStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgJavaLabelSymbolStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgLambdaRefExp ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgLambdaRefExpStorageClass* storageArray = new SgLambdaRefExpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgLambdaRefExp_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgLambdaRefExpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgLambdaRefExpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgLessOrEqualOp ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgLessOrEqualOpStorageClass* storageArray = new SgLessOrEqualOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgLessOrEqualOp_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgLessOrEqualOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgLessOrEqualOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgLessThanOp ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgLessThanOpStorageClass* storageArray = new SgLessThanOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgLessThanOp_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgLessThanOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgLessThanOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgLineDirectiveStatement ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgLineDirectiveStatementStorageClass* storageArray = new SgLineDirectiveStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgLineDirectiveStatement_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgLineDirectiveStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgLineDirectiveStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgLinemarkerDirectiveStatement ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgLinemarkerDirectiveStatementStorageClass* storageArray = new SgLinemarkerDirectiveStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgLinemarkerDirectiveStatement_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgLinemarkerDirectiveStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgLinemarkerDirectiveStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgLinkageModifier ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgLinkageModifierStorageClass* storageArray = new SgLinkageModifierStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgLinkageModifier_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgLinkageModifierStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgListComprehension ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgListComprehensionStorageClass* storageArray = new SgListComprehensionStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgListComprehension_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgListComprehensionStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgListComprehensionStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgListExp ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgListExpStorageClass* storageArray = new SgListExpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgListExp_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgListExpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgListExpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgLocatedNode ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgLocatedNodeStorageClass* storageArray = new SgLocatedNodeStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgLocatedNode_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgLocatedNodeStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgLocatedNodeStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgLocatedNodeSupport ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgLocatedNodeSupportStorageClass* storageArray = new SgLocatedNodeSupportStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgLocatedNodeSupport_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgLocatedNodeSupportStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgLocatedNodeSupportStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgLongDoubleVal ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgLongDoubleValStorageClass* storageArray = new SgLongDoubleValStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgLongDoubleVal_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgLongDoubleValStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgLongDoubleValStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgLongIntVal ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgLongIntValStorageClass* storageArray = new SgLongIntValStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgLongIntVal_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgLongIntValStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgLongIntValStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgLongLongIntVal ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgLongLongIntValStorageClass* storageArray = new SgLongLongIntValStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgLongLongIntVal_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgLongLongIntValStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgLongLongIntValStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgLshiftAssignOp ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgLshiftAssignOpStorageClass* storageArray = new SgLshiftAssignOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgLshiftAssignOp_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgLshiftAssignOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgLshiftAssignOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgLshiftOp ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgLshiftOpStorageClass* storageArray = new SgLshiftOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgLshiftOp_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgLshiftOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgLshiftOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgMemberFunctionDeclaration ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgMemberFunctionDeclarationStorageClass* storageArray = new SgMemberFunctionDeclarationStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgMemberFunctionDeclaration_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgMemberFunctionDeclarationStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgMemberFunctionDeclarationStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgMemberFunctionRefExp ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgMemberFunctionRefExpStorageClass* storageArray = new SgMemberFunctionRefExpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgMemberFunctionRefExp_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgMemberFunctionRefExpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgMemberFunctionRefExpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgMemberFunctionSymbol ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgMemberFunctionSymbolStorageClass* storageArray = new SgMemberFunctionSymbolStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgMemberFunctionSymbol_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgMemberFunctionSymbolStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgMemberFunctionSymbolStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgMemberFunctionType ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgMemberFunctionTypeStorageClass* storageArray = new SgMemberFunctionTypeStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgMemberFunctionType_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgMemberFunctionTypeStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgMemberFunctionTypeStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgMembershipOp ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgMembershipOpStorageClass* storageArray = new SgMembershipOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgMembershipOp_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgMembershipOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgMembershipOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgMinusAssignOp ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgMinusAssignOpStorageClass* storageArray = new SgMinusAssignOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgMinusAssignOp_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgMinusAssignOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgMinusAssignOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgMinusMinusOp ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgMinusMinusOpStorageClass* storageArray = new SgMinusMinusOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgMinusMinusOp_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgMinusMinusOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgMinusMinusOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgMinusOp ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgMinusOpStorageClass* storageArray = new SgMinusOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgMinusOp_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgMinusOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgMinusOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgModAssignOp ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgModAssignOpStorageClass* storageArray = new SgModAssignOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgModAssignOp_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgModAssignOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgModAssignOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgModOp ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgModOpStorageClass* storageArray = new SgModOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgModOp_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgModOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgModOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgModifier ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgModifierStorageClass* storageArray = new SgModifierStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgModifier_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgModifierStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgModifierNodes ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgModifierNodesStorageClass* storageArray = new SgModifierNodesStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgModifierNodes_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgModifierNodesStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgModifierNodesStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgModifierType ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgModifierTypeStorageClass* storageArray = new SgModifierTypeStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgModifierType_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgModifierTypeStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgModifierTypeStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgModuleStatement ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgModuleStatementStorageClass* storageArray = new SgModuleStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgModuleStatement_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgModuleStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgModuleStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgModuleSymbol ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgModuleSymbolStorageClass* storageArray = new SgModuleSymbolStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgModuleSymbol_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgModuleSymbolStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgModuleSymbolStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgMultAssignOp ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgMultAssignOpStorageClass* storageArray = new SgMultAssignOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgMultAssignOp_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgMultAssignOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgMultAssignOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgMultiplyOp ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgMultiplyOpStorageClass* storageArray = new SgMultiplyOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgMultiplyOp_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgMultiplyOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgMultiplyOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgName ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgNameStorageClass* storageArray = new SgNameStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgName_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgNameStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgNameGroup ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgNameGroupStorageClass* storageArray = new SgNameGroupStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgNameGroup_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgNameGroupStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgNameGroupStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgNamedType ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgNamedTypeStorageClass* storageArray = new SgNamedTypeStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgNamedType_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgNamedTypeStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgNamedTypeStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgNamelistStatement ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgNamelistStatementStorageClass* storageArray = new SgNamelistStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgNamelistStatement_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgNamelistStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgNamelistStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgNamespaceAliasDeclarationStatement ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgNamespaceAliasDeclarationStatementStorageClass* storageArray = new SgNamespaceAliasDeclarationStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgNamespaceAliasDeclarationStatement_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgNamespaceAliasDeclarationStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgNamespaceAliasDeclarationStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgNamespaceDeclarationStatement ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgNamespaceDeclarationStatementStorageClass* storageArray = new SgNamespaceDeclarationStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgNamespaceDeclarationStatement_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgNamespaceDeclarationStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgNamespaceDeclarationStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgNamespaceDefinitionStatement ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgNamespaceDefinitionStatementStorageClass* storageArray = new SgNamespaceDefinitionStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgNamespaceDefinitionStatement_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgNamespaceDefinitionStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgNamespaceDefinitionStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgNamespaceSymbol ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgNamespaceSymbolStorageClass* storageArray = new SgNamespaceSymbolStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgNamespaceSymbol_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgNamespaceSymbolStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgNamespaceSymbolStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgNaryOp ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgNaryOpStorageClass* storageArray = new SgNaryOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgNaryOp_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgNaryOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgNaryOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgNaryBooleanOp ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgNaryBooleanOpStorageClass* storageArray = new SgNaryBooleanOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgNaryBooleanOp_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgNaryBooleanOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgNaryBooleanOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgNaryComparisonOp ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgNaryComparisonOpStorageClass* storageArray = new SgNaryComparisonOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgNaryComparisonOp_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgNaryComparisonOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgNaryComparisonOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgNewExp ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgNewExpStorageClass* storageArray = new SgNewExpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgNewExp_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgNewExpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgNewExpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgNode ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgNodeStorageClass* storageArray = new SgNodeStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgNode_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgNodeStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgNotEqualOp ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgNotEqualOpStorageClass* storageArray = new SgNotEqualOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgNotEqualOp_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgNotEqualOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgNotEqualOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgNotOp ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgNotOpStorageClass* storageArray = new SgNotOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgNotOp_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgNotOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgNotOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgNonMembershipOp ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgNonMembershipOpStorageClass* storageArray = new SgNonMembershipOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgNonMembershipOp_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgNonMembershipOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgNonMembershipOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgNullExpression ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgNullExpressionStorageClass* storageArray = new SgNullExpressionStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgNullExpression_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgNullExpressionStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgNullExpressionStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgNullStatement ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgNullStatementStorageClass* storageArray = new SgNullStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgNullStatement_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgNullStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgNullStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgNullifyStatement ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgNullifyStatementStorageClass* storageArray = new SgNullifyStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgNullifyStatement_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgNullifyStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgNullifyStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgOmpAtomicStatement ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpAtomicStatementStorageClass* storageArray = new SgOmpAtomicStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgOmpAtomicStatement_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgOmpAtomicStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgOmpAtomicStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgOmpBarrierStatement ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpBarrierStatementStorageClass* storageArray = new SgOmpBarrierStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgOmpBarrierStatement_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgOmpBarrierStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgOmpBarrierStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgOmpCriticalStatement ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpCriticalStatementStorageClass* storageArray = new SgOmpCriticalStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgOmpCriticalStatement_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgOmpCriticalStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgOmpCriticalStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgOmpClauseBodyStatement ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpClauseBodyStatementStorageClass* storageArray = new SgOmpClauseBodyStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgOmpClauseBodyStatement_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgOmpClauseBodyStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgOmpClauseBodyStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgOmpBodyStatement ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpBodyStatementStorageClass* storageArray = new SgOmpBodyStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgOmpBodyStatement_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgOmpBodyStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgOmpBodyStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgOmpDoStatement ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpDoStatementStorageClass* storageArray = new SgOmpDoStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgOmpDoStatement_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgOmpDoStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgOmpDoStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgOmpFlushStatement ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpFlushStatementStorageClass* storageArray = new SgOmpFlushStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgOmpFlushStatement_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgOmpFlushStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgOmpFlushStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgOmpForStatement ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpForStatementStorageClass* storageArray = new SgOmpForStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgOmpForStatement_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgOmpForStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgOmpForStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgOmpMasterStatement ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpMasterStatementStorageClass* storageArray = new SgOmpMasterStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgOmpMasterStatement_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgOmpMasterStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgOmpMasterStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgOmpOrderedStatement ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpOrderedStatementStorageClass* storageArray = new SgOmpOrderedStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgOmpOrderedStatement_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgOmpOrderedStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgOmpOrderedStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgOmpParallelStatement ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpParallelStatementStorageClass* storageArray = new SgOmpParallelStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgOmpParallelStatement_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgOmpParallelStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgOmpParallelStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgOmpSectionStatement ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpSectionStatementStorageClass* storageArray = new SgOmpSectionStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgOmpSectionStatement_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgOmpSectionStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgOmpSectionStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgOmpSectionsStatement ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpSectionsStatementStorageClass* storageArray = new SgOmpSectionsStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgOmpSectionsStatement_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgOmpSectionsStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgOmpSectionsStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgOmpSingleStatement ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpSingleStatementStorageClass* storageArray = new SgOmpSingleStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgOmpSingleStatement_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgOmpSingleStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgOmpSingleStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgOmpTaskStatement ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpTaskStatementStorageClass* storageArray = new SgOmpTaskStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgOmpTaskStatement_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgOmpTaskStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgOmpTaskStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgOmpTaskwaitStatement ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpTaskwaitStatementStorageClass* storageArray = new SgOmpTaskwaitStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgOmpTaskwaitStatement_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgOmpTaskwaitStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgOmpTaskwaitStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgOmpThreadprivateStatement ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpThreadprivateStatementStorageClass* storageArray = new SgOmpThreadprivateStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgOmpThreadprivateStatement_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgOmpThreadprivateStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgOmpThreadprivateStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgOmpWorkshareStatement ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpWorkshareStatementStorageClass* storageArray = new SgOmpWorkshareStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgOmpWorkshareStatement_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgOmpWorkshareStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgOmpWorkshareStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgOmpClause ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpClauseStorageClass* storageArray = new SgOmpClauseStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgOmpClause_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgOmpClauseStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgOmpClauseStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgOmpCollapseClause ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpCollapseClauseStorageClass* storageArray = new SgOmpCollapseClauseStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgOmpCollapseClause_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgOmpCollapseClauseStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgOmpCollapseClauseStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgOmpCopyinClause ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpCopyinClauseStorageClass* storageArray = new SgOmpCopyinClauseStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgOmpCopyinClause_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgOmpCopyinClauseStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgOmpCopyinClauseStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgOmpCopyprivateClause ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpCopyprivateClauseStorageClass* storageArray = new SgOmpCopyprivateClauseStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgOmpCopyprivateClause_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgOmpCopyprivateClauseStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgOmpCopyprivateClauseStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgOmpDefaultClause ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpDefaultClauseStorageClass* storageArray = new SgOmpDefaultClauseStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgOmpDefaultClause_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgOmpDefaultClauseStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgOmpDefaultClauseStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgOmpExpressionClause ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpExpressionClauseStorageClass* storageArray = new SgOmpExpressionClauseStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgOmpExpressionClause_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgOmpExpressionClauseStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgOmpExpressionClauseStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgOmpFirstprivateClause ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpFirstprivateClauseStorageClass* storageArray = new SgOmpFirstprivateClauseStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgOmpFirstprivateClause_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgOmpFirstprivateClauseStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgOmpFirstprivateClauseStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgOmpIfClause ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpIfClauseStorageClass* storageArray = new SgOmpIfClauseStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgOmpIfClause_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgOmpIfClauseStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgOmpIfClauseStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgOmpLastprivateClause ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpLastprivateClauseStorageClass* storageArray = new SgOmpLastprivateClauseStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgOmpLastprivateClause_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgOmpLastprivateClauseStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgOmpLastprivateClauseStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgOmpNowaitClause ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpNowaitClauseStorageClass* storageArray = new SgOmpNowaitClauseStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgOmpNowaitClause_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgOmpNowaitClauseStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgOmpNowaitClauseStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgOmpNumThreadsClause ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpNumThreadsClauseStorageClass* storageArray = new SgOmpNumThreadsClauseStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgOmpNumThreadsClause_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgOmpNumThreadsClauseStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgOmpNumThreadsClauseStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgOmpOrderedClause ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpOrderedClauseStorageClass* storageArray = new SgOmpOrderedClauseStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgOmpOrderedClause_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgOmpOrderedClauseStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgOmpOrderedClauseStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgOmpPrivateClause ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpPrivateClauseStorageClass* storageArray = new SgOmpPrivateClauseStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgOmpPrivateClause_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgOmpPrivateClauseStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgOmpPrivateClauseStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgOmpReductionClause ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpReductionClauseStorageClass* storageArray = new SgOmpReductionClauseStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgOmpReductionClause_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgOmpReductionClauseStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgOmpReductionClauseStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgOmpScheduleClause ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpScheduleClauseStorageClass* storageArray = new SgOmpScheduleClauseStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgOmpScheduleClause_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgOmpScheduleClauseStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgOmpScheduleClauseStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgOmpSharedClause ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpSharedClauseStorageClass* storageArray = new SgOmpSharedClauseStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgOmpSharedClause_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgOmpSharedClauseStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgOmpSharedClauseStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgOmpUntiedClause ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpUntiedClauseStorageClass* storageArray = new SgOmpUntiedClauseStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgOmpUntiedClause_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgOmpUntiedClauseStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgOmpUntiedClauseStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgOmpVariablesClause ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOmpVariablesClauseStorageClass* storageArray = new SgOmpVariablesClauseStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgOmpVariablesClause_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgOmpVariablesClauseStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgOmpVariablesClauseStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgOpenclAccessModeModifier ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOpenclAccessModeModifierStorageClass* storageArray = new SgOpenclAccessModeModifierStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgOpenclAccessModeModifier_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgOpenclAccessModeModifierStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgOpenStatement ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOpenStatementStorageClass* storageArray = new SgOpenStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgOpenStatement_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgOpenStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgOpenStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgOptions ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOptionsStorageClass* storageArray = new SgOptionsStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgOptions_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgOptionsStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgOrOp ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgOrOpStorageClass* storageArray = new SgOrOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgOrOp_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgOrOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgOrOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgParameterStatement ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgParameterStatementStorageClass* storageArray = new SgParameterStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgParameterStatement_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgParameterStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgParameterStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgPartialFunctionModifierType ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgPartialFunctionModifierTypeStorageClass* storageArray = new SgPartialFunctionModifierTypeStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgPartialFunctionModifierType_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgPartialFunctionModifierTypeStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgPartialFunctionModifierTypeStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgPartialFunctionType ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgPartialFunctionTypeStorageClass* storageArray = new SgPartialFunctionTypeStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgPartialFunctionType_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgPartialFunctionTypeStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgPartialFunctionTypeStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgPassStatement ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgPassStatementStorageClass* storageArray = new SgPassStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgPassStatement_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgPassStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgPassStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgPlusAssignOp ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgPlusAssignOpStorageClass* storageArray = new SgPlusAssignOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgPlusAssignOp_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgPlusAssignOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgPlusAssignOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgPlusPlusOp ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgPlusPlusOpStorageClass* storageArray = new SgPlusPlusOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgPlusPlusOp_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgPlusPlusOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgPlusPlusOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgPntrArrRefExp ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgPntrArrRefExpStorageClass* storageArray = new SgPntrArrRefExpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgPntrArrRefExp_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgPntrArrRefExpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgPntrArrRefExpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgPointerAssignOp ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgPointerAssignOpStorageClass* storageArray = new SgPointerAssignOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgPointerAssignOp_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgPointerAssignOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgPointerAssignOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgPointerDerefExp ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgPointerDerefExpStorageClass* storageArray = new SgPointerDerefExpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgPointerDerefExp_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgPointerDerefExpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgPointerDerefExpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgPointerMemberType ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgPointerMemberTypeStorageClass* storageArray = new SgPointerMemberTypeStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgPointerMemberType_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgPointerMemberTypeStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgPointerMemberTypeStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgPointerType ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgPointerTypeStorageClass* storageArray = new SgPointerTypeStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgPointerType_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgPointerTypeStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgPointerTypeStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgPragma ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgPragmaStorageClass* storageArray = new SgPragmaStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgPragma_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgPragmaStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgPragmaStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgPragmaDeclaration ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgPragmaDeclarationStorageClass* storageArray = new SgPragmaDeclarationStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgPragmaDeclaration_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgPragmaDeclarationStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgPragmaDeclarationStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgPrintStatement ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgPrintStatementStorageClass* storageArray = new SgPrintStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgPrintStatement_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgPrintStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgPrintStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgProcedureHeaderStatement ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgProcedureHeaderStatementStorageClass* storageArray = new SgProcedureHeaderStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgProcedureHeaderStatement_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgProcedureHeaderStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgProcedureHeaderStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgProgramHeaderStatement ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgProgramHeaderStatementStorageClass* storageArray = new SgProgramHeaderStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgProgramHeaderStatement_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgProgramHeaderStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgProgramHeaderStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgProject ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgProjectStorageClass* storageArray = new SgProjectStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgProject_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgProjectStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgProjectStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgPseudoDestructorRefExp ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgPseudoDestructorRefExpStorageClass* storageArray = new SgPseudoDestructorRefExpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgPseudoDestructorRefExp_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgPseudoDestructorRefExpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgPseudoDestructorRefExpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgPythonGlobalStmt ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgPythonGlobalStmtStorageClass* storageArray = new SgPythonGlobalStmtStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgPythonGlobalStmt_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgPythonGlobalStmtStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgPythonGlobalStmtStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgPythonPrintStmt ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgPythonPrintStmtStorageClass* storageArray = new SgPythonPrintStmtStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgPythonPrintStmt_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgPythonPrintStmtStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgPythonPrintStmtStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgQualifiedName ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgQualifiedNameStorageClass* storageArray = new SgQualifiedNameStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgQualifiedName_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgQualifiedNameStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgQualifiedNameType ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgQualifiedNameTypeStorageClass* storageArray = new SgQualifiedNameTypeStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgQualifiedNameType_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgQualifiedNameTypeStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgQualifiedNameTypeStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgReadStatement ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgReadStatementStorageClass* storageArray = new SgReadStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgReadStatement_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgReadStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgReadStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgRealPartOp ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgRealPartOpStorageClass* storageArray = new SgRealPartOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgRealPartOp_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgRealPartOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgRealPartOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgRefExp ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgRefExpStorageClass* storageArray = new SgRefExpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgRefExp_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgRefExpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgRefExpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgReferenceType ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgReferenceTypeStorageClass* storageArray = new SgReferenceTypeStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgReferenceType_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgReferenceTypeStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgReferenceTypeStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgRenamePair ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgRenamePairStorageClass* storageArray = new SgRenamePairStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgRenamePair_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgRenamePairStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgRenamePairStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgRenameSymbol ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgRenameSymbolStorageClass* storageArray = new SgRenameSymbolStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgRenameSymbol_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgRenameSymbolStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgRenameSymbolStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgReturnStmt ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgReturnStmtStorageClass* storageArray = new SgReturnStmtStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgReturnStmt_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgReturnStmtStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgReturnStmtStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgRewindStatement ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgRewindStatementStorageClass* storageArray = new SgRewindStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgRewindStatement_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgRewindStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgRewindStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgRshiftAssignOp ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgRshiftAssignOpStorageClass* storageArray = new SgRshiftAssignOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgRshiftAssignOp_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgRshiftAssignOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgRshiftAssignOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgRshiftOp ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgRshiftOpStorageClass* storageArray = new SgRshiftOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgRshiftOp_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgRshiftOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgRshiftOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgJavaUnsignedRshiftAssignOp ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgJavaUnsignedRshiftAssignOpStorageClass* storageArray = new SgJavaUnsignedRshiftAssignOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgJavaUnsignedRshiftAssignOp_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgJavaUnsignedRshiftAssignOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgJavaUnsignedRshiftAssignOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgJavaUnsignedRshiftOp ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgJavaUnsignedRshiftOpStorageClass* storageArray = new SgJavaUnsignedRshiftOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgJavaUnsignedRshiftOp_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgJavaUnsignedRshiftOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgJavaUnsignedRshiftOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgScopeOp ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgScopeOpStorageClass* storageArray = new SgScopeOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgScopeOp_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgScopeOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgScopeOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgScopeStatement ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgScopeStatementStorageClass* storageArray = new SgScopeStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgScopeStatement_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgScopeStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgScopeStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgSequenceStatement ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgSequenceStatementStorageClass* storageArray = new SgSequenceStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgSequenceStatement_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgSequenceStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgSequenceStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgSetComprehension ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgSetComprehensionStorageClass* storageArray = new SgSetComprehensionStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgSetComprehension_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgSetComprehensionStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgSetComprehensionStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgShortVal ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgShortValStorageClass* storageArray = new SgShortValStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgShortVal_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgShortValStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgShortValStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgSizeOfOp ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgSizeOfOpStorageClass* storageArray = new SgSizeOfOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgSizeOfOp_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgSizeOfOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgSizeOfOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgJavaInstanceOfOp ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgJavaInstanceOfOpStorageClass* storageArray = new SgJavaInstanceOfOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgJavaInstanceOfOp_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgJavaInstanceOfOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgJavaInstanceOfOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgSourceFile ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgSourceFileStorageClass* storageArray = new SgSourceFileStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgSourceFile_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgSourceFileStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgSourceFileStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgSpawnStmt ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgSpawnStmtStorageClass* storageArray = new SgSpawnStmtStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgSpawnStmt_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgSpawnStmtStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgSpawnStmtStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgJavaThrowStatement ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgJavaThrowStatementStorageClass* storageArray = new SgJavaThrowStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgJavaThrowStatement_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgJavaThrowStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgJavaThrowStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgJavaForEachStatement ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgJavaForEachStatementStorageClass* storageArray = new SgJavaForEachStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgJavaForEachStatement_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgJavaForEachStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgJavaForEachStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgJavaSynchronizedStatement ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgJavaSynchronizedStatementStorageClass* storageArray = new SgJavaSynchronizedStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgJavaSynchronizedStatement_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgJavaSynchronizedStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgJavaSynchronizedStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgJavaParameterizedType ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgJavaParameterizedTypeStorageClass* storageArray = new SgJavaParameterizedTypeStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgJavaParameterizedType_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgJavaParameterizedTypeStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgJavaParameterizedTypeStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgSpecialFunctionModifier ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgSpecialFunctionModifierStorageClass* storageArray = new SgSpecialFunctionModifierStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgSpecialFunctionModifier_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgSpecialFunctionModifierStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgSpecialFunctionModifierStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgStatement ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgStatementStorageClass* storageArray = new SgStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgStatement_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgStmtDeclarationStatement ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgStmtDeclarationStatementStorageClass* storageArray = new SgStmtDeclarationStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgStmtDeclarationStatement_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgStmtDeclarationStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgStmtDeclarationStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgStatementExpression ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgStatementExpressionStorageClass* storageArray = new SgStatementExpressionStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgStatementExpression_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgStatementExpressionStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgStatementExpressionStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgStatementFunctionStatement ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgStatementFunctionStatementStorageClass* storageArray = new SgStatementFunctionStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgStatementFunctionStatement_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgStatementFunctionStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgStatementFunctionStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgStopOrPauseStatement ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgStopOrPauseStatementStorageClass* storageArray = new SgStopOrPauseStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgStopOrPauseStatement_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgStopOrPauseStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgStopOrPauseStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgStorageModifier ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgStorageModifierStorageClass* storageArray = new SgStorageModifierStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgStorageModifier_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgStorageModifierStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgStringConversion ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgStringConversionStorageClass* storageArray = new SgStringConversionStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgStringConversion_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgStringConversionStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgStringConversionStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgStringKeyedBidirectionalGraph ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgStringKeyedBidirectionalGraphStorageClass* storageArray = new SgStringKeyedBidirectionalGraphStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgStringKeyedBidirectionalGraph_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgStringKeyedBidirectionalGraphStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgStringKeyedBidirectionalGraphStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgStringVal ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgStringValStorageClass* storageArray = new SgStringValStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgStringVal_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgStringValStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgStringValStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgSubscriptExpression ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgSubscriptExpressionStorageClass* storageArray = new SgSubscriptExpressionStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgSubscriptExpression_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgSubscriptExpressionStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgSubscriptExpressionStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgSubtractOp ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgSubtractOpStorageClass* storageArray = new SgSubtractOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgSubtractOp_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgSubtractOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgSubtractOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgSupport ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgSupportStorageClass* storageArray = new SgSupportStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgSupport_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgSupportStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgSwitchStatement ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgSwitchStatementStorageClass* storageArray = new SgSwitchStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgSwitchStatement_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgSwitchStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgSwitchStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgSymbolTable ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgSymbolTableStorageClass* storageArray = new SgSymbolTableStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgSymbolTable_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgSymbolTableStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgSymbolTableStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgTemplateArgument ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTemplateArgumentStorageClass* storageArray = new SgTemplateArgumentStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgTemplateArgument_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgTemplateArgumentStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgTemplateArgumentList ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTemplateArgumentListStorageClass* storageArray = new SgTemplateArgumentListStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgTemplateArgumentList_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgTemplateArgumentListStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgTemplateArgumentListStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgTemplateDeclaration ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTemplateDeclarationStorageClass* storageArray = new SgTemplateDeclarationStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgTemplateDeclaration_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgTemplateDeclarationStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgTemplateDeclarationStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgTemplateClassDeclaration ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTemplateClassDeclarationStorageClass* storageArray = new SgTemplateClassDeclarationStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgTemplateClassDeclaration_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgTemplateClassDeclarationStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgTemplateClassDeclarationStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgTemplateFunctionDeclaration ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTemplateFunctionDeclarationStorageClass* storageArray = new SgTemplateFunctionDeclarationStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgTemplateFunctionDeclaration_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgTemplateFunctionDeclarationStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgTemplateFunctionDeclarationStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgTemplateMemberFunctionDeclaration ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTemplateMemberFunctionDeclarationStorageClass* storageArray = new SgTemplateMemberFunctionDeclarationStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgTemplateMemberFunctionDeclaration_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgTemplateMemberFunctionDeclarationStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgTemplateMemberFunctionDeclarationStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgTemplateClassDefinition ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTemplateClassDefinitionStorageClass* storageArray = new SgTemplateClassDefinitionStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgTemplateClassDefinition_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgTemplateClassDefinitionStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgTemplateClassDefinitionStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgTemplateFunctionDefinition ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTemplateFunctionDefinitionStorageClass* storageArray = new SgTemplateFunctionDefinitionStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgTemplateFunctionDefinition_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgTemplateFunctionDefinitionStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgTemplateFunctionDefinitionStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgTemplateInstantiationDecl ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTemplateInstantiationDeclStorageClass* storageArray = new SgTemplateInstantiationDeclStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgTemplateInstantiationDecl_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgTemplateInstantiationDeclStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgTemplateInstantiationDeclStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgTemplateInstantiationDefn ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTemplateInstantiationDefnStorageClass* storageArray = new SgTemplateInstantiationDefnStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgTemplateInstantiationDefn_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgTemplateInstantiationDefnStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgTemplateInstantiationDefnStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgTemplateInstantiationDirectiveStatement ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTemplateInstantiationDirectiveStatementStorageClass* storageArray = new SgTemplateInstantiationDirectiveStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgTemplateInstantiationDirectiveStatement_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgTemplateInstantiationDirectiveStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgTemplateInstantiationDirectiveStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgTemplateInstantiationFunctionDecl ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTemplateInstantiationFunctionDeclStorageClass* storageArray = new SgTemplateInstantiationFunctionDeclStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgTemplateInstantiationFunctionDecl_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgTemplateInstantiationFunctionDeclStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgTemplateInstantiationFunctionDeclStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgTemplateInstantiationMemberFunctionDecl ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTemplateInstantiationMemberFunctionDeclStorageClass* storageArray = new SgTemplateInstantiationMemberFunctionDeclStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgTemplateInstantiationMemberFunctionDecl_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgTemplateInstantiationMemberFunctionDeclStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgTemplateInstantiationMemberFunctionDeclStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgTemplateParameter ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTemplateParameterStorageClass* storageArray = new SgTemplateParameterStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgTemplateParameter_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgTemplateParameterStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgTemplateParameterList ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTemplateParameterListStorageClass* storageArray = new SgTemplateParameterListStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgTemplateParameterList_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgTemplateParameterListStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgTemplateParameterListStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgTemplateSymbol ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTemplateSymbolStorageClass* storageArray = new SgTemplateSymbolStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgTemplateSymbol_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgTemplateSymbolStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgTemplateSymbolStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgTemplateType ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTemplateTypeStorageClass* storageArray = new SgTemplateTypeStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgTemplateType_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgTemplateTypeStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgTemplateTypeStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgThisExp ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgThisExpStorageClass* storageArray = new SgThisExpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgThisExp_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgThisExpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgThisExpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgSuperExp ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgSuperExpStorageClass* storageArray = new SgSuperExpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgSuperExp_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgSuperExpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgSuperExpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgThrowOp ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgThrowOpStorageClass* storageArray = new SgThrowOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgThrowOp_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgThrowOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgThrowOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgToken ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTokenStorageClass* storageArray = new SgTokenStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgToken_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgTokenStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgTokenStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgTryStmt ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTryStmtStorageClass* storageArray = new SgTryStmtStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgTryStmt_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgTryStmtStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgTryStmtStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgTupleExp ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTupleExpStorageClass* storageArray = new SgTupleExpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgTupleExp_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgTupleExpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgTupleExpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgType ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeStorageClass* storageArray = new SgTypeStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgType_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgTypeStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgTypeStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgTypeBool ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeBoolStorageClass* storageArray = new SgTypeBoolStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgTypeBool_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgTypeBoolStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgTypeBoolStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgTypeChar ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeCharStorageClass* storageArray = new SgTypeCharStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgTypeChar_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgTypeCharStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgTypeCharStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgTypeComplex ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeComplexStorageClass* storageArray = new SgTypeComplexStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgTypeComplex_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgTypeComplexStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgTypeComplexStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgTypeDefault ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeDefaultStorageClass* storageArray = new SgTypeDefaultStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgTypeDefault_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgTypeDefaultStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgTypeDefaultStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgTypeLabel ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeLabelStorageClass* storageArray = new SgTypeLabelStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgTypeLabel_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgTypeLabelStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgTypeLabelStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgTypeDouble ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeDoubleStorageClass* storageArray = new SgTypeDoubleStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgTypeDouble_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgTypeDoubleStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgTypeDoubleStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgTypeEllipse ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeEllipseStorageClass* storageArray = new SgTypeEllipseStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgTypeEllipse_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgTypeEllipseStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgTypeEllipseStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgTypeFloat ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeFloatStorageClass* storageArray = new SgTypeFloatStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgTypeFloat_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgTypeFloatStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgTypeFloatStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgTypeGlobalVoid ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeGlobalVoidStorageClass* storageArray = new SgTypeGlobalVoidStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgTypeGlobalVoid_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgTypeGlobalVoidStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgTypeGlobalVoidStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgTypeIdOp ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeIdOpStorageClass* storageArray = new SgTypeIdOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgTypeIdOp_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgTypeIdOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgTypeIdOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgTypeImaginary ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeImaginaryStorageClass* storageArray = new SgTypeImaginaryStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgTypeImaginary_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgTypeImaginaryStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgTypeImaginaryStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgTypeInt ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeIntStorageClass* storageArray = new SgTypeIntStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgTypeInt_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgTypeIntStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgTypeIntStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgTypeLong ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeLongStorageClass* storageArray = new SgTypeLongStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgTypeLong_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgTypeLongStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgTypeLongStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgTypeLongDouble ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeLongDoubleStorageClass* storageArray = new SgTypeLongDoubleStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgTypeLongDouble_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgTypeLongDoubleStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgTypeLongDoubleStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgTypeLongLong ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeLongLongStorageClass* storageArray = new SgTypeLongLongStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgTypeLongLong_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgTypeLongLongStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgTypeLongLongStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgTypeModifier ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeModifierStorageClass* storageArray = new SgTypeModifierStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgTypeModifier_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgTypeModifierStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgTypeModifierStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgTypeShort ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeShortStorageClass* storageArray = new SgTypeShortStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgTypeShort_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgTypeShortStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgTypeShortStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgTypeSignedChar ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeSignedCharStorageClass* storageArray = new SgTypeSignedCharStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgTypeSignedChar_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgTypeSignedCharStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgTypeSignedCharStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgTypeSignedInt ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeSignedIntStorageClass* storageArray = new SgTypeSignedIntStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgTypeSignedInt_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgTypeSignedIntStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgTypeSignedIntStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgTypeSignedLong ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeSignedLongStorageClass* storageArray = new SgTypeSignedLongStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgTypeSignedLong_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgTypeSignedLongStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgTypeSignedLongStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgTypeSignedLongLong ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeSignedLongLongStorageClass* storageArray = new SgTypeSignedLongLongStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgTypeSignedLongLong_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgTypeSignedLongLongStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgTypeSignedLongLongStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgTypeSignedShort ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeSignedShortStorageClass* storageArray = new SgTypeSignedShortStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgTypeSignedShort_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgTypeSignedShortStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgTypeSignedShortStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgTypeString ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeStringStorageClass* storageArray = new SgTypeStringStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgTypeString_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgTypeStringStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgTypeStringStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgTypeUnknown ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeUnknownStorageClass* storageArray = new SgTypeUnknownStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgTypeUnknown_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgTypeUnknownStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgTypeUnknownStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgTypeUnsignedChar ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeUnsignedCharStorageClass* storageArray = new SgTypeUnsignedCharStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgTypeUnsignedChar_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgTypeUnsignedCharStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgTypeUnsignedCharStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgTypeUnsignedInt ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeUnsignedIntStorageClass* storageArray = new SgTypeUnsignedIntStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgTypeUnsignedInt_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgTypeUnsignedIntStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgTypeUnsignedIntStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgTypeUnsignedLong ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeUnsignedLongStorageClass* storageArray = new SgTypeUnsignedLongStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgTypeUnsignedLong_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgTypeUnsignedLongStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgTypeUnsignedLongStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgTypeUnsignedLongLong ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeUnsignedLongLongStorageClass* storageArray = new SgTypeUnsignedLongLongStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgTypeUnsignedLongLong_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgTypeUnsignedLongLongStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgTypeUnsignedLongLongStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgTypeUnsignedShort ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeUnsignedShortStorageClass* storageArray = new SgTypeUnsignedShortStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgTypeUnsignedShort_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgTypeUnsignedShortStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgTypeUnsignedShortStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgTypeVoid ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeVoidStorageClass* storageArray = new SgTypeVoidStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgTypeVoid_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgTypeVoidStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgTypeVoidStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgTypeWchar ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeWcharStorageClass* storageArray = new SgTypeWcharStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgTypeWchar_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgTypeWcharStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgTypeWcharStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgTypedefDeclaration ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypedefDeclarationStorageClass* storageArray = new SgTypedefDeclarationStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgTypedefDeclaration_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgTypedefDeclarationStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgTypedefDeclarationStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgTypedefSeq ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypedefSeqStorageClass* storageArray = new SgTypedefSeqStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgTypedefSeq_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgTypedefSeqStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgTypedefSeqStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgTypedefSymbol ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypedefSymbolStorageClass* storageArray = new SgTypedefSymbolStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgTypedefSymbol_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgTypedefSymbolStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgTypedefSymbolStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgTypedefType ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypedefTypeStorageClass* storageArray = new SgTypedefTypeStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgTypedefType_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgTypedefTypeStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgTypedefTypeStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgUPC_AccessModifier ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgUPC_AccessModifierStorageClass* storageArray = new SgUPC_AccessModifierStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgUPC_AccessModifier_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgUPC_AccessModifierStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgUnaryAddOp ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgUnaryAddOpStorageClass* storageArray = new SgUnaryAddOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgUnaryAddOp_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgUnaryAddOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgUnaryAddOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgUnaryOp ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgUnaryOpStorageClass* storageArray = new SgUnaryOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgUnaryOp_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgUnaryOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgUnaryOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgUndefDirectiveStatement ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgUndefDirectiveStatementStorageClass* storageArray = new SgUndefDirectiveStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgUndefDirectiveStatement_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgUndefDirectiveStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgUndefDirectiveStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgUndirectedGraphEdge ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgUndirectedGraphEdgeStorageClass* storageArray = new SgUndirectedGraphEdgeStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgUndirectedGraphEdge_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgUndirectedGraphEdgeStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgUndirectedGraphEdgeStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgUnknownArrayOrFunctionReference ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgUnknownArrayOrFunctionReferenceStorageClass* storageArray = new SgUnknownArrayOrFunctionReferenceStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgUnknownArrayOrFunctionReference_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgUnknownArrayOrFunctionReferenceStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgUnknownArrayOrFunctionReferenceStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgUnknownFile ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgUnknownFileStorageClass* storageArray = new SgUnknownFileStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgUnknownFile_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgUnknownFileStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgUnknownFileStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgUnparse_Info ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgUnparse_InfoStorageClass* storageArray = new SgUnparse_InfoStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgUnparse_Info_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgUnparse_InfoStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgUnparse_InfoStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgUnsignedCharVal ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgUnsignedCharValStorageClass* storageArray = new SgUnsignedCharValStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgUnsignedCharVal_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgUnsignedCharValStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgUnsignedCharValStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgUnsignedIntVal ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgUnsignedIntValStorageClass* storageArray = new SgUnsignedIntValStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgUnsignedIntVal_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgUnsignedIntValStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgUnsignedIntValStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgUnsignedLongLongIntVal ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgUnsignedLongLongIntValStorageClass* storageArray = new SgUnsignedLongLongIntValStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgUnsignedLongLongIntVal_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgUnsignedLongLongIntValStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgUnsignedLongLongIntValStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgUnsignedLongVal ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgUnsignedLongValStorageClass* storageArray = new SgUnsignedLongValStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgUnsignedLongVal_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgUnsignedLongValStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgUnsignedLongValStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgUnsignedShortVal ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgUnsignedShortValStorageClass* storageArray = new SgUnsignedShortValStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgUnsignedShortVal_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgUnsignedShortValStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgUnsignedShortValStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgUpcBarrierStatement ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgUpcBarrierStatementStorageClass* storageArray = new SgUpcBarrierStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgUpcBarrierStatement_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgUpcBarrierStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgUpcBarrierStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgUpcBlocksizeofExpression ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgUpcBlocksizeofExpressionStorageClass* storageArray = new SgUpcBlocksizeofExpressionStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgUpcBlocksizeofExpression_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgUpcBlocksizeofExpressionStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgUpcBlocksizeofExpressionStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgUpcElemsizeofExpression ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgUpcElemsizeofExpressionStorageClass* storageArray = new SgUpcElemsizeofExpressionStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgUpcElemsizeofExpression_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgUpcElemsizeofExpressionStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgUpcElemsizeofExpressionStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgUpcFenceStatement ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgUpcFenceStatementStorageClass* storageArray = new SgUpcFenceStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgUpcFenceStatement_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgUpcFenceStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgUpcFenceStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgUpcForAllStatement ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgUpcForAllStatementStorageClass* storageArray = new SgUpcForAllStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgUpcForAllStatement_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgUpcForAllStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgUpcForAllStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgUpcLocalsizeofExpression ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgUpcLocalsizeofExpressionStorageClass* storageArray = new SgUpcLocalsizeofExpressionStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgUpcLocalsizeofExpression_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgUpcLocalsizeofExpressionStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgUpcLocalsizeofExpressionStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgUpcMythread ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgUpcMythreadStorageClass* storageArray = new SgUpcMythreadStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgUpcMythread_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgUpcMythreadStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgUpcMythreadStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgUpcNotifyStatement ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgUpcNotifyStatementStorageClass* storageArray = new SgUpcNotifyStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgUpcNotifyStatement_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgUpcNotifyStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgUpcNotifyStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgUpcThreads ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgUpcThreadsStorageClass* storageArray = new SgUpcThreadsStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgUpcThreads_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgUpcThreadsStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgUpcThreadsStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgUpcWaitStatement ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgUpcWaitStatementStorageClass* storageArray = new SgUpcWaitStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgUpcWaitStatement_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgUpcWaitStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgUpcWaitStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgUseStatement ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgUseStatementStorageClass* storageArray = new SgUseStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgUseStatement_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgUseStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgUseStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgUserDefinedBinaryOp ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgUserDefinedBinaryOpStorageClass* storageArray = new SgUserDefinedBinaryOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgUserDefinedBinaryOp_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgUserDefinedBinaryOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgUserDefinedBinaryOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgUserDefinedUnaryOp ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgUserDefinedUnaryOpStorageClass* storageArray = new SgUserDefinedUnaryOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgUserDefinedUnaryOp_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgUserDefinedUnaryOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgUserDefinedUnaryOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgUsingDeclarationStatement ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgUsingDeclarationStatementStorageClass* storageArray = new SgUsingDeclarationStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgUsingDeclarationStatement_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgUsingDeclarationStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgUsingDeclarationStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgUsingDirectiveStatement ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgUsingDirectiveStatementStorageClass* storageArray = new SgUsingDirectiveStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgUsingDirectiveStatement_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgUsingDirectiveStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgUsingDirectiveStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgValueExp ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgValueExpStorageClass* storageArray = new SgValueExpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgValueExp_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgValueExpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgValueExpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgVarArgCopyOp ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgVarArgCopyOpStorageClass* storageArray = new SgVarArgCopyOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgVarArgCopyOp_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgVarArgCopyOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgVarArgCopyOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgVarArgEndOp ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgVarArgEndOpStorageClass* storageArray = new SgVarArgEndOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgVarArgEndOp_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgVarArgEndOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgVarArgEndOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgVarArgOp ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgVarArgOpStorageClass* storageArray = new SgVarArgOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgVarArgOp_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgVarArgOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgVarArgOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgVarArgStartOneOperandOp ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgVarArgStartOneOperandOpStorageClass* storageArray = new SgVarArgStartOneOperandOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgVarArgStartOneOperandOp_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgVarArgStartOneOperandOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgVarArgStartOneOperandOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgVarArgStartOp ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgVarArgStartOpStorageClass* storageArray = new SgVarArgStartOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgVarArgStartOp_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgVarArgStartOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgVarArgStartOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgVarRefExp ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgVarRefExpStorageClass* storageArray = new SgVarRefExpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgVarRefExp_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgVarRefExpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgVarRefExpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgVariableDeclaration ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgVariableDeclarationStorageClass* storageArray = new SgVariableDeclarationStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgVariableDeclaration_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgVariableDeclarationStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgVariableDeclarationStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgVariableDefinition ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgVariableDefinitionStorageClass* storageArray = new SgVariableDefinitionStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgVariableDefinition_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgVariableDefinitionStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgVariableDefinitionStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgVariableSymbol ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgVariableSymbolStorageClass* storageArray = new SgVariableSymbolStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgVariableSymbol_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgVariableSymbolStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgVariableSymbolStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgVariantExpression ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgVariantExpressionStorageClass* storageArray = new SgVariantExpressionStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgVariantExpression_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgVariantExpressionStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgVariantExpressionStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgVariantStatement ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgVariantStatementStorageClass* storageArray = new SgVariantStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgVariantStatement_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgVariantStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgVariantStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgWaitStatement ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgWaitStatementStorageClass* storageArray = new SgWaitStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgWaitStatement_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgWaitStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgWaitStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgWarningDirectiveStatement ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgWarningDirectiveStatementStorageClass* storageArray = new SgWarningDirectiveStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgWarningDirectiveStatement_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgWarningDirectiveStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgWarningDirectiveStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgWithStatement ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgWithStatementStorageClass* storageArray = new SgWithStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgWithStatement_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgWithStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgWithStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgWcharVal ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgWcharValStorageClass* storageArray = new SgWcharValStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgWcharVal_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgWcharValStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgWcharValStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgWhereStatement ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgWhereStatementStorageClass* storageArray = new SgWhereStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgWhereStatement_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgWhereStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgWhereStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgWhileStmt ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgWhileStmtStorageClass* storageArray = new SgWhileStmtStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgWhileStmt_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgWhileStmtStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgWhileStmtStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgWriteStatement ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgWriteStatementStorageClass* storageArray = new SgWriteStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgWriteStatement_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgWriteStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgWriteStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgXorAssignOp ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgXorAssignOpStorageClass* storageArray = new SgXorAssignOpStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgXorAssignOp_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgXorAssignOpStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgXorAssignOpStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgYieldExpression ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgYieldExpressionStorageClass* storageArray = new SgYieldExpressionStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgYieldExpression_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgYieldExpressionStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgYieldExpressionStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_Sg_File_Info ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          Sg_File_InfoStorageClass* storageArray = new Sg_File_InfoStorageClass[sizeOfActualPool] ;
           storageClassIndex = Sg_File_Info_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( Sg_File_InfoStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           Sg_File_InfoStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgTypeCAFTeam ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeCAFTeamStorageClass* storageArray = new SgTypeCAFTeamStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgTypeCAFTeam_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgTypeCAFTeamStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgTypeCAFTeamStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgCAFWithTeamStatement ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgCAFWithTeamStatementStorageClass* storageArray = new SgCAFWithTeamStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgCAFWithTeamStatement_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgCAFWithTeamStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgCAFWithTeamStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgCAFCoExpression ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgCAFCoExpressionStorageClass* storageArray = new SgCAFCoExpressionStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgCAFCoExpression_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgCAFCoExpressionStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgCAFCoExpressionStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgCallExpression ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgCallExpressionStorageClass* storageArray = new SgCallExpressionStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgCallExpression_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgCallExpressionStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgCallExpressionStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgTypeCrayPointer ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgTypeCrayPointerStorageClass* storageArray = new SgTypeCrayPointerStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgTypeCrayPointer_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgTypeCrayPointerStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgTypeCrayPointerStorageClass :: writeEasyStorageDataToFile(out) ;
        }  

     sizeOfActualPool = getSizeOfMemoryPool(V_SgJavaImportStatement ); 
     storageClassIndex = 0 ;
     if ( 0 < sizeOfActualPool ) 
        {  
          SgJavaImportStatementStorageClass* storageArray = new SgJavaImportStatementStorageClass[sizeOfActualPool] ;
           storageClassIndex = SgJavaImportStatement_initializeStorageClassArray (storageArray); ;
           assert ( storageClassIndex == sizeOfActualPool ); 
           out.write ( (char*) (storageArray) , sizeof ( SgJavaImportStatementStorageClass ) * sizeOfActualPool) ;
           delete [] storageArray;  
           SgJavaImportStatementStorageClass :: writeEasyStorageDataToFile(out) ;
        }  


/* #line 619 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarAST_FileIoSource.code" */
   
     }

     {
  // DQ (4/22/2006): Added timer information for AST File I/O
     TimingPerformance timer ("AST_FILE_IO::writeASTToFile() closing file:");
     std::string endString = "ROSE_AST_BINARY_END";
     out.write ( endString.c_str(), endString.size() );
     }
     
  // clear everything, actually, this does not work, since I need a different way to 
  // initialize the actualRebuildAst
 //    delete actualRebuildAst;
 //    vectorOfASTs.clear();
     

     return ;
}


/* JH (01/03/2006) This method stores an AST in binary format to the file. 
*/
void 
AST_FILE_IO :: writeASTToFile ( std::string fileName )
  {
  // DQ (4/22/2006): Added timer information for AST File I/O
     TimingPerformance timer ("AST_FILE_IO::writeASTToFile():");
 
     std::ofstream out;
     out.open ( fileName.c_str(), std::ios::out | std::ios::binary );
     if ( out == NULL )
        {
          std::cout << "Problems opening file " << fileName << " for writing AST!" << std::endl;
          exit(-1);
        }
     AST_FILE_IO::writeASTToStream(out);

     {
  // DQ (4/22/2006): Added timer information for AST File I/O
     TimingPerformance timer ("AST_FILE_IO::writeASTToFile() closing file: time (sec) = ");
     out.close() ;
     }
     
     return ;
   }

std::string 
AST_FILE_IO :: writeASTToString()
  {
    std::ostringstream out;
    AST_FILE_IO::writeASTToStream(out);
    return out.str();
  }

/* JW (06/21/2006) Changed to use streams in base implementation */
SgProject*
AST_FILE_IO :: readASTFromStream ( std::istream& inFile )
  {
  // DQ (4/22/2006): Added timer information for AST File I/O
     TimingPerformance timer ("AST_FILE_IO::readASTFromStream() time (sec) = ");
 
     assert ( freepointersOfCurrentAstAreSetToGlobalIndices == false );
     std::string startString = "ROSE_AST_BINARY_START";
     char* startChar = new char [startString.size()+1];
     startChar[startString.size()] = '\0';
     inFile.read ( startChar, startString.size() );
     assert (inFile);
     assert ( string(startChar) == startString );
     delete [] startChar;
     REGISTER_ATTRIBUTE_FOR_FILE_IO(AstAttribute) ;

  // 1. Read the accumulatedPoolSizesOfNewAst 
     if ( SgProject::get_verbose() > 0 )
          std::cout << "Here we start the reading of the AST specific data ... " << std::endl;

     if ( SgProject::get_verbose() > 0 )
          std::cout << " Allocating AstDataStorageClass ... " << std::endl;
     AstDataStorageClass staticTemp;
     
     if ( SgProject::get_verbose() > 0 )
          std::cout << " Checking the ast via pool entries -- before AstDataStorageClass::readEasyStorageDataFromFile() .... " << std::endl;

#if 0
  // AST_FileIO::MemoryCheckingTraversalForAstFileIO memoryCheckingTraversal_A;
     MemoryCheckingTraversalForAstFileIO memoryCheckingTraversal_A;
     memoryCheckingTraversal_A.traverseMemoryPool();
#endif

     if ( SgProject::get_verbose() > 0 )
          std::cout << " DONE: Checking the ast via pool entries -- before AstDataStorageClass::readEasyStorageDataFromFile() .... " << std::endl;

     {
  // DQ (4/22/2006): Added timer information for AST File I/O
     TimingPerformance nested_timer ("AST_FILE_IO::readASTFromStream() raw file read:");

     if ( SgProject::get_verbose() > 0 )
          std::cout << " Reading the data from file ... " << std::endl;

     inFile.read ( (char*)(&staticTemp) , sizeof(AstDataStorageClass) );
     assert (inFile);

     if ( SgProject::get_verbose() > 0 )
          std::cout << " Reading the static (EasyStorage) data from file ... " << std::endl;

     AstDataStorageClass::readEasyStorageDataFromFile(inFile);
     }
     
     if ( SgProject::get_verbose() > 0 )
          std::cout << " Checking the ast via pool entries -- after AstDataStorageClass::readEasyStorageDataFromFile() .... " << std::endl;

#if 0
  // AST_FileIO::MemoryCheckingTraversalForAstFileIO memoryCheckingTraversal_B;
     MemoryCheckingTraversalForAstFileIO memoryCheckingTraversal_B;
     memoryCheckingTraversal_B.traverseMemoryPool();
#endif

     if ( SgProject::get_verbose() > 0 )
          std::cout << " DONE: Checking the ast via pool entries -- after AstDataStorageClass::readEasyStorageDataFromFile() .... " << std::endl;

  // 1.a Introducing a marker to check the right position in the file     

     {
  // DQ (4/22/2006): Added timer information for AST File I/O
     TimingPerformance nested_timer ("AST_FILE_IO::readASTFromStream() raw file (marker) read:");

     std::string markString = "#########";
     char* markChar = new char [markString.size()+1];

  // DQ (9/24/2007): Bug fix suggested by Jeremiah.
     markChar[markString.size()] = '\0';

     inFile.read ( markChar, markString.size() );
     assert (inFile);
     assert ( string(markChar) == markString ); 
     delete [] markChar;
     }
     
     if ( SgProject::get_verbose() > 0 )
          std::cout << " Checking the ast via pool entries -- after marker read .... " << std::endl;

#if 0
     MemoryCheckingTraversalForAstFileIO memoryCheckingTraversal_C;
     memoryCheckingTraversal_C.traverseMemoryPool();
#endif

     if ( SgProject::get_verbose() > 0 )
          std::cout << " DONE: Checking the ast via pool entries -- after marker read .... " << std::endl;

  // 2. Initialize the StorageClass and read

     {
  // DQ (4/22/2006): Added timer information for AST File I/O
     TimingPerformance nested_timer ("AST_FILE_IO::readASTFromStream() rebuild AST (part 1):");

     if ( SgProject::get_verbose() > 0 )
          std::cout << " Initializing the actualRebuildAST with staticTemp ... " << std::endl;

  // This calls the constructor AstSpecificDataManagingClass(const AstSpecificDataManagingClassStorageClass& source ).
  // The code used to generate this function is in: ROSETTA/src/buildStorageClasses.C
  // Note that AstData is typedefed to AstSpecificDataManagingClass 
     actualRebuildAst = new AstData(staticTemp);
  // extendMemoryPoolsForRebuildingAST();

  // The call to the constructor calls "extendMemoryPoolsForRebuildingAST()" which uses valid pointers
  // to reference the extended memory blocks where the new AST extends beyond the current memory block.
  // This means that freepointer values at the end of a sequence of memroy blocks will have values
  // that are not equal to "AST_FileIO::IS_VALID_POINTER()", thus causing warnings to be spewed
  // from the "MemoryCheckingTraversalForAstFileIO" tests (which I have added more of lately).
  // It seems that calling "new AstData(staticTemp)" is not meant to be done where part of the AST was 
  // read from a file??? Also the frepointer value of the next to last block in the memory block list
  // appears to be lost after the call to "extendMemoryPoolsForRebuildingAST()".

  // The problem is that when freepointers are converted to "AST_FileIO::IS_VALID_POINTER()", the last
  // block in the chain is lost. since it points to an entry that is not allocated and thus not used.
  // The freepointers, and/or the extension of the memory pools overwrites the last block in the chain.
  // But I don't yet see exactly why!!!

  // One thing to test is if the new operators are working properly (or used) when the "AST_FileIO::IS_VALID_POINTER()"
  // values are in place in the AST.  Seems like it would be an error. to mix an AST read from disk with
  // and AST that has been extended via "extendMemoryPoolsForRebuildingAST()".

  // I think the problem is in the conversion of freepointer values back to correct values after having
  // been set as "AST_FileIO::IS_VALID_POINTER()" (particularly when the "AST_FileIO::IS_VALID_POINTER()"
  // value has been over written.

     if ( SgProject::get_verbose() > 0 )
          std::cout << " Checking the ast via pool entries -- after actualRebuildAst = new AstData() .... " << std::endl;

#if 0
     MemoryCheckingTraversalForAstFileIO memoryCheckingTraversal_D;
     memoryCheckingTraversal_D.traverseMemoryPool();
#endif

     if ( SgProject::get_verbose() > 0 )
          std::cout << " DONE: Checking the ast via pool entries -- after actualRebuildAst = new AstData() .... " << std::endl;

  // 3.
  // DQ (6/7/2010): Not clear why this is only called for where there is a single AST.
  // printf ("AST_FILE_IO::vectorOfASTs.size() = %zu \n",AST_FILE_IO::vectorOfASTs.size());
     if (AST_FILE_IO::vectorOfASTs.size() == 1)
        { 
          if ( SgProject::get_verbose() > 0 )
               std::cout << "setting the static data of an AST, but only for the first AST in a pool ... " << std::flush;

          actualRebuildAst->setStaticDataMembersOfIRNodes();

          if ( SgProject::get_verbose() > 0 )
               std::cout << "done" << std::endl;
        }

     if ( SgProject::get_verbose() > 0 )
          std::cout << " Calling AstDataStorageClass::deleteStaticDataOfEasyStorageClasses() .... " << std::endl;

#if 0
     MemoryCheckingTraversalForAstFileIO memoryCheckingTraversal_D2;
     memoryCheckingTraversal_D2.traverseMemoryPool();
#endif

     AstDataStorageClass::deleteStaticDataOfEasyStorageClasses();
     }

     if ( SgProject::get_verbose() > 0 )
          std::cout << " Checking the ast via pool entries -- after AstDataStorageClass::deleteStaticDataOfEasyStorageClasses() .... " << std::endl;

#if 0
     MemoryCheckingTraversalForAstFileIO memoryCheckingTraversal_E;
     memoryCheckingTraversal_E.traverseMemoryPool();
#endif

     if ( SgProject::get_verbose() > 0 )
          std::cout << " DONE: Checking the ast via pool entries -- after AstDataStorageClass::deleteStaticDataOfEasyStorageClasses() .... " << std::endl;

     {
  // DQ (4/22/2006): Added timer information for AST File I/O
     TimingPerformance nested_timer ("AST_FILE_IO::readASTFromStream() rebuild AST (part 2):");

     unsigned long sizeOfActualPool = 0;
     long storageClassIndex = 0 ;


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAccessModifier ); 
     storageClassIndex = 0 ;
     SgAccessModifierStorageClass* storageArraySgAccessModifier = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAccessModifier = new SgAccessModifierStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAccessModifier) , sizeof ( SgAccessModifierStorageClass ) * sizeOfActualPool) ;
          SgAccessModifierStorageClass* storageArray = storageArraySgAccessModifier;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAccessModifier* tmp = new SgAccessModifier ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAccessModifier;  


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgActualArgumentExpression ); 
     storageClassIndex = 0 ;
     SgActualArgumentExpressionStorageClass* storageArraySgActualArgumentExpression = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgActualArgumentExpression = new SgActualArgumentExpressionStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgActualArgumentExpression) , sizeof ( SgActualArgumentExpressionStorageClass ) * sizeOfActualPool) ;
        SgActualArgumentExpressionStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgActualArgumentExpressionStorageClass* storageArray = storageArraySgActualArgumentExpression;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgActualArgumentExpression* tmp = new SgActualArgumentExpression ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgActualArgumentExpression;  
      SgActualArgumentExpressionStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAddOp ); 
     storageClassIndex = 0 ;
     SgAddOpStorageClass* storageArraySgAddOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAddOp = new SgAddOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAddOp) , sizeof ( SgAddOpStorageClass ) * sizeOfActualPool) ;
        SgAddOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAddOpStorageClass* storageArray = storageArraySgAddOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAddOp* tmp = new SgAddOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAddOp;  
      SgAddOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAddressOfOp ); 
     storageClassIndex = 0 ;
     SgAddressOfOpStorageClass* storageArraySgAddressOfOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAddressOfOp = new SgAddressOfOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAddressOfOp) , sizeof ( SgAddressOfOpStorageClass ) * sizeOfActualPool) ;
        SgAddressOfOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAddressOfOpStorageClass* storageArray = storageArraySgAddressOfOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAddressOfOp* tmp = new SgAddressOfOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAddressOfOp;  
      SgAddressOfOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAggregateInitializer ); 
     storageClassIndex = 0 ;
     SgAggregateInitializerStorageClass* storageArraySgAggregateInitializer = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAggregateInitializer = new SgAggregateInitializerStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAggregateInitializer) , sizeof ( SgAggregateInitializerStorageClass ) * sizeOfActualPool) ;
        SgAggregateInitializerStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAggregateInitializerStorageClass* storageArray = storageArraySgAggregateInitializer;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAggregateInitializer* tmp = new SgAggregateInitializer ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAggregateInitializer;  
      SgAggregateInitializerStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAliasSymbol ); 
     storageClassIndex = 0 ;
     SgAliasSymbolStorageClass* storageArraySgAliasSymbol = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAliasSymbol = new SgAliasSymbolStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAliasSymbol) , sizeof ( SgAliasSymbolStorageClass ) * sizeOfActualPool) ;
        SgAliasSymbolStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAliasSymbolStorageClass* storageArray = storageArraySgAliasSymbol;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAliasSymbol* tmp = new SgAliasSymbol ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAliasSymbol;  
      SgAliasSymbolStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAllocateStatement ); 
     storageClassIndex = 0 ;
     SgAllocateStatementStorageClass* storageArraySgAllocateStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAllocateStatement = new SgAllocateStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAllocateStatement) , sizeof ( SgAllocateStatementStorageClass ) * sizeOfActualPool) ;
        SgAllocateStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAllocateStatementStorageClass* storageArray = storageArraySgAllocateStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAllocateStatement* tmp = new SgAllocateStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAllocateStatement;  
      SgAllocateStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAndAssignOp ); 
     storageClassIndex = 0 ;
     SgAndAssignOpStorageClass* storageArraySgAndAssignOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAndAssignOp = new SgAndAssignOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAndAssignOp) , sizeof ( SgAndAssignOpStorageClass ) * sizeOfActualPool) ;
        SgAndAssignOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAndAssignOpStorageClass* storageArray = storageArraySgAndAssignOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAndAssignOp* tmp = new SgAndAssignOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAndAssignOp;  
      SgAndAssignOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAndOp ); 
     storageClassIndex = 0 ;
     SgAndOpStorageClass* storageArraySgAndOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAndOp = new SgAndOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAndOp) , sizeof ( SgAndOpStorageClass ) * sizeOfActualPool) ;
        SgAndOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAndOpStorageClass* storageArray = storageArraySgAndOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAndOp* tmp = new SgAndOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAndOp;  
      SgAndOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgArithmeticIfStatement ); 
     storageClassIndex = 0 ;
     SgArithmeticIfStatementStorageClass* storageArraySgArithmeticIfStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgArithmeticIfStatement = new SgArithmeticIfStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgArithmeticIfStatement) , sizeof ( SgArithmeticIfStatementStorageClass ) * sizeOfActualPool) ;
        SgArithmeticIfStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgArithmeticIfStatementStorageClass* storageArray = storageArraySgArithmeticIfStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgArithmeticIfStatement* tmp = new SgArithmeticIfStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgArithmeticIfStatement;  
      SgArithmeticIfStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgArrayType ); 
     storageClassIndex = 0 ;
     SgArrayTypeStorageClass* storageArraySgArrayType = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgArrayType = new SgArrayTypeStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgArrayType) , sizeof ( SgArrayTypeStorageClass ) * sizeOfActualPool) ;
        SgArrayTypeStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgArrayTypeStorageClass* storageArray = storageArraySgArrayType;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgArrayType* tmp = new SgArrayType ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgArrayType;  
      SgArrayTypeStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgArrowExp ); 
     storageClassIndex = 0 ;
     SgArrowExpStorageClass* storageArraySgArrowExp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgArrowExp = new SgArrowExpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgArrowExp) , sizeof ( SgArrowExpStorageClass ) * sizeOfActualPool) ;
        SgArrowExpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgArrowExpStorageClass* storageArray = storageArraySgArrowExp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgArrowExp* tmp = new SgArrowExp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgArrowExp;  
      SgArrowExpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgArrowStarOp ); 
     storageClassIndex = 0 ;
     SgArrowStarOpStorageClass* storageArraySgArrowStarOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgArrowStarOp = new SgArrowStarOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgArrowStarOp) , sizeof ( SgArrowStarOpStorageClass ) * sizeOfActualPool) ;
        SgArrowStarOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgArrowStarOpStorageClass* storageArray = storageArraySgArrowStarOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgArrowStarOp* tmp = new SgArrowStarOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgArrowStarOp;  
      SgArrowStarOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmArmInstruction ); 
     storageClassIndex = 0 ;
     SgAsmArmInstructionStorageClass* storageArraySgAsmArmInstruction = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmArmInstruction = new SgAsmArmInstructionStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmArmInstruction) , sizeof ( SgAsmArmInstructionStorageClass ) * sizeOfActualPool) ;
        SgAsmArmInstructionStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmArmInstructionStorageClass* storageArray = storageArraySgAsmArmInstruction;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmArmInstruction* tmp = new SgAsmArmInstruction ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmArmInstruction;  
      SgAsmArmInstructionStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmArmRegisterReferenceExpression ); 
     storageClassIndex = 0 ;
     SgAsmArmRegisterReferenceExpressionStorageClass* storageArraySgAsmArmRegisterReferenceExpression = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmArmRegisterReferenceExpression = new SgAsmArmRegisterReferenceExpressionStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmArmRegisterReferenceExpression) , sizeof ( SgAsmArmRegisterReferenceExpressionStorageClass ) * sizeOfActualPool) ;
        SgAsmArmRegisterReferenceExpressionStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmArmRegisterReferenceExpressionStorageClass* storageArray = storageArraySgAsmArmRegisterReferenceExpression;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmArmRegisterReferenceExpression* tmp = new SgAsmArmRegisterReferenceExpression ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmArmRegisterReferenceExpression;  
      SgAsmArmRegisterReferenceExpressionStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmBasicString ); 
     storageClassIndex = 0 ;
     SgAsmBasicStringStorageClass* storageArraySgAsmBasicString = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmBasicString = new SgAsmBasicStringStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmBasicString) , sizeof ( SgAsmBasicStringStorageClass ) * sizeOfActualPool) ;
        SgAsmBasicStringStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmBasicStringStorageClass* storageArray = storageArraySgAsmBasicString;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmBasicString* tmp = new SgAsmBasicString ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmBasicString;  
      SgAsmBasicStringStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmBinaryAdd ); 
     storageClassIndex = 0 ;
     SgAsmBinaryAddStorageClass* storageArraySgAsmBinaryAdd = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmBinaryAdd = new SgAsmBinaryAddStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmBinaryAdd) , sizeof ( SgAsmBinaryAddStorageClass ) * sizeOfActualPool) ;
        SgAsmBinaryAddStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmBinaryAddStorageClass* storageArray = storageArraySgAsmBinaryAdd;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmBinaryAdd* tmp = new SgAsmBinaryAdd ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmBinaryAdd;  
      SgAsmBinaryAddStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmBinaryAddPostupdate ); 
     storageClassIndex = 0 ;
     SgAsmBinaryAddPostupdateStorageClass* storageArraySgAsmBinaryAddPostupdate = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmBinaryAddPostupdate = new SgAsmBinaryAddPostupdateStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmBinaryAddPostupdate) , sizeof ( SgAsmBinaryAddPostupdateStorageClass ) * sizeOfActualPool) ;
        SgAsmBinaryAddPostupdateStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmBinaryAddPostupdateStorageClass* storageArray = storageArraySgAsmBinaryAddPostupdate;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmBinaryAddPostupdate* tmp = new SgAsmBinaryAddPostupdate ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmBinaryAddPostupdate;  
      SgAsmBinaryAddPostupdateStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmBinaryAddPreupdate ); 
     storageClassIndex = 0 ;
     SgAsmBinaryAddPreupdateStorageClass* storageArraySgAsmBinaryAddPreupdate = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmBinaryAddPreupdate = new SgAsmBinaryAddPreupdateStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmBinaryAddPreupdate) , sizeof ( SgAsmBinaryAddPreupdateStorageClass ) * sizeOfActualPool) ;
        SgAsmBinaryAddPreupdateStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmBinaryAddPreupdateStorageClass* storageArray = storageArraySgAsmBinaryAddPreupdate;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmBinaryAddPreupdate* tmp = new SgAsmBinaryAddPreupdate ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmBinaryAddPreupdate;  
      SgAsmBinaryAddPreupdateStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmBinaryAsr ); 
     storageClassIndex = 0 ;
     SgAsmBinaryAsrStorageClass* storageArraySgAsmBinaryAsr = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmBinaryAsr = new SgAsmBinaryAsrStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmBinaryAsr) , sizeof ( SgAsmBinaryAsrStorageClass ) * sizeOfActualPool) ;
        SgAsmBinaryAsrStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmBinaryAsrStorageClass* storageArray = storageArraySgAsmBinaryAsr;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmBinaryAsr* tmp = new SgAsmBinaryAsr ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmBinaryAsr;  
      SgAsmBinaryAsrStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmBinaryDivide ); 
     storageClassIndex = 0 ;
     SgAsmBinaryDivideStorageClass* storageArraySgAsmBinaryDivide = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmBinaryDivide = new SgAsmBinaryDivideStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmBinaryDivide) , sizeof ( SgAsmBinaryDivideStorageClass ) * sizeOfActualPool) ;
        SgAsmBinaryDivideStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmBinaryDivideStorageClass* storageArray = storageArraySgAsmBinaryDivide;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmBinaryDivide* tmp = new SgAsmBinaryDivide ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmBinaryDivide;  
      SgAsmBinaryDivideStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmBinaryExpression ); 
     storageClassIndex = 0 ;
     SgAsmBinaryExpressionStorageClass* storageArraySgAsmBinaryExpression = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmBinaryExpression = new SgAsmBinaryExpressionStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmBinaryExpression) , sizeof ( SgAsmBinaryExpressionStorageClass ) * sizeOfActualPool) ;
        SgAsmBinaryExpressionStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmBinaryExpressionStorageClass* storageArray = storageArraySgAsmBinaryExpression;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmBinaryExpression* tmp = new SgAsmBinaryExpression ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmBinaryExpression;  
      SgAsmBinaryExpressionStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmBinaryLsl ); 
     storageClassIndex = 0 ;
     SgAsmBinaryLslStorageClass* storageArraySgAsmBinaryLsl = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmBinaryLsl = new SgAsmBinaryLslStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmBinaryLsl) , sizeof ( SgAsmBinaryLslStorageClass ) * sizeOfActualPool) ;
        SgAsmBinaryLslStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmBinaryLslStorageClass* storageArray = storageArraySgAsmBinaryLsl;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmBinaryLsl* tmp = new SgAsmBinaryLsl ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmBinaryLsl;  
      SgAsmBinaryLslStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmBinaryLsr ); 
     storageClassIndex = 0 ;
     SgAsmBinaryLsrStorageClass* storageArraySgAsmBinaryLsr = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmBinaryLsr = new SgAsmBinaryLsrStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmBinaryLsr) , sizeof ( SgAsmBinaryLsrStorageClass ) * sizeOfActualPool) ;
        SgAsmBinaryLsrStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmBinaryLsrStorageClass* storageArray = storageArraySgAsmBinaryLsr;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmBinaryLsr* tmp = new SgAsmBinaryLsr ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmBinaryLsr;  
      SgAsmBinaryLsrStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmBinaryMod ); 
     storageClassIndex = 0 ;
     SgAsmBinaryModStorageClass* storageArraySgAsmBinaryMod = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmBinaryMod = new SgAsmBinaryModStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmBinaryMod) , sizeof ( SgAsmBinaryModStorageClass ) * sizeOfActualPool) ;
        SgAsmBinaryModStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmBinaryModStorageClass* storageArray = storageArraySgAsmBinaryMod;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmBinaryMod* tmp = new SgAsmBinaryMod ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmBinaryMod;  
      SgAsmBinaryModStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmBinaryMultiply ); 
     storageClassIndex = 0 ;
     SgAsmBinaryMultiplyStorageClass* storageArraySgAsmBinaryMultiply = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmBinaryMultiply = new SgAsmBinaryMultiplyStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmBinaryMultiply) , sizeof ( SgAsmBinaryMultiplyStorageClass ) * sizeOfActualPool) ;
        SgAsmBinaryMultiplyStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmBinaryMultiplyStorageClass* storageArray = storageArraySgAsmBinaryMultiply;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmBinaryMultiply* tmp = new SgAsmBinaryMultiply ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmBinaryMultiply;  
      SgAsmBinaryMultiplyStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmBinaryRor ); 
     storageClassIndex = 0 ;
     SgAsmBinaryRorStorageClass* storageArraySgAsmBinaryRor = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmBinaryRor = new SgAsmBinaryRorStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmBinaryRor) , sizeof ( SgAsmBinaryRorStorageClass ) * sizeOfActualPool) ;
        SgAsmBinaryRorStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmBinaryRorStorageClass* storageArray = storageArraySgAsmBinaryRor;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmBinaryRor* tmp = new SgAsmBinaryRor ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmBinaryRor;  
      SgAsmBinaryRorStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmBinarySubtract ); 
     storageClassIndex = 0 ;
     SgAsmBinarySubtractStorageClass* storageArraySgAsmBinarySubtract = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmBinarySubtract = new SgAsmBinarySubtractStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmBinarySubtract) , sizeof ( SgAsmBinarySubtractStorageClass ) * sizeOfActualPool) ;
        SgAsmBinarySubtractStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmBinarySubtractStorageClass* storageArray = storageArraySgAsmBinarySubtract;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmBinarySubtract* tmp = new SgAsmBinarySubtract ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmBinarySubtract;  
      SgAsmBinarySubtractStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmBinarySubtractPostupdate ); 
     storageClassIndex = 0 ;
     SgAsmBinarySubtractPostupdateStorageClass* storageArraySgAsmBinarySubtractPostupdate = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmBinarySubtractPostupdate = new SgAsmBinarySubtractPostupdateStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmBinarySubtractPostupdate) , sizeof ( SgAsmBinarySubtractPostupdateStorageClass ) * sizeOfActualPool) ;
        SgAsmBinarySubtractPostupdateStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmBinarySubtractPostupdateStorageClass* storageArray = storageArraySgAsmBinarySubtractPostupdate;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmBinarySubtractPostupdate* tmp = new SgAsmBinarySubtractPostupdate ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmBinarySubtractPostupdate;  
      SgAsmBinarySubtractPostupdateStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmBinarySubtractPreupdate ); 
     storageClassIndex = 0 ;
     SgAsmBinarySubtractPreupdateStorageClass* storageArraySgAsmBinarySubtractPreupdate = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmBinarySubtractPreupdate = new SgAsmBinarySubtractPreupdateStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmBinarySubtractPreupdate) , sizeof ( SgAsmBinarySubtractPreupdateStorageClass ) * sizeOfActualPool) ;
        SgAsmBinarySubtractPreupdateStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmBinarySubtractPreupdateStorageClass* storageArray = storageArraySgAsmBinarySubtractPreupdate;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmBinarySubtractPreupdate* tmp = new SgAsmBinarySubtractPreupdate ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmBinarySubtractPreupdate;  
      SgAsmBinarySubtractPreupdateStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmBlock ); 
     storageClassIndex = 0 ;
     SgAsmBlockStorageClass* storageArraySgAsmBlock = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmBlock = new SgAsmBlockStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmBlock) , sizeof ( SgAsmBlockStorageClass ) * sizeOfActualPool) ;
        SgAsmBlockStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmBlockStorageClass* storageArray = storageArraySgAsmBlock;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmBlock* tmp = new SgAsmBlock ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmBlock;  
      SgAsmBlockStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmByteValueExpression ); 
     storageClassIndex = 0 ;
     SgAsmByteValueExpressionStorageClass* storageArraySgAsmByteValueExpression = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmByteValueExpression = new SgAsmByteValueExpressionStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmByteValueExpression) , sizeof ( SgAsmByteValueExpressionStorageClass ) * sizeOfActualPool) ;
        SgAsmByteValueExpressionStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmByteValueExpressionStorageClass* storageArray = storageArraySgAsmByteValueExpression;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmByteValueExpression* tmp = new SgAsmByteValueExpression ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmByteValueExpression;  
      SgAsmByteValueExpressionStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmCoffStrtab ); 
     storageClassIndex = 0 ;
     SgAsmCoffStrtabStorageClass* storageArraySgAsmCoffStrtab = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmCoffStrtab = new SgAsmCoffStrtabStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmCoffStrtab) , sizeof ( SgAsmCoffStrtabStorageClass ) * sizeOfActualPool) ;
        SgAsmCoffStrtabStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmCoffStrtabStorageClass* storageArray = storageArraySgAsmCoffStrtab;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmCoffStrtab* tmp = new SgAsmCoffStrtab ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmCoffStrtab;  
      SgAsmCoffStrtabStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmCoffSymbol ); 
     storageClassIndex = 0 ;
     SgAsmCoffSymbolStorageClass* storageArraySgAsmCoffSymbol = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmCoffSymbol = new SgAsmCoffSymbolStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmCoffSymbol) , sizeof ( SgAsmCoffSymbolStorageClass ) * sizeOfActualPool) ;
        SgAsmCoffSymbolStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmCoffSymbolStorageClass* storageArray = storageArraySgAsmCoffSymbol;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmCoffSymbol* tmp = new SgAsmCoffSymbol ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmCoffSymbol;  
      SgAsmCoffSymbolStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmCoffSymbolList ); 
     storageClassIndex = 0 ;
     SgAsmCoffSymbolListStorageClass* storageArraySgAsmCoffSymbolList = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmCoffSymbolList = new SgAsmCoffSymbolListStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmCoffSymbolList) , sizeof ( SgAsmCoffSymbolListStorageClass ) * sizeOfActualPool) ;
        SgAsmCoffSymbolListStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmCoffSymbolListStorageClass* storageArray = storageArraySgAsmCoffSymbolList;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmCoffSymbolList* tmp = new SgAsmCoffSymbolList ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmCoffSymbolList;  
      SgAsmCoffSymbolListStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmCoffSymbolTable ); 
     storageClassIndex = 0 ;
     SgAsmCoffSymbolTableStorageClass* storageArraySgAsmCoffSymbolTable = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmCoffSymbolTable = new SgAsmCoffSymbolTableStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmCoffSymbolTable) , sizeof ( SgAsmCoffSymbolTableStorageClass ) * sizeOfActualPool) ;
        SgAsmCoffSymbolTableStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmCoffSymbolTableStorageClass* storageArray = storageArraySgAsmCoffSymbolTable;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmCoffSymbolTable* tmp = new SgAsmCoffSymbolTable ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmCoffSymbolTable;  
      SgAsmCoffSymbolTableStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmCommonSubExpression ); 
     storageClassIndex = 0 ;
     SgAsmCommonSubExpressionStorageClass* storageArraySgAsmCommonSubExpression = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmCommonSubExpression = new SgAsmCommonSubExpressionStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmCommonSubExpression) , sizeof ( SgAsmCommonSubExpressionStorageClass ) * sizeOfActualPool) ;
        SgAsmCommonSubExpressionStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmCommonSubExpressionStorageClass* storageArray = storageArraySgAsmCommonSubExpression;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmCommonSubExpression* tmp = new SgAsmCommonSubExpression ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmCommonSubExpression;  
      SgAsmCommonSubExpressionStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmControlFlagsExpression ); 
     storageClassIndex = 0 ;
     SgAsmControlFlagsExpressionStorageClass* storageArraySgAsmControlFlagsExpression = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmControlFlagsExpression = new SgAsmControlFlagsExpressionStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmControlFlagsExpression) , sizeof ( SgAsmControlFlagsExpressionStorageClass ) * sizeOfActualPool) ;
        SgAsmControlFlagsExpressionStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmControlFlagsExpressionStorageClass* storageArray = storageArraySgAsmControlFlagsExpression;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmControlFlagsExpression* tmp = new SgAsmControlFlagsExpression ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmControlFlagsExpression;  
      SgAsmControlFlagsExpressionStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDOSExtendedHeader ); 
     storageClassIndex = 0 ;
     SgAsmDOSExtendedHeaderStorageClass* storageArraySgAsmDOSExtendedHeader = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDOSExtendedHeader = new SgAsmDOSExtendedHeaderStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDOSExtendedHeader) , sizeof ( SgAsmDOSExtendedHeaderStorageClass ) * sizeOfActualPool) ;
        SgAsmDOSExtendedHeaderStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDOSExtendedHeaderStorageClass* storageArray = storageArraySgAsmDOSExtendedHeader;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmDOSExtendedHeader* tmp = new SgAsmDOSExtendedHeader ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDOSExtendedHeader;  
      SgAsmDOSExtendedHeaderStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDOSFileHeader ); 
     storageClassIndex = 0 ;
     SgAsmDOSFileHeaderStorageClass* storageArraySgAsmDOSFileHeader = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDOSFileHeader = new SgAsmDOSFileHeaderStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDOSFileHeader) , sizeof ( SgAsmDOSFileHeaderStorageClass ) * sizeOfActualPool) ;
        SgAsmDOSFileHeaderStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDOSFileHeaderStorageClass* storageArray = storageArraySgAsmDOSFileHeader;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmDOSFileHeader* tmp = new SgAsmDOSFileHeader ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDOSFileHeader;  
      SgAsmDOSFileHeaderStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDoubleFloatValueExpression ); 
     storageClassIndex = 0 ;
     SgAsmDoubleFloatValueExpressionStorageClass* storageArraySgAsmDoubleFloatValueExpression = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDoubleFloatValueExpression = new SgAsmDoubleFloatValueExpressionStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDoubleFloatValueExpression) , sizeof ( SgAsmDoubleFloatValueExpressionStorageClass ) * sizeOfActualPool) ;
        SgAsmDoubleFloatValueExpressionStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDoubleFloatValueExpressionStorageClass* storageArray = storageArraySgAsmDoubleFloatValueExpression;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmDoubleFloatValueExpression* tmp = new SgAsmDoubleFloatValueExpression ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDoubleFloatValueExpression;  
      SgAsmDoubleFloatValueExpressionStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDoubleWordValueExpression ); 
     storageClassIndex = 0 ;
     SgAsmDoubleWordValueExpressionStorageClass* storageArraySgAsmDoubleWordValueExpression = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDoubleWordValueExpression = new SgAsmDoubleWordValueExpressionStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDoubleWordValueExpression) , sizeof ( SgAsmDoubleWordValueExpressionStorageClass ) * sizeOfActualPool) ;
        SgAsmDoubleWordValueExpressionStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDoubleWordValueExpressionStorageClass* storageArray = storageArraySgAsmDoubleWordValueExpression;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmDoubleWordValueExpression* tmp = new SgAsmDoubleWordValueExpression ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDoubleWordValueExpression;  
      SgAsmDoubleWordValueExpressionStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDwarfAccessDeclaration ); 
     storageClassIndex = 0 ;
     SgAsmDwarfAccessDeclarationStorageClass* storageArraySgAsmDwarfAccessDeclaration = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDwarfAccessDeclaration = new SgAsmDwarfAccessDeclarationStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDwarfAccessDeclaration) , sizeof ( SgAsmDwarfAccessDeclarationStorageClass ) * sizeOfActualPool) ;
        SgAsmDwarfAccessDeclarationStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDwarfAccessDeclarationStorageClass* storageArray = storageArraySgAsmDwarfAccessDeclaration;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmDwarfAccessDeclaration* tmp = new SgAsmDwarfAccessDeclaration ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDwarfAccessDeclaration;  
      SgAsmDwarfAccessDeclarationStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDwarfArrayType ); 
     storageClassIndex = 0 ;
     SgAsmDwarfArrayTypeStorageClass* storageArraySgAsmDwarfArrayType = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDwarfArrayType = new SgAsmDwarfArrayTypeStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDwarfArrayType) , sizeof ( SgAsmDwarfArrayTypeStorageClass ) * sizeOfActualPool) ;
        SgAsmDwarfArrayTypeStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDwarfArrayTypeStorageClass* storageArray = storageArraySgAsmDwarfArrayType;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmDwarfArrayType* tmp = new SgAsmDwarfArrayType ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDwarfArrayType;  
      SgAsmDwarfArrayTypeStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDwarfBaseType ); 
     storageClassIndex = 0 ;
     SgAsmDwarfBaseTypeStorageClass* storageArraySgAsmDwarfBaseType = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDwarfBaseType = new SgAsmDwarfBaseTypeStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDwarfBaseType) , sizeof ( SgAsmDwarfBaseTypeStorageClass ) * sizeOfActualPool) ;
        SgAsmDwarfBaseTypeStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDwarfBaseTypeStorageClass* storageArray = storageArraySgAsmDwarfBaseType;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmDwarfBaseType* tmp = new SgAsmDwarfBaseType ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDwarfBaseType;  
      SgAsmDwarfBaseTypeStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDwarfCatchBlock ); 
     storageClassIndex = 0 ;
     SgAsmDwarfCatchBlockStorageClass* storageArraySgAsmDwarfCatchBlock = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDwarfCatchBlock = new SgAsmDwarfCatchBlockStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDwarfCatchBlock) , sizeof ( SgAsmDwarfCatchBlockStorageClass ) * sizeOfActualPool) ;
        SgAsmDwarfCatchBlockStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDwarfCatchBlockStorageClass* storageArray = storageArraySgAsmDwarfCatchBlock;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmDwarfCatchBlock* tmp = new SgAsmDwarfCatchBlock ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDwarfCatchBlock;  
      SgAsmDwarfCatchBlockStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDwarfClassTemplate ); 
     storageClassIndex = 0 ;
     SgAsmDwarfClassTemplateStorageClass* storageArraySgAsmDwarfClassTemplate = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDwarfClassTemplate = new SgAsmDwarfClassTemplateStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDwarfClassTemplate) , sizeof ( SgAsmDwarfClassTemplateStorageClass ) * sizeOfActualPool) ;
        SgAsmDwarfClassTemplateStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDwarfClassTemplateStorageClass* storageArray = storageArraySgAsmDwarfClassTemplate;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmDwarfClassTemplate* tmp = new SgAsmDwarfClassTemplate ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDwarfClassTemplate;  
      SgAsmDwarfClassTemplateStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDwarfClassType ); 
     storageClassIndex = 0 ;
     SgAsmDwarfClassTypeStorageClass* storageArraySgAsmDwarfClassType = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDwarfClassType = new SgAsmDwarfClassTypeStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDwarfClassType) , sizeof ( SgAsmDwarfClassTypeStorageClass ) * sizeOfActualPool) ;
        SgAsmDwarfClassTypeStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDwarfClassTypeStorageClass* storageArray = storageArraySgAsmDwarfClassType;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmDwarfClassType* tmp = new SgAsmDwarfClassType ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDwarfClassType;  
      SgAsmDwarfClassTypeStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDwarfCommonBlock ); 
     storageClassIndex = 0 ;
     SgAsmDwarfCommonBlockStorageClass* storageArraySgAsmDwarfCommonBlock = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDwarfCommonBlock = new SgAsmDwarfCommonBlockStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDwarfCommonBlock) , sizeof ( SgAsmDwarfCommonBlockStorageClass ) * sizeOfActualPool) ;
        SgAsmDwarfCommonBlockStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDwarfCommonBlockStorageClass* storageArray = storageArraySgAsmDwarfCommonBlock;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmDwarfCommonBlock* tmp = new SgAsmDwarfCommonBlock ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDwarfCommonBlock;  
      SgAsmDwarfCommonBlockStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDwarfCommonInclusion ); 
     storageClassIndex = 0 ;
     SgAsmDwarfCommonInclusionStorageClass* storageArraySgAsmDwarfCommonInclusion = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDwarfCommonInclusion = new SgAsmDwarfCommonInclusionStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDwarfCommonInclusion) , sizeof ( SgAsmDwarfCommonInclusionStorageClass ) * sizeOfActualPool) ;
        SgAsmDwarfCommonInclusionStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDwarfCommonInclusionStorageClass* storageArray = storageArraySgAsmDwarfCommonInclusion;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmDwarfCommonInclusion* tmp = new SgAsmDwarfCommonInclusion ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDwarfCommonInclusion;  
      SgAsmDwarfCommonInclusionStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDwarfCompilationUnit ); 
     storageClassIndex = 0 ;
     SgAsmDwarfCompilationUnitStorageClass* storageArraySgAsmDwarfCompilationUnit = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDwarfCompilationUnit = new SgAsmDwarfCompilationUnitStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDwarfCompilationUnit) , sizeof ( SgAsmDwarfCompilationUnitStorageClass ) * sizeOfActualPool) ;
        SgAsmDwarfCompilationUnitStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDwarfCompilationUnitStorageClass* storageArray = storageArraySgAsmDwarfCompilationUnit;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmDwarfCompilationUnit* tmp = new SgAsmDwarfCompilationUnit ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDwarfCompilationUnit;  
      SgAsmDwarfCompilationUnitStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDwarfCompilationUnitList ); 
     storageClassIndex = 0 ;
     SgAsmDwarfCompilationUnitListStorageClass* storageArraySgAsmDwarfCompilationUnitList = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDwarfCompilationUnitList = new SgAsmDwarfCompilationUnitListStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDwarfCompilationUnitList) , sizeof ( SgAsmDwarfCompilationUnitListStorageClass ) * sizeOfActualPool) ;
        SgAsmDwarfCompilationUnitListStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDwarfCompilationUnitListStorageClass* storageArray = storageArraySgAsmDwarfCompilationUnitList;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmDwarfCompilationUnitList* tmp = new SgAsmDwarfCompilationUnitList ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDwarfCompilationUnitList;  
      SgAsmDwarfCompilationUnitListStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDwarfCondition ); 
     storageClassIndex = 0 ;
     SgAsmDwarfConditionStorageClass* storageArraySgAsmDwarfCondition = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDwarfCondition = new SgAsmDwarfConditionStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDwarfCondition) , sizeof ( SgAsmDwarfConditionStorageClass ) * sizeOfActualPool) ;
        SgAsmDwarfConditionStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDwarfConditionStorageClass* storageArray = storageArraySgAsmDwarfCondition;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmDwarfCondition* tmp = new SgAsmDwarfCondition ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDwarfCondition;  
      SgAsmDwarfConditionStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDwarfConstType ); 
     storageClassIndex = 0 ;
     SgAsmDwarfConstTypeStorageClass* storageArraySgAsmDwarfConstType = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDwarfConstType = new SgAsmDwarfConstTypeStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDwarfConstType) , sizeof ( SgAsmDwarfConstTypeStorageClass ) * sizeOfActualPool) ;
        SgAsmDwarfConstTypeStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDwarfConstTypeStorageClass* storageArray = storageArraySgAsmDwarfConstType;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmDwarfConstType* tmp = new SgAsmDwarfConstType ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDwarfConstType;  
      SgAsmDwarfConstTypeStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDwarfConstant ); 
     storageClassIndex = 0 ;
     SgAsmDwarfConstantStorageClass* storageArraySgAsmDwarfConstant = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDwarfConstant = new SgAsmDwarfConstantStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDwarfConstant) , sizeof ( SgAsmDwarfConstantStorageClass ) * sizeOfActualPool) ;
        SgAsmDwarfConstantStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDwarfConstantStorageClass* storageArray = storageArraySgAsmDwarfConstant;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmDwarfConstant* tmp = new SgAsmDwarfConstant ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDwarfConstant;  
      SgAsmDwarfConstantStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDwarfConstruct ); 
     storageClassIndex = 0 ;
     SgAsmDwarfConstructStorageClass* storageArraySgAsmDwarfConstruct = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDwarfConstruct = new SgAsmDwarfConstructStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDwarfConstruct) , sizeof ( SgAsmDwarfConstructStorageClass ) * sizeOfActualPool) ;
        SgAsmDwarfConstructStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDwarfConstructStorageClass* storageArray = storageArraySgAsmDwarfConstruct;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmDwarfConstruct* tmp = new SgAsmDwarfConstruct ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDwarfConstruct;  
      SgAsmDwarfConstructStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDwarfConstructList ); 
     storageClassIndex = 0 ;
     SgAsmDwarfConstructListStorageClass* storageArraySgAsmDwarfConstructList = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDwarfConstructList = new SgAsmDwarfConstructListStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDwarfConstructList) , sizeof ( SgAsmDwarfConstructListStorageClass ) * sizeOfActualPool) ;
        SgAsmDwarfConstructListStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDwarfConstructListStorageClass* storageArray = storageArraySgAsmDwarfConstructList;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmDwarfConstructList* tmp = new SgAsmDwarfConstructList ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDwarfConstructList;  
      SgAsmDwarfConstructListStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDwarfDwarfProcedure ); 
     storageClassIndex = 0 ;
     SgAsmDwarfDwarfProcedureStorageClass* storageArraySgAsmDwarfDwarfProcedure = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDwarfDwarfProcedure = new SgAsmDwarfDwarfProcedureStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDwarfDwarfProcedure) , sizeof ( SgAsmDwarfDwarfProcedureStorageClass ) * sizeOfActualPool) ;
        SgAsmDwarfDwarfProcedureStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDwarfDwarfProcedureStorageClass* storageArray = storageArraySgAsmDwarfDwarfProcedure;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmDwarfDwarfProcedure* tmp = new SgAsmDwarfDwarfProcedure ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDwarfDwarfProcedure;  
      SgAsmDwarfDwarfProcedureStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDwarfEntryPoint ); 
     storageClassIndex = 0 ;
     SgAsmDwarfEntryPointStorageClass* storageArraySgAsmDwarfEntryPoint = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDwarfEntryPoint = new SgAsmDwarfEntryPointStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDwarfEntryPoint) , sizeof ( SgAsmDwarfEntryPointStorageClass ) * sizeOfActualPool) ;
        SgAsmDwarfEntryPointStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDwarfEntryPointStorageClass* storageArray = storageArraySgAsmDwarfEntryPoint;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmDwarfEntryPoint* tmp = new SgAsmDwarfEntryPoint ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDwarfEntryPoint;  
      SgAsmDwarfEntryPointStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDwarfEnumerationType ); 
     storageClassIndex = 0 ;
     SgAsmDwarfEnumerationTypeStorageClass* storageArraySgAsmDwarfEnumerationType = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDwarfEnumerationType = new SgAsmDwarfEnumerationTypeStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDwarfEnumerationType) , sizeof ( SgAsmDwarfEnumerationTypeStorageClass ) * sizeOfActualPool) ;
        SgAsmDwarfEnumerationTypeStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDwarfEnumerationTypeStorageClass* storageArray = storageArraySgAsmDwarfEnumerationType;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmDwarfEnumerationType* tmp = new SgAsmDwarfEnumerationType ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDwarfEnumerationType;  
      SgAsmDwarfEnumerationTypeStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDwarfEnumerator ); 
     storageClassIndex = 0 ;
     SgAsmDwarfEnumeratorStorageClass* storageArraySgAsmDwarfEnumerator = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDwarfEnumerator = new SgAsmDwarfEnumeratorStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDwarfEnumerator) , sizeof ( SgAsmDwarfEnumeratorStorageClass ) * sizeOfActualPool) ;
        SgAsmDwarfEnumeratorStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDwarfEnumeratorStorageClass* storageArray = storageArraySgAsmDwarfEnumerator;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmDwarfEnumerator* tmp = new SgAsmDwarfEnumerator ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDwarfEnumerator;  
      SgAsmDwarfEnumeratorStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDwarfFileType ); 
     storageClassIndex = 0 ;
     SgAsmDwarfFileTypeStorageClass* storageArraySgAsmDwarfFileType = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDwarfFileType = new SgAsmDwarfFileTypeStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDwarfFileType) , sizeof ( SgAsmDwarfFileTypeStorageClass ) * sizeOfActualPool) ;
        SgAsmDwarfFileTypeStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDwarfFileTypeStorageClass* storageArray = storageArraySgAsmDwarfFileType;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmDwarfFileType* tmp = new SgAsmDwarfFileType ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDwarfFileType;  
      SgAsmDwarfFileTypeStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDwarfFormalParameter ); 
     storageClassIndex = 0 ;
     SgAsmDwarfFormalParameterStorageClass* storageArraySgAsmDwarfFormalParameter = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDwarfFormalParameter = new SgAsmDwarfFormalParameterStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDwarfFormalParameter) , sizeof ( SgAsmDwarfFormalParameterStorageClass ) * sizeOfActualPool) ;
        SgAsmDwarfFormalParameterStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDwarfFormalParameterStorageClass* storageArray = storageArraySgAsmDwarfFormalParameter;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmDwarfFormalParameter* tmp = new SgAsmDwarfFormalParameter ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDwarfFormalParameter;  
      SgAsmDwarfFormalParameterStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDwarfFormatLabel ); 
     storageClassIndex = 0 ;
     SgAsmDwarfFormatLabelStorageClass* storageArraySgAsmDwarfFormatLabel = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDwarfFormatLabel = new SgAsmDwarfFormatLabelStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDwarfFormatLabel) , sizeof ( SgAsmDwarfFormatLabelStorageClass ) * sizeOfActualPool) ;
        SgAsmDwarfFormatLabelStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDwarfFormatLabelStorageClass* storageArray = storageArraySgAsmDwarfFormatLabel;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmDwarfFormatLabel* tmp = new SgAsmDwarfFormatLabel ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDwarfFormatLabel;  
      SgAsmDwarfFormatLabelStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDwarfFriend ); 
     storageClassIndex = 0 ;
     SgAsmDwarfFriendStorageClass* storageArraySgAsmDwarfFriend = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDwarfFriend = new SgAsmDwarfFriendStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDwarfFriend) , sizeof ( SgAsmDwarfFriendStorageClass ) * sizeOfActualPool) ;
        SgAsmDwarfFriendStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDwarfFriendStorageClass* storageArray = storageArraySgAsmDwarfFriend;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmDwarfFriend* tmp = new SgAsmDwarfFriend ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDwarfFriend;  
      SgAsmDwarfFriendStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDwarfFunctionTemplate ); 
     storageClassIndex = 0 ;
     SgAsmDwarfFunctionTemplateStorageClass* storageArraySgAsmDwarfFunctionTemplate = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDwarfFunctionTemplate = new SgAsmDwarfFunctionTemplateStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDwarfFunctionTemplate) , sizeof ( SgAsmDwarfFunctionTemplateStorageClass ) * sizeOfActualPool) ;
        SgAsmDwarfFunctionTemplateStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDwarfFunctionTemplateStorageClass* storageArray = storageArraySgAsmDwarfFunctionTemplate;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmDwarfFunctionTemplate* tmp = new SgAsmDwarfFunctionTemplate ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDwarfFunctionTemplate;  
      SgAsmDwarfFunctionTemplateStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDwarfImportedDeclaration ); 
     storageClassIndex = 0 ;
     SgAsmDwarfImportedDeclarationStorageClass* storageArraySgAsmDwarfImportedDeclaration = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDwarfImportedDeclaration = new SgAsmDwarfImportedDeclarationStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDwarfImportedDeclaration) , sizeof ( SgAsmDwarfImportedDeclarationStorageClass ) * sizeOfActualPool) ;
        SgAsmDwarfImportedDeclarationStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDwarfImportedDeclarationStorageClass* storageArray = storageArraySgAsmDwarfImportedDeclaration;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmDwarfImportedDeclaration* tmp = new SgAsmDwarfImportedDeclaration ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDwarfImportedDeclaration;  
      SgAsmDwarfImportedDeclarationStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDwarfImportedModule ); 
     storageClassIndex = 0 ;
     SgAsmDwarfImportedModuleStorageClass* storageArraySgAsmDwarfImportedModule = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDwarfImportedModule = new SgAsmDwarfImportedModuleStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDwarfImportedModule) , sizeof ( SgAsmDwarfImportedModuleStorageClass ) * sizeOfActualPool) ;
        SgAsmDwarfImportedModuleStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDwarfImportedModuleStorageClass* storageArray = storageArraySgAsmDwarfImportedModule;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmDwarfImportedModule* tmp = new SgAsmDwarfImportedModule ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDwarfImportedModule;  
      SgAsmDwarfImportedModuleStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDwarfImportedUnit ); 
     storageClassIndex = 0 ;
     SgAsmDwarfImportedUnitStorageClass* storageArraySgAsmDwarfImportedUnit = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDwarfImportedUnit = new SgAsmDwarfImportedUnitStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDwarfImportedUnit) , sizeof ( SgAsmDwarfImportedUnitStorageClass ) * sizeOfActualPool) ;
        SgAsmDwarfImportedUnitStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDwarfImportedUnitStorageClass* storageArray = storageArraySgAsmDwarfImportedUnit;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmDwarfImportedUnit* tmp = new SgAsmDwarfImportedUnit ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDwarfImportedUnit;  
      SgAsmDwarfImportedUnitStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDwarfInformation ); 
     storageClassIndex = 0 ;
     SgAsmDwarfInformationStorageClass* storageArraySgAsmDwarfInformation = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDwarfInformation = new SgAsmDwarfInformationStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDwarfInformation) , sizeof ( SgAsmDwarfInformationStorageClass ) * sizeOfActualPool) ;
        SgAsmDwarfInformationStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDwarfInformationStorageClass* storageArray = storageArraySgAsmDwarfInformation;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmDwarfInformation* tmp = new SgAsmDwarfInformation ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDwarfInformation;  
      SgAsmDwarfInformationStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDwarfInheritance ); 
     storageClassIndex = 0 ;
     SgAsmDwarfInheritanceStorageClass* storageArraySgAsmDwarfInheritance = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDwarfInheritance = new SgAsmDwarfInheritanceStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDwarfInheritance) , sizeof ( SgAsmDwarfInheritanceStorageClass ) * sizeOfActualPool) ;
        SgAsmDwarfInheritanceStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDwarfInheritanceStorageClass* storageArray = storageArraySgAsmDwarfInheritance;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmDwarfInheritance* tmp = new SgAsmDwarfInheritance ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDwarfInheritance;  
      SgAsmDwarfInheritanceStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDwarfInlinedSubroutine ); 
     storageClassIndex = 0 ;
     SgAsmDwarfInlinedSubroutineStorageClass* storageArraySgAsmDwarfInlinedSubroutine = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDwarfInlinedSubroutine = new SgAsmDwarfInlinedSubroutineStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDwarfInlinedSubroutine) , sizeof ( SgAsmDwarfInlinedSubroutineStorageClass ) * sizeOfActualPool) ;
        SgAsmDwarfInlinedSubroutineStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDwarfInlinedSubroutineStorageClass* storageArray = storageArraySgAsmDwarfInlinedSubroutine;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmDwarfInlinedSubroutine* tmp = new SgAsmDwarfInlinedSubroutine ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDwarfInlinedSubroutine;  
      SgAsmDwarfInlinedSubroutineStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDwarfInterfaceType ); 
     storageClassIndex = 0 ;
     SgAsmDwarfInterfaceTypeStorageClass* storageArraySgAsmDwarfInterfaceType = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDwarfInterfaceType = new SgAsmDwarfInterfaceTypeStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDwarfInterfaceType) , sizeof ( SgAsmDwarfInterfaceTypeStorageClass ) * sizeOfActualPool) ;
        SgAsmDwarfInterfaceTypeStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDwarfInterfaceTypeStorageClass* storageArray = storageArraySgAsmDwarfInterfaceType;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmDwarfInterfaceType* tmp = new SgAsmDwarfInterfaceType ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDwarfInterfaceType;  
      SgAsmDwarfInterfaceTypeStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDwarfLabel ); 
     storageClassIndex = 0 ;
     SgAsmDwarfLabelStorageClass* storageArraySgAsmDwarfLabel = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDwarfLabel = new SgAsmDwarfLabelStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDwarfLabel) , sizeof ( SgAsmDwarfLabelStorageClass ) * sizeOfActualPool) ;
        SgAsmDwarfLabelStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDwarfLabelStorageClass* storageArray = storageArraySgAsmDwarfLabel;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmDwarfLabel* tmp = new SgAsmDwarfLabel ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDwarfLabel;  
      SgAsmDwarfLabelStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDwarfLexicalBlock ); 
     storageClassIndex = 0 ;
     SgAsmDwarfLexicalBlockStorageClass* storageArraySgAsmDwarfLexicalBlock = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDwarfLexicalBlock = new SgAsmDwarfLexicalBlockStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDwarfLexicalBlock) , sizeof ( SgAsmDwarfLexicalBlockStorageClass ) * sizeOfActualPool) ;
        SgAsmDwarfLexicalBlockStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDwarfLexicalBlockStorageClass* storageArray = storageArraySgAsmDwarfLexicalBlock;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmDwarfLexicalBlock* tmp = new SgAsmDwarfLexicalBlock ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDwarfLexicalBlock;  
      SgAsmDwarfLexicalBlockStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDwarfLine ); 
     storageClassIndex = 0 ;
     SgAsmDwarfLineStorageClass* storageArraySgAsmDwarfLine = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDwarfLine = new SgAsmDwarfLineStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDwarfLine) , sizeof ( SgAsmDwarfLineStorageClass ) * sizeOfActualPool) ;
        SgAsmDwarfLineStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDwarfLineStorageClass* storageArray = storageArraySgAsmDwarfLine;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmDwarfLine* tmp = new SgAsmDwarfLine ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDwarfLine;  
      SgAsmDwarfLineStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDwarfLineList ); 
     storageClassIndex = 0 ;
     SgAsmDwarfLineListStorageClass* storageArraySgAsmDwarfLineList = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDwarfLineList = new SgAsmDwarfLineListStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDwarfLineList) , sizeof ( SgAsmDwarfLineListStorageClass ) * sizeOfActualPool) ;
        SgAsmDwarfLineListStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDwarfLineListStorageClass* storageArray = storageArraySgAsmDwarfLineList;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmDwarfLineList* tmp = new SgAsmDwarfLineList ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDwarfLineList;  
      SgAsmDwarfLineListStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDwarfMacro ); 
     storageClassIndex = 0 ;
     SgAsmDwarfMacroStorageClass* storageArraySgAsmDwarfMacro = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDwarfMacro = new SgAsmDwarfMacroStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDwarfMacro) , sizeof ( SgAsmDwarfMacroStorageClass ) * sizeOfActualPool) ;
        SgAsmDwarfMacroStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDwarfMacroStorageClass* storageArray = storageArraySgAsmDwarfMacro;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmDwarfMacro* tmp = new SgAsmDwarfMacro ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDwarfMacro;  
      SgAsmDwarfMacroStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDwarfMacroList ); 
     storageClassIndex = 0 ;
     SgAsmDwarfMacroListStorageClass* storageArraySgAsmDwarfMacroList = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDwarfMacroList = new SgAsmDwarfMacroListStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDwarfMacroList) , sizeof ( SgAsmDwarfMacroListStorageClass ) * sizeOfActualPool) ;
        SgAsmDwarfMacroListStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDwarfMacroListStorageClass* storageArray = storageArraySgAsmDwarfMacroList;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmDwarfMacroList* tmp = new SgAsmDwarfMacroList ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDwarfMacroList;  
      SgAsmDwarfMacroListStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDwarfMember ); 
     storageClassIndex = 0 ;
     SgAsmDwarfMemberStorageClass* storageArraySgAsmDwarfMember = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDwarfMember = new SgAsmDwarfMemberStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDwarfMember) , sizeof ( SgAsmDwarfMemberStorageClass ) * sizeOfActualPool) ;
        SgAsmDwarfMemberStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDwarfMemberStorageClass* storageArray = storageArraySgAsmDwarfMember;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmDwarfMember* tmp = new SgAsmDwarfMember ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDwarfMember;  
      SgAsmDwarfMemberStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDwarfModule ); 
     storageClassIndex = 0 ;
     SgAsmDwarfModuleStorageClass* storageArraySgAsmDwarfModule = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDwarfModule = new SgAsmDwarfModuleStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDwarfModule) , sizeof ( SgAsmDwarfModuleStorageClass ) * sizeOfActualPool) ;
        SgAsmDwarfModuleStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDwarfModuleStorageClass* storageArray = storageArraySgAsmDwarfModule;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmDwarfModule* tmp = new SgAsmDwarfModule ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDwarfModule;  
      SgAsmDwarfModuleStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDwarfMutableType ); 
     storageClassIndex = 0 ;
     SgAsmDwarfMutableTypeStorageClass* storageArraySgAsmDwarfMutableType = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDwarfMutableType = new SgAsmDwarfMutableTypeStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDwarfMutableType) , sizeof ( SgAsmDwarfMutableTypeStorageClass ) * sizeOfActualPool) ;
        SgAsmDwarfMutableTypeStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDwarfMutableTypeStorageClass* storageArray = storageArraySgAsmDwarfMutableType;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmDwarfMutableType* tmp = new SgAsmDwarfMutableType ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDwarfMutableType;  
      SgAsmDwarfMutableTypeStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDwarfNamelist ); 
     storageClassIndex = 0 ;
     SgAsmDwarfNamelistStorageClass* storageArraySgAsmDwarfNamelist = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDwarfNamelist = new SgAsmDwarfNamelistStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDwarfNamelist) , sizeof ( SgAsmDwarfNamelistStorageClass ) * sizeOfActualPool) ;
        SgAsmDwarfNamelistStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDwarfNamelistStorageClass* storageArray = storageArraySgAsmDwarfNamelist;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmDwarfNamelist* tmp = new SgAsmDwarfNamelist ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDwarfNamelist;  
      SgAsmDwarfNamelistStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDwarfNamelistItem ); 
     storageClassIndex = 0 ;
     SgAsmDwarfNamelistItemStorageClass* storageArraySgAsmDwarfNamelistItem = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDwarfNamelistItem = new SgAsmDwarfNamelistItemStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDwarfNamelistItem) , sizeof ( SgAsmDwarfNamelistItemStorageClass ) * sizeOfActualPool) ;
        SgAsmDwarfNamelistItemStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDwarfNamelistItemStorageClass* storageArray = storageArraySgAsmDwarfNamelistItem;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmDwarfNamelistItem* tmp = new SgAsmDwarfNamelistItem ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDwarfNamelistItem;  
      SgAsmDwarfNamelistItemStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDwarfNamespace ); 
     storageClassIndex = 0 ;
     SgAsmDwarfNamespaceStorageClass* storageArraySgAsmDwarfNamespace = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDwarfNamespace = new SgAsmDwarfNamespaceStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDwarfNamespace) , sizeof ( SgAsmDwarfNamespaceStorageClass ) * sizeOfActualPool) ;
        SgAsmDwarfNamespaceStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDwarfNamespaceStorageClass* storageArray = storageArraySgAsmDwarfNamespace;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmDwarfNamespace* tmp = new SgAsmDwarfNamespace ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDwarfNamespace;  
      SgAsmDwarfNamespaceStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDwarfPackedType ); 
     storageClassIndex = 0 ;
     SgAsmDwarfPackedTypeStorageClass* storageArraySgAsmDwarfPackedType = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDwarfPackedType = new SgAsmDwarfPackedTypeStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDwarfPackedType) , sizeof ( SgAsmDwarfPackedTypeStorageClass ) * sizeOfActualPool) ;
        SgAsmDwarfPackedTypeStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDwarfPackedTypeStorageClass* storageArray = storageArraySgAsmDwarfPackedType;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmDwarfPackedType* tmp = new SgAsmDwarfPackedType ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDwarfPackedType;  
      SgAsmDwarfPackedTypeStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDwarfPartialUnit ); 
     storageClassIndex = 0 ;
     SgAsmDwarfPartialUnitStorageClass* storageArraySgAsmDwarfPartialUnit = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDwarfPartialUnit = new SgAsmDwarfPartialUnitStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDwarfPartialUnit) , sizeof ( SgAsmDwarfPartialUnitStorageClass ) * sizeOfActualPool) ;
        SgAsmDwarfPartialUnitStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDwarfPartialUnitStorageClass* storageArray = storageArraySgAsmDwarfPartialUnit;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmDwarfPartialUnit* tmp = new SgAsmDwarfPartialUnit ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDwarfPartialUnit;  
      SgAsmDwarfPartialUnitStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDwarfPointerType ); 
     storageClassIndex = 0 ;
     SgAsmDwarfPointerTypeStorageClass* storageArraySgAsmDwarfPointerType = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDwarfPointerType = new SgAsmDwarfPointerTypeStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDwarfPointerType) , sizeof ( SgAsmDwarfPointerTypeStorageClass ) * sizeOfActualPool) ;
        SgAsmDwarfPointerTypeStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDwarfPointerTypeStorageClass* storageArray = storageArraySgAsmDwarfPointerType;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmDwarfPointerType* tmp = new SgAsmDwarfPointerType ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDwarfPointerType;  
      SgAsmDwarfPointerTypeStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDwarfPtrToMemberType ); 
     storageClassIndex = 0 ;
     SgAsmDwarfPtrToMemberTypeStorageClass* storageArraySgAsmDwarfPtrToMemberType = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDwarfPtrToMemberType = new SgAsmDwarfPtrToMemberTypeStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDwarfPtrToMemberType) , sizeof ( SgAsmDwarfPtrToMemberTypeStorageClass ) * sizeOfActualPool) ;
        SgAsmDwarfPtrToMemberTypeStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDwarfPtrToMemberTypeStorageClass* storageArray = storageArraySgAsmDwarfPtrToMemberType;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmDwarfPtrToMemberType* tmp = new SgAsmDwarfPtrToMemberType ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDwarfPtrToMemberType;  
      SgAsmDwarfPtrToMemberTypeStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDwarfReferenceType ); 
     storageClassIndex = 0 ;
     SgAsmDwarfReferenceTypeStorageClass* storageArraySgAsmDwarfReferenceType = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDwarfReferenceType = new SgAsmDwarfReferenceTypeStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDwarfReferenceType) , sizeof ( SgAsmDwarfReferenceTypeStorageClass ) * sizeOfActualPool) ;
        SgAsmDwarfReferenceTypeStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDwarfReferenceTypeStorageClass* storageArray = storageArraySgAsmDwarfReferenceType;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmDwarfReferenceType* tmp = new SgAsmDwarfReferenceType ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDwarfReferenceType;  
      SgAsmDwarfReferenceTypeStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDwarfRestrictType ); 
     storageClassIndex = 0 ;
     SgAsmDwarfRestrictTypeStorageClass* storageArraySgAsmDwarfRestrictType = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDwarfRestrictType = new SgAsmDwarfRestrictTypeStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDwarfRestrictType) , sizeof ( SgAsmDwarfRestrictTypeStorageClass ) * sizeOfActualPool) ;
        SgAsmDwarfRestrictTypeStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDwarfRestrictTypeStorageClass* storageArray = storageArraySgAsmDwarfRestrictType;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmDwarfRestrictType* tmp = new SgAsmDwarfRestrictType ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDwarfRestrictType;  
      SgAsmDwarfRestrictTypeStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDwarfSetType ); 
     storageClassIndex = 0 ;
     SgAsmDwarfSetTypeStorageClass* storageArraySgAsmDwarfSetType = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDwarfSetType = new SgAsmDwarfSetTypeStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDwarfSetType) , sizeof ( SgAsmDwarfSetTypeStorageClass ) * sizeOfActualPool) ;
        SgAsmDwarfSetTypeStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDwarfSetTypeStorageClass* storageArray = storageArraySgAsmDwarfSetType;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmDwarfSetType* tmp = new SgAsmDwarfSetType ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDwarfSetType;  
      SgAsmDwarfSetTypeStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDwarfSharedType ); 
     storageClassIndex = 0 ;
     SgAsmDwarfSharedTypeStorageClass* storageArraySgAsmDwarfSharedType = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDwarfSharedType = new SgAsmDwarfSharedTypeStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDwarfSharedType) , sizeof ( SgAsmDwarfSharedTypeStorageClass ) * sizeOfActualPool) ;
        SgAsmDwarfSharedTypeStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDwarfSharedTypeStorageClass* storageArray = storageArraySgAsmDwarfSharedType;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmDwarfSharedType* tmp = new SgAsmDwarfSharedType ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDwarfSharedType;  
      SgAsmDwarfSharedTypeStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDwarfStringType ); 
     storageClassIndex = 0 ;
     SgAsmDwarfStringTypeStorageClass* storageArraySgAsmDwarfStringType = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDwarfStringType = new SgAsmDwarfStringTypeStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDwarfStringType) , sizeof ( SgAsmDwarfStringTypeStorageClass ) * sizeOfActualPool) ;
        SgAsmDwarfStringTypeStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDwarfStringTypeStorageClass* storageArray = storageArraySgAsmDwarfStringType;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmDwarfStringType* tmp = new SgAsmDwarfStringType ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDwarfStringType;  
      SgAsmDwarfStringTypeStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDwarfStructureType ); 
     storageClassIndex = 0 ;
     SgAsmDwarfStructureTypeStorageClass* storageArraySgAsmDwarfStructureType = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDwarfStructureType = new SgAsmDwarfStructureTypeStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDwarfStructureType) , sizeof ( SgAsmDwarfStructureTypeStorageClass ) * sizeOfActualPool) ;
        SgAsmDwarfStructureTypeStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDwarfStructureTypeStorageClass* storageArray = storageArraySgAsmDwarfStructureType;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmDwarfStructureType* tmp = new SgAsmDwarfStructureType ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDwarfStructureType;  
      SgAsmDwarfStructureTypeStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDwarfSubprogram ); 
     storageClassIndex = 0 ;
     SgAsmDwarfSubprogramStorageClass* storageArraySgAsmDwarfSubprogram = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDwarfSubprogram = new SgAsmDwarfSubprogramStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDwarfSubprogram) , sizeof ( SgAsmDwarfSubprogramStorageClass ) * sizeOfActualPool) ;
        SgAsmDwarfSubprogramStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDwarfSubprogramStorageClass* storageArray = storageArraySgAsmDwarfSubprogram;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmDwarfSubprogram* tmp = new SgAsmDwarfSubprogram ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDwarfSubprogram;  
      SgAsmDwarfSubprogramStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDwarfSubrangeType ); 
     storageClassIndex = 0 ;
     SgAsmDwarfSubrangeTypeStorageClass* storageArraySgAsmDwarfSubrangeType = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDwarfSubrangeType = new SgAsmDwarfSubrangeTypeStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDwarfSubrangeType) , sizeof ( SgAsmDwarfSubrangeTypeStorageClass ) * sizeOfActualPool) ;
        SgAsmDwarfSubrangeTypeStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDwarfSubrangeTypeStorageClass* storageArray = storageArraySgAsmDwarfSubrangeType;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmDwarfSubrangeType* tmp = new SgAsmDwarfSubrangeType ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDwarfSubrangeType;  
      SgAsmDwarfSubrangeTypeStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDwarfSubroutineType ); 
     storageClassIndex = 0 ;
     SgAsmDwarfSubroutineTypeStorageClass* storageArraySgAsmDwarfSubroutineType = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDwarfSubroutineType = new SgAsmDwarfSubroutineTypeStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDwarfSubroutineType) , sizeof ( SgAsmDwarfSubroutineTypeStorageClass ) * sizeOfActualPool) ;
        SgAsmDwarfSubroutineTypeStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDwarfSubroutineTypeStorageClass* storageArray = storageArraySgAsmDwarfSubroutineType;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmDwarfSubroutineType* tmp = new SgAsmDwarfSubroutineType ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDwarfSubroutineType;  
      SgAsmDwarfSubroutineTypeStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDwarfTemplateTypeParameter ); 
     storageClassIndex = 0 ;
     SgAsmDwarfTemplateTypeParameterStorageClass* storageArraySgAsmDwarfTemplateTypeParameter = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDwarfTemplateTypeParameter = new SgAsmDwarfTemplateTypeParameterStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDwarfTemplateTypeParameter) , sizeof ( SgAsmDwarfTemplateTypeParameterStorageClass ) * sizeOfActualPool) ;
        SgAsmDwarfTemplateTypeParameterStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDwarfTemplateTypeParameterStorageClass* storageArray = storageArraySgAsmDwarfTemplateTypeParameter;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmDwarfTemplateTypeParameter* tmp = new SgAsmDwarfTemplateTypeParameter ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDwarfTemplateTypeParameter;  
      SgAsmDwarfTemplateTypeParameterStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDwarfTemplateValueParameter ); 
     storageClassIndex = 0 ;
     SgAsmDwarfTemplateValueParameterStorageClass* storageArraySgAsmDwarfTemplateValueParameter = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDwarfTemplateValueParameter = new SgAsmDwarfTemplateValueParameterStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDwarfTemplateValueParameter) , sizeof ( SgAsmDwarfTemplateValueParameterStorageClass ) * sizeOfActualPool) ;
        SgAsmDwarfTemplateValueParameterStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDwarfTemplateValueParameterStorageClass* storageArray = storageArraySgAsmDwarfTemplateValueParameter;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmDwarfTemplateValueParameter* tmp = new SgAsmDwarfTemplateValueParameter ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDwarfTemplateValueParameter;  
      SgAsmDwarfTemplateValueParameterStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDwarfThrownType ); 
     storageClassIndex = 0 ;
     SgAsmDwarfThrownTypeStorageClass* storageArraySgAsmDwarfThrownType = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDwarfThrownType = new SgAsmDwarfThrownTypeStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDwarfThrownType) , sizeof ( SgAsmDwarfThrownTypeStorageClass ) * sizeOfActualPool) ;
        SgAsmDwarfThrownTypeStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDwarfThrownTypeStorageClass* storageArray = storageArraySgAsmDwarfThrownType;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmDwarfThrownType* tmp = new SgAsmDwarfThrownType ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDwarfThrownType;  
      SgAsmDwarfThrownTypeStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDwarfTryBlock ); 
     storageClassIndex = 0 ;
     SgAsmDwarfTryBlockStorageClass* storageArraySgAsmDwarfTryBlock = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDwarfTryBlock = new SgAsmDwarfTryBlockStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDwarfTryBlock) , sizeof ( SgAsmDwarfTryBlockStorageClass ) * sizeOfActualPool) ;
        SgAsmDwarfTryBlockStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDwarfTryBlockStorageClass* storageArray = storageArraySgAsmDwarfTryBlock;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmDwarfTryBlock* tmp = new SgAsmDwarfTryBlock ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDwarfTryBlock;  
      SgAsmDwarfTryBlockStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDwarfTypedef ); 
     storageClassIndex = 0 ;
     SgAsmDwarfTypedefStorageClass* storageArraySgAsmDwarfTypedef = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDwarfTypedef = new SgAsmDwarfTypedefStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDwarfTypedef) , sizeof ( SgAsmDwarfTypedefStorageClass ) * sizeOfActualPool) ;
        SgAsmDwarfTypedefStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDwarfTypedefStorageClass* storageArray = storageArraySgAsmDwarfTypedef;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmDwarfTypedef* tmp = new SgAsmDwarfTypedef ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDwarfTypedef;  
      SgAsmDwarfTypedefStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDwarfUnionType ); 
     storageClassIndex = 0 ;
     SgAsmDwarfUnionTypeStorageClass* storageArraySgAsmDwarfUnionType = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDwarfUnionType = new SgAsmDwarfUnionTypeStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDwarfUnionType) , sizeof ( SgAsmDwarfUnionTypeStorageClass ) * sizeOfActualPool) ;
        SgAsmDwarfUnionTypeStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDwarfUnionTypeStorageClass* storageArray = storageArraySgAsmDwarfUnionType;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmDwarfUnionType* tmp = new SgAsmDwarfUnionType ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDwarfUnionType;  
      SgAsmDwarfUnionTypeStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDwarfUnknownConstruct ); 
     storageClassIndex = 0 ;
     SgAsmDwarfUnknownConstructStorageClass* storageArraySgAsmDwarfUnknownConstruct = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDwarfUnknownConstruct = new SgAsmDwarfUnknownConstructStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDwarfUnknownConstruct) , sizeof ( SgAsmDwarfUnknownConstructStorageClass ) * sizeOfActualPool) ;
        SgAsmDwarfUnknownConstructStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDwarfUnknownConstructStorageClass* storageArray = storageArraySgAsmDwarfUnknownConstruct;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmDwarfUnknownConstruct* tmp = new SgAsmDwarfUnknownConstruct ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDwarfUnknownConstruct;  
      SgAsmDwarfUnknownConstructStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDwarfUnspecifiedParameters ); 
     storageClassIndex = 0 ;
     SgAsmDwarfUnspecifiedParametersStorageClass* storageArraySgAsmDwarfUnspecifiedParameters = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDwarfUnspecifiedParameters = new SgAsmDwarfUnspecifiedParametersStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDwarfUnspecifiedParameters) , sizeof ( SgAsmDwarfUnspecifiedParametersStorageClass ) * sizeOfActualPool) ;
        SgAsmDwarfUnspecifiedParametersStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDwarfUnspecifiedParametersStorageClass* storageArray = storageArraySgAsmDwarfUnspecifiedParameters;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmDwarfUnspecifiedParameters* tmp = new SgAsmDwarfUnspecifiedParameters ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDwarfUnspecifiedParameters;  
      SgAsmDwarfUnspecifiedParametersStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDwarfUnspecifiedType ); 
     storageClassIndex = 0 ;
     SgAsmDwarfUnspecifiedTypeStorageClass* storageArraySgAsmDwarfUnspecifiedType = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDwarfUnspecifiedType = new SgAsmDwarfUnspecifiedTypeStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDwarfUnspecifiedType) , sizeof ( SgAsmDwarfUnspecifiedTypeStorageClass ) * sizeOfActualPool) ;
        SgAsmDwarfUnspecifiedTypeStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDwarfUnspecifiedTypeStorageClass* storageArray = storageArraySgAsmDwarfUnspecifiedType;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmDwarfUnspecifiedType* tmp = new SgAsmDwarfUnspecifiedType ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDwarfUnspecifiedType;  
      SgAsmDwarfUnspecifiedTypeStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDwarfUpcRelaxedType ); 
     storageClassIndex = 0 ;
     SgAsmDwarfUpcRelaxedTypeStorageClass* storageArraySgAsmDwarfUpcRelaxedType = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDwarfUpcRelaxedType = new SgAsmDwarfUpcRelaxedTypeStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDwarfUpcRelaxedType) , sizeof ( SgAsmDwarfUpcRelaxedTypeStorageClass ) * sizeOfActualPool) ;
        SgAsmDwarfUpcRelaxedTypeStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDwarfUpcRelaxedTypeStorageClass* storageArray = storageArraySgAsmDwarfUpcRelaxedType;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmDwarfUpcRelaxedType* tmp = new SgAsmDwarfUpcRelaxedType ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDwarfUpcRelaxedType;  
      SgAsmDwarfUpcRelaxedTypeStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDwarfUpcSharedType ); 
     storageClassIndex = 0 ;
     SgAsmDwarfUpcSharedTypeStorageClass* storageArraySgAsmDwarfUpcSharedType = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDwarfUpcSharedType = new SgAsmDwarfUpcSharedTypeStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDwarfUpcSharedType) , sizeof ( SgAsmDwarfUpcSharedTypeStorageClass ) * sizeOfActualPool) ;
        SgAsmDwarfUpcSharedTypeStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDwarfUpcSharedTypeStorageClass* storageArray = storageArraySgAsmDwarfUpcSharedType;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmDwarfUpcSharedType* tmp = new SgAsmDwarfUpcSharedType ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDwarfUpcSharedType;  
      SgAsmDwarfUpcSharedTypeStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDwarfUpcStrictType ); 
     storageClassIndex = 0 ;
     SgAsmDwarfUpcStrictTypeStorageClass* storageArraySgAsmDwarfUpcStrictType = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDwarfUpcStrictType = new SgAsmDwarfUpcStrictTypeStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDwarfUpcStrictType) , sizeof ( SgAsmDwarfUpcStrictTypeStorageClass ) * sizeOfActualPool) ;
        SgAsmDwarfUpcStrictTypeStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDwarfUpcStrictTypeStorageClass* storageArray = storageArraySgAsmDwarfUpcStrictType;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmDwarfUpcStrictType* tmp = new SgAsmDwarfUpcStrictType ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDwarfUpcStrictType;  
      SgAsmDwarfUpcStrictTypeStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDwarfVariable ); 
     storageClassIndex = 0 ;
     SgAsmDwarfVariableStorageClass* storageArraySgAsmDwarfVariable = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDwarfVariable = new SgAsmDwarfVariableStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDwarfVariable) , sizeof ( SgAsmDwarfVariableStorageClass ) * sizeOfActualPool) ;
        SgAsmDwarfVariableStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDwarfVariableStorageClass* storageArray = storageArraySgAsmDwarfVariable;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmDwarfVariable* tmp = new SgAsmDwarfVariable ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDwarfVariable;  
      SgAsmDwarfVariableStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDwarfVariant ); 
     storageClassIndex = 0 ;
     SgAsmDwarfVariantStorageClass* storageArraySgAsmDwarfVariant = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDwarfVariant = new SgAsmDwarfVariantStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDwarfVariant) , sizeof ( SgAsmDwarfVariantStorageClass ) * sizeOfActualPool) ;
        SgAsmDwarfVariantStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDwarfVariantStorageClass* storageArray = storageArraySgAsmDwarfVariant;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmDwarfVariant* tmp = new SgAsmDwarfVariant ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDwarfVariant;  
      SgAsmDwarfVariantStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDwarfVariantPart ); 
     storageClassIndex = 0 ;
     SgAsmDwarfVariantPartStorageClass* storageArraySgAsmDwarfVariantPart = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDwarfVariantPart = new SgAsmDwarfVariantPartStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDwarfVariantPart) , sizeof ( SgAsmDwarfVariantPartStorageClass ) * sizeOfActualPool) ;
        SgAsmDwarfVariantPartStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDwarfVariantPartStorageClass* storageArray = storageArraySgAsmDwarfVariantPart;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmDwarfVariantPart* tmp = new SgAsmDwarfVariantPart ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDwarfVariantPart;  
      SgAsmDwarfVariantPartStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDwarfVolatileType ); 
     storageClassIndex = 0 ;
     SgAsmDwarfVolatileTypeStorageClass* storageArraySgAsmDwarfVolatileType = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDwarfVolatileType = new SgAsmDwarfVolatileTypeStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDwarfVolatileType) , sizeof ( SgAsmDwarfVolatileTypeStorageClass ) * sizeOfActualPool) ;
        SgAsmDwarfVolatileTypeStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDwarfVolatileTypeStorageClass* storageArray = storageArraySgAsmDwarfVolatileType;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmDwarfVolatileType* tmp = new SgAsmDwarfVolatileType ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDwarfVolatileType;  
      SgAsmDwarfVolatileTypeStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmDwarfWithStmt ); 
     storageClassIndex = 0 ;
     SgAsmDwarfWithStmtStorageClass* storageArraySgAsmDwarfWithStmt = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmDwarfWithStmt = new SgAsmDwarfWithStmtStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmDwarfWithStmt) , sizeof ( SgAsmDwarfWithStmtStorageClass ) * sizeOfActualPool) ;
        SgAsmDwarfWithStmtStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmDwarfWithStmtStorageClass* storageArray = storageArraySgAsmDwarfWithStmt;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmDwarfWithStmt* tmp = new SgAsmDwarfWithStmt ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmDwarfWithStmt;  
      SgAsmDwarfWithStmtStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmElfDynamicEntry ); 
     storageClassIndex = 0 ;
     SgAsmElfDynamicEntryStorageClass* storageArraySgAsmElfDynamicEntry = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmElfDynamicEntry = new SgAsmElfDynamicEntryStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmElfDynamicEntry) , sizeof ( SgAsmElfDynamicEntryStorageClass ) * sizeOfActualPool) ;
        SgAsmElfDynamicEntryStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmElfDynamicEntryStorageClass* storageArray = storageArraySgAsmElfDynamicEntry;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmElfDynamicEntry* tmp = new SgAsmElfDynamicEntry ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmElfDynamicEntry;  
      SgAsmElfDynamicEntryStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmElfDynamicEntryList ); 
     storageClassIndex = 0 ;
     SgAsmElfDynamicEntryListStorageClass* storageArraySgAsmElfDynamicEntryList = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmElfDynamicEntryList = new SgAsmElfDynamicEntryListStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmElfDynamicEntryList) , sizeof ( SgAsmElfDynamicEntryListStorageClass ) * sizeOfActualPool) ;
        SgAsmElfDynamicEntryListStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmElfDynamicEntryListStorageClass* storageArray = storageArraySgAsmElfDynamicEntryList;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmElfDynamicEntryList* tmp = new SgAsmElfDynamicEntryList ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmElfDynamicEntryList;  
      SgAsmElfDynamicEntryListStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmElfDynamicSection ); 
     storageClassIndex = 0 ;
     SgAsmElfDynamicSectionStorageClass* storageArraySgAsmElfDynamicSection = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmElfDynamicSection = new SgAsmElfDynamicSectionStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmElfDynamicSection) , sizeof ( SgAsmElfDynamicSectionStorageClass ) * sizeOfActualPool) ;
        SgAsmElfDynamicSectionStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmElfDynamicSectionStorageClass* storageArray = storageArraySgAsmElfDynamicSection;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmElfDynamicSection* tmp = new SgAsmElfDynamicSection ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmElfDynamicSection;  
      SgAsmElfDynamicSectionStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmElfEHFrameEntryCI ); 
     storageClassIndex = 0 ;
     SgAsmElfEHFrameEntryCIStorageClass* storageArraySgAsmElfEHFrameEntryCI = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmElfEHFrameEntryCI = new SgAsmElfEHFrameEntryCIStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmElfEHFrameEntryCI) , sizeof ( SgAsmElfEHFrameEntryCIStorageClass ) * sizeOfActualPool) ;
        SgAsmElfEHFrameEntryCIStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmElfEHFrameEntryCIStorageClass* storageArray = storageArraySgAsmElfEHFrameEntryCI;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmElfEHFrameEntryCI* tmp = new SgAsmElfEHFrameEntryCI ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmElfEHFrameEntryCI;  
      SgAsmElfEHFrameEntryCIStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmElfEHFrameEntryCIList ); 
     storageClassIndex = 0 ;
     SgAsmElfEHFrameEntryCIListStorageClass* storageArraySgAsmElfEHFrameEntryCIList = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmElfEHFrameEntryCIList = new SgAsmElfEHFrameEntryCIListStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmElfEHFrameEntryCIList) , sizeof ( SgAsmElfEHFrameEntryCIListStorageClass ) * sizeOfActualPool) ;
        SgAsmElfEHFrameEntryCIListStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmElfEHFrameEntryCIListStorageClass* storageArray = storageArraySgAsmElfEHFrameEntryCIList;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmElfEHFrameEntryCIList* tmp = new SgAsmElfEHFrameEntryCIList ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmElfEHFrameEntryCIList;  
      SgAsmElfEHFrameEntryCIListStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmElfEHFrameEntryFD ); 
     storageClassIndex = 0 ;
     SgAsmElfEHFrameEntryFDStorageClass* storageArraySgAsmElfEHFrameEntryFD = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmElfEHFrameEntryFD = new SgAsmElfEHFrameEntryFDStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmElfEHFrameEntryFD) , sizeof ( SgAsmElfEHFrameEntryFDStorageClass ) * sizeOfActualPool) ;
        SgAsmElfEHFrameEntryFDStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmElfEHFrameEntryFDStorageClass* storageArray = storageArraySgAsmElfEHFrameEntryFD;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmElfEHFrameEntryFD* tmp = new SgAsmElfEHFrameEntryFD ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmElfEHFrameEntryFD;  
      SgAsmElfEHFrameEntryFDStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmElfEHFrameEntryFDList ); 
     storageClassIndex = 0 ;
     SgAsmElfEHFrameEntryFDListStorageClass* storageArraySgAsmElfEHFrameEntryFDList = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmElfEHFrameEntryFDList = new SgAsmElfEHFrameEntryFDListStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmElfEHFrameEntryFDList) , sizeof ( SgAsmElfEHFrameEntryFDListStorageClass ) * sizeOfActualPool) ;
        SgAsmElfEHFrameEntryFDListStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmElfEHFrameEntryFDListStorageClass* storageArray = storageArraySgAsmElfEHFrameEntryFDList;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmElfEHFrameEntryFDList* tmp = new SgAsmElfEHFrameEntryFDList ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmElfEHFrameEntryFDList;  
      SgAsmElfEHFrameEntryFDListStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmElfEHFrameSection ); 
     storageClassIndex = 0 ;
     SgAsmElfEHFrameSectionStorageClass* storageArraySgAsmElfEHFrameSection = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmElfEHFrameSection = new SgAsmElfEHFrameSectionStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmElfEHFrameSection) , sizeof ( SgAsmElfEHFrameSectionStorageClass ) * sizeOfActualPool) ;
        SgAsmElfEHFrameSectionStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmElfEHFrameSectionStorageClass* storageArray = storageArraySgAsmElfEHFrameSection;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmElfEHFrameSection* tmp = new SgAsmElfEHFrameSection ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmElfEHFrameSection;  
      SgAsmElfEHFrameSectionStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmElfFileHeader ); 
     storageClassIndex = 0 ;
     SgAsmElfFileHeaderStorageClass* storageArraySgAsmElfFileHeader = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmElfFileHeader = new SgAsmElfFileHeaderStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmElfFileHeader) , sizeof ( SgAsmElfFileHeaderStorageClass ) * sizeOfActualPool) ;
        SgAsmElfFileHeaderStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmElfFileHeaderStorageClass* storageArray = storageArraySgAsmElfFileHeader;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmElfFileHeader* tmp = new SgAsmElfFileHeader ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmElfFileHeader;  
      SgAsmElfFileHeaderStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmElfNoteEntry ); 
     storageClassIndex = 0 ;
     SgAsmElfNoteEntryStorageClass* storageArraySgAsmElfNoteEntry = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmElfNoteEntry = new SgAsmElfNoteEntryStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmElfNoteEntry) , sizeof ( SgAsmElfNoteEntryStorageClass ) * sizeOfActualPool) ;
        SgAsmElfNoteEntryStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmElfNoteEntryStorageClass* storageArray = storageArraySgAsmElfNoteEntry;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmElfNoteEntry* tmp = new SgAsmElfNoteEntry ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmElfNoteEntry;  
      SgAsmElfNoteEntryStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmElfNoteEntryList ); 
     storageClassIndex = 0 ;
     SgAsmElfNoteEntryListStorageClass* storageArraySgAsmElfNoteEntryList = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmElfNoteEntryList = new SgAsmElfNoteEntryListStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmElfNoteEntryList) , sizeof ( SgAsmElfNoteEntryListStorageClass ) * sizeOfActualPool) ;
        SgAsmElfNoteEntryListStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmElfNoteEntryListStorageClass* storageArray = storageArraySgAsmElfNoteEntryList;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmElfNoteEntryList* tmp = new SgAsmElfNoteEntryList ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmElfNoteEntryList;  
      SgAsmElfNoteEntryListStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmElfNoteSection ); 
     storageClassIndex = 0 ;
     SgAsmElfNoteSectionStorageClass* storageArraySgAsmElfNoteSection = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmElfNoteSection = new SgAsmElfNoteSectionStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmElfNoteSection) , sizeof ( SgAsmElfNoteSectionStorageClass ) * sizeOfActualPool) ;
        SgAsmElfNoteSectionStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmElfNoteSectionStorageClass* storageArray = storageArraySgAsmElfNoteSection;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmElfNoteSection* tmp = new SgAsmElfNoteSection ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmElfNoteSection;  
      SgAsmElfNoteSectionStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmElfRelocEntry ); 
     storageClassIndex = 0 ;
     SgAsmElfRelocEntryStorageClass* storageArraySgAsmElfRelocEntry = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmElfRelocEntry = new SgAsmElfRelocEntryStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmElfRelocEntry) , sizeof ( SgAsmElfRelocEntryStorageClass ) * sizeOfActualPool) ;
        SgAsmElfRelocEntryStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmElfRelocEntryStorageClass* storageArray = storageArraySgAsmElfRelocEntry;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmElfRelocEntry* tmp = new SgAsmElfRelocEntry ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmElfRelocEntry;  
      SgAsmElfRelocEntryStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmElfRelocEntryList ); 
     storageClassIndex = 0 ;
     SgAsmElfRelocEntryListStorageClass* storageArraySgAsmElfRelocEntryList = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmElfRelocEntryList = new SgAsmElfRelocEntryListStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmElfRelocEntryList) , sizeof ( SgAsmElfRelocEntryListStorageClass ) * sizeOfActualPool) ;
        SgAsmElfRelocEntryListStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmElfRelocEntryListStorageClass* storageArray = storageArraySgAsmElfRelocEntryList;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmElfRelocEntryList* tmp = new SgAsmElfRelocEntryList ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmElfRelocEntryList;  
      SgAsmElfRelocEntryListStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmElfRelocSection ); 
     storageClassIndex = 0 ;
     SgAsmElfRelocSectionStorageClass* storageArraySgAsmElfRelocSection = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmElfRelocSection = new SgAsmElfRelocSectionStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmElfRelocSection) , sizeof ( SgAsmElfRelocSectionStorageClass ) * sizeOfActualPool) ;
        SgAsmElfRelocSectionStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmElfRelocSectionStorageClass* storageArray = storageArraySgAsmElfRelocSection;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmElfRelocSection* tmp = new SgAsmElfRelocSection ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmElfRelocSection;  
      SgAsmElfRelocSectionStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmElfSection ); 
     storageClassIndex = 0 ;
     SgAsmElfSectionStorageClass* storageArraySgAsmElfSection = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmElfSection = new SgAsmElfSectionStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmElfSection) , sizeof ( SgAsmElfSectionStorageClass ) * sizeOfActualPool) ;
        SgAsmElfSectionStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmElfSectionStorageClass* storageArray = storageArraySgAsmElfSection;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmElfSection* tmp = new SgAsmElfSection ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmElfSection;  
      SgAsmElfSectionStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmElfSectionTable ); 
     storageClassIndex = 0 ;
     SgAsmElfSectionTableStorageClass* storageArraySgAsmElfSectionTable = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmElfSectionTable = new SgAsmElfSectionTableStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmElfSectionTable) , sizeof ( SgAsmElfSectionTableStorageClass ) * sizeOfActualPool) ;
        SgAsmElfSectionTableStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmElfSectionTableStorageClass* storageArray = storageArraySgAsmElfSectionTable;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmElfSectionTable* tmp = new SgAsmElfSectionTable ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmElfSectionTable;  
      SgAsmElfSectionTableStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmElfSectionTableEntry ); 
     storageClassIndex = 0 ;
     SgAsmElfSectionTableEntryStorageClass* storageArraySgAsmElfSectionTableEntry = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmElfSectionTableEntry = new SgAsmElfSectionTableEntryStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmElfSectionTableEntry) , sizeof ( SgAsmElfSectionTableEntryStorageClass ) * sizeOfActualPool) ;
        SgAsmElfSectionTableEntryStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmElfSectionTableEntryStorageClass* storageArray = storageArraySgAsmElfSectionTableEntry;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmElfSectionTableEntry* tmp = new SgAsmElfSectionTableEntry ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmElfSectionTableEntry;  
      SgAsmElfSectionTableEntryStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmElfSegmentTable ); 
     storageClassIndex = 0 ;
     SgAsmElfSegmentTableStorageClass* storageArraySgAsmElfSegmentTable = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmElfSegmentTable = new SgAsmElfSegmentTableStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmElfSegmentTable) , sizeof ( SgAsmElfSegmentTableStorageClass ) * sizeOfActualPool) ;
        SgAsmElfSegmentTableStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmElfSegmentTableStorageClass* storageArray = storageArraySgAsmElfSegmentTable;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmElfSegmentTable* tmp = new SgAsmElfSegmentTable ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmElfSegmentTable;  
      SgAsmElfSegmentTableStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmElfSegmentTableEntry ); 
     storageClassIndex = 0 ;
     SgAsmElfSegmentTableEntryStorageClass* storageArraySgAsmElfSegmentTableEntry = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmElfSegmentTableEntry = new SgAsmElfSegmentTableEntryStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmElfSegmentTableEntry) , sizeof ( SgAsmElfSegmentTableEntryStorageClass ) * sizeOfActualPool) ;
        SgAsmElfSegmentTableEntryStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmElfSegmentTableEntryStorageClass* storageArray = storageArraySgAsmElfSegmentTableEntry;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmElfSegmentTableEntry* tmp = new SgAsmElfSegmentTableEntry ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmElfSegmentTableEntry;  
      SgAsmElfSegmentTableEntryStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmElfSegmentTableEntryList ); 
     storageClassIndex = 0 ;
     SgAsmElfSegmentTableEntryListStorageClass* storageArraySgAsmElfSegmentTableEntryList = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmElfSegmentTableEntryList = new SgAsmElfSegmentTableEntryListStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmElfSegmentTableEntryList) , sizeof ( SgAsmElfSegmentTableEntryListStorageClass ) * sizeOfActualPool) ;
        SgAsmElfSegmentTableEntryListStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmElfSegmentTableEntryListStorageClass* storageArray = storageArraySgAsmElfSegmentTableEntryList;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmElfSegmentTableEntryList* tmp = new SgAsmElfSegmentTableEntryList ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmElfSegmentTableEntryList;  
      SgAsmElfSegmentTableEntryListStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmElfStringSection ); 
     storageClassIndex = 0 ;
     SgAsmElfStringSectionStorageClass* storageArraySgAsmElfStringSection = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmElfStringSection = new SgAsmElfStringSectionStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmElfStringSection) , sizeof ( SgAsmElfStringSectionStorageClass ) * sizeOfActualPool) ;
        SgAsmElfStringSectionStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmElfStringSectionStorageClass* storageArray = storageArraySgAsmElfStringSection;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmElfStringSection* tmp = new SgAsmElfStringSection ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmElfStringSection;  
      SgAsmElfStringSectionStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmElfStrtab ); 
     storageClassIndex = 0 ;
     SgAsmElfStrtabStorageClass* storageArraySgAsmElfStrtab = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmElfStrtab = new SgAsmElfStrtabStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmElfStrtab) , sizeof ( SgAsmElfStrtabStorageClass ) * sizeOfActualPool) ;
        SgAsmElfStrtabStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmElfStrtabStorageClass* storageArray = storageArraySgAsmElfStrtab;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmElfStrtab* tmp = new SgAsmElfStrtab ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmElfStrtab;  
      SgAsmElfStrtabStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmElfSymbol ); 
     storageClassIndex = 0 ;
     SgAsmElfSymbolStorageClass* storageArraySgAsmElfSymbol = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmElfSymbol = new SgAsmElfSymbolStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmElfSymbol) , sizeof ( SgAsmElfSymbolStorageClass ) * sizeOfActualPool) ;
        SgAsmElfSymbolStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmElfSymbolStorageClass* storageArray = storageArraySgAsmElfSymbol;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmElfSymbol* tmp = new SgAsmElfSymbol ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmElfSymbol;  
      SgAsmElfSymbolStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmElfSymbolList ); 
     storageClassIndex = 0 ;
     SgAsmElfSymbolListStorageClass* storageArraySgAsmElfSymbolList = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmElfSymbolList = new SgAsmElfSymbolListStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmElfSymbolList) , sizeof ( SgAsmElfSymbolListStorageClass ) * sizeOfActualPool) ;
        SgAsmElfSymbolListStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmElfSymbolListStorageClass* storageArray = storageArraySgAsmElfSymbolList;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmElfSymbolList* tmp = new SgAsmElfSymbolList ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmElfSymbolList;  
      SgAsmElfSymbolListStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmElfSymbolSection ); 
     storageClassIndex = 0 ;
     SgAsmElfSymbolSectionStorageClass* storageArraySgAsmElfSymbolSection = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmElfSymbolSection = new SgAsmElfSymbolSectionStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmElfSymbolSection) , sizeof ( SgAsmElfSymbolSectionStorageClass ) * sizeOfActualPool) ;
        SgAsmElfSymbolSectionStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmElfSymbolSectionStorageClass* storageArray = storageArraySgAsmElfSymbolSection;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmElfSymbolSection* tmp = new SgAsmElfSymbolSection ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmElfSymbolSection;  
      SgAsmElfSymbolSectionStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmElfSymverDefinedAux ); 
     storageClassIndex = 0 ;
     SgAsmElfSymverDefinedAuxStorageClass* storageArraySgAsmElfSymverDefinedAux = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmElfSymverDefinedAux = new SgAsmElfSymverDefinedAuxStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmElfSymverDefinedAux) , sizeof ( SgAsmElfSymverDefinedAuxStorageClass ) * sizeOfActualPool) ;
        SgAsmElfSymverDefinedAuxStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmElfSymverDefinedAuxStorageClass* storageArray = storageArraySgAsmElfSymverDefinedAux;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmElfSymverDefinedAux* tmp = new SgAsmElfSymverDefinedAux ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmElfSymverDefinedAux;  
      SgAsmElfSymverDefinedAuxStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmElfSymverDefinedAuxList ); 
     storageClassIndex = 0 ;
     SgAsmElfSymverDefinedAuxListStorageClass* storageArraySgAsmElfSymverDefinedAuxList = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmElfSymverDefinedAuxList = new SgAsmElfSymverDefinedAuxListStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmElfSymverDefinedAuxList) , sizeof ( SgAsmElfSymverDefinedAuxListStorageClass ) * sizeOfActualPool) ;
        SgAsmElfSymverDefinedAuxListStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmElfSymverDefinedAuxListStorageClass* storageArray = storageArraySgAsmElfSymverDefinedAuxList;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmElfSymverDefinedAuxList* tmp = new SgAsmElfSymverDefinedAuxList ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmElfSymverDefinedAuxList;  
      SgAsmElfSymverDefinedAuxListStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmElfSymverDefinedEntry ); 
     storageClassIndex = 0 ;
     SgAsmElfSymverDefinedEntryStorageClass* storageArraySgAsmElfSymverDefinedEntry = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmElfSymverDefinedEntry = new SgAsmElfSymverDefinedEntryStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmElfSymverDefinedEntry) , sizeof ( SgAsmElfSymverDefinedEntryStorageClass ) * sizeOfActualPool) ;
        SgAsmElfSymverDefinedEntryStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmElfSymverDefinedEntryStorageClass* storageArray = storageArraySgAsmElfSymverDefinedEntry;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmElfSymverDefinedEntry* tmp = new SgAsmElfSymverDefinedEntry ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmElfSymverDefinedEntry;  
      SgAsmElfSymverDefinedEntryStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmElfSymverDefinedEntryList ); 
     storageClassIndex = 0 ;
     SgAsmElfSymverDefinedEntryListStorageClass* storageArraySgAsmElfSymverDefinedEntryList = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmElfSymverDefinedEntryList = new SgAsmElfSymverDefinedEntryListStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmElfSymverDefinedEntryList) , sizeof ( SgAsmElfSymverDefinedEntryListStorageClass ) * sizeOfActualPool) ;
        SgAsmElfSymverDefinedEntryListStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmElfSymverDefinedEntryListStorageClass* storageArray = storageArraySgAsmElfSymverDefinedEntryList;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmElfSymverDefinedEntryList* tmp = new SgAsmElfSymverDefinedEntryList ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmElfSymverDefinedEntryList;  
      SgAsmElfSymverDefinedEntryListStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmElfSymverDefinedSection ); 
     storageClassIndex = 0 ;
     SgAsmElfSymverDefinedSectionStorageClass* storageArraySgAsmElfSymverDefinedSection = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmElfSymverDefinedSection = new SgAsmElfSymverDefinedSectionStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmElfSymverDefinedSection) , sizeof ( SgAsmElfSymverDefinedSectionStorageClass ) * sizeOfActualPool) ;
        SgAsmElfSymverDefinedSectionStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmElfSymverDefinedSectionStorageClass* storageArray = storageArraySgAsmElfSymverDefinedSection;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmElfSymverDefinedSection* tmp = new SgAsmElfSymverDefinedSection ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmElfSymverDefinedSection;  
      SgAsmElfSymverDefinedSectionStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmElfSymverEntry ); 
     storageClassIndex = 0 ;
     SgAsmElfSymverEntryStorageClass* storageArraySgAsmElfSymverEntry = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmElfSymverEntry = new SgAsmElfSymverEntryStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmElfSymverEntry) , sizeof ( SgAsmElfSymverEntryStorageClass ) * sizeOfActualPool) ;
        SgAsmElfSymverEntryStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmElfSymverEntryStorageClass* storageArray = storageArraySgAsmElfSymverEntry;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmElfSymverEntry* tmp = new SgAsmElfSymverEntry ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmElfSymverEntry;  
      SgAsmElfSymverEntryStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmElfSymverEntryList ); 
     storageClassIndex = 0 ;
     SgAsmElfSymverEntryListStorageClass* storageArraySgAsmElfSymverEntryList = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmElfSymverEntryList = new SgAsmElfSymverEntryListStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmElfSymverEntryList) , sizeof ( SgAsmElfSymverEntryListStorageClass ) * sizeOfActualPool) ;
        SgAsmElfSymverEntryListStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmElfSymverEntryListStorageClass* storageArray = storageArraySgAsmElfSymverEntryList;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmElfSymverEntryList* tmp = new SgAsmElfSymverEntryList ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmElfSymverEntryList;  
      SgAsmElfSymverEntryListStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmElfSymverNeededAux ); 
     storageClassIndex = 0 ;
     SgAsmElfSymverNeededAuxStorageClass* storageArraySgAsmElfSymverNeededAux = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmElfSymverNeededAux = new SgAsmElfSymverNeededAuxStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmElfSymverNeededAux) , sizeof ( SgAsmElfSymverNeededAuxStorageClass ) * sizeOfActualPool) ;
        SgAsmElfSymverNeededAuxStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmElfSymverNeededAuxStorageClass* storageArray = storageArraySgAsmElfSymverNeededAux;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmElfSymverNeededAux* tmp = new SgAsmElfSymverNeededAux ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmElfSymverNeededAux;  
      SgAsmElfSymverNeededAuxStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmElfSymverNeededAuxList ); 
     storageClassIndex = 0 ;
     SgAsmElfSymverNeededAuxListStorageClass* storageArraySgAsmElfSymverNeededAuxList = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmElfSymverNeededAuxList = new SgAsmElfSymverNeededAuxListStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmElfSymverNeededAuxList) , sizeof ( SgAsmElfSymverNeededAuxListStorageClass ) * sizeOfActualPool) ;
        SgAsmElfSymverNeededAuxListStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmElfSymverNeededAuxListStorageClass* storageArray = storageArraySgAsmElfSymverNeededAuxList;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmElfSymverNeededAuxList* tmp = new SgAsmElfSymverNeededAuxList ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmElfSymverNeededAuxList;  
      SgAsmElfSymverNeededAuxListStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmElfSymverNeededEntry ); 
     storageClassIndex = 0 ;
     SgAsmElfSymverNeededEntryStorageClass* storageArraySgAsmElfSymverNeededEntry = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmElfSymverNeededEntry = new SgAsmElfSymverNeededEntryStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmElfSymverNeededEntry) , sizeof ( SgAsmElfSymverNeededEntryStorageClass ) * sizeOfActualPool) ;
        SgAsmElfSymverNeededEntryStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmElfSymverNeededEntryStorageClass* storageArray = storageArraySgAsmElfSymverNeededEntry;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmElfSymverNeededEntry* tmp = new SgAsmElfSymverNeededEntry ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmElfSymverNeededEntry;  
      SgAsmElfSymverNeededEntryStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmElfSymverNeededEntryList ); 
     storageClassIndex = 0 ;
     SgAsmElfSymverNeededEntryListStorageClass* storageArraySgAsmElfSymverNeededEntryList = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmElfSymverNeededEntryList = new SgAsmElfSymverNeededEntryListStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmElfSymverNeededEntryList) , sizeof ( SgAsmElfSymverNeededEntryListStorageClass ) * sizeOfActualPool) ;
        SgAsmElfSymverNeededEntryListStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmElfSymverNeededEntryListStorageClass* storageArray = storageArraySgAsmElfSymverNeededEntryList;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmElfSymverNeededEntryList* tmp = new SgAsmElfSymverNeededEntryList ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmElfSymverNeededEntryList;  
      SgAsmElfSymverNeededEntryListStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmElfSymverNeededSection ); 
     storageClassIndex = 0 ;
     SgAsmElfSymverNeededSectionStorageClass* storageArraySgAsmElfSymverNeededSection = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmElfSymverNeededSection = new SgAsmElfSymverNeededSectionStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmElfSymverNeededSection) , sizeof ( SgAsmElfSymverNeededSectionStorageClass ) * sizeOfActualPool) ;
        SgAsmElfSymverNeededSectionStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmElfSymverNeededSectionStorageClass* storageArray = storageArraySgAsmElfSymverNeededSection;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmElfSymverNeededSection* tmp = new SgAsmElfSymverNeededSection ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmElfSymverNeededSection;  
      SgAsmElfSymverNeededSectionStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmElfSymverSection ); 
     storageClassIndex = 0 ;
     SgAsmElfSymverSectionStorageClass* storageArraySgAsmElfSymverSection = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmElfSymverSection = new SgAsmElfSymverSectionStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmElfSymverSection) , sizeof ( SgAsmElfSymverSectionStorageClass ) * sizeOfActualPool) ;
        SgAsmElfSymverSectionStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmElfSymverSectionStorageClass* storageArray = storageArraySgAsmElfSymverSection;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmElfSymverSection* tmp = new SgAsmElfSymverSection ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmElfSymverSection;  
      SgAsmElfSymverSectionStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmExecutableFileFormat ); 
     storageClassIndex = 0 ;
     SgAsmExecutableFileFormatStorageClass* storageArraySgAsmExecutableFileFormat = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmExecutableFileFormat = new SgAsmExecutableFileFormatStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmExecutableFileFormat) , sizeof ( SgAsmExecutableFileFormatStorageClass ) * sizeOfActualPool) ;
        SgAsmExecutableFileFormatStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmExecutableFileFormatStorageClass* storageArray = storageArraySgAsmExecutableFileFormat;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmExecutableFileFormat* tmp = new SgAsmExecutableFileFormat ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmExecutableFileFormat;  
      SgAsmExecutableFileFormatStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmExprListExp ); 
     storageClassIndex = 0 ;
     SgAsmExprListExpStorageClass* storageArraySgAsmExprListExp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmExprListExp = new SgAsmExprListExpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmExprListExp) , sizeof ( SgAsmExprListExpStorageClass ) * sizeOfActualPool) ;
        SgAsmExprListExpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmExprListExpStorageClass* storageArray = storageArraySgAsmExprListExp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmExprListExp* tmp = new SgAsmExprListExp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmExprListExp;  
      SgAsmExprListExpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmExpression ); 
     storageClassIndex = 0 ;
     SgAsmExpressionStorageClass* storageArraySgAsmExpression = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmExpression = new SgAsmExpressionStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmExpression) , sizeof ( SgAsmExpressionStorageClass ) * sizeOfActualPool) ;
        SgAsmExpressionStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmExpressionStorageClass* storageArray = storageArraySgAsmExpression;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmExpression* tmp = new SgAsmExpression ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmExpression;  
      SgAsmExpressionStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmFunction ); 
     storageClassIndex = 0 ;
     SgAsmFunctionStorageClass* storageArraySgAsmFunction = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmFunction = new SgAsmFunctionStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmFunction) , sizeof ( SgAsmFunctionStorageClass ) * sizeOfActualPool) ;
        SgAsmFunctionStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmFunctionStorageClass* storageArray = storageArraySgAsmFunction;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmFunction* tmp = new SgAsmFunction ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmFunction;  
      SgAsmFunctionStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmGenericDLL ); 
     storageClassIndex = 0 ;
     SgAsmGenericDLLStorageClass* storageArraySgAsmGenericDLL = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmGenericDLL = new SgAsmGenericDLLStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmGenericDLL) , sizeof ( SgAsmGenericDLLStorageClass ) * sizeOfActualPool) ;
        SgAsmGenericDLLStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmGenericDLLStorageClass* storageArray = storageArraySgAsmGenericDLL;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmGenericDLL* tmp = new SgAsmGenericDLL ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmGenericDLL;  
      SgAsmGenericDLLStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmGenericDLLList ); 
     storageClassIndex = 0 ;
     SgAsmGenericDLLListStorageClass* storageArraySgAsmGenericDLLList = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmGenericDLLList = new SgAsmGenericDLLListStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmGenericDLLList) , sizeof ( SgAsmGenericDLLListStorageClass ) * sizeOfActualPool) ;
        SgAsmGenericDLLListStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmGenericDLLListStorageClass* storageArray = storageArraySgAsmGenericDLLList;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmGenericDLLList* tmp = new SgAsmGenericDLLList ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmGenericDLLList;  
      SgAsmGenericDLLListStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmGenericFile ); 
     storageClassIndex = 0 ;
     SgAsmGenericFileStorageClass* storageArraySgAsmGenericFile = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmGenericFile = new SgAsmGenericFileStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmGenericFile) , sizeof ( SgAsmGenericFileStorageClass ) * sizeOfActualPool) ;
        SgAsmGenericFileStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmGenericFileStorageClass* storageArray = storageArraySgAsmGenericFile;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmGenericFile* tmp = new SgAsmGenericFile ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmGenericFile;  
      SgAsmGenericFileStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmGenericFileList ); 
     storageClassIndex = 0 ;
     SgAsmGenericFileListStorageClass* storageArraySgAsmGenericFileList = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmGenericFileList = new SgAsmGenericFileListStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmGenericFileList) , sizeof ( SgAsmGenericFileListStorageClass ) * sizeOfActualPool) ;
        SgAsmGenericFileListStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmGenericFileListStorageClass* storageArray = storageArraySgAsmGenericFileList;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmGenericFileList* tmp = new SgAsmGenericFileList ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmGenericFileList;  
      SgAsmGenericFileListStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmGenericFormat ); 
     storageClassIndex = 0 ;
     SgAsmGenericFormatStorageClass* storageArraySgAsmGenericFormat = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmGenericFormat = new SgAsmGenericFormatStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmGenericFormat) , sizeof ( SgAsmGenericFormatStorageClass ) * sizeOfActualPool) ;
        SgAsmGenericFormatStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmGenericFormatStorageClass* storageArray = storageArraySgAsmGenericFormat;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmGenericFormat* tmp = new SgAsmGenericFormat ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmGenericFormat;  
      SgAsmGenericFormatStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmGenericHeader ); 
     storageClassIndex = 0 ;
     SgAsmGenericHeaderStorageClass* storageArraySgAsmGenericHeader = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmGenericHeader = new SgAsmGenericHeaderStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmGenericHeader) , sizeof ( SgAsmGenericHeaderStorageClass ) * sizeOfActualPool) ;
        SgAsmGenericHeaderStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmGenericHeaderStorageClass* storageArray = storageArraySgAsmGenericHeader;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmGenericHeader* tmp = new SgAsmGenericHeader ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmGenericHeader;  
      SgAsmGenericHeaderStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmGenericHeaderList ); 
     storageClassIndex = 0 ;
     SgAsmGenericHeaderListStorageClass* storageArraySgAsmGenericHeaderList = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmGenericHeaderList = new SgAsmGenericHeaderListStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmGenericHeaderList) , sizeof ( SgAsmGenericHeaderListStorageClass ) * sizeOfActualPool) ;
        SgAsmGenericHeaderListStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmGenericHeaderListStorageClass* storageArray = storageArraySgAsmGenericHeaderList;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmGenericHeaderList* tmp = new SgAsmGenericHeaderList ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmGenericHeaderList;  
      SgAsmGenericHeaderListStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmGenericSection ); 
     storageClassIndex = 0 ;
     SgAsmGenericSectionStorageClass* storageArraySgAsmGenericSection = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmGenericSection = new SgAsmGenericSectionStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmGenericSection) , sizeof ( SgAsmGenericSectionStorageClass ) * sizeOfActualPool) ;
        SgAsmGenericSectionStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmGenericSectionStorageClass* storageArray = storageArraySgAsmGenericSection;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmGenericSection* tmp = new SgAsmGenericSection ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmGenericSection;  
      SgAsmGenericSectionStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmGenericSectionList ); 
     storageClassIndex = 0 ;
     SgAsmGenericSectionListStorageClass* storageArraySgAsmGenericSectionList = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmGenericSectionList = new SgAsmGenericSectionListStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmGenericSectionList) , sizeof ( SgAsmGenericSectionListStorageClass ) * sizeOfActualPool) ;
        SgAsmGenericSectionListStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmGenericSectionListStorageClass* storageArray = storageArraySgAsmGenericSectionList;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmGenericSectionList* tmp = new SgAsmGenericSectionList ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmGenericSectionList;  
      SgAsmGenericSectionListStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmGenericString ); 
     storageClassIndex = 0 ;
     SgAsmGenericStringStorageClass* storageArraySgAsmGenericString = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmGenericString = new SgAsmGenericStringStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmGenericString) , sizeof ( SgAsmGenericStringStorageClass ) * sizeOfActualPool) ;
        SgAsmGenericStringStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmGenericStringStorageClass* storageArray = storageArraySgAsmGenericString;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmGenericString* tmp = new SgAsmGenericString ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmGenericString;  
      SgAsmGenericStringStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmGenericStrtab ); 
     storageClassIndex = 0 ;
     SgAsmGenericStrtabStorageClass* storageArraySgAsmGenericStrtab = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmGenericStrtab = new SgAsmGenericStrtabStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmGenericStrtab) , sizeof ( SgAsmGenericStrtabStorageClass ) * sizeOfActualPool) ;
        SgAsmGenericStrtabStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmGenericStrtabStorageClass* storageArray = storageArraySgAsmGenericStrtab;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmGenericStrtab* tmp = new SgAsmGenericStrtab ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmGenericStrtab;  
      SgAsmGenericStrtabStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmGenericSymbol ); 
     storageClassIndex = 0 ;
     SgAsmGenericSymbolStorageClass* storageArraySgAsmGenericSymbol = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmGenericSymbol = new SgAsmGenericSymbolStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmGenericSymbol) , sizeof ( SgAsmGenericSymbolStorageClass ) * sizeOfActualPool) ;
        SgAsmGenericSymbolStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmGenericSymbolStorageClass* storageArray = storageArraySgAsmGenericSymbol;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmGenericSymbol* tmp = new SgAsmGenericSymbol ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmGenericSymbol;  
      SgAsmGenericSymbolStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmGenericSymbolList ); 
     storageClassIndex = 0 ;
     SgAsmGenericSymbolListStorageClass* storageArraySgAsmGenericSymbolList = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmGenericSymbolList = new SgAsmGenericSymbolListStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmGenericSymbolList) , sizeof ( SgAsmGenericSymbolListStorageClass ) * sizeOfActualPool) ;
        SgAsmGenericSymbolListStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmGenericSymbolListStorageClass* storageArray = storageArraySgAsmGenericSymbolList;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmGenericSymbolList* tmp = new SgAsmGenericSymbolList ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmGenericSymbolList;  
      SgAsmGenericSymbolListStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmInstruction ); 
     storageClassIndex = 0 ;
     SgAsmInstructionStorageClass* storageArraySgAsmInstruction = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmInstruction = new SgAsmInstructionStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmInstruction) , sizeof ( SgAsmInstructionStorageClass ) * sizeOfActualPool) ;
        SgAsmInstructionStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmInstructionStorageClass* storageArray = storageArraySgAsmInstruction;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmInstruction* tmp = new SgAsmInstruction ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmInstruction;  
      SgAsmInstructionStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmIntegerValueExpression ); 
     storageClassIndex = 0 ;
     SgAsmIntegerValueExpressionStorageClass* storageArraySgAsmIntegerValueExpression = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmIntegerValueExpression = new SgAsmIntegerValueExpressionStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmIntegerValueExpression) , sizeof ( SgAsmIntegerValueExpressionStorageClass ) * sizeOfActualPool) ;
        SgAsmIntegerValueExpressionStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmIntegerValueExpressionStorageClass* storageArray = storageArraySgAsmIntegerValueExpression;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmIntegerValueExpression* tmp = new SgAsmIntegerValueExpression ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmIntegerValueExpression;  
      SgAsmIntegerValueExpressionStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmInterpretation ); 
     storageClassIndex = 0 ;
     SgAsmInterpretationStorageClass* storageArraySgAsmInterpretation = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmInterpretation = new SgAsmInterpretationStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmInterpretation) , sizeof ( SgAsmInterpretationStorageClass ) * sizeOfActualPool) ;
        SgAsmInterpretationStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmInterpretationStorageClass* storageArray = storageArraySgAsmInterpretation;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmInterpretation* tmp = new SgAsmInterpretation ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmInterpretation;  
      SgAsmInterpretationStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmInterpretationList ); 
     storageClassIndex = 0 ;
     SgAsmInterpretationListStorageClass* storageArraySgAsmInterpretationList = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmInterpretationList = new SgAsmInterpretationListStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmInterpretationList) , sizeof ( SgAsmInterpretationListStorageClass ) * sizeOfActualPool) ;
        SgAsmInterpretationListStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmInterpretationListStorageClass* storageArray = storageArraySgAsmInterpretationList;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmInterpretationList* tmp = new SgAsmInterpretationList ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmInterpretationList;  
      SgAsmInterpretationListStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmLEEntryPoint ); 
     storageClassIndex = 0 ;
     SgAsmLEEntryPointStorageClass* storageArraySgAsmLEEntryPoint = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmLEEntryPoint = new SgAsmLEEntryPointStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmLEEntryPoint) , sizeof ( SgAsmLEEntryPointStorageClass ) * sizeOfActualPool) ;
        SgAsmLEEntryPointStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmLEEntryPointStorageClass* storageArray = storageArraySgAsmLEEntryPoint;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmLEEntryPoint* tmp = new SgAsmLEEntryPoint ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmLEEntryPoint;  
      SgAsmLEEntryPointStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmLEEntryTable ); 
     storageClassIndex = 0 ;
     SgAsmLEEntryTableStorageClass* storageArraySgAsmLEEntryTable = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmLEEntryTable = new SgAsmLEEntryTableStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmLEEntryTable) , sizeof ( SgAsmLEEntryTableStorageClass ) * sizeOfActualPool) ;
        SgAsmLEEntryTableStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmLEEntryTableStorageClass* storageArray = storageArraySgAsmLEEntryTable;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmLEEntryTable* tmp = new SgAsmLEEntryTable ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmLEEntryTable;  
      SgAsmLEEntryTableStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmLEFileHeader ); 
     storageClassIndex = 0 ;
     SgAsmLEFileHeaderStorageClass* storageArraySgAsmLEFileHeader = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmLEFileHeader = new SgAsmLEFileHeaderStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmLEFileHeader) , sizeof ( SgAsmLEFileHeaderStorageClass ) * sizeOfActualPool) ;
        SgAsmLEFileHeaderStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmLEFileHeaderStorageClass* storageArray = storageArraySgAsmLEFileHeader;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmLEFileHeader* tmp = new SgAsmLEFileHeader ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmLEFileHeader;  
      SgAsmLEFileHeaderStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmLENameTable ); 
     storageClassIndex = 0 ;
     SgAsmLENameTableStorageClass* storageArraySgAsmLENameTable = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmLENameTable = new SgAsmLENameTableStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmLENameTable) , sizeof ( SgAsmLENameTableStorageClass ) * sizeOfActualPool) ;
        SgAsmLENameTableStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmLENameTableStorageClass* storageArray = storageArraySgAsmLENameTable;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmLENameTable* tmp = new SgAsmLENameTable ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmLENameTable;  
      SgAsmLENameTableStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmLEPageTable ); 
     storageClassIndex = 0 ;
     SgAsmLEPageTableStorageClass* storageArraySgAsmLEPageTable = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmLEPageTable = new SgAsmLEPageTableStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmLEPageTable) , sizeof ( SgAsmLEPageTableStorageClass ) * sizeOfActualPool) ;
        SgAsmLEPageTableStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmLEPageTableStorageClass* storageArray = storageArraySgAsmLEPageTable;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmLEPageTable* tmp = new SgAsmLEPageTable ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmLEPageTable;  
      SgAsmLEPageTableStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmLEPageTableEntry ); 
     storageClassIndex = 0 ;
     SgAsmLEPageTableEntryStorageClass* storageArraySgAsmLEPageTableEntry = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmLEPageTableEntry = new SgAsmLEPageTableEntryStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmLEPageTableEntry) , sizeof ( SgAsmLEPageTableEntryStorageClass ) * sizeOfActualPool) ;
        SgAsmLEPageTableEntryStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmLEPageTableEntryStorageClass* storageArray = storageArraySgAsmLEPageTableEntry;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmLEPageTableEntry* tmp = new SgAsmLEPageTableEntry ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmLEPageTableEntry;  
      SgAsmLEPageTableEntryStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmLERelocTable ); 
     storageClassIndex = 0 ;
     SgAsmLERelocTableStorageClass* storageArraySgAsmLERelocTable = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmLERelocTable = new SgAsmLERelocTableStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmLERelocTable) , sizeof ( SgAsmLERelocTableStorageClass ) * sizeOfActualPool) ;
        SgAsmLERelocTableStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmLERelocTableStorageClass* storageArray = storageArraySgAsmLERelocTable;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmLERelocTable* tmp = new SgAsmLERelocTable ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmLERelocTable;  
      SgAsmLERelocTableStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmLESection ); 
     storageClassIndex = 0 ;
     SgAsmLESectionStorageClass* storageArraySgAsmLESection = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmLESection = new SgAsmLESectionStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmLESection) , sizeof ( SgAsmLESectionStorageClass ) * sizeOfActualPool) ;
        SgAsmLESectionStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmLESectionStorageClass* storageArray = storageArraySgAsmLESection;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmLESection* tmp = new SgAsmLESection ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmLESection;  
      SgAsmLESectionStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmLESectionTable ); 
     storageClassIndex = 0 ;
     SgAsmLESectionTableStorageClass* storageArraySgAsmLESectionTable = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmLESectionTable = new SgAsmLESectionTableStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmLESectionTable) , sizeof ( SgAsmLESectionTableStorageClass ) * sizeOfActualPool) ;
        SgAsmLESectionTableStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmLESectionTableStorageClass* storageArray = storageArraySgAsmLESectionTable;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmLESectionTable* tmp = new SgAsmLESectionTable ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmLESectionTable;  
      SgAsmLESectionTableStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmLESectionTableEntry ); 
     storageClassIndex = 0 ;
     SgAsmLESectionTableEntryStorageClass* storageArraySgAsmLESectionTableEntry = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmLESectionTableEntry = new SgAsmLESectionTableEntryStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmLESectionTableEntry) , sizeof ( SgAsmLESectionTableEntryStorageClass ) * sizeOfActualPool) ;
        SgAsmLESectionTableEntryStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmLESectionTableEntryStorageClass* storageArray = storageArraySgAsmLESectionTableEntry;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmLESectionTableEntry* tmp = new SgAsmLESectionTableEntry ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmLESectionTableEntry;  
      SgAsmLESectionTableEntryStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmMemoryReferenceExpression ); 
     storageClassIndex = 0 ;
     SgAsmMemoryReferenceExpressionStorageClass* storageArraySgAsmMemoryReferenceExpression = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmMemoryReferenceExpression = new SgAsmMemoryReferenceExpressionStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmMemoryReferenceExpression) , sizeof ( SgAsmMemoryReferenceExpressionStorageClass ) * sizeOfActualPool) ;
        SgAsmMemoryReferenceExpressionStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmMemoryReferenceExpressionStorageClass* storageArray = storageArraySgAsmMemoryReferenceExpression;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmMemoryReferenceExpression* tmp = new SgAsmMemoryReferenceExpression ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmMemoryReferenceExpression;  
      SgAsmMemoryReferenceExpressionStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmNEEntryPoint ); 
     storageClassIndex = 0 ;
     SgAsmNEEntryPointStorageClass* storageArraySgAsmNEEntryPoint = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmNEEntryPoint = new SgAsmNEEntryPointStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmNEEntryPoint) , sizeof ( SgAsmNEEntryPointStorageClass ) * sizeOfActualPool) ;
        SgAsmNEEntryPointStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmNEEntryPointStorageClass* storageArray = storageArraySgAsmNEEntryPoint;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmNEEntryPoint* tmp = new SgAsmNEEntryPoint ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmNEEntryPoint;  
      SgAsmNEEntryPointStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmNEEntryTable ); 
     storageClassIndex = 0 ;
     SgAsmNEEntryTableStorageClass* storageArraySgAsmNEEntryTable = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmNEEntryTable = new SgAsmNEEntryTableStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmNEEntryTable) , sizeof ( SgAsmNEEntryTableStorageClass ) * sizeOfActualPool) ;
        SgAsmNEEntryTableStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmNEEntryTableStorageClass* storageArray = storageArraySgAsmNEEntryTable;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmNEEntryTable* tmp = new SgAsmNEEntryTable ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmNEEntryTable;  
      SgAsmNEEntryTableStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmNEFileHeader ); 
     storageClassIndex = 0 ;
     SgAsmNEFileHeaderStorageClass* storageArraySgAsmNEFileHeader = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmNEFileHeader = new SgAsmNEFileHeaderStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmNEFileHeader) , sizeof ( SgAsmNEFileHeaderStorageClass ) * sizeOfActualPool) ;
        SgAsmNEFileHeaderStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmNEFileHeaderStorageClass* storageArray = storageArraySgAsmNEFileHeader;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmNEFileHeader* tmp = new SgAsmNEFileHeader ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmNEFileHeader;  
      SgAsmNEFileHeaderStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmNEModuleTable ); 
     storageClassIndex = 0 ;
     SgAsmNEModuleTableStorageClass* storageArraySgAsmNEModuleTable = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmNEModuleTable = new SgAsmNEModuleTableStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmNEModuleTable) , sizeof ( SgAsmNEModuleTableStorageClass ) * sizeOfActualPool) ;
        SgAsmNEModuleTableStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmNEModuleTableStorageClass* storageArray = storageArraySgAsmNEModuleTable;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmNEModuleTable* tmp = new SgAsmNEModuleTable ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmNEModuleTable;  
      SgAsmNEModuleTableStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmNENameTable ); 
     storageClassIndex = 0 ;
     SgAsmNENameTableStorageClass* storageArraySgAsmNENameTable = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmNENameTable = new SgAsmNENameTableStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmNENameTable) , sizeof ( SgAsmNENameTableStorageClass ) * sizeOfActualPool) ;
        SgAsmNENameTableStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmNENameTableStorageClass* storageArray = storageArraySgAsmNENameTable;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmNENameTable* tmp = new SgAsmNENameTable ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmNENameTable;  
      SgAsmNENameTableStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmNERelocEntry ); 
     storageClassIndex = 0 ;
     SgAsmNERelocEntryStorageClass* storageArraySgAsmNERelocEntry = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmNERelocEntry = new SgAsmNERelocEntryStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmNERelocEntry) , sizeof ( SgAsmNERelocEntryStorageClass ) * sizeOfActualPool) ;
        SgAsmNERelocEntryStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmNERelocEntryStorageClass* storageArray = storageArraySgAsmNERelocEntry;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmNERelocEntry* tmp = new SgAsmNERelocEntry ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmNERelocEntry;  
      SgAsmNERelocEntryStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmNERelocTable ); 
     storageClassIndex = 0 ;
     SgAsmNERelocTableStorageClass* storageArraySgAsmNERelocTable = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmNERelocTable = new SgAsmNERelocTableStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmNERelocTable) , sizeof ( SgAsmNERelocTableStorageClass ) * sizeOfActualPool) ;
        SgAsmNERelocTableStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmNERelocTableStorageClass* storageArray = storageArraySgAsmNERelocTable;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmNERelocTable* tmp = new SgAsmNERelocTable ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmNERelocTable;  
      SgAsmNERelocTableStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmNESection ); 
     storageClassIndex = 0 ;
     SgAsmNESectionStorageClass* storageArraySgAsmNESection = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmNESection = new SgAsmNESectionStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmNESection) , sizeof ( SgAsmNESectionStorageClass ) * sizeOfActualPool) ;
        SgAsmNESectionStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmNESectionStorageClass* storageArray = storageArraySgAsmNESection;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmNESection* tmp = new SgAsmNESection ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmNESection;  
      SgAsmNESectionStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmNESectionTable ); 
     storageClassIndex = 0 ;
     SgAsmNESectionTableStorageClass* storageArraySgAsmNESectionTable = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmNESectionTable = new SgAsmNESectionTableStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmNESectionTable) , sizeof ( SgAsmNESectionTableStorageClass ) * sizeOfActualPool) ;
        SgAsmNESectionTableStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmNESectionTableStorageClass* storageArray = storageArraySgAsmNESectionTable;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmNESectionTable* tmp = new SgAsmNESectionTable ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmNESectionTable;  
      SgAsmNESectionTableStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmNESectionTableEntry ); 
     storageClassIndex = 0 ;
     SgAsmNESectionTableEntryStorageClass* storageArraySgAsmNESectionTableEntry = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmNESectionTableEntry = new SgAsmNESectionTableEntryStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmNESectionTableEntry) , sizeof ( SgAsmNESectionTableEntryStorageClass ) * sizeOfActualPool) ;
        SgAsmNESectionTableEntryStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmNESectionTableEntryStorageClass* storageArray = storageArraySgAsmNESectionTableEntry;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmNESectionTableEntry* tmp = new SgAsmNESectionTableEntry ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmNESectionTableEntry;  
      SgAsmNESectionTableEntryStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmNEStringTable ); 
     storageClassIndex = 0 ;
     SgAsmNEStringTableStorageClass* storageArraySgAsmNEStringTable = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmNEStringTable = new SgAsmNEStringTableStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmNEStringTable) , sizeof ( SgAsmNEStringTableStorageClass ) * sizeOfActualPool) ;
        SgAsmNEStringTableStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmNEStringTableStorageClass* storageArray = storageArraySgAsmNEStringTable;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmNEStringTable* tmp = new SgAsmNEStringTable ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmNEStringTable;  
      SgAsmNEStringTableStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmNode ); 
     storageClassIndex = 0 ;
     SgAsmNodeStorageClass* storageArraySgAsmNode = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmNode = new SgAsmNodeStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmNode) , sizeof ( SgAsmNodeStorageClass ) * sizeOfActualPool) ;
        SgAsmNodeStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmNodeStorageClass* storageArray = storageArraySgAsmNode;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmNode* tmp = new SgAsmNode ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmNode;  
      SgAsmNodeStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmOp ); 
     storageClassIndex = 0 ;
     SgAsmOpStorageClass* storageArraySgAsmOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmOp = new SgAsmOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmOp) , sizeof ( SgAsmOpStorageClass ) * sizeOfActualPool) ;
        SgAsmOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmOpStorageClass* storageArray = storageArraySgAsmOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmOp* tmp = new SgAsmOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmOp;  
      SgAsmOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmOperandList ); 
     storageClassIndex = 0 ;
     SgAsmOperandListStorageClass* storageArraySgAsmOperandList = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmOperandList = new SgAsmOperandListStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmOperandList) , sizeof ( SgAsmOperandListStorageClass ) * sizeOfActualPool) ;
        SgAsmOperandListStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmOperandListStorageClass* storageArray = storageArraySgAsmOperandList;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmOperandList* tmp = new SgAsmOperandList ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmOperandList;  
      SgAsmOperandListStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmPEExportDirectory ); 
     storageClassIndex = 0 ;
     SgAsmPEExportDirectoryStorageClass* storageArraySgAsmPEExportDirectory = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmPEExportDirectory = new SgAsmPEExportDirectoryStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmPEExportDirectory) , sizeof ( SgAsmPEExportDirectoryStorageClass ) * sizeOfActualPool) ;
        SgAsmPEExportDirectoryStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmPEExportDirectoryStorageClass* storageArray = storageArraySgAsmPEExportDirectory;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmPEExportDirectory* tmp = new SgAsmPEExportDirectory ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmPEExportDirectory;  
      SgAsmPEExportDirectoryStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmPEExportEntry ); 
     storageClassIndex = 0 ;
     SgAsmPEExportEntryStorageClass* storageArraySgAsmPEExportEntry = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmPEExportEntry = new SgAsmPEExportEntryStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmPEExportEntry) , sizeof ( SgAsmPEExportEntryStorageClass ) * sizeOfActualPool) ;
        SgAsmPEExportEntryStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmPEExportEntryStorageClass* storageArray = storageArraySgAsmPEExportEntry;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmPEExportEntry* tmp = new SgAsmPEExportEntry ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmPEExportEntry;  
      SgAsmPEExportEntryStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmPEExportEntryList ); 
     storageClassIndex = 0 ;
     SgAsmPEExportEntryListStorageClass* storageArraySgAsmPEExportEntryList = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmPEExportEntryList = new SgAsmPEExportEntryListStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmPEExportEntryList) , sizeof ( SgAsmPEExportEntryListStorageClass ) * sizeOfActualPool) ;
        SgAsmPEExportEntryListStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmPEExportEntryListStorageClass* storageArray = storageArraySgAsmPEExportEntryList;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmPEExportEntryList* tmp = new SgAsmPEExportEntryList ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmPEExportEntryList;  
      SgAsmPEExportEntryListStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmPEExportSection ); 
     storageClassIndex = 0 ;
     SgAsmPEExportSectionStorageClass* storageArraySgAsmPEExportSection = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmPEExportSection = new SgAsmPEExportSectionStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmPEExportSection) , sizeof ( SgAsmPEExportSectionStorageClass ) * sizeOfActualPool) ;
        SgAsmPEExportSectionStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmPEExportSectionStorageClass* storageArray = storageArraySgAsmPEExportSection;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmPEExportSection* tmp = new SgAsmPEExportSection ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmPEExportSection;  
      SgAsmPEExportSectionStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmPEFileHeader ); 
     storageClassIndex = 0 ;
     SgAsmPEFileHeaderStorageClass* storageArraySgAsmPEFileHeader = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmPEFileHeader = new SgAsmPEFileHeaderStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmPEFileHeader) , sizeof ( SgAsmPEFileHeaderStorageClass ) * sizeOfActualPool) ;
        SgAsmPEFileHeaderStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmPEFileHeaderStorageClass* storageArray = storageArraySgAsmPEFileHeader;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmPEFileHeader* tmp = new SgAsmPEFileHeader ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmPEFileHeader;  
      SgAsmPEFileHeaderStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmPEImportDirectory ); 
     storageClassIndex = 0 ;
     SgAsmPEImportDirectoryStorageClass* storageArraySgAsmPEImportDirectory = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmPEImportDirectory = new SgAsmPEImportDirectoryStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmPEImportDirectory) , sizeof ( SgAsmPEImportDirectoryStorageClass ) * sizeOfActualPool) ;
        SgAsmPEImportDirectoryStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmPEImportDirectoryStorageClass* storageArray = storageArraySgAsmPEImportDirectory;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmPEImportDirectory* tmp = new SgAsmPEImportDirectory ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmPEImportDirectory;  
      SgAsmPEImportDirectoryStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmPEImportDirectoryList ); 
     storageClassIndex = 0 ;
     SgAsmPEImportDirectoryListStorageClass* storageArraySgAsmPEImportDirectoryList = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmPEImportDirectoryList = new SgAsmPEImportDirectoryListStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmPEImportDirectoryList) , sizeof ( SgAsmPEImportDirectoryListStorageClass ) * sizeOfActualPool) ;
        SgAsmPEImportDirectoryListStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmPEImportDirectoryListStorageClass* storageArray = storageArraySgAsmPEImportDirectoryList;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmPEImportDirectoryList* tmp = new SgAsmPEImportDirectoryList ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmPEImportDirectoryList;  
      SgAsmPEImportDirectoryListStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmPEImportItem ); 
     storageClassIndex = 0 ;
     SgAsmPEImportItemStorageClass* storageArraySgAsmPEImportItem = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmPEImportItem = new SgAsmPEImportItemStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmPEImportItem) , sizeof ( SgAsmPEImportItemStorageClass ) * sizeOfActualPool) ;
        SgAsmPEImportItemStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmPEImportItemStorageClass* storageArray = storageArraySgAsmPEImportItem;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmPEImportItem* tmp = new SgAsmPEImportItem ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmPEImportItem;  
      SgAsmPEImportItemStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmPEImportItemList ); 
     storageClassIndex = 0 ;
     SgAsmPEImportItemListStorageClass* storageArraySgAsmPEImportItemList = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmPEImportItemList = new SgAsmPEImportItemListStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmPEImportItemList) , sizeof ( SgAsmPEImportItemListStorageClass ) * sizeOfActualPool) ;
        SgAsmPEImportItemListStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmPEImportItemListStorageClass* storageArray = storageArraySgAsmPEImportItemList;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmPEImportItemList* tmp = new SgAsmPEImportItemList ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmPEImportItemList;  
      SgAsmPEImportItemListStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmPEImportSection ); 
     storageClassIndex = 0 ;
     SgAsmPEImportSectionStorageClass* storageArraySgAsmPEImportSection = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmPEImportSection = new SgAsmPEImportSectionStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmPEImportSection) , sizeof ( SgAsmPEImportSectionStorageClass ) * sizeOfActualPool) ;
        SgAsmPEImportSectionStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmPEImportSectionStorageClass* storageArray = storageArraySgAsmPEImportSection;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmPEImportSection* tmp = new SgAsmPEImportSection ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmPEImportSection;  
      SgAsmPEImportSectionStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmPERVASizePair ); 
     storageClassIndex = 0 ;
     SgAsmPERVASizePairStorageClass* storageArraySgAsmPERVASizePair = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmPERVASizePair = new SgAsmPERVASizePairStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmPERVASizePair) , sizeof ( SgAsmPERVASizePairStorageClass ) * sizeOfActualPool) ;
        SgAsmPERVASizePairStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmPERVASizePairStorageClass* storageArray = storageArraySgAsmPERVASizePair;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmPERVASizePair* tmp = new SgAsmPERVASizePair ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmPERVASizePair;  
      SgAsmPERVASizePairStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmPERVASizePairList ); 
     storageClassIndex = 0 ;
     SgAsmPERVASizePairListStorageClass* storageArraySgAsmPERVASizePairList = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmPERVASizePairList = new SgAsmPERVASizePairListStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmPERVASizePairList) , sizeof ( SgAsmPERVASizePairListStorageClass ) * sizeOfActualPool) ;
        SgAsmPERVASizePairListStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmPERVASizePairListStorageClass* storageArray = storageArraySgAsmPERVASizePairList;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmPERVASizePairList* tmp = new SgAsmPERVASizePairList ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmPERVASizePairList;  
      SgAsmPERVASizePairListStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmPESection ); 
     storageClassIndex = 0 ;
     SgAsmPESectionStorageClass* storageArraySgAsmPESection = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmPESection = new SgAsmPESectionStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmPESection) , sizeof ( SgAsmPESectionStorageClass ) * sizeOfActualPool) ;
        SgAsmPESectionStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmPESectionStorageClass* storageArray = storageArraySgAsmPESection;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmPESection* tmp = new SgAsmPESection ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmPESection;  
      SgAsmPESectionStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmPESectionTable ); 
     storageClassIndex = 0 ;
     SgAsmPESectionTableStorageClass* storageArraySgAsmPESectionTable = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmPESectionTable = new SgAsmPESectionTableStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmPESectionTable) , sizeof ( SgAsmPESectionTableStorageClass ) * sizeOfActualPool) ;
        SgAsmPESectionTableStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmPESectionTableStorageClass* storageArray = storageArraySgAsmPESectionTable;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmPESectionTable* tmp = new SgAsmPESectionTable ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmPESectionTable;  
      SgAsmPESectionTableStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmPESectionTableEntry ); 
     storageClassIndex = 0 ;
     SgAsmPESectionTableEntryStorageClass* storageArraySgAsmPESectionTableEntry = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmPESectionTableEntry = new SgAsmPESectionTableEntryStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmPESectionTableEntry) , sizeof ( SgAsmPESectionTableEntryStorageClass ) * sizeOfActualPool) ;
        SgAsmPESectionTableEntryStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmPESectionTableEntryStorageClass* storageArray = storageArraySgAsmPESectionTableEntry;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmPESectionTableEntry* tmp = new SgAsmPESectionTableEntry ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmPESectionTableEntry;  
      SgAsmPESectionTableEntryStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmPEStringSection ); 
     storageClassIndex = 0 ;
     SgAsmPEStringSectionStorageClass* storageArraySgAsmPEStringSection = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmPEStringSection = new SgAsmPEStringSectionStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmPEStringSection) , sizeof ( SgAsmPEStringSectionStorageClass ) * sizeOfActualPool) ;
        SgAsmPEStringSectionStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmPEStringSectionStorageClass* storageArray = storageArraySgAsmPEStringSection;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmPEStringSection* tmp = new SgAsmPEStringSection ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmPEStringSection;  
      SgAsmPEStringSectionStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmPowerpcInstruction ); 
     storageClassIndex = 0 ;
     SgAsmPowerpcInstructionStorageClass* storageArraySgAsmPowerpcInstruction = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmPowerpcInstruction = new SgAsmPowerpcInstructionStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmPowerpcInstruction) , sizeof ( SgAsmPowerpcInstructionStorageClass ) * sizeOfActualPool) ;
        SgAsmPowerpcInstructionStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmPowerpcInstructionStorageClass* storageArray = storageArraySgAsmPowerpcInstruction;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmPowerpcInstruction* tmp = new SgAsmPowerpcInstruction ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmPowerpcInstruction;  
      SgAsmPowerpcInstructionStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmPowerpcRegisterReferenceExpression ); 
     storageClassIndex = 0 ;
     SgAsmPowerpcRegisterReferenceExpressionStorageClass* storageArraySgAsmPowerpcRegisterReferenceExpression = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmPowerpcRegisterReferenceExpression = new SgAsmPowerpcRegisterReferenceExpressionStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmPowerpcRegisterReferenceExpression) , sizeof ( SgAsmPowerpcRegisterReferenceExpressionStorageClass ) * sizeOfActualPool) ;
        SgAsmPowerpcRegisterReferenceExpressionStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmPowerpcRegisterReferenceExpressionStorageClass* storageArray = storageArraySgAsmPowerpcRegisterReferenceExpression;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmPowerpcRegisterReferenceExpression* tmp = new SgAsmPowerpcRegisterReferenceExpression ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmPowerpcRegisterReferenceExpression;  
      SgAsmPowerpcRegisterReferenceExpressionStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmQuadWordValueExpression ); 
     storageClassIndex = 0 ;
     SgAsmQuadWordValueExpressionStorageClass* storageArraySgAsmQuadWordValueExpression = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmQuadWordValueExpression = new SgAsmQuadWordValueExpressionStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmQuadWordValueExpression) , sizeof ( SgAsmQuadWordValueExpressionStorageClass ) * sizeOfActualPool) ;
        SgAsmQuadWordValueExpressionStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmQuadWordValueExpressionStorageClass* storageArray = storageArraySgAsmQuadWordValueExpression;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmQuadWordValueExpression* tmp = new SgAsmQuadWordValueExpression ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmQuadWordValueExpression;  
      SgAsmQuadWordValueExpressionStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmRegisterReferenceExpression ); 
     storageClassIndex = 0 ;
     SgAsmRegisterReferenceExpressionStorageClass* storageArraySgAsmRegisterReferenceExpression = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmRegisterReferenceExpression = new SgAsmRegisterReferenceExpressionStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmRegisterReferenceExpression) , sizeof ( SgAsmRegisterReferenceExpressionStorageClass ) * sizeOfActualPool) ;
        SgAsmRegisterReferenceExpressionStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmRegisterReferenceExpressionStorageClass* storageArray = storageArraySgAsmRegisterReferenceExpression;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmRegisterReferenceExpression* tmp = new SgAsmRegisterReferenceExpression ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmRegisterReferenceExpression;  
      SgAsmRegisterReferenceExpressionStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmSingleFloatValueExpression ); 
     storageClassIndex = 0 ;
     SgAsmSingleFloatValueExpressionStorageClass* storageArraySgAsmSingleFloatValueExpression = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmSingleFloatValueExpression = new SgAsmSingleFloatValueExpressionStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmSingleFloatValueExpression) , sizeof ( SgAsmSingleFloatValueExpressionStorageClass ) * sizeOfActualPool) ;
        SgAsmSingleFloatValueExpressionStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmSingleFloatValueExpressionStorageClass* storageArray = storageArraySgAsmSingleFloatValueExpression;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmSingleFloatValueExpression* tmp = new SgAsmSingleFloatValueExpression ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmSingleFloatValueExpression;  
      SgAsmSingleFloatValueExpressionStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmStatement ); 
     storageClassIndex = 0 ;
     SgAsmStatementStorageClass* storageArraySgAsmStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmStatement = new SgAsmStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmStatement) , sizeof ( SgAsmStatementStorageClass ) * sizeOfActualPool) ;
        SgAsmStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmStatementStorageClass* storageArray = storageArraySgAsmStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmStatement* tmp = new SgAsmStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmStatement;  
      SgAsmStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmStaticData ); 
     storageClassIndex = 0 ;
     SgAsmStaticDataStorageClass* storageArraySgAsmStaticData = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmStaticData = new SgAsmStaticDataStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmStaticData) , sizeof ( SgAsmStaticDataStorageClass ) * sizeOfActualPool) ;
        SgAsmStaticDataStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmStaticDataStorageClass* storageArray = storageArraySgAsmStaticData;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmStaticData* tmp = new SgAsmStaticData ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmStaticData;  
      SgAsmStaticDataStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmStmt ); 
     storageClassIndex = 0 ;
     SgAsmStmtStorageClass* storageArraySgAsmStmt = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmStmt = new SgAsmStmtStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmStmt) , sizeof ( SgAsmStmtStorageClass ) * sizeOfActualPool) ;
        SgAsmStmtStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmStmtStorageClass* storageArray = storageArraySgAsmStmt;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmStmt* tmp = new SgAsmStmt ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmStmt;  
      SgAsmStmtStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmStoredString ); 
     storageClassIndex = 0 ;
     SgAsmStoredStringStorageClass* storageArraySgAsmStoredString = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmStoredString = new SgAsmStoredStringStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmStoredString) , sizeof ( SgAsmStoredStringStorageClass ) * sizeOfActualPool) ;
        SgAsmStoredStringStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmStoredStringStorageClass* storageArray = storageArraySgAsmStoredString;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmStoredString* tmp = new SgAsmStoredString ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmStoredString;  
      SgAsmStoredStringStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmStringStorage ); 
     storageClassIndex = 0 ;
     SgAsmStringStorageStorageClass* storageArraySgAsmStringStorage = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmStringStorage = new SgAsmStringStorageStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmStringStorage) , sizeof ( SgAsmStringStorageStorageClass ) * sizeOfActualPool) ;
        SgAsmStringStorageStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmStringStorageStorageClass* storageArray = storageArraySgAsmStringStorage;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmStringStorage* tmp = new SgAsmStringStorage ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmStringStorage;  
      SgAsmStringStorageStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmType ); 
     storageClassIndex = 0 ;
     SgAsmTypeStorageClass* storageArraySgAsmType = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmType = new SgAsmTypeStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmType) , sizeof ( SgAsmTypeStorageClass ) * sizeOfActualPool) ;
        SgAsmTypeStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmTypeStorageClass* storageArray = storageArraySgAsmType;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmType* tmp = new SgAsmType ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmType;  
      SgAsmTypeStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmType128bitFloat ); 
     storageClassIndex = 0 ;
     SgAsmType128bitFloatStorageClass* storageArraySgAsmType128bitFloat = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmType128bitFloat = new SgAsmType128bitFloatStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmType128bitFloat) , sizeof ( SgAsmType128bitFloatStorageClass ) * sizeOfActualPool) ;
        SgAsmType128bitFloatStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmType128bitFloatStorageClass* storageArray = storageArraySgAsmType128bitFloat;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmType128bitFloat* tmp = new SgAsmType128bitFloat ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmType128bitFloat;  
      SgAsmType128bitFloatStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmType80bitFloat ); 
     storageClassIndex = 0 ;
     SgAsmType80bitFloatStorageClass* storageArraySgAsmType80bitFloat = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmType80bitFloat = new SgAsmType80bitFloatStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmType80bitFloat) , sizeof ( SgAsmType80bitFloatStorageClass ) * sizeOfActualPool) ;
        SgAsmType80bitFloatStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmType80bitFloatStorageClass* storageArray = storageArraySgAsmType80bitFloat;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmType80bitFloat* tmp = new SgAsmType80bitFloat ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmType80bitFloat;  
      SgAsmType80bitFloatStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmTypeByte ); 
     storageClassIndex = 0 ;
     SgAsmTypeByteStorageClass* storageArraySgAsmTypeByte = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmTypeByte = new SgAsmTypeByteStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmTypeByte) , sizeof ( SgAsmTypeByteStorageClass ) * sizeOfActualPool) ;
        SgAsmTypeByteStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmTypeByteStorageClass* storageArray = storageArraySgAsmTypeByte;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmTypeByte* tmp = new SgAsmTypeByte ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmTypeByte;  
      SgAsmTypeByteStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmTypeDoubleFloat ); 
     storageClassIndex = 0 ;
     SgAsmTypeDoubleFloatStorageClass* storageArraySgAsmTypeDoubleFloat = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmTypeDoubleFloat = new SgAsmTypeDoubleFloatStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmTypeDoubleFloat) , sizeof ( SgAsmTypeDoubleFloatStorageClass ) * sizeOfActualPool) ;
        SgAsmTypeDoubleFloatStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmTypeDoubleFloatStorageClass* storageArray = storageArraySgAsmTypeDoubleFloat;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmTypeDoubleFloat* tmp = new SgAsmTypeDoubleFloat ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmTypeDoubleFloat;  
      SgAsmTypeDoubleFloatStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmTypeDoubleQuadWord ); 
     storageClassIndex = 0 ;
     SgAsmTypeDoubleQuadWordStorageClass* storageArraySgAsmTypeDoubleQuadWord = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmTypeDoubleQuadWord = new SgAsmTypeDoubleQuadWordStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmTypeDoubleQuadWord) , sizeof ( SgAsmTypeDoubleQuadWordStorageClass ) * sizeOfActualPool) ;
        SgAsmTypeDoubleQuadWordStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmTypeDoubleQuadWordStorageClass* storageArray = storageArraySgAsmTypeDoubleQuadWord;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmTypeDoubleQuadWord* tmp = new SgAsmTypeDoubleQuadWord ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmTypeDoubleQuadWord;  
      SgAsmTypeDoubleQuadWordStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmTypeDoubleWord ); 
     storageClassIndex = 0 ;
     SgAsmTypeDoubleWordStorageClass* storageArraySgAsmTypeDoubleWord = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmTypeDoubleWord = new SgAsmTypeDoubleWordStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmTypeDoubleWord) , sizeof ( SgAsmTypeDoubleWordStorageClass ) * sizeOfActualPool) ;
        SgAsmTypeDoubleWordStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmTypeDoubleWordStorageClass* storageArray = storageArraySgAsmTypeDoubleWord;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmTypeDoubleWord* tmp = new SgAsmTypeDoubleWord ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmTypeDoubleWord;  
      SgAsmTypeDoubleWordStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmTypeQuadWord ); 
     storageClassIndex = 0 ;
     SgAsmTypeQuadWordStorageClass* storageArraySgAsmTypeQuadWord = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmTypeQuadWord = new SgAsmTypeQuadWordStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmTypeQuadWord) , sizeof ( SgAsmTypeQuadWordStorageClass ) * sizeOfActualPool) ;
        SgAsmTypeQuadWordStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmTypeQuadWordStorageClass* storageArray = storageArraySgAsmTypeQuadWord;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmTypeQuadWord* tmp = new SgAsmTypeQuadWord ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmTypeQuadWord;  
      SgAsmTypeQuadWordStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmTypeSingleFloat ); 
     storageClassIndex = 0 ;
     SgAsmTypeSingleFloatStorageClass* storageArraySgAsmTypeSingleFloat = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmTypeSingleFloat = new SgAsmTypeSingleFloatStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmTypeSingleFloat) , sizeof ( SgAsmTypeSingleFloatStorageClass ) * sizeOfActualPool) ;
        SgAsmTypeSingleFloatStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmTypeSingleFloatStorageClass* storageArray = storageArraySgAsmTypeSingleFloat;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmTypeSingleFloat* tmp = new SgAsmTypeSingleFloat ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmTypeSingleFloat;  
      SgAsmTypeSingleFloatStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmTypeVector ); 
     storageClassIndex = 0 ;
     SgAsmTypeVectorStorageClass* storageArraySgAsmTypeVector = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmTypeVector = new SgAsmTypeVectorStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmTypeVector) , sizeof ( SgAsmTypeVectorStorageClass ) * sizeOfActualPool) ;
        SgAsmTypeVectorStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmTypeVectorStorageClass* storageArray = storageArraySgAsmTypeVector;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmTypeVector* tmp = new SgAsmTypeVector ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmTypeVector;  
      SgAsmTypeVectorStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmTypeWord ); 
     storageClassIndex = 0 ;
     SgAsmTypeWordStorageClass* storageArraySgAsmTypeWord = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmTypeWord = new SgAsmTypeWordStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmTypeWord) , sizeof ( SgAsmTypeWordStorageClass ) * sizeOfActualPool) ;
        SgAsmTypeWordStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmTypeWordStorageClass* storageArray = storageArraySgAsmTypeWord;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmTypeWord* tmp = new SgAsmTypeWord ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmTypeWord;  
      SgAsmTypeWordStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmUnaryArmSpecialRegisterList ); 
     storageClassIndex = 0 ;
     SgAsmUnaryArmSpecialRegisterListStorageClass* storageArraySgAsmUnaryArmSpecialRegisterList = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmUnaryArmSpecialRegisterList = new SgAsmUnaryArmSpecialRegisterListStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmUnaryArmSpecialRegisterList) , sizeof ( SgAsmUnaryArmSpecialRegisterListStorageClass ) * sizeOfActualPool) ;
        SgAsmUnaryArmSpecialRegisterListStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmUnaryArmSpecialRegisterListStorageClass* storageArray = storageArraySgAsmUnaryArmSpecialRegisterList;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmUnaryArmSpecialRegisterList* tmp = new SgAsmUnaryArmSpecialRegisterList ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmUnaryArmSpecialRegisterList;  
      SgAsmUnaryArmSpecialRegisterListStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmUnaryExpression ); 
     storageClassIndex = 0 ;
     SgAsmUnaryExpressionStorageClass* storageArraySgAsmUnaryExpression = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmUnaryExpression = new SgAsmUnaryExpressionStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmUnaryExpression) , sizeof ( SgAsmUnaryExpressionStorageClass ) * sizeOfActualPool) ;
        SgAsmUnaryExpressionStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmUnaryExpressionStorageClass* storageArray = storageArraySgAsmUnaryExpression;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmUnaryExpression* tmp = new SgAsmUnaryExpression ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmUnaryExpression;  
      SgAsmUnaryExpressionStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmUnaryMinus ); 
     storageClassIndex = 0 ;
     SgAsmUnaryMinusStorageClass* storageArraySgAsmUnaryMinus = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmUnaryMinus = new SgAsmUnaryMinusStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmUnaryMinus) , sizeof ( SgAsmUnaryMinusStorageClass ) * sizeOfActualPool) ;
        SgAsmUnaryMinusStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmUnaryMinusStorageClass* storageArray = storageArraySgAsmUnaryMinus;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmUnaryMinus* tmp = new SgAsmUnaryMinus ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmUnaryMinus;  
      SgAsmUnaryMinusStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmUnaryPlus ); 
     storageClassIndex = 0 ;
     SgAsmUnaryPlusStorageClass* storageArraySgAsmUnaryPlus = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmUnaryPlus = new SgAsmUnaryPlusStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmUnaryPlus) , sizeof ( SgAsmUnaryPlusStorageClass ) * sizeOfActualPool) ;
        SgAsmUnaryPlusStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmUnaryPlusStorageClass* storageArray = storageArraySgAsmUnaryPlus;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmUnaryPlus* tmp = new SgAsmUnaryPlus ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmUnaryPlus;  
      SgAsmUnaryPlusStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmUnaryRrx ); 
     storageClassIndex = 0 ;
     SgAsmUnaryRrxStorageClass* storageArraySgAsmUnaryRrx = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmUnaryRrx = new SgAsmUnaryRrxStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmUnaryRrx) , sizeof ( SgAsmUnaryRrxStorageClass ) * sizeOfActualPool) ;
        SgAsmUnaryRrxStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmUnaryRrxStorageClass* storageArray = storageArraySgAsmUnaryRrx;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmUnaryRrx* tmp = new SgAsmUnaryRrx ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmUnaryRrx;  
      SgAsmUnaryRrxStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmValueExpression ); 
     storageClassIndex = 0 ;
     SgAsmValueExpressionStorageClass* storageArraySgAsmValueExpression = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmValueExpression = new SgAsmValueExpressionStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmValueExpression) , sizeof ( SgAsmValueExpressionStorageClass ) * sizeOfActualPool) ;
        SgAsmValueExpressionStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmValueExpressionStorageClass* storageArray = storageArraySgAsmValueExpression;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmValueExpression* tmp = new SgAsmValueExpression ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmValueExpression;  
      SgAsmValueExpressionStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmVectorValueExpression ); 
     storageClassIndex = 0 ;
     SgAsmVectorValueExpressionStorageClass* storageArraySgAsmVectorValueExpression = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmVectorValueExpression = new SgAsmVectorValueExpressionStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmVectorValueExpression) , sizeof ( SgAsmVectorValueExpressionStorageClass ) * sizeOfActualPool) ;
        SgAsmVectorValueExpressionStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmVectorValueExpressionStorageClass* storageArray = storageArraySgAsmVectorValueExpression;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmVectorValueExpression* tmp = new SgAsmVectorValueExpression ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmVectorValueExpression;  
      SgAsmVectorValueExpressionStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmWordValueExpression ); 
     storageClassIndex = 0 ;
     SgAsmWordValueExpressionStorageClass* storageArraySgAsmWordValueExpression = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmWordValueExpression = new SgAsmWordValueExpressionStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmWordValueExpression) , sizeof ( SgAsmWordValueExpressionStorageClass ) * sizeOfActualPool) ;
        SgAsmWordValueExpressionStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmWordValueExpressionStorageClass* storageArray = storageArraySgAsmWordValueExpression;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmWordValueExpression* tmp = new SgAsmWordValueExpression ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmWordValueExpression;  
      SgAsmWordValueExpressionStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmx86Instruction ); 
     storageClassIndex = 0 ;
     SgAsmx86InstructionStorageClass* storageArraySgAsmx86Instruction = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmx86Instruction = new SgAsmx86InstructionStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmx86Instruction) , sizeof ( SgAsmx86InstructionStorageClass ) * sizeOfActualPool) ;
        SgAsmx86InstructionStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmx86InstructionStorageClass* storageArray = storageArraySgAsmx86Instruction;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmx86Instruction* tmp = new SgAsmx86Instruction ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmx86Instruction;  
      SgAsmx86InstructionStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmx86RegisterReferenceExpression ); 
     storageClassIndex = 0 ;
     SgAsmx86RegisterReferenceExpressionStorageClass* storageArraySgAsmx86RegisterReferenceExpression = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmx86RegisterReferenceExpression = new SgAsmx86RegisterReferenceExpressionStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmx86RegisterReferenceExpression) , sizeof ( SgAsmx86RegisterReferenceExpressionStorageClass ) * sizeOfActualPool) ;
        SgAsmx86RegisterReferenceExpressionStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmx86RegisterReferenceExpressionStorageClass* storageArray = storageArraySgAsmx86RegisterReferenceExpression;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmx86RegisterReferenceExpression* tmp = new SgAsmx86RegisterReferenceExpression ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmx86RegisterReferenceExpression;  
      SgAsmx86RegisterReferenceExpressionStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmBinaryAddressSymbol ); 
     storageClassIndex = 0 ;
     SgAsmBinaryAddressSymbolStorageClass* storageArraySgAsmBinaryAddressSymbol = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmBinaryAddressSymbol = new SgAsmBinaryAddressSymbolStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmBinaryAddressSymbol) , sizeof ( SgAsmBinaryAddressSymbolStorageClass ) * sizeOfActualPool) ;
        SgAsmBinaryAddressSymbolStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmBinaryAddressSymbolStorageClass* storageArray = storageArraySgAsmBinaryAddressSymbol;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmBinaryAddressSymbol* tmp = new SgAsmBinaryAddressSymbol ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmBinaryAddressSymbol;  
      SgAsmBinaryAddressSymbolStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsmBinaryDataSymbol ); 
     storageClassIndex = 0 ;
     SgAsmBinaryDataSymbolStorageClass* storageArraySgAsmBinaryDataSymbol = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsmBinaryDataSymbol = new SgAsmBinaryDataSymbolStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsmBinaryDataSymbol) , sizeof ( SgAsmBinaryDataSymbolStorageClass ) * sizeOfActualPool) ;
        SgAsmBinaryDataSymbolStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsmBinaryDataSymbolStorageClass* storageArray = storageArraySgAsmBinaryDataSymbol;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsmBinaryDataSymbol* tmp = new SgAsmBinaryDataSymbol ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsmBinaryDataSymbol;  
      SgAsmBinaryDataSymbolStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAssertStmt ); 
     storageClassIndex = 0 ;
     SgAssertStmtStorageClass* storageArraySgAssertStmt = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAssertStmt = new SgAssertStmtStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAssertStmt) , sizeof ( SgAssertStmtStorageClass ) * sizeOfActualPool) ;
        SgAssertStmtStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAssertStmtStorageClass* storageArray = storageArraySgAssertStmt;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAssertStmt* tmp = new SgAssertStmt ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAssertStmt;  
      SgAssertStmtStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAssignInitializer ); 
     storageClassIndex = 0 ;
     SgAssignInitializerStorageClass* storageArraySgAssignInitializer = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAssignInitializer = new SgAssignInitializerStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAssignInitializer) , sizeof ( SgAssignInitializerStorageClass ) * sizeOfActualPool) ;
        SgAssignInitializerStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAssignInitializerStorageClass* storageArray = storageArraySgAssignInitializer;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAssignInitializer* tmp = new SgAssignInitializer ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAssignInitializer;  
      SgAssignInitializerStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAssignOp ); 
     storageClassIndex = 0 ;
     SgAssignOpStorageClass* storageArraySgAssignOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAssignOp = new SgAssignOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAssignOp) , sizeof ( SgAssignOpStorageClass ) * sizeOfActualPool) ;
        SgAssignOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAssignOpStorageClass* storageArray = storageArraySgAssignOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAssignOp* tmp = new SgAssignOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAssignOp;  
      SgAssignOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAssignStatement ); 
     storageClassIndex = 0 ;
     SgAssignStatementStorageClass* storageArraySgAssignStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAssignStatement = new SgAssignStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAssignStatement) , sizeof ( SgAssignStatementStorageClass ) * sizeOfActualPool) ;
        SgAssignStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAssignStatementStorageClass* storageArray = storageArraySgAssignStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAssignStatement* tmp = new SgAssignStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAssignStatement;  
      SgAssignStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAssignedGotoStatement ); 
     storageClassIndex = 0 ;
     SgAssignedGotoStatementStorageClass* storageArraySgAssignedGotoStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAssignedGotoStatement = new SgAssignedGotoStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAssignedGotoStatement) , sizeof ( SgAssignedGotoStatementStorageClass ) * sizeOfActualPool) ;
        SgAssignedGotoStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAssignedGotoStatementStorageClass* storageArray = storageArraySgAssignedGotoStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAssignedGotoStatement* tmp = new SgAssignedGotoStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAssignedGotoStatement;  
      SgAssignedGotoStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAssociateStatement ); 
     storageClassIndex = 0 ;
     SgAssociateStatementStorageClass* storageArraySgAssociateStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAssociateStatement = new SgAssociateStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAssociateStatement) , sizeof ( SgAssociateStatementStorageClass ) * sizeOfActualPool) ;
        SgAssociateStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAssociateStatementStorageClass* storageArray = storageArraySgAssociateStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAssociateStatement* tmp = new SgAssociateStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAssociateStatement;  
      SgAssociateStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAsteriskShapeExp ); 
     storageClassIndex = 0 ;
     SgAsteriskShapeExpStorageClass* storageArraySgAsteriskShapeExp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAsteriskShapeExp = new SgAsteriskShapeExpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAsteriskShapeExp) , sizeof ( SgAsteriskShapeExpStorageClass ) * sizeOfActualPool) ;
        SgAsteriskShapeExpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAsteriskShapeExpStorageClass* storageArray = storageArraySgAsteriskShapeExp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAsteriskShapeExp* tmp = new SgAsteriskShapeExp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAsteriskShapeExp;  
      SgAsteriskShapeExpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAttribute ); 
     storageClassIndex = 0 ;
     SgAttributeStorageClass* storageArraySgAttribute = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAttribute = new SgAttributeStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAttribute) , sizeof ( SgAttributeStorageClass ) * sizeOfActualPool) ;
        SgAttributeStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAttributeStorageClass* storageArray = storageArraySgAttribute;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAttribute* tmp = new SgAttribute ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAttribute;  
      SgAttributeStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgAttributeSpecificationStatement ); 
     storageClassIndex = 0 ;
     SgAttributeSpecificationStatementStorageClass* storageArraySgAttributeSpecificationStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgAttributeSpecificationStatement = new SgAttributeSpecificationStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgAttributeSpecificationStatement) , sizeof ( SgAttributeSpecificationStatementStorageClass ) * sizeOfActualPool) ;
        SgAttributeSpecificationStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgAttributeSpecificationStatementStorageClass* storageArray = storageArraySgAttributeSpecificationStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgAttributeSpecificationStatement* tmp = new SgAttributeSpecificationStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgAttributeSpecificationStatement;  
      SgAttributeSpecificationStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgBackspaceStatement ); 
     storageClassIndex = 0 ;
     SgBackspaceStatementStorageClass* storageArraySgBackspaceStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgBackspaceStatement = new SgBackspaceStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgBackspaceStatement) , sizeof ( SgBackspaceStatementStorageClass ) * sizeOfActualPool) ;
        SgBackspaceStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgBackspaceStatementStorageClass* storageArray = storageArraySgBackspaceStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgBackspaceStatement* tmp = new SgBackspaceStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgBackspaceStatement;  
      SgBackspaceStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgBaseClass ); 
     storageClassIndex = 0 ;
     SgBaseClassStorageClass* storageArraySgBaseClass = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgBaseClass = new SgBaseClassStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgBaseClass) , sizeof ( SgBaseClassStorageClass ) * sizeOfActualPool) ;
          SgBaseClassStorageClass* storageArray = storageArraySgBaseClass;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgBaseClass* tmp = new SgBaseClass ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgBaseClass;  


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgExpBaseClass ); 
     storageClassIndex = 0 ;
     SgExpBaseClassStorageClass* storageArraySgExpBaseClass = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgExpBaseClass = new SgExpBaseClassStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgExpBaseClass) , sizeof ( SgExpBaseClassStorageClass ) * sizeOfActualPool) ;
          SgExpBaseClassStorageClass* storageArray = storageArraySgExpBaseClass;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgExpBaseClass* tmp = new SgExpBaseClass ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgExpBaseClass;  


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgBaseClassModifier ); 
     storageClassIndex = 0 ;
     SgBaseClassModifierStorageClass* storageArraySgBaseClassModifier = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgBaseClassModifier = new SgBaseClassModifierStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgBaseClassModifier) , sizeof ( SgBaseClassModifierStorageClass ) * sizeOfActualPool) ;
        SgBaseClassModifierStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgBaseClassModifierStorageClass* storageArray = storageArraySgBaseClassModifier;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgBaseClassModifier* tmp = new SgBaseClassModifier ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgBaseClassModifier;  
      SgBaseClassModifierStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgBasicBlock ); 
     storageClassIndex = 0 ;
     SgBasicBlockStorageClass* storageArraySgBasicBlock = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgBasicBlock = new SgBasicBlockStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgBasicBlock) , sizeof ( SgBasicBlockStorageClass ) * sizeOfActualPool) ;
        SgBasicBlockStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgBasicBlockStorageClass* storageArray = storageArraySgBasicBlock;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgBasicBlock* tmp = new SgBasicBlock ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgBasicBlock;  
      SgBasicBlockStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgBidirectionalGraph ); 
     storageClassIndex = 0 ;
     SgBidirectionalGraphStorageClass* storageArraySgBidirectionalGraph = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgBidirectionalGraph = new SgBidirectionalGraphStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgBidirectionalGraph) , sizeof ( SgBidirectionalGraphStorageClass ) * sizeOfActualPool) ;
        SgBidirectionalGraphStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgBidirectionalGraphStorageClass* storageArray = storageArraySgBidirectionalGraph;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgBidirectionalGraph* tmp = new SgBidirectionalGraph ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgBidirectionalGraph;  
      SgBidirectionalGraphStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgBinaryComposite ); 
     storageClassIndex = 0 ;
     SgBinaryCompositeStorageClass* storageArraySgBinaryComposite = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgBinaryComposite = new SgBinaryCompositeStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgBinaryComposite) , sizeof ( SgBinaryCompositeStorageClass ) * sizeOfActualPool) ;
        SgBinaryCompositeStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgBinaryCompositeStorageClass* storageArray = storageArraySgBinaryComposite;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgBinaryComposite* tmp = new SgBinaryComposite ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgBinaryComposite;  
      SgBinaryCompositeStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgBinaryOp ); 
     storageClassIndex = 0 ;
     SgBinaryOpStorageClass* storageArraySgBinaryOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgBinaryOp = new SgBinaryOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgBinaryOp) , sizeof ( SgBinaryOpStorageClass ) * sizeOfActualPool) ;
        SgBinaryOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgBinaryOpStorageClass* storageArray = storageArraySgBinaryOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgBinaryOp* tmp = new SgBinaryOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgBinaryOp;  
      SgBinaryOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgBitAndOp ); 
     storageClassIndex = 0 ;
     SgBitAndOpStorageClass* storageArraySgBitAndOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgBitAndOp = new SgBitAndOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgBitAndOp) , sizeof ( SgBitAndOpStorageClass ) * sizeOfActualPool) ;
        SgBitAndOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgBitAndOpStorageClass* storageArray = storageArraySgBitAndOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgBitAndOp* tmp = new SgBitAndOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgBitAndOp;  
      SgBitAndOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgBitAttribute ); 
     storageClassIndex = 0 ;
     SgBitAttributeStorageClass* storageArraySgBitAttribute = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgBitAttribute = new SgBitAttributeStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgBitAttribute) , sizeof ( SgBitAttributeStorageClass ) * sizeOfActualPool) ;
        SgBitAttributeStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgBitAttributeStorageClass* storageArray = storageArraySgBitAttribute;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgBitAttribute* tmp = new SgBitAttribute ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgBitAttribute;  
      SgBitAttributeStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgBitComplementOp ); 
     storageClassIndex = 0 ;
     SgBitComplementOpStorageClass* storageArraySgBitComplementOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgBitComplementOp = new SgBitComplementOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgBitComplementOp) , sizeof ( SgBitComplementOpStorageClass ) * sizeOfActualPool) ;
        SgBitComplementOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgBitComplementOpStorageClass* storageArray = storageArraySgBitComplementOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgBitComplementOp* tmp = new SgBitComplementOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgBitComplementOp;  
      SgBitComplementOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgBitOrOp ); 
     storageClassIndex = 0 ;
     SgBitOrOpStorageClass* storageArraySgBitOrOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgBitOrOp = new SgBitOrOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgBitOrOp) , sizeof ( SgBitOrOpStorageClass ) * sizeOfActualPool) ;
        SgBitOrOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgBitOrOpStorageClass* storageArray = storageArraySgBitOrOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgBitOrOp* tmp = new SgBitOrOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgBitOrOp;  
      SgBitOrOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgBitXorOp ); 
     storageClassIndex = 0 ;
     SgBitXorOpStorageClass* storageArraySgBitXorOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgBitXorOp = new SgBitXorOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgBitXorOp) , sizeof ( SgBitXorOpStorageClass ) * sizeOfActualPool) ;
        SgBitXorOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgBitXorOpStorageClass* storageArray = storageArraySgBitXorOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgBitXorOp* tmp = new SgBitXorOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgBitXorOp;  
      SgBitXorOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgBlockDataStatement ); 
     storageClassIndex = 0 ;
     SgBlockDataStatementStorageClass* storageArraySgBlockDataStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgBlockDataStatement = new SgBlockDataStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgBlockDataStatement) , sizeof ( SgBlockDataStatementStorageClass ) * sizeOfActualPool) ;
        SgBlockDataStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgBlockDataStatementStorageClass* storageArray = storageArraySgBlockDataStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgBlockDataStatement* tmp = new SgBlockDataStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgBlockDataStatement;  
      SgBlockDataStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgBoolValExp ); 
     storageClassIndex = 0 ;
     SgBoolValExpStorageClass* storageArraySgBoolValExp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgBoolValExp = new SgBoolValExpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgBoolValExp) , sizeof ( SgBoolValExpStorageClass ) * sizeOfActualPool) ;
        SgBoolValExpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgBoolValExpStorageClass* storageArray = storageArraySgBoolValExp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgBoolValExp* tmp = new SgBoolValExp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgBoolValExp;  
      SgBoolValExpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgBreakStmt ); 
     storageClassIndex = 0 ;
     SgBreakStmtStorageClass* storageArraySgBreakStmt = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgBreakStmt = new SgBreakStmtStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgBreakStmt) , sizeof ( SgBreakStmtStorageClass ) * sizeOfActualPool) ;
        SgBreakStmtStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgBreakStmtStorageClass* storageArray = storageArraySgBreakStmt;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgBreakStmt* tmp = new SgBreakStmt ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgBreakStmt;  
      SgBreakStmtStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgC_PreprocessorDirectiveStatement ); 
     storageClassIndex = 0 ;
     SgC_PreprocessorDirectiveStatementStorageClass* storageArraySgC_PreprocessorDirectiveStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgC_PreprocessorDirectiveStatement = new SgC_PreprocessorDirectiveStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgC_PreprocessorDirectiveStatement) , sizeof ( SgC_PreprocessorDirectiveStatementStorageClass ) * sizeOfActualPool) ;
        SgC_PreprocessorDirectiveStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgC_PreprocessorDirectiveStatementStorageClass* storageArray = storageArraySgC_PreprocessorDirectiveStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgC_PreprocessorDirectiveStatement* tmp = new SgC_PreprocessorDirectiveStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgC_PreprocessorDirectiveStatement;  
      SgC_PreprocessorDirectiveStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgCaseOptionStmt ); 
     storageClassIndex = 0 ;
     SgCaseOptionStmtStorageClass* storageArraySgCaseOptionStmt = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgCaseOptionStmt = new SgCaseOptionStmtStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgCaseOptionStmt) , sizeof ( SgCaseOptionStmtStorageClass ) * sizeOfActualPool) ;
        SgCaseOptionStmtStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgCaseOptionStmtStorageClass* storageArray = storageArraySgCaseOptionStmt;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgCaseOptionStmt* tmp = new SgCaseOptionStmt ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgCaseOptionStmt;  
      SgCaseOptionStmtStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgCastExp ); 
     storageClassIndex = 0 ;
     SgCastExpStorageClass* storageArraySgCastExp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgCastExp = new SgCastExpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgCastExp) , sizeof ( SgCastExpStorageClass ) * sizeOfActualPool) ;
        SgCastExpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgCastExpStorageClass* storageArray = storageArraySgCastExp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgCastExp* tmp = new SgCastExp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgCastExp;  
      SgCastExpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgCatchOptionStmt ); 
     storageClassIndex = 0 ;
     SgCatchOptionStmtStorageClass* storageArraySgCatchOptionStmt = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgCatchOptionStmt = new SgCatchOptionStmtStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgCatchOptionStmt) , sizeof ( SgCatchOptionStmtStorageClass ) * sizeOfActualPool) ;
        SgCatchOptionStmtStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgCatchOptionStmtStorageClass* storageArray = storageArraySgCatchOptionStmt;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgCatchOptionStmt* tmp = new SgCatchOptionStmt ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgCatchOptionStmt;  
      SgCatchOptionStmtStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgCatchStatementSeq ); 
     storageClassIndex = 0 ;
     SgCatchStatementSeqStorageClass* storageArraySgCatchStatementSeq = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgCatchStatementSeq = new SgCatchStatementSeqStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgCatchStatementSeq) , sizeof ( SgCatchStatementSeqStorageClass ) * sizeOfActualPool) ;
        SgCatchStatementSeqStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgCatchStatementSeqStorageClass* storageArray = storageArraySgCatchStatementSeq;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgCatchStatementSeq* tmp = new SgCatchStatementSeq ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgCatchStatementSeq;  
      SgCatchStatementSeqStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgCharVal ); 
     storageClassIndex = 0 ;
     SgCharValStorageClass* storageArraySgCharVal = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgCharVal = new SgCharValStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgCharVal) , sizeof ( SgCharValStorageClass ) * sizeOfActualPool) ;
        SgCharValStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgCharValStorageClass* storageArray = storageArraySgCharVal;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgCharVal* tmp = new SgCharVal ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgCharVal;  
      SgCharValStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgClassDecl_attr ); 
     storageClassIndex = 0 ;
     SgClassDecl_attrStorageClass* storageArraySgClassDecl_attr = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgClassDecl_attr = new SgClassDecl_attrStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgClassDecl_attr) , sizeof ( SgClassDecl_attrStorageClass ) * sizeOfActualPool) ;
        SgClassDecl_attrStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgClassDecl_attrStorageClass* storageArray = storageArraySgClassDecl_attr;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgClassDecl_attr* tmp = new SgClassDecl_attr ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgClassDecl_attr;  
      SgClassDecl_attrStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgClassDeclaration ); 
     storageClassIndex = 0 ;
     SgClassDeclarationStorageClass* storageArraySgClassDeclaration = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgClassDeclaration = new SgClassDeclarationStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgClassDeclaration) , sizeof ( SgClassDeclarationStorageClass ) * sizeOfActualPool) ;
        SgClassDeclarationStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgClassDeclarationStorageClass* storageArray = storageArraySgClassDeclaration;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgClassDeclaration* tmp = new SgClassDeclaration ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgClassDeclaration;  
      SgClassDeclarationStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgClassDefinition ); 
     storageClassIndex = 0 ;
     SgClassDefinitionStorageClass* storageArraySgClassDefinition = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgClassDefinition = new SgClassDefinitionStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgClassDefinition) , sizeof ( SgClassDefinitionStorageClass ) * sizeOfActualPool) ;
        SgClassDefinitionStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgClassDefinitionStorageClass* storageArray = storageArraySgClassDefinition;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgClassDefinition* tmp = new SgClassDefinition ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgClassDefinition;  
      SgClassDefinitionStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgClassNameRefExp ); 
     storageClassIndex = 0 ;
     SgClassNameRefExpStorageClass* storageArraySgClassNameRefExp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgClassNameRefExp = new SgClassNameRefExpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgClassNameRefExp) , sizeof ( SgClassNameRefExpStorageClass ) * sizeOfActualPool) ;
        SgClassNameRefExpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgClassNameRefExpStorageClass* storageArray = storageArraySgClassNameRefExp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgClassNameRefExp* tmp = new SgClassNameRefExp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgClassNameRefExp;  
      SgClassNameRefExpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgClassSymbol ); 
     storageClassIndex = 0 ;
     SgClassSymbolStorageClass* storageArraySgClassSymbol = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgClassSymbol = new SgClassSymbolStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgClassSymbol) , sizeof ( SgClassSymbolStorageClass ) * sizeOfActualPool) ;
        SgClassSymbolStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgClassSymbolStorageClass* storageArray = storageArraySgClassSymbol;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgClassSymbol* tmp = new SgClassSymbol ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgClassSymbol;  
      SgClassSymbolStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgClassType ); 
     storageClassIndex = 0 ;
     SgClassTypeStorageClass* storageArraySgClassType = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgClassType = new SgClassTypeStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgClassType) , sizeof ( SgClassTypeStorageClass ) * sizeOfActualPool) ;
        SgClassTypeStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgClassTypeStorageClass* storageArray = storageArraySgClassType;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgClassType* tmp = new SgClassType ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgClassType;  
      SgClassTypeStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgClinkageDeclarationStatement ); 
     storageClassIndex = 0 ;
     SgClinkageDeclarationStatementStorageClass* storageArraySgClinkageDeclarationStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgClinkageDeclarationStatement = new SgClinkageDeclarationStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgClinkageDeclarationStatement) , sizeof ( SgClinkageDeclarationStatementStorageClass ) * sizeOfActualPool) ;
        SgClinkageDeclarationStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgClinkageDeclarationStatementStorageClass* storageArray = storageArraySgClinkageDeclarationStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgClinkageDeclarationStatement* tmp = new SgClinkageDeclarationStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgClinkageDeclarationStatement;  
      SgClinkageDeclarationStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgClinkageEndStatement ); 
     storageClassIndex = 0 ;
     SgClinkageEndStatementStorageClass* storageArraySgClinkageEndStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgClinkageEndStatement = new SgClinkageEndStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgClinkageEndStatement) , sizeof ( SgClinkageEndStatementStorageClass ) * sizeOfActualPool) ;
        SgClinkageEndStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgClinkageEndStatementStorageClass* storageArray = storageArraySgClinkageEndStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgClinkageEndStatement* tmp = new SgClinkageEndStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgClinkageEndStatement;  
      SgClinkageEndStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgClinkageStartStatement ); 
     storageClassIndex = 0 ;
     SgClinkageStartStatementStorageClass* storageArraySgClinkageStartStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgClinkageStartStatement = new SgClinkageStartStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgClinkageStartStatement) , sizeof ( SgClinkageStartStatementStorageClass ) * sizeOfActualPool) ;
        SgClinkageStartStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgClinkageStartStatementStorageClass* storageArray = storageArraySgClinkageStartStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgClinkageStartStatement* tmp = new SgClinkageStartStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgClinkageStartStatement;  
      SgClinkageStartStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgCloseStatement ); 
     storageClassIndex = 0 ;
     SgCloseStatementStorageClass* storageArraySgCloseStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgCloseStatement = new SgCloseStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgCloseStatement) , sizeof ( SgCloseStatementStorageClass ) * sizeOfActualPool) ;
        SgCloseStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgCloseStatementStorageClass* storageArray = storageArraySgCloseStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgCloseStatement* tmp = new SgCloseStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgCloseStatement;  
      SgCloseStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgColonShapeExp ); 
     storageClassIndex = 0 ;
     SgColonShapeExpStorageClass* storageArraySgColonShapeExp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgColonShapeExp = new SgColonShapeExpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgColonShapeExp) , sizeof ( SgColonShapeExpStorageClass ) * sizeOfActualPool) ;
        SgColonShapeExpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgColonShapeExpStorageClass* storageArray = storageArraySgColonShapeExp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgColonShapeExp* tmp = new SgColonShapeExp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgColonShapeExp;  
      SgColonShapeExpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgCommaOpExp ); 
     storageClassIndex = 0 ;
     SgCommaOpExpStorageClass* storageArraySgCommaOpExp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgCommaOpExp = new SgCommaOpExpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgCommaOpExp) , sizeof ( SgCommaOpExpStorageClass ) * sizeOfActualPool) ;
        SgCommaOpExpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgCommaOpExpStorageClass* storageArray = storageArraySgCommaOpExp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgCommaOpExp* tmp = new SgCommaOpExp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgCommaOpExp;  
      SgCommaOpExpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgCommonBlock ); 
     storageClassIndex = 0 ;
     SgCommonBlockStorageClass* storageArraySgCommonBlock = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgCommonBlock = new SgCommonBlockStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgCommonBlock) , sizeof ( SgCommonBlockStorageClass ) * sizeOfActualPool) ;
        SgCommonBlockStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgCommonBlockStorageClass* storageArray = storageArraySgCommonBlock;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgCommonBlock* tmp = new SgCommonBlock ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgCommonBlock;  
      SgCommonBlockStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgCommonBlockObject ); 
     storageClassIndex = 0 ;
     SgCommonBlockObjectStorageClass* storageArraySgCommonBlockObject = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgCommonBlockObject = new SgCommonBlockObjectStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgCommonBlockObject) , sizeof ( SgCommonBlockObjectStorageClass ) * sizeOfActualPool) ;
        SgCommonBlockObjectStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgCommonBlockObjectStorageClass* storageArray = storageArraySgCommonBlockObject;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgCommonBlockObject* tmp = new SgCommonBlockObject ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgCommonBlockObject;  
      SgCommonBlockObjectStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgCommonSymbol ); 
     storageClassIndex = 0 ;
     SgCommonSymbolStorageClass* storageArraySgCommonSymbol = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgCommonSymbol = new SgCommonSymbolStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgCommonSymbol) , sizeof ( SgCommonSymbolStorageClass ) * sizeOfActualPool) ;
        SgCommonSymbolStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgCommonSymbolStorageClass* storageArray = storageArraySgCommonSymbol;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgCommonSymbol* tmp = new SgCommonSymbol ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgCommonSymbol;  
      SgCommonSymbolStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgComplexVal ); 
     storageClassIndex = 0 ;
     SgComplexValStorageClass* storageArraySgComplexVal = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgComplexVal = new SgComplexValStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgComplexVal) , sizeof ( SgComplexValStorageClass ) * sizeOfActualPool) ;
        SgComplexValStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgComplexValStorageClass* storageArray = storageArraySgComplexVal;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgComplexVal* tmp = new SgComplexVal ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgComplexVal;  
      SgComplexValStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgComprehension ); 
     storageClassIndex = 0 ;
     SgComprehensionStorageClass* storageArraySgComprehension = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgComprehension = new SgComprehensionStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgComprehension) , sizeof ( SgComprehensionStorageClass ) * sizeOfActualPool) ;
        SgComprehensionStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgComprehensionStorageClass* storageArray = storageArraySgComprehension;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgComprehension* tmp = new SgComprehension ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgComprehension;  
      SgComprehensionStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgCompoundAssignOp ); 
     storageClassIndex = 0 ;
     SgCompoundAssignOpStorageClass* storageArraySgCompoundAssignOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgCompoundAssignOp = new SgCompoundAssignOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgCompoundAssignOp) , sizeof ( SgCompoundAssignOpStorageClass ) * sizeOfActualPool) ;
        SgCompoundAssignOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgCompoundAssignOpStorageClass* storageArray = storageArraySgCompoundAssignOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgCompoundAssignOp* tmp = new SgCompoundAssignOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgCompoundAssignOp;  
      SgCompoundAssignOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgCompoundInitializer ); 
     storageClassIndex = 0 ;
     SgCompoundInitializerStorageClass* storageArraySgCompoundInitializer = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgCompoundInitializer = new SgCompoundInitializerStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgCompoundInitializer) , sizeof ( SgCompoundInitializerStorageClass ) * sizeOfActualPool) ;
        SgCompoundInitializerStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgCompoundInitializerStorageClass* storageArray = storageArraySgCompoundInitializer;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgCompoundInitializer* tmp = new SgCompoundInitializer ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgCompoundInitializer;  
      SgCompoundInitializerStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgComputedGotoStatement ); 
     storageClassIndex = 0 ;
     SgComputedGotoStatementStorageClass* storageArraySgComputedGotoStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgComputedGotoStatement = new SgComputedGotoStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgComputedGotoStatement) , sizeof ( SgComputedGotoStatementStorageClass ) * sizeOfActualPool) ;
        SgComputedGotoStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgComputedGotoStatementStorageClass* storageArray = storageArraySgComputedGotoStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgComputedGotoStatement* tmp = new SgComputedGotoStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgComputedGotoStatement;  
      SgComputedGotoStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgConcatenationOp ); 
     storageClassIndex = 0 ;
     SgConcatenationOpStorageClass* storageArraySgConcatenationOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgConcatenationOp = new SgConcatenationOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgConcatenationOp) , sizeof ( SgConcatenationOpStorageClass ) * sizeOfActualPool) ;
        SgConcatenationOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgConcatenationOpStorageClass* storageArray = storageArraySgConcatenationOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgConcatenationOp* tmp = new SgConcatenationOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgConcatenationOp;  
      SgConcatenationOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgConditionalExp ); 
     storageClassIndex = 0 ;
     SgConditionalExpStorageClass* storageArraySgConditionalExp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgConditionalExp = new SgConditionalExpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgConditionalExp) , sizeof ( SgConditionalExpStorageClass ) * sizeOfActualPool) ;
        SgConditionalExpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgConditionalExpStorageClass* storageArray = storageArraySgConditionalExp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgConditionalExp* tmp = new SgConditionalExp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgConditionalExp;  
      SgConditionalExpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgConjugateOp ); 
     storageClassIndex = 0 ;
     SgConjugateOpStorageClass* storageArraySgConjugateOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgConjugateOp = new SgConjugateOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgConjugateOp) , sizeof ( SgConjugateOpStorageClass ) * sizeOfActualPool) ;
        SgConjugateOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgConjugateOpStorageClass* storageArray = storageArraySgConjugateOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgConjugateOp* tmp = new SgConjugateOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgConjugateOp;  
      SgConjugateOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgConstVolatileModifier ); 
     storageClassIndex = 0 ;
     SgConstVolatileModifierStorageClass* storageArraySgConstVolatileModifier = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgConstVolatileModifier = new SgConstVolatileModifierStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgConstVolatileModifier) , sizeof ( SgConstVolatileModifierStorageClass ) * sizeOfActualPool) ;
          SgConstVolatileModifierStorageClass* storageArray = storageArraySgConstVolatileModifier;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgConstVolatileModifier* tmp = new SgConstVolatileModifier ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgConstVolatileModifier;  


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgConstructorInitializer ); 
     storageClassIndex = 0 ;
     SgConstructorInitializerStorageClass* storageArraySgConstructorInitializer = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgConstructorInitializer = new SgConstructorInitializerStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgConstructorInitializer) , sizeof ( SgConstructorInitializerStorageClass ) * sizeOfActualPool) ;
        SgConstructorInitializerStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgConstructorInitializerStorageClass* storageArray = storageArraySgConstructorInitializer;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgConstructorInitializer* tmp = new SgConstructorInitializer ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgConstructorInitializer;  
      SgConstructorInitializerStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgContainsStatement ); 
     storageClassIndex = 0 ;
     SgContainsStatementStorageClass* storageArraySgContainsStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgContainsStatement = new SgContainsStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgContainsStatement) , sizeof ( SgContainsStatementStorageClass ) * sizeOfActualPool) ;
        SgContainsStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgContainsStatementStorageClass* storageArray = storageArraySgContainsStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgContainsStatement* tmp = new SgContainsStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgContainsStatement;  
      SgContainsStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgContinueStmt ); 
     storageClassIndex = 0 ;
     SgContinueStmtStorageClass* storageArraySgContinueStmt = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgContinueStmt = new SgContinueStmtStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgContinueStmt) , sizeof ( SgContinueStmtStorageClass ) * sizeOfActualPool) ;
        SgContinueStmtStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgContinueStmtStorageClass* storageArray = storageArraySgContinueStmt;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgContinueStmt* tmp = new SgContinueStmt ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgContinueStmt;  
      SgContinueStmtStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgCtorInitializerList ); 
     storageClassIndex = 0 ;
     SgCtorInitializerListStorageClass* storageArraySgCtorInitializerList = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgCtorInitializerList = new SgCtorInitializerListStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgCtorInitializerList) , sizeof ( SgCtorInitializerListStorageClass ) * sizeOfActualPool) ;
        SgCtorInitializerListStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgCtorInitializerListStorageClass* storageArray = storageArraySgCtorInitializerList;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgCtorInitializerList* tmp = new SgCtorInitializerList ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgCtorInitializerList;  
      SgCtorInitializerListStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgDataStatementGroup ); 
     storageClassIndex = 0 ;
     SgDataStatementGroupStorageClass* storageArraySgDataStatementGroup = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgDataStatementGroup = new SgDataStatementGroupStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgDataStatementGroup) , sizeof ( SgDataStatementGroupStorageClass ) * sizeOfActualPool) ;
        SgDataStatementGroupStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgDataStatementGroupStorageClass* storageArray = storageArraySgDataStatementGroup;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgDataStatementGroup* tmp = new SgDataStatementGroup ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgDataStatementGroup;  
      SgDataStatementGroupStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgDataStatementObject ); 
     storageClassIndex = 0 ;
     SgDataStatementObjectStorageClass* storageArraySgDataStatementObject = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgDataStatementObject = new SgDataStatementObjectStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgDataStatementObject) , sizeof ( SgDataStatementObjectStorageClass ) * sizeOfActualPool) ;
          SgDataStatementObjectStorageClass* storageArray = storageArraySgDataStatementObject;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgDataStatementObject* tmp = new SgDataStatementObject ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgDataStatementObject;  


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgDataStatementValue ); 
     storageClassIndex = 0 ;
     SgDataStatementValueStorageClass* storageArraySgDataStatementValue = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgDataStatementValue = new SgDataStatementValueStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgDataStatementValue) , sizeof ( SgDataStatementValueStorageClass ) * sizeOfActualPool) ;
          SgDataStatementValueStorageClass* storageArray = storageArraySgDataStatementValue;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgDataStatementValue* tmp = new SgDataStatementValue ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgDataStatementValue;  


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgDeadIfDirectiveStatement ); 
     storageClassIndex = 0 ;
     SgDeadIfDirectiveStatementStorageClass* storageArraySgDeadIfDirectiveStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgDeadIfDirectiveStatement = new SgDeadIfDirectiveStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgDeadIfDirectiveStatement) , sizeof ( SgDeadIfDirectiveStatementStorageClass ) * sizeOfActualPool) ;
        SgDeadIfDirectiveStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgDeadIfDirectiveStatementStorageClass* storageArray = storageArraySgDeadIfDirectiveStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgDeadIfDirectiveStatement* tmp = new SgDeadIfDirectiveStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgDeadIfDirectiveStatement;  
      SgDeadIfDirectiveStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgDeallocateStatement ); 
     storageClassIndex = 0 ;
     SgDeallocateStatementStorageClass* storageArraySgDeallocateStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgDeallocateStatement = new SgDeallocateStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgDeallocateStatement) , sizeof ( SgDeallocateStatementStorageClass ) * sizeOfActualPool) ;
        SgDeallocateStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgDeallocateStatementStorageClass* storageArray = storageArraySgDeallocateStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgDeallocateStatement* tmp = new SgDeallocateStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgDeallocateStatement;  
      SgDeallocateStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgDeclarationModifier ); 
     storageClassIndex = 0 ;
     SgDeclarationModifierStorageClass* storageArraySgDeclarationModifier = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgDeclarationModifier = new SgDeclarationModifierStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgDeclarationModifier) , sizeof ( SgDeclarationModifierStorageClass ) * sizeOfActualPool) ;
        SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgDeclarationModifierStorageClass* storageArray = storageArraySgDeclarationModifier;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgDeclarationModifier* tmp = new SgDeclarationModifier ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgDeclarationModifier;  
      SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgDeclarationStatement ); 
     storageClassIndex = 0 ;
     SgDeclarationStatementStorageClass* storageArraySgDeclarationStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgDeclarationStatement = new SgDeclarationStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgDeclarationStatement) , sizeof ( SgDeclarationStatementStorageClass ) * sizeOfActualPool) ;
        SgDeclarationStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgDeclarationStatementStorageClass* storageArray = storageArraySgDeclarationStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgDeclarationStatement* tmp = new SgDeclarationStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgDeclarationStatement;  
      SgDeclarationStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgDefaultOptionStmt ); 
     storageClassIndex = 0 ;
     SgDefaultOptionStmtStorageClass* storageArraySgDefaultOptionStmt = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgDefaultOptionStmt = new SgDefaultOptionStmtStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgDefaultOptionStmt) , sizeof ( SgDefaultOptionStmtStorageClass ) * sizeOfActualPool) ;
        SgDefaultOptionStmtStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgDefaultOptionStmtStorageClass* storageArray = storageArraySgDefaultOptionStmt;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgDefaultOptionStmt* tmp = new SgDefaultOptionStmt ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgDefaultOptionStmt;  
      SgDefaultOptionStmtStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgDefaultSymbol ); 
     storageClassIndex = 0 ;
     SgDefaultSymbolStorageClass* storageArraySgDefaultSymbol = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgDefaultSymbol = new SgDefaultSymbolStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgDefaultSymbol) , sizeof ( SgDefaultSymbolStorageClass ) * sizeOfActualPool) ;
        SgDefaultSymbolStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgDefaultSymbolStorageClass* storageArray = storageArraySgDefaultSymbol;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgDefaultSymbol* tmp = new SgDefaultSymbol ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgDefaultSymbol;  
      SgDefaultSymbolStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgDefineDirectiveStatement ); 
     storageClassIndex = 0 ;
     SgDefineDirectiveStatementStorageClass* storageArraySgDefineDirectiveStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgDefineDirectiveStatement = new SgDefineDirectiveStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgDefineDirectiveStatement) , sizeof ( SgDefineDirectiveStatementStorageClass ) * sizeOfActualPool) ;
        SgDefineDirectiveStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgDefineDirectiveStatementStorageClass* storageArray = storageArraySgDefineDirectiveStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgDefineDirectiveStatement* tmp = new SgDefineDirectiveStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgDefineDirectiveStatement;  
      SgDefineDirectiveStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgDeleteExp ); 
     storageClassIndex = 0 ;
     SgDeleteExpStorageClass* storageArraySgDeleteExp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgDeleteExp = new SgDeleteExpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgDeleteExp) , sizeof ( SgDeleteExpStorageClass ) * sizeOfActualPool) ;
        SgDeleteExpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgDeleteExpStorageClass* storageArray = storageArraySgDeleteExp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgDeleteExp* tmp = new SgDeleteExp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgDeleteExp;  
      SgDeleteExpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgDerivedTypeStatement ); 
     storageClassIndex = 0 ;
     SgDerivedTypeStatementStorageClass* storageArraySgDerivedTypeStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgDerivedTypeStatement = new SgDerivedTypeStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgDerivedTypeStatement) , sizeof ( SgDerivedTypeStatementStorageClass ) * sizeOfActualPool) ;
        SgDerivedTypeStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgDerivedTypeStatementStorageClass* storageArray = storageArraySgDerivedTypeStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgDerivedTypeStatement* tmp = new SgDerivedTypeStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgDerivedTypeStatement;  
      SgDerivedTypeStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgDesignatedInitializer ); 
     storageClassIndex = 0 ;
     SgDesignatedInitializerStorageClass* storageArraySgDesignatedInitializer = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgDesignatedInitializer = new SgDesignatedInitializerStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgDesignatedInitializer) , sizeof ( SgDesignatedInitializerStorageClass ) * sizeOfActualPool) ;
        SgDesignatedInitializerStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgDesignatedInitializerStorageClass* storageArray = storageArraySgDesignatedInitializer;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgDesignatedInitializer* tmp = new SgDesignatedInitializer ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgDesignatedInitializer;  
      SgDesignatedInitializerStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgDictionaryComprehension ); 
     storageClassIndex = 0 ;
     SgDictionaryComprehensionStorageClass* storageArraySgDictionaryComprehension = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgDictionaryComprehension = new SgDictionaryComprehensionStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgDictionaryComprehension) , sizeof ( SgDictionaryComprehensionStorageClass ) * sizeOfActualPool) ;
        SgDictionaryComprehensionStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgDictionaryComprehensionStorageClass* storageArray = storageArraySgDictionaryComprehension;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgDictionaryComprehension* tmp = new SgDictionaryComprehension ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgDictionaryComprehension;  
      SgDictionaryComprehensionStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgDictionaryExp ); 
     storageClassIndex = 0 ;
     SgDictionaryExpStorageClass* storageArraySgDictionaryExp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgDictionaryExp = new SgDictionaryExpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgDictionaryExp) , sizeof ( SgDictionaryExpStorageClass ) * sizeOfActualPool) ;
        SgDictionaryExpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgDictionaryExpStorageClass* storageArray = storageArraySgDictionaryExp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgDictionaryExp* tmp = new SgDictionaryExp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgDictionaryExp;  
      SgDictionaryExpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgDimensionObject ); 
     storageClassIndex = 0 ;
     SgDimensionObjectStorageClass* storageArraySgDimensionObject = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgDimensionObject = new SgDimensionObjectStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgDimensionObject) , sizeof ( SgDimensionObjectStorageClass ) * sizeOfActualPool) ;
          SgDimensionObjectStorageClass* storageArray = storageArraySgDimensionObject;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgDimensionObject* tmp = new SgDimensionObject ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgDimensionObject;  


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgDirectedGraphEdge ); 
     storageClassIndex = 0 ;
     SgDirectedGraphEdgeStorageClass* storageArraySgDirectedGraphEdge = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgDirectedGraphEdge = new SgDirectedGraphEdgeStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgDirectedGraphEdge) , sizeof ( SgDirectedGraphEdgeStorageClass ) * sizeOfActualPool) ;
        SgDirectedGraphEdgeStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgDirectedGraphEdgeStorageClass* storageArray = storageArraySgDirectedGraphEdge;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgDirectedGraphEdge* tmp = new SgDirectedGraphEdge ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgDirectedGraphEdge;  
      SgDirectedGraphEdgeStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgDirectory ); 
     storageClassIndex = 0 ;
     SgDirectoryStorageClass* storageArraySgDirectory = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgDirectory = new SgDirectoryStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgDirectory) , sizeof ( SgDirectoryStorageClass ) * sizeOfActualPool) ;
        SgDirectoryStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgDirectoryStorageClass* storageArray = storageArraySgDirectory;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgDirectory* tmp = new SgDirectory ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgDirectory;  
      SgDirectoryStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgDirectoryList ); 
     storageClassIndex = 0 ;
     SgDirectoryListStorageClass* storageArraySgDirectoryList = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgDirectoryList = new SgDirectoryListStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgDirectoryList) , sizeof ( SgDirectoryListStorageClass ) * sizeOfActualPool) ;
        SgDirectoryListStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgDirectoryListStorageClass* storageArray = storageArraySgDirectoryList;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgDirectoryList* tmp = new SgDirectoryList ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgDirectoryList;  
      SgDirectoryListStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgDivAssignOp ); 
     storageClassIndex = 0 ;
     SgDivAssignOpStorageClass* storageArraySgDivAssignOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgDivAssignOp = new SgDivAssignOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgDivAssignOp) , sizeof ( SgDivAssignOpStorageClass ) * sizeOfActualPool) ;
        SgDivAssignOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgDivAssignOpStorageClass* storageArray = storageArraySgDivAssignOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgDivAssignOp* tmp = new SgDivAssignOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgDivAssignOp;  
      SgDivAssignOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgDivideOp ); 
     storageClassIndex = 0 ;
     SgDivideOpStorageClass* storageArraySgDivideOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgDivideOp = new SgDivideOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgDivideOp) , sizeof ( SgDivideOpStorageClass ) * sizeOfActualPool) ;
        SgDivideOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgDivideOpStorageClass* storageArray = storageArraySgDivideOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgDivideOp* tmp = new SgDivideOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgDivideOp;  
      SgDivideOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgDoWhileStmt ); 
     storageClassIndex = 0 ;
     SgDoWhileStmtStorageClass* storageArraySgDoWhileStmt = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgDoWhileStmt = new SgDoWhileStmtStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgDoWhileStmt) , sizeof ( SgDoWhileStmtStorageClass ) * sizeOfActualPool) ;
        SgDoWhileStmtStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgDoWhileStmtStorageClass* storageArray = storageArraySgDoWhileStmt;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgDoWhileStmt* tmp = new SgDoWhileStmt ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgDoWhileStmt;  
      SgDoWhileStmtStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgDotExp ); 
     storageClassIndex = 0 ;
     SgDotExpStorageClass* storageArraySgDotExp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgDotExp = new SgDotExpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgDotExp) , sizeof ( SgDotExpStorageClass ) * sizeOfActualPool) ;
        SgDotExpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgDotExpStorageClass* storageArray = storageArraySgDotExp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgDotExp* tmp = new SgDotExp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgDotExp;  
      SgDotExpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgDotStarOp ); 
     storageClassIndex = 0 ;
     SgDotStarOpStorageClass* storageArraySgDotStarOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgDotStarOp = new SgDotStarOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgDotStarOp) , sizeof ( SgDotStarOpStorageClass ) * sizeOfActualPool) ;
        SgDotStarOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgDotStarOpStorageClass* storageArray = storageArraySgDotStarOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgDotStarOp* tmp = new SgDotStarOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgDotStarOp;  
      SgDotStarOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgDoubleVal ); 
     storageClassIndex = 0 ;
     SgDoubleValStorageClass* storageArraySgDoubleVal = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgDoubleVal = new SgDoubleValStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgDoubleVal) , sizeof ( SgDoubleValStorageClass ) * sizeOfActualPool) ;
        SgDoubleValStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgDoubleValStorageClass* storageArray = storageArraySgDoubleVal;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgDoubleVal* tmp = new SgDoubleVal ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgDoubleVal;  
      SgDoubleValStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgElaboratedTypeModifier ); 
     storageClassIndex = 0 ;
     SgElaboratedTypeModifierStorageClass* storageArraySgElaboratedTypeModifier = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgElaboratedTypeModifier = new SgElaboratedTypeModifierStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgElaboratedTypeModifier) , sizeof ( SgElaboratedTypeModifierStorageClass ) * sizeOfActualPool) ;
          SgElaboratedTypeModifierStorageClass* storageArray = storageArraySgElaboratedTypeModifier;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgElaboratedTypeModifier* tmp = new SgElaboratedTypeModifier ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgElaboratedTypeModifier;  


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgElseDirectiveStatement ); 
     storageClassIndex = 0 ;
     SgElseDirectiveStatementStorageClass* storageArraySgElseDirectiveStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgElseDirectiveStatement = new SgElseDirectiveStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgElseDirectiveStatement) , sizeof ( SgElseDirectiveStatementStorageClass ) * sizeOfActualPool) ;
        SgElseDirectiveStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgElseDirectiveStatementStorageClass* storageArray = storageArraySgElseDirectiveStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgElseDirectiveStatement* tmp = new SgElseDirectiveStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgElseDirectiveStatement;  
      SgElseDirectiveStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgElseWhereStatement ); 
     storageClassIndex = 0 ;
     SgElseWhereStatementStorageClass* storageArraySgElseWhereStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgElseWhereStatement = new SgElseWhereStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgElseWhereStatement) , sizeof ( SgElseWhereStatementStorageClass ) * sizeOfActualPool) ;
        SgElseWhereStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgElseWhereStatementStorageClass* storageArray = storageArraySgElseWhereStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgElseWhereStatement* tmp = new SgElseWhereStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgElseWhereStatement;  
      SgElseWhereStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgElseifDirectiveStatement ); 
     storageClassIndex = 0 ;
     SgElseifDirectiveStatementStorageClass* storageArraySgElseifDirectiveStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgElseifDirectiveStatement = new SgElseifDirectiveStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgElseifDirectiveStatement) , sizeof ( SgElseifDirectiveStatementStorageClass ) * sizeOfActualPool) ;
        SgElseifDirectiveStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgElseifDirectiveStatementStorageClass* storageArray = storageArraySgElseifDirectiveStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgElseifDirectiveStatement* tmp = new SgElseifDirectiveStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgElseifDirectiveStatement;  
      SgElseifDirectiveStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgEmptyDirectiveStatement ); 
     storageClassIndex = 0 ;
     SgEmptyDirectiveStatementStorageClass* storageArraySgEmptyDirectiveStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgEmptyDirectiveStatement = new SgEmptyDirectiveStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgEmptyDirectiveStatement) , sizeof ( SgEmptyDirectiveStatementStorageClass ) * sizeOfActualPool) ;
        SgEmptyDirectiveStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgEmptyDirectiveStatementStorageClass* storageArray = storageArraySgEmptyDirectiveStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgEmptyDirectiveStatement* tmp = new SgEmptyDirectiveStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgEmptyDirectiveStatement;  
      SgEmptyDirectiveStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgEndfileStatement ); 
     storageClassIndex = 0 ;
     SgEndfileStatementStorageClass* storageArraySgEndfileStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgEndfileStatement = new SgEndfileStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgEndfileStatement) , sizeof ( SgEndfileStatementStorageClass ) * sizeOfActualPool) ;
        SgEndfileStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgEndfileStatementStorageClass* storageArray = storageArraySgEndfileStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgEndfileStatement* tmp = new SgEndfileStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgEndfileStatement;  
      SgEndfileStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgEndifDirectiveStatement ); 
     storageClassIndex = 0 ;
     SgEndifDirectiveStatementStorageClass* storageArraySgEndifDirectiveStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgEndifDirectiveStatement = new SgEndifDirectiveStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgEndifDirectiveStatement) , sizeof ( SgEndifDirectiveStatementStorageClass ) * sizeOfActualPool) ;
        SgEndifDirectiveStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgEndifDirectiveStatementStorageClass* storageArray = storageArraySgEndifDirectiveStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgEndifDirectiveStatement* tmp = new SgEndifDirectiveStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgEndifDirectiveStatement;  
      SgEndifDirectiveStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgEntryStatement ); 
     storageClassIndex = 0 ;
     SgEntryStatementStorageClass* storageArraySgEntryStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgEntryStatement = new SgEntryStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgEntryStatement) , sizeof ( SgEntryStatementStorageClass ) * sizeOfActualPool) ;
        SgEntryStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgEntryStatementStorageClass* storageArray = storageArraySgEntryStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgEntryStatement* tmp = new SgEntryStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgEntryStatement;  
      SgEntryStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgEnumDeclaration ); 
     storageClassIndex = 0 ;
     SgEnumDeclarationStorageClass* storageArraySgEnumDeclaration = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgEnumDeclaration = new SgEnumDeclarationStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgEnumDeclaration) , sizeof ( SgEnumDeclarationStorageClass ) * sizeOfActualPool) ;
        SgEnumDeclarationStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgEnumDeclarationStorageClass* storageArray = storageArraySgEnumDeclaration;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgEnumDeclaration* tmp = new SgEnumDeclaration ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgEnumDeclaration;  
      SgEnumDeclarationStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgEnumFieldSymbol ); 
     storageClassIndex = 0 ;
     SgEnumFieldSymbolStorageClass* storageArraySgEnumFieldSymbol = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgEnumFieldSymbol = new SgEnumFieldSymbolStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgEnumFieldSymbol) , sizeof ( SgEnumFieldSymbolStorageClass ) * sizeOfActualPool) ;
        SgEnumFieldSymbolStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgEnumFieldSymbolStorageClass* storageArray = storageArraySgEnumFieldSymbol;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgEnumFieldSymbol* tmp = new SgEnumFieldSymbol ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgEnumFieldSymbol;  
      SgEnumFieldSymbolStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgEnumSymbol ); 
     storageClassIndex = 0 ;
     SgEnumSymbolStorageClass* storageArraySgEnumSymbol = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgEnumSymbol = new SgEnumSymbolStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgEnumSymbol) , sizeof ( SgEnumSymbolStorageClass ) * sizeOfActualPool) ;
        SgEnumSymbolStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgEnumSymbolStorageClass* storageArray = storageArraySgEnumSymbol;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgEnumSymbol* tmp = new SgEnumSymbol ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgEnumSymbol;  
      SgEnumSymbolStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgEnumType ); 
     storageClassIndex = 0 ;
     SgEnumTypeStorageClass* storageArraySgEnumType = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgEnumType = new SgEnumTypeStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgEnumType) , sizeof ( SgEnumTypeStorageClass ) * sizeOfActualPool) ;
        SgEnumTypeStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgEnumTypeStorageClass* storageArray = storageArraySgEnumType;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgEnumType* tmp = new SgEnumType ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgEnumType;  
      SgEnumTypeStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgEnumVal ); 
     storageClassIndex = 0 ;
     SgEnumValStorageClass* storageArraySgEnumVal = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgEnumVal = new SgEnumValStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgEnumVal) , sizeof ( SgEnumValStorageClass ) * sizeOfActualPool) ;
        SgEnumValStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgEnumValStorageClass* storageArray = storageArraySgEnumVal;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgEnumVal* tmp = new SgEnumVal ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgEnumVal;  
      SgEnumValStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgEqualityOp ); 
     storageClassIndex = 0 ;
     SgEqualityOpStorageClass* storageArraySgEqualityOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgEqualityOp = new SgEqualityOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgEqualityOp) , sizeof ( SgEqualityOpStorageClass ) * sizeOfActualPool) ;
        SgEqualityOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgEqualityOpStorageClass* storageArray = storageArraySgEqualityOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgEqualityOp* tmp = new SgEqualityOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgEqualityOp;  
      SgEqualityOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgEquivalenceStatement ); 
     storageClassIndex = 0 ;
     SgEquivalenceStatementStorageClass* storageArraySgEquivalenceStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgEquivalenceStatement = new SgEquivalenceStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgEquivalenceStatement) , sizeof ( SgEquivalenceStatementStorageClass ) * sizeOfActualPool) ;
        SgEquivalenceStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgEquivalenceStatementStorageClass* storageArray = storageArraySgEquivalenceStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgEquivalenceStatement* tmp = new SgEquivalenceStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgEquivalenceStatement;  
      SgEquivalenceStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgErrorDirectiveStatement ); 
     storageClassIndex = 0 ;
     SgErrorDirectiveStatementStorageClass* storageArraySgErrorDirectiveStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgErrorDirectiveStatement = new SgErrorDirectiveStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgErrorDirectiveStatement) , sizeof ( SgErrorDirectiveStatementStorageClass ) * sizeOfActualPool) ;
        SgErrorDirectiveStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgErrorDirectiveStatementStorageClass* storageArray = storageArraySgErrorDirectiveStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgErrorDirectiveStatement* tmp = new SgErrorDirectiveStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgErrorDirectiveStatement;  
      SgErrorDirectiveStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgExecStatement ); 
     storageClassIndex = 0 ;
     SgExecStatementStorageClass* storageArraySgExecStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgExecStatement = new SgExecStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgExecStatement) , sizeof ( SgExecStatementStorageClass ) * sizeOfActualPool) ;
        SgExecStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgExecStatementStorageClass* storageArray = storageArraySgExecStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgExecStatement* tmp = new SgExecStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgExecStatement;  
      SgExecStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgExponentiationOp ); 
     storageClassIndex = 0 ;
     SgExponentiationOpStorageClass* storageArraySgExponentiationOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgExponentiationOp = new SgExponentiationOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgExponentiationOp) , sizeof ( SgExponentiationOpStorageClass ) * sizeOfActualPool) ;
        SgExponentiationOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgExponentiationOpStorageClass* storageArray = storageArraySgExponentiationOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgExponentiationOp* tmp = new SgExponentiationOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgExponentiationOp;  
      SgExponentiationOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgExponentiationAssignOp ); 
     storageClassIndex = 0 ;
     SgExponentiationAssignOpStorageClass* storageArraySgExponentiationAssignOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgExponentiationAssignOp = new SgExponentiationAssignOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgExponentiationAssignOp) , sizeof ( SgExponentiationAssignOpStorageClass ) * sizeOfActualPool) ;
        SgExponentiationAssignOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgExponentiationAssignOpStorageClass* storageArray = storageArraySgExponentiationAssignOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgExponentiationAssignOp* tmp = new SgExponentiationAssignOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgExponentiationAssignOp;  
      SgExponentiationAssignOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgExprListExp ); 
     storageClassIndex = 0 ;
     SgExprListExpStorageClass* storageArraySgExprListExp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgExprListExp = new SgExprListExpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgExprListExp) , sizeof ( SgExprListExpStorageClass ) * sizeOfActualPool) ;
        SgExprListExpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgExprListExpStorageClass* storageArray = storageArraySgExprListExp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgExprListExp* tmp = new SgExprListExp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgExprListExp;  
      SgExprListExpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgExprStatement ); 
     storageClassIndex = 0 ;
     SgExprStatementStorageClass* storageArraySgExprStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgExprStatement = new SgExprStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgExprStatement) , sizeof ( SgExprStatementStorageClass ) * sizeOfActualPool) ;
        SgExprStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgExprStatementStorageClass* storageArray = storageArraySgExprStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgExprStatement* tmp = new SgExprStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgExprStatement;  
      SgExprStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgExpression ); 
     storageClassIndex = 0 ;
     SgExpressionStorageClass* storageArraySgExpression = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgExpression = new SgExpressionStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgExpression) , sizeof ( SgExpressionStorageClass ) * sizeOfActualPool) ;
        SgExpressionStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgExpressionStorageClass* storageArray = storageArraySgExpression;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgExpression* tmp = new SgExpression ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgExpression;  
      SgExpressionStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgExpressionRoot ); 
     storageClassIndex = 0 ;
     SgExpressionRootStorageClass* storageArraySgExpressionRoot = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgExpressionRoot = new SgExpressionRootStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgExpressionRoot) , sizeof ( SgExpressionRootStorageClass ) * sizeOfActualPool) ;
        SgExpressionRootStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgExpressionRootStorageClass* storageArray = storageArraySgExpressionRoot;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgExpressionRoot* tmp = new SgExpressionRoot ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgExpressionRoot;  
      SgExpressionRootStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgFile ); 
     storageClassIndex = 0 ;
     SgFileStorageClass* storageArraySgFile = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgFile = new SgFileStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgFile) , sizeof ( SgFileStorageClass ) * sizeOfActualPool) ;
        SgFileStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgFileStorageClass* storageArray = storageArraySgFile;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgFile* tmp = new SgFile ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgFile;  
      SgFileStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgFileList ); 
     storageClassIndex = 0 ;
     SgFileListStorageClass* storageArraySgFileList = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgFileList = new SgFileListStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgFileList) , sizeof ( SgFileListStorageClass ) * sizeOfActualPool) ;
        SgFileListStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgFileListStorageClass* storageArray = storageArraySgFileList;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgFileList* tmp = new SgFileList ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgFileList;  
      SgFileListStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgFloatVal ); 
     storageClassIndex = 0 ;
     SgFloatValStorageClass* storageArraySgFloatVal = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgFloatVal = new SgFloatValStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgFloatVal) , sizeof ( SgFloatValStorageClass ) * sizeOfActualPool) ;
        SgFloatValStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgFloatValStorageClass* storageArray = storageArraySgFloatVal;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgFloatVal* tmp = new SgFloatVal ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgFloatVal;  
      SgFloatValStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgFlushStatement ); 
     storageClassIndex = 0 ;
     SgFlushStatementStorageClass* storageArraySgFlushStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgFlushStatement = new SgFlushStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgFlushStatement) , sizeof ( SgFlushStatementStorageClass ) * sizeOfActualPool) ;
        SgFlushStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgFlushStatementStorageClass* storageArray = storageArraySgFlushStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgFlushStatement* tmp = new SgFlushStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgFlushStatement;  
      SgFlushStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgForAllStatement ); 
     storageClassIndex = 0 ;
     SgForAllStatementStorageClass* storageArraySgForAllStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgForAllStatement = new SgForAllStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgForAllStatement) , sizeof ( SgForAllStatementStorageClass ) * sizeOfActualPool) ;
        SgForAllStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgForAllStatementStorageClass* storageArray = storageArraySgForAllStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgForAllStatement* tmp = new SgForAllStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgForAllStatement;  
      SgForAllStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgForInitStatement ); 
     storageClassIndex = 0 ;
     SgForInitStatementStorageClass* storageArraySgForInitStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgForInitStatement = new SgForInitStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgForInitStatement) , sizeof ( SgForInitStatementStorageClass ) * sizeOfActualPool) ;
        SgForInitStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgForInitStatementStorageClass* storageArray = storageArraySgForInitStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgForInitStatement* tmp = new SgForInitStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgForInitStatement;  
      SgForInitStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgForStatement ); 
     storageClassIndex = 0 ;
     SgForStatementStorageClass* storageArraySgForStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgForStatement = new SgForStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgForStatement) , sizeof ( SgForStatementStorageClass ) * sizeOfActualPool) ;
        SgForStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgForStatementStorageClass* storageArray = storageArraySgForStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgForStatement* tmp = new SgForStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgForStatement;  
      SgForStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgFormatItem ); 
     storageClassIndex = 0 ;
     SgFormatItemStorageClass* storageArraySgFormatItem = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgFormatItem = new SgFormatItemStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgFormatItem) , sizeof ( SgFormatItemStorageClass ) * sizeOfActualPool) ;
          SgFormatItemStorageClass* storageArray = storageArraySgFormatItem;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgFormatItem* tmp = new SgFormatItem ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgFormatItem;  


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgFormatItemList ); 
     storageClassIndex = 0 ;
     SgFormatItemListStorageClass* storageArraySgFormatItemList = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgFormatItemList = new SgFormatItemListStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgFormatItemList) , sizeof ( SgFormatItemListStorageClass ) * sizeOfActualPool) ;
        SgFormatItemListStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgFormatItemListStorageClass* storageArray = storageArraySgFormatItemList;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgFormatItemList* tmp = new SgFormatItemList ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgFormatItemList;  
      SgFormatItemListStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgFormatStatement ); 
     storageClassIndex = 0 ;
     SgFormatStatementStorageClass* storageArraySgFormatStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgFormatStatement = new SgFormatStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgFormatStatement) , sizeof ( SgFormatStatementStorageClass ) * sizeOfActualPool) ;
        SgFormatStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgFormatStatementStorageClass* storageArray = storageArraySgFormatStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgFormatStatement* tmp = new SgFormatStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgFormatStatement;  
      SgFormatStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgFortranDo ); 
     storageClassIndex = 0 ;
     SgFortranDoStorageClass* storageArraySgFortranDo = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgFortranDo = new SgFortranDoStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgFortranDo) , sizeof ( SgFortranDoStorageClass ) * sizeOfActualPool) ;
        SgFortranDoStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgFortranDoStorageClass* storageArray = storageArraySgFortranDo;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgFortranDo* tmp = new SgFortranDo ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgFortranDo;  
      SgFortranDoStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgFortranIncludeLine ); 
     storageClassIndex = 0 ;
     SgFortranIncludeLineStorageClass* storageArraySgFortranIncludeLine = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgFortranIncludeLine = new SgFortranIncludeLineStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgFortranIncludeLine) , sizeof ( SgFortranIncludeLineStorageClass ) * sizeOfActualPool) ;
        SgFortranIncludeLineStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgFortranIncludeLineStorageClass* storageArray = storageArraySgFortranIncludeLine;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgFortranIncludeLine* tmp = new SgFortranIncludeLine ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgFortranIncludeLine;  
      SgFortranIncludeLineStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgFortranNonblockedDo ); 
     storageClassIndex = 0 ;
     SgFortranNonblockedDoStorageClass* storageArraySgFortranNonblockedDo = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgFortranNonblockedDo = new SgFortranNonblockedDoStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgFortranNonblockedDo) , sizeof ( SgFortranNonblockedDoStorageClass ) * sizeOfActualPool) ;
        SgFortranNonblockedDoStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgFortranNonblockedDoStorageClass* storageArray = storageArraySgFortranNonblockedDo;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgFortranNonblockedDo* tmp = new SgFortranNonblockedDo ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgFortranNonblockedDo;  
      SgFortranNonblockedDoStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgFuncDecl_attr ); 
     storageClassIndex = 0 ;
     SgFuncDecl_attrStorageClass* storageArraySgFuncDecl_attr = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgFuncDecl_attr = new SgFuncDecl_attrStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgFuncDecl_attr) , sizeof ( SgFuncDecl_attrStorageClass ) * sizeOfActualPool) ;
        SgFuncDecl_attrStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgFuncDecl_attrStorageClass* storageArray = storageArraySgFuncDecl_attr;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgFuncDecl_attr* tmp = new SgFuncDecl_attr ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgFuncDecl_attr;  
      SgFuncDecl_attrStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgFunctionCallExp ); 
     storageClassIndex = 0 ;
     SgFunctionCallExpStorageClass* storageArraySgFunctionCallExp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgFunctionCallExp = new SgFunctionCallExpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgFunctionCallExp) , sizeof ( SgFunctionCallExpStorageClass ) * sizeOfActualPool) ;
        SgFunctionCallExpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgFunctionCallExpStorageClass* storageArray = storageArraySgFunctionCallExp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgFunctionCallExp* tmp = new SgFunctionCallExp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgFunctionCallExp;  
      SgFunctionCallExpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgFunctionDeclaration ); 
     storageClassIndex = 0 ;
     SgFunctionDeclarationStorageClass* storageArraySgFunctionDeclaration = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgFunctionDeclaration = new SgFunctionDeclarationStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgFunctionDeclaration) , sizeof ( SgFunctionDeclarationStorageClass ) * sizeOfActualPool) ;
        SgFunctionDeclarationStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgFunctionDeclarationStorageClass* storageArray = storageArraySgFunctionDeclaration;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgFunctionDeclaration* tmp = new SgFunctionDeclaration ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgFunctionDeclaration;  
      SgFunctionDeclarationStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgFunctionDefinition ); 
     storageClassIndex = 0 ;
     SgFunctionDefinitionStorageClass* storageArraySgFunctionDefinition = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgFunctionDefinition = new SgFunctionDefinitionStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgFunctionDefinition) , sizeof ( SgFunctionDefinitionStorageClass ) * sizeOfActualPool) ;
        SgFunctionDefinitionStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgFunctionDefinitionStorageClass* storageArray = storageArraySgFunctionDefinition;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgFunctionDefinition* tmp = new SgFunctionDefinition ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgFunctionDefinition;  
      SgFunctionDefinitionStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgFunctionModifier ); 
     storageClassIndex = 0 ;
     SgFunctionModifierStorageClass* storageArraySgFunctionModifier = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgFunctionModifier = new SgFunctionModifierStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgFunctionModifier) , sizeof ( SgFunctionModifierStorageClass ) * sizeOfActualPool) ;
        SgFunctionModifierStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgFunctionModifierStorageClass* storageArray = storageArraySgFunctionModifier;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgFunctionModifier* tmp = new SgFunctionModifier ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgFunctionModifier;  
      SgFunctionModifierStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgFunctionParameterList ); 
     storageClassIndex = 0 ;
     SgFunctionParameterListStorageClass* storageArraySgFunctionParameterList = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgFunctionParameterList = new SgFunctionParameterListStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgFunctionParameterList) , sizeof ( SgFunctionParameterListStorageClass ) * sizeOfActualPool) ;
        SgFunctionParameterListStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgFunctionParameterListStorageClass* storageArray = storageArraySgFunctionParameterList;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgFunctionParameterList* tmp = new SgFunctionParameterList ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgFunctionParameterList;  
      SgFunctionParameterListStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgFunctionParameterTypeList ); 
     storageClassIndex = 0 ;
     SgFunctionParameterTypeListStorageClass* storageArraySgFunctionParameterTypeList = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgFunctionParameterTypeList = new SgFunctionParameterTypeListStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgFunctionParameterTypeList) , sizeof ( SgFunctionParameterTypeListStorageClass ) * sizeOfActualPool) ;
        SgFunctionParameterTypeListStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgFunctionParameterTypeListStorageClass* storageArray = storageArraySgFunctionParameterTypeList;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgFunctionParameterTypeList* tmp = new SgFunctionParameterTypeList ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgFunctionParameterTypeList;  
      SgFunctionParameterTypeListStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgFunctionRefExp ); 
     storageClassIndex = 0 ;
     SgFunctionRefExpStorageClass* storageArraySgFunctionRefExp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgFunctionRefExp = new SgFunctionRefExpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgFunctionRefExp) , sizeof ( SgFunctionRefExpStorageClass ) * sizeOfActualPool) ;
        SgFunctionRefExpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgFunctionRefExpStorageClass* storageArray = storageArraySgFunctionRefExp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgFunctionRefExp* tmp = new SgFunctionRefExp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgFunctionRefExp;  
      SgFunctionRefExpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgFunctionSymbol ); 
     storageClassIndex = 0 ;
     SgFunctionSymbolStorageClass* storageArraySgFunctionSymbol = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgFunctionSymbol = new SgFunctionSymbolStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgFunctionSymbol) , sizeof ( SgFunctionSymbolStorageClass ) * sizeOfActualPool) ;
        SgFunctionSymbolStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgFunctionSymbolStorageClass* storageArray = storageArraySgFunctionSymbol;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgFunctionSymbol* tmp = new SgFunctionSymbol ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgFunctionSymbol;  
      SgFunctionSymbolStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgFunctionType ); 
     storageClassIndex = 0 ;
     SgFunctionTypeStorageClass* storageArraySgFunctionType = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgFunctionType = new SgFunctionTypeStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgFunctionType) , sizeof ( SgFunctionTypeStorageClass ) * sizeOfActualPool) ;
        SgFunctionTypeStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgFunctionTypeStorageClass* storageArray = storageArraySgFunctionType;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgFunctionType* tmp = new SgFunctionType ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgFunctionType;  
      SgFunctionTypeStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgFunctionTypeSymbol ); 
     storageClassIndex = 0 ;
     SgFunctionTypeSymbolStorageClass* storageArraySgFunctionTypeSymbol = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgFunctionTypeSymbol = new SgFunctionTypeSymbolStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgFunctionTypeSymbol) , sizeof ( SgFunctionTypeSymbolStorageClass ) * sizeOfActualPool) ;
        SgFunctionTypeSymbolStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgFunctionTypeSymbolStorageClass* storageArray = storageArraySgFunctionTypeSymbol;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgFunctionTypeSymbol* tmp = new SgFunctionTypeSymbol ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgFunctionTypeSymbol;  
      SgFunctionTypeSymbolStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgFunctionTypeTable ); 
     storageClassIndex = 0 ;
     SgFunctionTypeTableStorageClass* storageArraySgFunctionTypeTable = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgFunctionTypeTable = new SgFunctionTypeTableStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgFunctionTypeTable) , sizeof ( SgFunctionTypeTableStorageClass ) * sizeOfActualPool) ;
        SgFunctionTypeTableStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgFunctionTypeTableStorageClass* storageArray = storageArraySgFunctionTypeTable;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgFunctionTypeTable* tmp = new SgFunctionTypeTable ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgFunctionTypeTable;  
      SgFunctionTypeTableStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgTypeTable ); 
     storageClassIndex = 0 ;
     SgTypeTableStorageClass* storageArraySgTypeTable = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgTypeTable = new SgTypeTableStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgTypeTable) , sizeof ( SgTypeTableStorageClass ) * sizeOfActualPool) ;
          SgTypeTableStorageClass* storageArray = storageArraySgTypeTable;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgTypeTable* tmp = new SgTypeTable ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgTypeTable;  


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgGlobal ); 
     storageClassIndex = 0 ;
     SgGlobalStorageClass* storageArraySgGlobal = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgGlobal = new SgGlobalStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgGlobal) , sizeof ( SgGlobalStorageClass ) * sizeOfActualPool) ;
        SgGlobalStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgGlobalStorageClass* storageArray = storageArraySgGlobal;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgGlobal* tmp = new SgGlobal ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgGlobal;  
      SgGlobalStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgGotoStatement ); 
     storageClassIndex = 0 ;
     SgGotoStatementStorageClass* storageArraySgGotoStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgGotoStatement = new SgGotoStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgGotoStatement) , sizeof ( SgGotoStatementStorageClass ) * sizeOfActualPool) ;
        SgGotoStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgGotoStatementStorageClass* storageArray = storageArraySgGotoStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgGotoStatement* tmp = new SgGotoStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgGotoStatement;  
      SgGotoStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgGraph ); 
     storageClassIndex = 0 ;
     SgGraphStorageClass* storageArraySgGraph = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgGraph = new SgGraphStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgGraph) , sizeof ( SgGraphStorageClass ) * sizeOfActualPool) ;
        SgGraphStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgGraphStorageClass* storageArray = storageArraySgGraph;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgGraph* tmp = new SgGraph ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgGraph;  
      SgGraphStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgGraphEdge ); 
     storageClassIndex = 0 ;
     SgGraphEdgeStorageClass* storageArraySgGraphEdge = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgGraphEdge = new SgGraphEdgeStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgGraphEdge) , sizeof ( SgGraphEdgeStorageClass ) * sizeOfActualPool) ;
        SgGraphEdgeStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgGraphEdgeStorageClass* storageArray = storageArraySgGraphEdge;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgGraphEdge* tmp = new SgGraphEdge ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgGraphEdge;  
      SgGraphEdgeStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgGraphEdgeList ); 
     storageClassIndex = 0 ;
     SgGraphEdgeListStorageClass* storageArraySgGraphEdgeList = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgGraphEdgeList = new SgGraphEdgeListStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgGraphEdgeList) , sizeof ( SgGraphEdgeListStorageClass ) * sizeOfActualPool) ;
          SgGraphEdgeListStorageClass* storageArray = storageArraySgGraphEdgeList;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgGraphEdgeList* tmp = new SgGraphEdgeList ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgGraphEdgeList;  


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgGraphNode ); 
     storageClassIndex = 0 ;
     SgGraphNodeStorageClass* storageArraySgGraphNode = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgGraphNode = new SgGraphNodeStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgGraphNode) , sizeof ( SgGraphNodeStorageClass ) * sizeOfActualPool) ;
        SgGraphNodeStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgGraphNodeStorageClass* storageArray = storageArraySgGraphNode;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgGraphNode* tmp = new SgGraphNode ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgGraphNode;  
      SgGraphNodeStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgGraphNodeList ); 
     storageClassIndex = 0 ;
     SgGraphNodeListStorageClass* storageArraySgGraphNodeList = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgGraphNodeList = new SgGraphNodeListStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgGraphNodeList) , sizeof ( SgGraphNodeListStorageClass ) * sizeOfActualPool) ;
          SgGraphNodeListStorageClass* storageArray = storageArraySgGraphNodeList;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgGraphNodeList* tmp = new SgGraphNodeList ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgGraphNodeList;  


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgGreaterOrEqualOp ); 
     storageClassIndex = 0 ;
     SgGreaterOrEqualOpStorageClass* storageArraySgGreaterOrEqualOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgGreaterOrEqualOp = new SgGreaterOrEqualOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgGreaterOrEqualOp) , sizeof ( SgGreaterOrEqualOpStorageClass ) * sizeOfActualPool) ;
        SgGreaterOrEqualOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgGreaterOrEqualOpStorageClass* storageArray = storageArraySgGreaterOrEqualOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgGreaterOrEqualOp* tmp = new SgGreaterOrEqualOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgGreaterOrEqualOp;  
      SgGreaterOrEqualOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgGreaterThanOp ); 
     storageClassIndex = 0 ;
     SgGreaterThanOpStorageClass* storageArraySgGreaterThanOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgGreaterThanOp = new SgGreaterThanOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgGreaterThanOp) , sizeof ( SgGreaterThanOpStorageClass ) * sizeOfActualPool) ;
        SgGreaterThanOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgGreaterThanOpStorageClass* storageArray = storageArraySgGreaterThanOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgGreaterThanOp* tmp = new SgGreaterThanOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgGreaterThanOp;  
      SgGreaterThanOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgIOItemExpression ); 
     storageClassIndex = 0 ;
     SgIOItemExpressionStorageClass* storageArraySgIOItemExpression = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgIOItemExpression = new SgIOItemExpressionStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgIOItemExpression) , sizeof ( SgIOItemExpressionStorageClass ) * sizeOfActualPool) ;
        SgIOItemExpressionStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgIOItemExpressionStorageClass* storageArray = storageArraySgIOItemExpression;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgIOItemExpression* tmp = new SgIOItemExpression ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgIOItemExpression;  
      SgIOItemExpressionStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgIOStatement ); 
     storageClassIndex = 0 ;
     SgIOStatementStorageClass* storageArraySgIOStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgIOStatement = new SgIOStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgIOStatement) , sizeof ( SgIOStatementStorageClass ) * sizeOfActualPool) ;
        SgIOStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgIOStatementStorageClass* storageArray = storageArraySgIOStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgIOStatement* tmp = new SgIOStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgIOStatement;  
      SgIOStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgIdentDirectiveStatement ); 
     storageClassIndex = 0 ;
     SgIdentDirectiveStatementStorageClass* storageArraySgIdentDirectiveStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgIdentDirectiveStatement = new SgIdentDirectiveStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgIdentDirectiveStatement) , sizeof ( SgIdentDirectiveStatementStorageClass ) * sizeOfActualPool) ;
        SgIdentDirectiveStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgIdentDirectiveStatementStorageClass* storageArray = storageArraySgIdentDirectiveStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgIdentDirectiveStatement* tmp = new SgIdentDirectiveStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgIdentDirectiveStatement;  
      SgIdentDirectiveStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgIfDirectiveStatement ); 
     storageClassIndex = 0 ;
     SgIfDirectiveStatementStorageClass* storageArraySgIfDirectiveStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgIfDirectiveStatement = new SgIfDirectiveStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgIfDirectiveStatement) , sizeof ( SgIfDirectiveStatementStorageClass ) * sizeOfActualPool) ;
        SgIfDirectiveStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgIfDirectiveStatementStorageClass* storageArray = storageArraySgIfDirectiveStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgIfDirectiveStatement* tmp = new SgIfDirectiveStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgIfDirectiveStatement;  
      SgIfDirectiveStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgIfStmt ); 
     storageClassIndex = 0 ;
     SgIfStmtStorageClass* storageArraySgIfStmt = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgIfStmt = new SgIfStmtStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgIfStmt) , sizeof ( SgIfStmtStorageClass ) * sizeOfActualPool) ;
        SgIfStmtStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgIfStmtStorageClass* storageArray = storageArraySgIfStmt;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgIfStmt* tmp = new SgIfStmt ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgIfStmt;  
      SgIfStmtStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgIfdefDirectiveStatement ); 
     storageClassIndex = 0 ;
     SgIfdefDirectiveStatementStorageClass* storageArraySgIfdefDirectiveStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgIfdefDirectiveStatement = new SgIfdefDirectiveStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgIfdefDirectiveStatement) , sizeof ( SgIfdefDirectiveStatementStorageClass ) * sizeOfActualPool) ;
        SgIfdefDirectiveStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgIfdefDirectiveStatementStorageClass* storageArray = storageArraySgIfdefDirectiveStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgIfdefDirectiveStatement* tmp = new SgIfdefDirectiveStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgIfdefDirectiveStatement;  
      SgIfdefDirectiveStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgIfndefDirectiveStatement ); 
     storageClassIndex = 0 ;
     SgIfndefDirectiveStatementStorageClass* storageArraySgIfndefDirectiveStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgIfndefDirectiveStatement = new SgIfndefDirectiveStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgIfndefDirectiveStatement) , sizeof ( SgIfndefDirectiveStatementStorageClass ) * sizeOfActualPool) ;
        SgIfndefDirectiveStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgIfndefDirectiveStatementStorageClass* storageArray = storageArraySgIfndefDirectiveStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgIfndefDirectiveStatement* tmp = new SgIfndefDirectiveStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgIfndefDirectiveStatement;  
      SgIfndefDirectiveStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgImagPartOp ); 
     storageClassIndex = 0 ;
     SgImagPartOpStorageClass* storageArraySgImagPartOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgImagPartOp = new SgImagPartOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgImagPartOp) , sizeof ( SgImagPartOpStorageClass ) * sizeOfActualPool) ;
        SgImagPartOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgImagPartOpStorageClass* storageArray = storageArraySgImagPartOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgImagPartOp* tmp = new SgImagPartOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgImagPartOp;  
      SgImagPartOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgImplicitStatement ); 
     storageClassIndex = 0 ;
     SgImplicitStatementStorageClass* storageArraySgImplicitStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgImplicitStatement = new SgImplicitStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgImplicitStatement) , sizeof ( SgImplicitStatementStorageClass ) * sizeOfActualPool) ;
        SgImplicitStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgImplicitStatementStorageClass* storageArray = storageArraySgImplicitStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgImplicitStatement* tmp = new SgImplicitStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgImplicitStatement;  
      SgImplicitStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgImpliedDo ); 
     storageClassIndex = 0 ;
     SgImpliedDoStorageClass* storageArraySgImpliedDo = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgImpliedDo = new SgImpliedDoStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgImpliedDo) , sizeof ( SgImpliedDoStorageClass ) * sizeOfActualPool) ;
        SgImpliedDoStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgImpliedDoStorageClass* storageArray = storageArraySgImpliedDo;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgImpliedDo* tmp = new SgImpliedDo ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgImpliedDo;  
      SgImpliedDoStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgImportStatement ); 
     storageClassIndex = 0 ;
     SgImportStatementStorageClass* storageArraySgImportStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgImportStatement = new SgImportStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgImportStatement) , sizeof ( SgImportStatementStorageClass ) * sizeOfActualPool) ;
        SgImportStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgImportStatementStorageClass* storageArray = storageArraySgImportStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgImportStatement* tmp = new SgImportStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgImportStatement;  
      SgImportStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgIncidenceDirectedGraph ); 
     storageClassIndex = 0 ;
     SgIncidenceDirectedGraphStorageClass* storageArraySgIncidenceDirectedGraph = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgIncidenceDirectedGraph = new SgIncidenceDirectedGraphStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgIncidenceDirectedGraph) , sizeof ( SgIncidenceDirectedGraphStorageClass ) * sizeOfActualPool) ;
        SgIncidenceDirectedGraphStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgIncidenceDirectedGraphStorageClass* storageArray = storageArraySgIncidenceDirectedGraph;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgIncidenceDirectedGraph* tmp = new SgIncidenceDirectedGraph ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgIncidenceDirectedGraph;  
      SgIncidenceDirectedGraphStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgIncidenceUndirectedGraph ); 
     storageClassIndex = 0 ;
     SgIncidenceUndirectedGraphStorageClass* storageArraySgIncidenceUndirectedGraph = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgIncidenceUndirectedGraph = new SgIncidenceUndirectedGraphStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgIncidenceUndirectedGraph) , sizeof ( SgIncidenceUndirectedGraphStorageClass ) * sizeOfActualPool) ;
        SgIncidenceUndirectedGraphStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgIncidenceUndirectedGraphStorageClass* storageArray = storageArraySgIncidenceUndirectedGraph;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgIncidenceUndirectedGraph* tmp = new SgIncidenceUndirectedGraph ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgIncidenceUndirectedGraph;  
      SgIncidenceUndirectedGraphStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgIncludeDirectiveStatement ); 
     storageClassIndex = 0 ;
     SgIncludeDirectiveStatementStorageClass* storageArraySgIncludeDirectiveStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgIncludeDirectiveStatement = new SgIncludeDirectiveStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgIncludeDirectiveStatement) , sizeof ( SgIncludeDirectiveStatementStorageClass ) * sizeOfActualPool) ;
        SgIncludeDirectiveStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgIncludeDirectiveStatementStorageClass* storageArray = storageArraySgIncludeDirectiveStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgIncludeDirectiveStatement* tmp = new SgIncludeDirectiveStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgIncludeDirectiveStatement;  
      SgIncludeDirectiveStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgIncludeNextDirectiveStatement ); 
     storageClassIndex = 0 ;
     SgIncludeNextDirectiveStatementStorageClass* storageArraySgIncludeNextDirectiveStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgIncludeNextDirectiveStatement = new SgIncludeNextDirectiveStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgIncludeNextDirectiveStatement) , sizeof ( SgIncludeNextDirectiveStatementStorageClass ) * sizeOfActualPool) ;
        SgIncludeNextDirectiveStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgIncludeNextDirectiveStatementStorageClass* storageArray = storageArraySgIncludeNextDirectiveStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgIncludeNextDirectiveStatement* tmp = new SgIncludeNextDirectiveStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgIncludeNextDirectiveStatement;  
      SgIncludeNextDirectiveStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgInitializedName ); 
     storageClassIndex = 0 ;
     SgInitializedNameStorageClass* storageArraySgInitializedName = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgInitializedName = new SgInitializedNameStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgInitializedName) , sizeof ( SgInitializedNameStorageClass ) * sizeOfActualPool) ;
        SgInitializedNameStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgInitializedNameStorageClass* storageArray = storageArraySgInitializedName;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgInitializedName* tmp = new SgInitializedName ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgInitializedName;  
      SgInitializedNameStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgInitializer ); 
     storageClassIndex = 0 ;
     SgInitializerStorageClass* storageArraySgInitializer = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgInitializer = new SgInitializerStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgInitializer) , sizeof ( SgInitializerStorageClass ) * sizeOfActualPool) ;
        SgInitializerStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgInitializerStorageClass* storageArray = storageArraySgInitializer;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgInitializer* tmp = new SgInitializer ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgInitializer;  
      SgInitializerStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgInquireStatement ); 
     storageClassIndex = 0 ;
     SgInquireStatementStorageClass* storageArraySgInquireStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgInquireStatement = new SgInquireStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgInquireStatement) , sizeof ( SgInquireStatementStorageClass ) * sizeOfActualPool) ;
        SgInquireStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgInquireStatementStorageClass* storageArray = storageArraySgInquireStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgInquireStatement* tmp = new SgInquireStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgInquireStatement;  
      SgInquireStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgIntKeyedBidirectionalGraph ); 
     storageClassIndex = 0 ;
     SgIntKeyedBidirectionalGraphStorageClass* storageArraySgIntKeyedBidirectionalGraph = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgIntKeyedBidirectionalGraph = new SgIntKeyedBidirectionalGraphStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgIntKeyedBidirectionalGraph) , sizeof ( SgIntKeyedBidirectionalGraphStorageClass ) * sizeOfActualPool) ;
        SgIntKeyedBidirectionalGraphStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgIntKeyedBidirectionalGraphStorageClass* storageArray = storageArraySgIntKeyedBidirectionalGraph;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgIntKeyedBidirectionalGraph* tmp = new SgIntKeyedBidirectionalGraph ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgIntKeyedBidirectionalGraph;  
      SgIntKeyedBidirectionalGraphStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgIntVal ); 
     storageClassIndex = 0 ;
     SgIntValStorageClass* storageArraySgIntVal = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgIntVal = new SgIntValStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgIntVal) , sizeof ( SgIntValStorageClass ) * sizeOfActualPool) ;
        SgIntValStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgIntValStorageClass* storageArray = storageArraySgIntVal;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgIntVal* tmp = new SgIntVal ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgIntVal;  
      SgIntValStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgIntegerDivideOp ); 
     storageClassIndex = 0 ;
     SgIntegerDivideOpStorageClass* storageArraySgIntegerDivideOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgIntegerDivideOp = new SgIntegerDivideOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgIntegerDivideOp) , sizeof ( SgIntegerDivideOpStorageClass ) * sizeOfActualPool) ;
        SgIntegerDivideOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgIntegerDivideOpStorageClass* storageArray = storageArraySgIntegerDivideOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgIntegerDivideOp* tmp = new SgIntegerDivideOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgIntegerDivideOp;  
      SgIntegerDivideOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgIntegerDivideAssignOp ); 
     storageClassIndex = 0 ;
     SgIntegerDivideAssignOpStorageClass* storageArraySgIntegerDivideAssignOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgIntegerDivideAssignOp = new SgIntegerDivideAssignOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgIntegerDivideAssignOp) , sizeof ( SgIntegerDivideAssignOpStorageClass ) * sizeOfActualPool) ;
        SgIntegerDivideAssignOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgIntegerDivideAssignOpStorageClass* storageArray = storageArraySgIntegerDivideAssignOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgIntegerDivideAssignOp* tmp = new SgIntegerDivideAssignOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgIntegerDivideAssignOp;  
      SgIntegerDivideAssignOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgInterfaceBody ); 
     storageClassIndex = 0 ;
     SgInterfaceBodyStorageClass* storageArraySgInterfaceBody = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgInterfaceBody = new SgInterfaceBodyStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgInterfaceBody) , sizeof ( SgInterfaceBodyStorageClass ) * sizeOfActualPool) ;
        SgInterfaceBodyStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgInterfaceBodyStorageClass* storageArray = storageArraySgInterfaceBody;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgInterfaceBody* tmp = new SgInterfaceBody ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgInterfaceBody;  
      SgInterfaceBodyStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgHeaderFileBody ); 
     storageClassIndex = 0 ;
     SgHeaderFileBodyStorageClass* storageArraySgHeaderFileBody = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgHeaderFileBody = new SgHeaderFileBodyStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgHeaderFileBody) , sizeof ( SgHeaderFileBodyStorageClass ) * sizeOfActualPool) ;
        SgHeaderFileBodyStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgHeaderFileBodyStorageClass* storageArray = storageArraySgHeaderFileBody;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgHeaderFileBody* tmp = new SgHeaderFileBody ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgHeaderFileBody;  
      SgHeaderFileBodyStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgInterfaceStatement ); 
     storageClassIndex = 0 ;
     SgInterfaceStatementStorageClass* storageArraySgInterfaceStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgInterfaceStatement = new SgInterfaceStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgInterfaceStatement) , sizeof ( SgInterfaceStatementStorageClass ) * sizeOfActualPool) ;
        SgInterfaceStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgInterfaceStatementStorageClass* storageArray = storageArraySgInterfaceStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgInterfaceStatement* tmp = new SgInterfaceStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgInterfaceStatement;  
      SgInterfaceStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgInterfaceSymbol ); 
     storageClassIndex = 0 ;
     SgInterfaceSymbolStorageClass* storageArraySgInterfaceSymbol = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgInterfaceSymbol = new SgInterfaceSymbolStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgInterfaceSymbol) , sizeof ( SgInterfaceSymbolStorageClass ) * sizeOfActualPool) ;
        SgInterfaceSymbolStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgInterfaceSymbolStorageClass* storageArray = storageArraySgInterfaceSymbol;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgInterfaceSymbol* tmp = new SgInterfaceSymbol ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgInterfaceSymbol;  
      SgInterfaceSymbolStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgIntrinsicSymbol ); 
     storageClassIndex = 0 ;
     SgIntrinsicSymbolStorageClass* storageArraySgIntrinsicSymbol = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgIntrinsicSymbol = new SgIntrinsicSymbolStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgIntrinsicSymbol) , sizeof ( SgIntrinsicSymbolStorageClass ) * sizeOfActualPool) ;
        SgIntrinsicSymbolStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgIntrinsicSymbolStorageClass* storageArray = storageArraySgIntrinsicSymbol;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgIntrinsicSymbol* tmp = new SgIntrinsicSymbol ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgIntrinsicSymbol;  
      SgIntrinsicSymbolStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgIsOp ); 
     storageClassIndex = 0 ;
     SgIsOpStorageClass* storageArraySgIsOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgIsOp = new SgIsOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgIsOp) , sizeof ( SgIsOpStorageClass ) * sizeOfActualPool) ;
        SgIsOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgIsOpStorageClass* storageArray = storageArraySgIsOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgIsOp* tmp = new SgIsOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgIsOp;  
      SgIsOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgIsNotOp ); 
     storageClassIndex = 0 ;
     SgIsNotOpStorageClass* storageArraySgIsNotOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgIsNotOp = new SgIsNotOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgIsNotOp) , sizeof ( SgIsNotOpStorageClass ) * sizeOfActualPool) ;
        SgIsNotOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgIsNotOpStorageClass* storageArray = storageArraySgIsNotOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgIsNotOp* tmp = new SgIsNotOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgIsNotOp;  
      SgIsNotOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgIorAssignOp ); 
     storageClassIndex = 0 ;
     SgIorAssignOpStorageClass* storageArraySgIorAssignOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgIorAssignOp = new SgIorAssignOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgIorAssignOp) , sizeof ( SgIorAssignOpStorageClass ) * sizeOfActualPool) ;
        SgIorAssignOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgIorAssignOpStorageClass* storageArray = storageArraySgIorAssignOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgIorAssignOp* tmp = new SgIorAssignOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgIorAssignOp;  
      SgIorAssignOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgKeyDatumPair ); 
     storageClassIndex = 0 ;
     SgKeyDatumPairStorageClass* storageArraySgKeyDatumPair = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgKeyDatumPair = new SgKeyDatumPairStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgKeyDatumPair) , sizeof ( SgKeyDatumPairStorageClass ) * sizeOfActualPool) ;
        SgKeyDatumPairStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgKeyDatumPairStorageClass* storageArray = storageArraySgKeyDatumPair;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgKeyDatumPair* tmp = new SgKeyDatumPair ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgKeyDatumPair;  
      SgKeyDatumPairStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgCudaKernelExecConfig ); 
     storageClassIndex = 0 ;
     SgCudaKernelExecConfigStorageClass* storageArraySgCudaKernelExecConfig = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgCudaKernelExecConfig = new SgCudaKernelExecConfigStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgCudaKernelExecConfig) , sizeof ( SgCudaKernelExecConfigStorageClass ) * sizeOfActualPool) ;
        SgCudaKernelExecConfigStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgCudaKernelExecConfigStorageClass* storageArray = storageArraySgCudaKernelExecConfig;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgCudaKernelExecConfig* tmp = new SgCudaKernelExecConfig ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgCudaKernelExecConfig;  
      SgCudaKernelExecConfigStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgCudaKernelCallExp ); 
     storageClassIndex = 0 ;
     SgCudaKernelCallExpStorageClass* storageArraySgCudaKernelCallExp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgCudaKernelCallExp = new SgCudaKernelCallExpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgCudaKernelCallExp) , sizeof ( SgCudaKernelCallExpStorageClass ) * sizeOfActualPool) ;
        SgCudaKernelCallExpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgCudaKernelCallExpStorageClass* storageArray = storageArraySgCudaKernelCallExp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgCudaKernelCallExp* tmp = new SgCudaKernelCallExp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgCudaKernelCallExp;  
      SgCudaKernelCallExpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgLabelRefExp ); 
     storageClassIndex = 0 ;
     SgLabelRefExpStorageClass* storageArraySgLabelRefExp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgLabelRefExp = new SgLabelRefExpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgLabelRefExp) , sizeof ( SgLabelRefExpStorageClass ) * sizeOfActualPool) ;
        SgLabelRefExpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgLabelRefExpStorageClass* storageArray = storageArraySgLabelRefExp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgLabelRefExp* tmp = new SgLabelRefExp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgLabelRefExp;  
      SgLabelRefExpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgLabelStatement ); 
     storageClassIndex = 0 ;
     SgLabelStatementStorageClass* storageArraySgLabelStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgLabelStatement = new SgLabelStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgLabelStatement) , sizeof ( SgLabelStatementStorageClass ) * sizeOfActualPool) ;
        SgLabelStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgLabelStatementStorageClass* storageArray = storageArraySgLabelStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgLabelStatement* tmp = new SgLabelStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgLabelStatement;  
      SgLabelStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgJavaLabelStatement ); 
     storageClassIndex = 0 ;
     SgJavaLabelStatementStorageClass* storageArraySgJavaLabelStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgJavaLabelStatement = new SgJavaLabelStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgJavaLabelStatement) , sizeof ( SgJavaLabelStatementStorageClass ) * sizeOfActualPool) ;
        SgJavaLabelStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgJavaLabelStatementStorageClass* storageArray = storageArraySgJavaLabelStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgJavaLabelStatement* tmp = new SgJavaLabelStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgJavaLabelStatement;  
      SgJavaLabelStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgLabelSymbol ); 
     storageClassIndex = 0 ;
     SgLabelSymbolStorageClass* storageArraySgLabelSymbol = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgLabelSymbol = new SgLabelSymbolStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgLabelSymbol) , sizeof ( SgLabelSymbolStorageClass ) * sizeOfActualPool) ;
        SgLabelSymbolStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgLabelSymbolStorageClass* storageArray = storageArraySgLabelSymbol;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgLabelSymbol* tmp = new SgLabelSymbol ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgLabelSymbol;  
      SgLabelSymbolStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgJavaLabelSymbol ); 
     storageClassIndex = 0 ;
     SgJavaLabelSymbolStorageClass* storageArraySgJavaLabelSymbol = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgJavaLabelSymbol = new SgJavaLabelSymbolStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgJavaLabelSymbol) , sizeof ( SgJavaLabelSymbolStorageClass ) * sizeOfActualPool) ;
        SgJavaLabelSymbolStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgJavaLabelSymbolStorageClass* storageArray = storageArraySgJavaLabelSymbol;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgJavaLabelSymbol* tmp = new SgJavaLabelSymbol ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgJavaLabelSymbol;  
      SgJavaLabelSymbolStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgLambdaRefExp ); 
     storageClassIndex = 0 ;
     SgLambdaRefExpStorageClass* storageArraySgLambdaRefExp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgLambdaRefExp = new SgLambdaRefExpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgLambdaRefExp) , sizeof ( SgLambdaRefExpStorageClass ) * sizeOfActualPool) ;
        SgLambdaRefExpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgLambdaRefExpStorageClass* storageArray = storageArraySgLambdaRefExp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgLambdaRefExp* tmp = new SgLambdaRefExp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgLambdaRefExp;  
      SgLambdaRefExpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgLessOrEqualOp ); 
     storageClassIndex = 0 ;
     SgLessOrEqualOpStorageClass* storageArraySgLessOrEqualOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgLessOrEqualOp = new SgLessOrEqualOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgLessOrEqualOp) , sizeof ( SgLessOrEqualOpStorageClass ) * sizeOfActualPool) ;
        SgLessOrEqualOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgLessOrEqualOpStorageClass* storageArray = storageArraySgLessOrEqualOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgLessOrEqualOp* tmp = new SgLessOrEqualOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgLessOrEqualOp;  
      SgLessOrEqualOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgLessThanOp ); 
     storageClassIndex = 0 ;
     SgLessThanOpStorageClass* storageArraySgLessThanOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgLessThanOp = new SgLessThanOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgLessThanOp) , sizeof ( SgLessThanOpStorageClass ) * sizeOfActualPool) ;
        SgLessThanOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgLessThanOpStorageClass* storageArray = storageArraySgLessThanOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgLessThanOp* tmp = new SgLessThanOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgLessThanOp;  
      SgLessThanOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgLineDirectiveStatement ); 
     storageClassIndex = 0 ;
     SgLineDirectiveStatementStorageClass* storageArraySgLineDirectiveStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgLineDirectiveStatement = new SgLineDirectiveStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgLineDirectiveStatement) , sizeof ( SgLineDirectiveStatementStorageClass ) * sizeOfActualPool) ;
        SgLineDirectiveStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgLineDirectiveStatementStorageClass* storageArray = storageArraySgLineDirectiveStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgLineDirectiveStatement* tmp = new SgLineDirectiveStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgLineDirectiveStatement;  
      SgLineDirectiveStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgLinemarkerDirectiveStatement ); 
     storageClassIndex = 0 ;
     SgLinemarkerDirectiveStatementStorageClass* storageArraySgLinemarkerDirectiveStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgLinemarkerDirectiveStatement = new SgLinemarkerDirectiveStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgLinemarkerDirectiveStatement) , sizeof ( SgLinemarkerDirectiveStatementStorageClass ) * sizeOfActualPool) ;
        SgLinemarkerDirectiveStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgLinemarkerDirectiveStatementStorageClass* storageArray = storageArraySgLinemarkerDirectiveStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgLinemarkerDirectiveStatement* tmp = new SgLinemarkerDirectiveStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgLinemarkerDirectiveStatement;  
      SgLinemarkerDirectiveStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgLinkageModifier ); 
     storageClassIndex = 0 ;
     SgLinkageModifierStorageClass* storageArraySgLinkageModifier = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgLinkageModifier = new SgLinkageModifierStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgLinkageModifier) , sizeof ( SgLinkageModifierStorageClass ) * sizeOfActualPool) ;
          SgLinkageModifierStorageClass* storageArray = storageArraySgLinkageModifier;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgLinkageModifier* tmp = new SgLinkageModifier ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgLinkageModifier;  


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgListComprehension ); 
     storageClassIndex = 0 ;
     SgListComprehensionStorageClass* storageArraySgListComprehension = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgListComprehension = new SgListComprehensionStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgListComprehension) , sizeof ( SgListComprehensionStorageClass ) * sizeOfActualPool) ;
        SgListComprehensionStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgListComprehensionStorageClass* storageArray = storageArraySgListComprehension;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgListComprehension* tmp = new SgListComprehension ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgListComprehension;  
      SgListComprehensionStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgListExp ); 
     storageClassIndex = 0 ;
     SgListExpStorageClass* storageArraySgListExp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgListExp = new SgListExpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgListExp) , sizeof ( SgListExpStorageClass ) * sizeOfActualPool) ;
        SgListExpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgListExpStorageClass* storageArray = storageArraySgListExp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgListExp* tmp = new SgListExp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgListExp;  
      SgListExpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgLocatedNode ); 
     storageClassIndex = 0 ;
     SgLocatedNodeStorageClass* storageArraySgLocatedNode = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgLocatedNode = new SgLocatedNodeStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgLocatedNode) , sizeof ( SgLocatedNodeStorageClass ) * sizeOfActualPool) ;
        SgLocatedNodeStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgLocatedNodeStorageClass* storageArray = storageArraySgLocatedNode;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgLocatedNode* tmp = new SgLocatedNode ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgLocatedNode;  
      SgLocatedNodeStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgLocatedNodeSupport ); 
     storageClassIndex = 0 ;
     SgLocatedNodeSupportStorageClass* storageArraySgLocatedNodeSupport = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgLocatedNodeSupport = new SgLocatedNodeSupportStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgLocatedNodeSupport) , sizeof ( SgLocatedNodeSupportStorageClass ) * sizeOfActualPool) ;
        SgLocatedNodeSupportStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgLocatedNodeSupportStorageClass* storageArray = storageArraySgLocatedNodeSupport;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgLocatedNodeSupport* tmp = new SgLocatedNodeSupport ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgLocatedNodeSupport;  
      SgLocatedNodeSupportStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgLongDoubleVal ); 
     storageClassIndex = 0 ;
     SgLongDoubleValStorageClass* storageArraySgLongDoubleVal = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgLongDoubleVal = new SgLongDoubleValStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgLongDoubleVal) , sizeof ( SgLongDoubleValStorageClass ) * sizeOfActualPool) ;
        SgLongDoubleValStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgLongDoubleValStorageClass* storageArray = storageArraySgLongDoubleVal;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgLongDoubleVal* tmp = new SgLongDoubleVal ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgLongDoubleVal;  
      SgLongDoubleValStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgLongIntVal ); 
     storageClassIndex = 0 ;
     SgLongIntValStorageClass* storageArraySgLongIntVal = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgLongIntVal = new SgLongIntValStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgLongIntVal) , sizeof ( SgLongIntValStorageClass ) * sizeOfActualPool) ;
        SgLongIntValStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgLongIntValStorageClass* storageArray = storageArraySgLongIntVal;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgLongIntVal* tmp = new SgLongIntVal ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgLongIntVal;  
      SgLongIntValStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgLongLongIntVal ); 
     storageClassIndex = 0 ;
     SgLongLongIntValStorageClass* storageArraySgLongLongIntVal = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgLongLongIntVal = new SgLongLongIntValStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgLongLongIntVal) , sizeof ( SgLongLongIntValStorageClass ) * sizeOfActualPool) ;
        SgLongLongIntValStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgLongLongIntValStorageClass* storageArray = storageArraySgLongLongIntVal;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgLongLongIntVal* tmp = new SgLongLongIntVal ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgLongLongIntVal;  
      SgLongLongIntValStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgLshiftAssignOp ); 
     storageClassIndex = 0 ;
     SgLshiftAssignOpStorageClass* storageArraySgLshiftAssignOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgLshiftAssignOp = new SgLshiftAssignOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgLshiftAssignOp) , sizeof ( SgLshiftAssignOpStorageClass ) * sizeOfActualPool) ;
        SgLshiftAssignOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgLshiftAssignOpStorageClass* storageArray = storageArraySgLshiftAssignOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgLshiftAssignOp* tmp = new SgLshiftAssignOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgLshiftAssignOp;  
      SgLshiftAssignOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgLshiftOp ); 
     storageClassIndex = 0 ;
     SgLshiftOpStorageClass* storageArraySgLshiftOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgLshiftOp = new SgLshiftOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgLshiftOp) , sizeof ( SgLshiftOpStorageClass ) * sizeOfActualPool) ;
        SgLshiftOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgLshiftOpStorageClass* storageArray = storageArraySgLshiftOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgLshiftOp* tmp = new SgLshiftOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgLshiftOp;  
      SgLshiftOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgMemberFunctionDeclaration ); 
     storageClassIndex = 0 ;
     SgMemberFunctionDeclarationStorageClass* storageArraySgMemberFunctionDeclaration = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgMemberFunctionDeclaration = new SgMemberFunctionDeclarationStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgMemberFunctionDeclaration) , sizeof ( SgMemberFunctionDeclarationStorageClass ) * sizeOfActualPool) ;
        SgMemberFunctionDeclarationStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgMemberFunctionDeclarationStorageClass* storageArray = storageArraySgMemberFunctionDeclaration;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgMemberFunctionDeclaration* tmp = new SgMemberFunctionDeclaration ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgMemberFunctionDeclaration;  
      SgMemberFunctionDeclarationStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgMemberFunctionRefExp ); 
     storageClassIndex = 0 ;
     SgMemberFunctionRefExpStorageClass* storageArraySgMemberFunctionRefExp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgMemberFunctionRefExp = new SgMemberFunctionRefExpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgMemberFunctionRefExp) , sizeof ( SgMemberFunctionRefExpStorageClass ) * sizeOfActualPool) ;
        SgMemberFunctionRefExpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgMemberFunctionRefExpStorageClass* storageArray = storageArraySgMemberFunctionRefExp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgMemberFunctionRefExp* tmp = new SgMemberFunctionRefExp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgMemberFunctionRefExp;  
      SgMemberFunctionRefExpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgMemberFunctionSymbol ); 
     storageClassIndex = 0 ;
     SgMemberFunctionSymbolStorageClass* storageArraySgMemberFunctionSymbol = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgMemberFunctionSymbol = new SgMemberFunctionSymbolStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgMemberFunctionSymbol) , sizeof ( SgMemberFunctionSymbolStorageClass ) * sizeOfActualPool) ;
        SgMemberFunctionSymbolStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgMemberFunctionSymbolStorageClass* storageArray = storageArraySgMemberFunctionSymbol;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgMemberFunctionSymbol* tmp = new SgMemberFunctionSymbol ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgMemberFunctionSymbol;  
      SgMemberFunctionSymbolStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgMemberFunctionType ); 
     storageClassIndex = 0 ;
     SgMemberFunctionTypeStorageClass* storageArraySgMemberFunctionType = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgMemberFunctionType = new SgMemberFunctionTypeStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgMemberFunctionType) , sizeof ( SgMemberFunctionTypeStorageClass ) * sizeOfActualPool) ;
        SgMemberFunctionTypeStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgMemberFunctionTypeStorageClass* storageArray = storageArraySgMemberFunctionType;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgMemberFunctionType* tmp = new SgMemberFunctionType ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgMemberFunctionType;  
      SgMemberFunctionTypeStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgMembershipOp ); 
     storageClassIndex = 0 ;
     SgMembershipOpStorageClass* storageArraySgMembershipOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgMembershipOp = new SgMembershipOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgMembershipOp) , sizeof ( SgMembershipOpStorageClass ) * sizeOfActualPool) ;
        SgMembershipOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgMembershipOpStorageClass* storageArray = storageArraySgMembershipOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgMembershipOp* tmp = new SgMembershipOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgMembershipOp;  
      SgMembershipOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgMinusAssignOp ); 
     storageClassIndex = 0 ;
     SgMinusAssignOpStorageClass* storageArraySgMinusAssignOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgMinusAssignOp = new SgMinusAssignOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgMinusAssignOp) , sizeof ( SgMinusAssignOpStorageClass ) * sizeOfActualPool) ;
        SgMinusAssignOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgMinusAssignOpStorageClass* storageArray = storageArraySgMinusAssignOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgMinusAssignOp* tmp = new SgMinusAssignOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgMinusAssignOp;  
      SgMinusAssignOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgMinusMinusOp ); 
     storageClassIndex = 0 ;
     SgMinusMinusOpStorageClass* storageArraySgMinusMinusOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgMinusMinusOp = new SgMinusMinusOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgMinusMinusOp) , sizeof ( SgMinusMinusOpStorageClass ) * sizeOfActualPool) ;
        SgMinusMinusOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgMinusMinusOpStorageClass* storageArray = storageArraySgMinusMinusOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgMinusMinusOp* tmp = new SgMinusMinusOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgMinusMinusOp;  
      SgMinusMinusOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgMinusOp ); 
     storageClassIndex = 0 ;
     SgMinusOpStorageClass* storageArraySgMinusOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgMinusOp = new SgMinusOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgMinusOp) , sizeof ( SgMinusOpStorageClass ) * sizeOfActualPool) ;
        SgMinusOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgMinusOpStorageClass* storageArray = storageArraySgMinusOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgMinusOp* tmp = new SgMinusOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgMinusOp;  
      SgMinusOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgModAssignOp ); 
     storageClassIndex = 0 ;
     SgModAssignOpStorageClass* storageArraySgModAssignOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgModAssignOp = new SgModAssignOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgModAssignOp) , sizeof ( SgModAssignOpStorageClass ) * sizeOfActualPool) ;
        SgModAssignOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgModAssignOpStorageClass* storageArray = storageArraySgModAssignOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgModAssignOp* tmp = new SgModAssignOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgModAssignOp;  
      SgModAssignOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgModOp ); 
     storageClassIndex = 0 ;
     SgModOpStorageClass* storageArraySgModOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgModOp = new SgModOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgModOp) , sizeof ( SgModOpStorageClass ) * sizeOfActualPool) ;
        SgModOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgModOpStorageClass* storageArray = storageArraySgModOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgModOp* tmp = new SgModOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgModOp;  
      SgModOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgModifier ); 
     storageClassIndex = 0 ;
     SgModifierStorageClass* storageArraySgModifier = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgModifier = new SgModifierStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgModifier) , sizeof ( SgModifierStorageClass ) * sizeOfActualPool) ;
          SgModifierStorageClass* storageArray = storageArraySgModifier;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgModifier* tmp = new SgModifier ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgModifier;  


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgModifierNodes ); 
     storageClassIndex = 0 ;
     SgModifierNodesStorageClass* storageArraySgModifierNodes = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgModifierNodes = new SgModifierNodesStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgModifierNodes) , sizeof ( SgModifierNodesStorageClass ) * sizeOfActualPool) ;
        SgModifierNodesStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgModifierNodesStorageClass* storageArray = storageArraySgModifierNodes;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgModifierNodes* tmp = new SgModifierNodes ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgModifierNodes;  
      SgModifierNodesStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgModifierType ); 
     storageClassIndex = 0 ;
     SgModifierTypeStorageClass* storageArraySgModifierType = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgModifierType = new SgModifierTypeStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgModifierType) , sizeof ( SgModifierTypeStorageClass ) * sizeOfActualPool) ;
        SgModifierTypeStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgModifierTypeStorageClass* storageArray = storageArraySgModifierType;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgModifierType* tmp = new SgModifierType ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgModifierType;  
      SgModifierTypeStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgModuleStatement ); 
     storageClassIndex = 0 ;
     SgModuleStatementStorageClass* storageArraySgModuleStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgModuleStatement = new SgModuleStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgModuleStatement) , sizeof ( SgModuleStatementStorageClass ) * sizeOfActualPool) ;
        SgModuleStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgModuleStatementStorageClass* storageArray = storageArraySgModuleStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgModuleStatement* tmp = new SgModuleStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgModuleStatement;  
      SgModuleStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgModuleSymbol ); 
     storageClassIndex = 0 ;
     SgModuleSymbolStorageClass* storageArraySgModuleSymbol = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgModuleSymbol = new SgModuleSymbolStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgModuleSymbol) , sizeof ( SgModuleSymbolStorageClass ) * sizeOfActualPool) ;
        SgModuleSymbolStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgModuleSymbolStorageClass* storageArray = storageArraySgModuleSymbol;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgModuleSymbol* tmp = new SgModuleSymbol ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgModuleSymbol;  
      SgModuleSymbolStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgMultAssignOp ); 
     storageClassIndex = 0 ;
     SgMultAssignOpStorageClass* storageArraySgMultAssignOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgMultAssignOp = new SgMultAssignOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgMultAssignOp) , sizeof ( SgMultAssignOpStorageClass ) * sizeOfActualPool) ;
        SgMultAssignOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgMultAssignOpStorageClass* storageArray = storageArraySgMultAssignOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgMultAssignOp* tmp = new SgMultAssignOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgMultAssignOp;  
      SgMultAssignOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgMultiplyOp ); 
     storageClassIndex = 0 ;
     SgMultiplyOpStorageClass* storageArraySgMultiplyOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgMultiplyOp = new SgMultiplyOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgMultiplyOp) , sizeof ( SgMultiplyOpStorageClass ) * sizeOfActualPool) ;
        SgMultiplyOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgMultiplyOpStorageClass* storageArray = storageArraySgMultiplyOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgMultiplyOp* tmp = new SgMultiplyOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgMultiplyOp;  
      SgMultiplyOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgName ); 
     storageClassIndex = 0 ;
     SgNameStorageClass* storageArraySgName = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgName = new SgNameStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgName) , sizeof ( SgNameStorageClass ) * sizeOfActualPool) ;
        SgNameStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgNameStorageClass* storageArray = storageArraySgName;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgName* tmp = new SgName ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgName;  
      SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgNameGroup ); 
     storageClassIndex = 0 ;
     SgNameGroupStorageClass* storageArraySgNameGroup = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgNameGroup = new SgNameGroupStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgNameGroup) , sizeof ( SgNameGroupStorageClass ) * sizeOfActualPool) ;
        SgNameGroupStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgNameGroupStorageClass* storageArray = storageArraySgNameGroup;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgNameGroup* tmp = new SgNameGroup ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgNameGroup;  
      SgNameGroupStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgNamedType ); 
     storageClassIndex = 0 ;
     SgNamedTypeStorageClass* storageArraySgNamedType = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgNamedType = new SgNamedTypeStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgNamedType) , sizeof ( SgNamedTypeStorageClass ) * sizeOfActualPool) ;
        SgNamedTypeStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgNamedTypeStorageClass* storageArray = storageArraySgNamedType;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgNamedType* tmp = new SgNamedType ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgNamedType;  
      SgNamedTypeStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgNamelistStatement ); 
     storageClassIndex = 0 ;
     SgNamelistStatementStorageClass* storageArraySgNamelistStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgNamelistStatement = new SgNamelistStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgNamelistStatement) , sizeof ( SgNamelistStatementStorageClass ) * sizeOfActualPool) ;
        SgNamelistStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgNamelistStatementStorageClass* storageArray = storageArraySgNamelistStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgNamelistStatement* tmp = new SgNamelistStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgNamelistStatement;  
      SgNamelistStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgNamespaceAliasDeclarationStatement ); 
     storageClassIndex = 0 ;
     SgNamespaceAliasDeclarationStatementStorageClass* storageArraySgNamespaceAliasDeclarationStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgNamespaceAliasDeclarationStatement = new SgNamespaceAliasDeclarationStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgNamespaceAliasDeclarationStatement) , sizeof ( SgNamespaceAliasDeclarationStatementStorageClass ) * sizeOfActualPool) ;
        SgNamespaceAliasDeclarationStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgNamespaceAliasDeclarationStatementStorageClass* storageArray = storageArraySgNamespaceAliasDeclarationStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgNamespaceAliasDeclarationStatement* tmp = new SgNamespaceAliasDeclarationStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgNamespaceAliasDeclarationStatement;  
      SgNamespaceAliasDeclarationStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgNamespaceDeclarationStatement ); 
     storageClassIndex = 0 ;
     SgNamespaceDeclarationStatementStorageClass* storageArraySgNamespaceDeclarationStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgNamespaceDeclarationStatement = new SgNamespaceDeclarationStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgNamespaceDeclarationStatement) , sizeof ( SgNamespaceDeclarationStatementStorageClass ) * sizeOfActualPool) ;
        SgNamespaceDeclarationStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgNamespaceDeclarationStatementStorageClass* storageArray = storageArraySgNamespaceDeclarationStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgNamespaceDeclarationStatement* tmp = new SgNamespaceDeclarationStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgNamespaceDeclarationStatement;  
      SgNamespaceDeclarationStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgNamespaceDefinitionStatement ); 
     storageClassIndex = 0 ;
     SgNamespaceDefinitionStatementStorageClass* storageArraySgNamespaceDefinitionStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgNamespaceDefinitionStatement = new SgNamespaceDefinitionStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgNamespaceDefinitionStatement) , sizeof ( SgNamespaceDefinitionStatementStorageClass ) * sizeOfActualPool) ;
        SgNamespaceDefinitionStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgNamespaceDefinitionStatementStorageClass* storageArray = storageArraySgNamespaceDefinitionStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgNamespaceDefinitionStatement* tmp = new SgNamespaceDefinitionStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgNamespaceDefinitionStatement;  
      SgNamespaceDefinitionStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgNamespaceSymbol ); 
     storageClassIndex = 0 ;
     SgNamespaceSymbolStorageClass* storageArraySgNamespaceSymbol = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgNamespaceSymbol = new SgNamespaceSymbolStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgNamespaceSymbol) , sizeof ( SgNamespaceSymbolStorageClass ) * sizeOfActualPool) ;
        SgNamespaceSymbolStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgNamespaceSymbolStorageClass* storageArray = storageArraySgNamespaceSymbol;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgNamespaceSymbol* tmp = new SgNamespaceSymbol ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgNamespaceSymbol;  
      SgNamespaceSymbolStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgNaryOp ); 
     storageClassIndex = 0 ;
     SgNaryOpStorageClass* storageArraySgNaryOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgNaryOp = new SgNaryOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgNaryOp) , sizeof ( SgNaryOpStorageClass ) * sizeOfActualPool) ;
        SgNaryOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgNaryOpStorageClass* storageArray = storageArraySgNaryOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgNaryOp* tmp = new SgNaryOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgNaryOp;  
      SgNaryOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgNaryBooleanOp ); 
     storageClassIndex = 0 ;
     SgNaryBooleanOpStorageClass* storageArraySgNaryBooleanOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgNaryBooleanOp = new SgNaryBooleanOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgNaryBooleanOp) , sizeof ( SgNaryBooleanOpStorageClass ) * sizeOfActualPool) ;
        SgNaryBooleanOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgNaryBooleanOpStorageClass* storageArray = storageArraySgNaryBooleanOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgNaryBooleanOp* tmp = new SgNaryBooleanOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgNaryBooleanOp;  
      SgNaryBooleanOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgNaryComparisonOp ); 
     storageClassIndex = 0 ;
     SgNaryComparisonOpStorageClass* storageArraySgNaryComparisonOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgNaryComparisonOp = new SgNaryComparisonOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgNaryComparisonOp) , sizeof ( SgNaryComparisonOpStorageClass ) * sizeOfActualPool) ;
        SgNaryComparisonOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgNaryComparisonOpStorageClass* storageArray = storageArraySgNaryComparisonOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgNaryComparisonOp* tmp = new SgNaryComparisonOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgNaryComparisonOp;  
      SgNaryComparisonOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgNewExp ); 
     storageClassIndex = 0 ;
     SgNewExpStorageClass* storageArraySgNewExp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgNewExp = new SgNewExpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgNewExp) , sizeof ( SgNewExpStorageClass ) * sizeOfActualPool) ;
        SgNewExpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgNewExpStorageClass* storageArray = storageArraySgNewExp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgNewExp* tmp = new SgNewExp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgNewExp;  
      SgNewExpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgNode ); 
     storageClassIndex = 0 ;
     SgNodeStorageClass* storageArraySgNode = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgNode = new SgNodeStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgNode) , sizeof ( SgNodeStorageClass ) * sizeOfActualPool) ;
          SgNodeStorageClass* storageArray = storageArraySgNode;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgNode* tmp = new SgNode ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgNode;  


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgNotEqualOp ); 
     storageClassIndex = 0 ;
     SgNotEqualOpStorageClass* storageArraySgNotEqualOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgNotEqualOp = new SgNotEqualOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgNotEqualOp) , sizeof ( SgNotEqualOpStorageClass ) * sizeOfActualPool) ;
        SgNotEqualOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgNotEqualOpStorageClass* storageArray = storageArraySgNotEqualOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgNotEqualOp* tmp = new SgNotEqualOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgNotEqualOp;  
      SgNotEqualOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgNotOp ); 
     storageClassIndex = 0 ;
     SgNotOpStorageClass* storageArraySgNotOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgNotOp = new SgNotOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgNotOp) , sizeof ( SgNotOpStorageClass ) * sizeOfActualPool) ;
        SgNotOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgNotOpStorageClass* storageArray = storageArraySgNotOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgNotOp* tmp = new SgNotOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgNotOp;  
      SgNotOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgNonMembershipOp ); 
     storageClassIndex = 0 ;
     SgNonMembershipOpStorageClass* storageArraySgNonMembershipOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgNonMembershipOp = new SgNonMembershipOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgNonMembershipOp) , sizeof ( SgNonMembershipOpStorageClass ) * sizeOfActualPool) ;
        SgNonMembershipOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgNonMembershipOpStorageClass* storageArray = storageArraySgNonMembershipOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgNonMembershipOp* tmp = new SgNonMembershipOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgNonMembershipOp;  
      SgNonMembershipOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgNullExpression ); 
     storageClassIndex = 0 ;
     SgNullExpressionStorageClass* storageArraySgNullExpression = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgNullExpression = new SgNullExpressionStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgNullExpression) , sizeof ( SgNullExpressionStorageClass ) * sizeOfActualPool) ;
        SgNullExpressionStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgNullExpressionStorageClass* storageArray = storageArraySgNullExpression;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgNullExpression* tmp = new SgNullExpression ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgNullExpression;  
      SgNullExpressionStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgNullStatement ); 
     storageClassIndex = 0 ;
     SgNullStatementStorageClass* storageArraySgNullStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgNullStatement = new SgNullStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgNullStatement) , sizeof ( SgNullStatementStorageClass ) * sizeOfActualPool) ;
        SgNullStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgNullStatementStorageClass* storageArray = storageArraySgNullStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgNullStatement* tmp = new SgNullStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgNullStatement;  
      SgNullStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgNullifyStatement ); 
     storageClassIndex = 0 ;
     SgNullifyStatementStorageClass* storageArraySgNullifyStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgNullifyStatement = new SgNullifyStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgNullifyStatement) , sizeof ( SgNullifyStatementStorageClass ) * sizeOfActualPool) ;
        SgNullifyStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgNullifyStatementStorageClass* storageArray = storageArraySgNullifyStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgNullifyStatement* tmp = new SgNullifyStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgNullifyStatement;  
      SgNullifyStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgOmpAtomicStatement ); 
     storageClassIndex = 0 ;
     SgOmpAtomicStatementStorageClass* storageArraySgOmpAtomicStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgOmpAtomicStatement = new SgOmpAtomicStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgOmpAtomicStatement) , sizeof ( SgOmpAtomicStatementStorageClass ) * sizeOfActualPool) ;
        SgOmpAtomicStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgOmpAtomicStatementStorageClass* storageArray = storageArraySgOmpAtomicStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgOmpAtomicStatement* tmp = new SgOmpAtomicStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgOmpAtomicStatement;  
      SgOmpAtomicStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgOmpBarrierStatement ); 
     storageClassIndex = 0 ;
     SgOmpBarrierStatementStorageClass* storageArraySgOmpBarrierStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgOmpBarrierStatement = new SgOmpBarrierStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgOmpBarrierStatement) , sizeof ( SgOmpBarrierStatementStorageClass ) * sizeOfActualPool) ;
        SgOmpBarrierStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgOmpBarrierStatementStorageClass* storageArray = storageArraySgOmpBarrierStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgOmpBarrierStatement* tmp = new SgOmpBarrierStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgOmpBarrierStatement;  
      SgOmpBarrierStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgOmpCriticalStatement ); 
     storageClassIndex = 0 ;
     SgOmpCriticalStatementStorageClass* storageArraySgOmpCriticalStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgOmpCriticalStatement = new SgOmpCriticalStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgOmpCriticalStatement) , sizeof ( SgOmpCriticalStatementStorageClass ) * sizeOfActualPool) ;
        SgOmpCriticalStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgOmpCriticalStatementStorageClass* storageArray = storageArraySgOmpCriticalStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgOmpCriticalStatement* tmp = new SgOmpCriticalStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgOmpCriticalStatement;  
      SgOmpCriticalStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgOmpClauseBodyStatement ); 
     storageClassIndex = 0 ;
     SgOmpClauseBodyStatementStorageClass* storageArraySgOmpClauseBodyStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgOmpClauseBodyStatement = new SgOmpClauseBodyStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgOmpClauseBodyStatement) , sizeof ( SgOmpClauseBodyStatementStorageClass ) * sizeOfActualPool) ;
        SgOmpClauseBodyStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgOmpClauseBodyStatementStorageClass* storageArray = storageArraySgOmpClauseBodyStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgOmpClauseBodyStatement* tmp = new SgOmpClauseBodyStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgOmpClauseBodyStatement;  
      SgOmpClauseBodyStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgOmpBodyStatement ); 
     storageClassIndex = 0 ;
     SgOmpBodyStatementStorageClass* storageArraySgOmpBodyStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgOmpBodyStatement = new SgOmpBodyStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgOmpBodyStatement) , sizeof ( SgOmpBodyStatementStorageClass ) * sizeOfActualPool) ;
        SgOmpBodyStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgOmpBodyStatementStorageClass* storageArray = storageArraySgOmpBodyStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgOmpBodyStatement* tmp = new SgOmpBodyStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgOmpBodyStatement;  
      SgOmpBodyStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgOmpDoStatement ); 
     storageClassIndex = 0 ;
     SgOmpDoStatementStorageClass* storageArraySgOmpDoStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgOmpDoStatement = new SgOmpDoStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgOmpDoStatement) , sizeof ( SgOmpDoStatementStorageClass ) * sizeOfActualPool) ;
        SgOmpDoStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgOmpDoStatementStorageClass* storageArray = storageArraySgOmpDoStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgOmpDoStatement* tmp = new SgOmpDoStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgOmpDoStatement;  
      SgOmpDoStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgOmpFlushStatement ); 
     storageClassIndex = 0 ;
     SgOmpFlushStatementStorageClass* storageArraySgOmpFlushStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgOmpFlushStatement = new SgOmpFlushStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgOmpFlushStatement) , sizeof ( SgOmpFlushStatementStorageClass ) * sizeOfActualPool) ;
        SgOmpFlushStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgOmpFlushStatementStorageClass* storageArray = storageArraySgOmpFlushStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgOmpFlushStatement* tmp = new SgOmpFlushStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgOmpFlushStatement;  
      SgOmpFlushStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgOmpForStatement ); 
     storageClassIndex = 0 ;
     SgOmpForStatementStorageClass* storageArraySgOmpForStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgOmpForStatement = new SgOmpForStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgOmpForStatement) , sizeof ( SgOmpForStatementStorageClass ) * sizeOfActualPool) ;
        SgOmpForStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgOmpForStatementStorageClass* storageArray = storageArraySgOmpForStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgOmpForStatement* tmp = new SgOmpForStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgOmpForStatement;  
      SgOmpForStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgOmpMasterStatement ); 
     storageClassIndex = 0 ;
     SgOmpMasterStatementStorageClass* storageArraySgOmpMasterStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgOmpMasterStatement = new SgOmpMasterStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgOmpMasterStatement) , sizeof ( SgOmpMasterStatementStorageClass ) * sizeOfActualPool) ;
        SgOmpMasterStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgOmpMasterStatementStorageClass* storageArray = storageArraySgOmpMasterStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgOmpMasterStatement* tmp = new SgOmpMasterStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgOmpMasterStatement;  
      SgOmpMasterStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgOmpOrderedStatement ); 
     storageClassIndex = 0 ;
     SgOmpOrderedStatementStorageClass* storageArraySgOmpOrderedStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgOmpOrderedStatement = new SgOmpOrderedStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgOmpOrderedStatement) , sizeof ( SgOmpOrderedStatementStorageClass ) * sizeOfActualPool) ;
        SgOmpOrderedStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgOmpOrderedStatementStorageClass* storageArray = storageArraySgOmpOrderedStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgOmpOrderedStatement* tmp = new SgOmpOrderedStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgOmpOrderedStatement;  
      SgOmpOrderedStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgOmpParallelStatement ); 
     storageClassIndex = 0 ;
     SgOmpParallelStatementStorageClass* storageArraySgOmpParallelStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgOmpParallelStatement = new SgOmpParallelStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgOmpParallelStatement) , sizeof ( SgOmpParallelStatementStorageClass ) * sizeOfActualPool) ;
        SgOmpParallelStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgOmpParallelStatementStorageClass* storageArray = storageArraySgOmpParallelStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgOmpParallelStatement* tmp = new SgOmpParallelStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgOmpParallelStatement;  
      SgOmpParallelStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgOmpSectionStatement ); 
     storageClassIndex = 0 ;
     SgOmpSectionStatementStorageClass* storageArraySgOmpSectionStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgOmpSectionStatement = new SgOmpSectionStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgOmpSectionStatement) , sizeof ( SgOmpSectionStatementStorageClass ) * sizeOfActualPool) ;
        SgOmpSectionStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgOmpSectionStatementStorageClass* storageArray = storageArraySgOmpSectionStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgOmpSectionStatement* tmp = new SgOmpSectionStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgOmpSectionStatement;  
      SgOmpSectionStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgOmpSectionsStatement ); 
     storageClassIndex = 0 ;
     SgOmpSectionsStatementStorageClass* storageArraySgOmpSectionsStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgOmpSectionsStatement = new SgOmpSectionsStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgOmpSectionsStatement) , sizeof ( SgOmpSectionsStatementStorageClass ) * sizeOfActualPool) ;
        SgOmpSectionsStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgOmpSectionsStatementStorageClass* storageArray = storageArraySgOmpSectionsStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgOmpSectionsStatement* tmp = new SgOmpSectionsStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgOmpSectionsStatement;  
      SgOmpSectionsStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgOmpSingleStatement ); 
     storageClassIndex = 0 ;
     SgOmpSingleStatementStorageClass* storageArraySgOmpSingleStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgOmpSingleStatement = new SgOmpSingleStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgOmpSingleStatement) , sizeof ( SgOmpSingleStatementStorageClass ) * sizeOfActualPool) ;
        SgOmpSingleStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgOmpSingleStatementStorageClass* storageArray = storageArraySgOmpSingleStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgOmpSingleStatement* tmp = new SgOmpSingleStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgOmpSingleStatement;  
      SgOmpSingleStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgOmpTaskStatement ); 
     storageClassIndex = 0 ;
     SgOmpTaskStatementStorageClass* storageArraySgOmpTaskStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgOmpTaskStatement = new SgOmpTaskStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgOmpTaskStatement) , sizeof ( SgOmpTaskStatementStorageClass ) * sizeOfActualPool) ;
        SgOmpTaskStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgOmpTaskStatementStorageClass* storageArray = storageArraySgOmpTaskStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgOmpTaskStatement* tmp = new SgOmpTaskStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgOmpTaskStatement;  
      SgOmpTaskStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgOmpTaskwaitStatement ); 
     storageClassIndex = 0 ;
     SgOmpTaskwaitStatementStorageClass* storageArraySgOmpTaskwaitStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgOmpTaskwaitStatement = new SgOmpTaskwaitStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgOmpTaskwaitStatement) , sizeof ( SgOmpTaskwaitStatementStorageClass ) * sizeOfActualPool) ;
        SgOmpTaskwaitStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgOmpTaskwaitStatementStorageClass* storageArray = storageArraySgOmpTaskwaitStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgOmpTaskwaitStatement* tmp = new SgOmpTaskwaitStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgOmpTaskwaitStatement;  
      SgOmpTaskwaitStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgOmpThreadprivateStatement ); 
     storageClassIndex = 0 ;
     SgOmpThreadprivateStatementStorageClass* storageArraySgOmpThreadprivateStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgOmpThreadprivateStatement = new SgOmpThreadprivateStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgOmpThreadprivateStatement) , sizeof ( SgOmpThreadprivateStatementStorageClass ) * sizeOfActualPool) ;
        SgOmpThreadprivateStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgOmpThreadprivateStatementStorageClass* storageArray = storageArraySgOmpThreadprivateStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgOmpThreadprivateStatement* tmp = new SgOmpThreadprivateStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgOmpThreadprivateStatement;  
      SgOmpThreadprivateStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgOmpWorkshareStatement ); 
     storageClassIndex = 0 ;
     SgOmpWorkshareStatementStorageClass* storageArraySgOmpWorkshareStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgOmpWorkshareStatement = new SgOmpWorkshareStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgOmpWorkshareStatement) , sizeof ( SgOmpWorkshareStatementStorageClass ) * sizeOfActualPool) ;
        SgOmpWorkshareStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgOmpWorkshareStatementStorageClass* storageArray = storageArraySgOmpWorkshareStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgOmpWorkshareStatement* tmp = new SgOmpWorkshareStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgOmpWorkshareStatement;  
      SgOmpWorkshareStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgOmpClause ); 
     storageClassIndex = 0 ;
     SgOmpClauseStorageClass* storageArraySgOmpClause = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgOmpClause = new SgOmpClauseStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgOmpClause) , sizeof ( SgOmpClauseStorageClass ) * sizeOfActualPool) ;
        SgOmpClauseStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgOmpClauseStorageClass* storageArray = storageArraySgOmpClause;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgOmpClause* tmp = new SgOmpClause ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgOmpClause;  
      SgOmpClauseStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgOmpCollapseClause ); 
     storageClassIndex = 0 ;
     SgOmpCollapseClauseStorageClass* storageArraySgOmpCollapseClause = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgOmpCollapseClause = new SgOmpCollapseClauseStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgOmpCollapseClause) , sizeof ( SgOmpCollapseClauseStorageClass ) * sizeOfActualPool) ;
        SgOmpCollapseClauseStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgOmpCollapseClauseStorageClass* storageArray = storageArraySgOmpCollapseClause;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgOmpCollapseClause* tmp = new SgOmpCollapseClause ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgOmpCollapseClause;  
      SgOmpCollapseClauseStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgOmpCopyinClause ); 
     storageClassIndex = 0 ;
     SgOmpCopyinClauseStorageClass* storageArraySgOmpCopyinClause = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgOmpCopyinClause = new SgOmpCopyinClauseStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgOmpCopyinClause) , sizeof ( SgOmpCopyinClauseStorageClass ) * sizeOfActualPool) ;
        SgOmpCopyinClauseStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgOmpCopyinClauseStorageClass* storageArray = storageArraySgOmpCopyinClause;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgOmpCopyinClause* tmp = new SgOmpCopyinClause ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgOmpCopyinClause;  
      SgOmpCopyinClauseStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgOmpCopyprivateClause ); 
     storageClassIndex = 0 ;
     SgOmpCopyprivateClauseStorageClass* storageArraySgOmpCopyprivateClause = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgOmpCopyprivateClause = new SgOmpCopyprivateClauseStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgOmpCopyprivateClause) , sizeof ( SgOmpCopyprivateClauseStorageClass ) * sizeOfActualPool) ;
        SgOmpCopyprivateClauseStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgOmpCopyprivateClauseStorageClass* storageArray = storageArraySgOmpCopyprivateClause;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgOmpCopyprivateClause* tmp = new SgOmpCopyprivateClause ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgOmpCopyprivateClause;  
      SgOmpCopyprivateClauseStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgOmpDefaultClause ); 
     storageClassIndex = 0 ;
     SgOmpDefaultClauseStorageClass* storageArraySgOmpDefaultClause = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgOmpDefaultClause = new SgOmpDefaultClauseStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgOmpDefaultClause) , sizeof ( SgOmpDefaultClauseStorageClass ) * sizeOfActualPool) ;
        SgOmpDefaultClauseStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgOmpDefaultClauseStorageClass* storageArray = storageArraySgOmpDefaultClause;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgOmpDefaultClause* tmp = new SgOmpDefaultClause ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgOmpDefaultClause;  
      SgOmpDefaultClauseStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgOmpExpressionClause ); 
     storageClassIndex = 0 ;
     SgOmpExpressionClauseStorageClass* storageArraySgOmpExpressionClause = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgOmpExpressionClause = new SgOmpExpressionClauseStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgOmpExpressionClause) , sizeof ( SgOmpExpressionClauseStorageClass ) * sizeOfActualPool) ;
        SgOmpExpressionClauseStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgOmpExpressionClauseStorageClass* storageArray = storageArraySgOmpExpressionClause;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgOmpExpressionClause* tmp = new SgOmpExpressionClause ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgOmpExpressionClause;  
      SgOmpExpressionClauseStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgOmpFirstprivateClause ); 
     storageClassIndex = 0 ;
     SgOmpFirstprivateClauseStorageClass* storageArraySgOmpFirstprivateClause = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgOmpFirstprivateClause = new SgOmpFirstprivateClauseStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgOmpFirstprivateClause) , sizeof ( SgOmpFirstprivateClauseStorageClass ) * sizeOfActualPool) ;
        SgOmpFirstprivateClauseStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgOmpFirstprivateClauseStorageClass* storageArray = storageArraySgOmpFirstprivateClause;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgOmpFirstprivateClause* tmp = new SgOmpFirstprivateClause ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgOmpFirstprivateClause;  
      SgOmpFirstprivateClauseStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgOmpIfClause ); 
     storageClassIndex = 0 ;
     SgOmpIfClauseStorageClass* storageArraySgOmpIfClause = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgOmpIfClause = new SgOmpIfClauseStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgOmpIfClause) , sizeof ( SgOmpIfClauseStorageClass ) * sizeOfActualPool) ;
        SgOmpIfClauseStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgOmpIfClauseStorageClass* storageArray = storageArraySgOmpIfClause;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgOmpIfClause* tmp = new SgOmpIfClause ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgOmpIfClause;  
      SgOmpIfClauseStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgOmpLastprivateClause ); 
     storageClassIndex = 0 ;
     SgOmpLastprivateClauseStorageClass* storageArraySgOmpLastprivateClause = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgOmpLastprivateClause = new SgOmpLastprivateClauseStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgOmpLastprivateClause) , sizeof ( SgOmpLastprivateClauseStorageClass ) * sizeOfActualPool) ;
        SgOmpLastprivateClauseStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgOmpLastprivateClauseStorageClass* storageArray = storageArraySgOmpLastprivateClause;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgOmpLastprivateClause* tmp = new SgOmpLastprivateClause ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgOmpLastprivateClause;  
      SgOmpLastprivateClauseStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgOmpNowaitClause ); 
     storageClassIndex = 0 ;
     SgOmpNowaitClauseStorageClass* storageArraySgOmpNowaitClause = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgOmpNowaitClause = new SgOmpNowaitClauseStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgOmpNowaitClause) , sizeof ( SgOmpNowaitClauseStorageClass ) * sizeOfActualPool) ;
        SgOmpNowaitClauseStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgOmpNowaitClauseStorageClass* storageArray = storageArraySgOmpNowaitClause;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgOmpNowaitClause* tmp = new SgOmpNowaitClause ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgOmpNowaitClause;  
      SgOmpNowaitClauseStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgOmpNumThreadsClause ); 
     storageClassIndex = 0 ;
     SgOmpNumThreadsClauseStorageClass* storageArraySgOmpNumThreadsClause = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgOmpNumThreadsClause = new SgOmpNumThreadsClauseStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgOmpNumThreadsClause) , sizeof ( SgOmpNumThreadsClauseStorageClass ) * sizeOfActualPool) ;
        SgOmpNumThreadsClauseStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgOmpNumThreadsClauseStorageClass* storageArray = storageArraySgOmpNumThreadsClause;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgOmpNumThreadsClause* tmp = new SgOmpNumThreadsClause ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgOmpNumThreadsClause;  
      SgOmpNumThreadsClauseStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgOmpOrderedClause ); 
     storageClassIndex = 0 ;
     SgOmpOrderedClauseStorageClass* storageArraySgOmpOrderedClause = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgOmpOrderedClause = new SgOmpOrderedClauseStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgOmpOrderedClause) , sizeof ( SgOmpOrderedClauseStorageClass ) * sizeOfActualPool) ;
        SgOmpOrderedClauseStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgOmpOrderedClauseStorageClass* storageArray = storageArraySgOmpOrderedClause;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgOmpOrderedClause* tmp = new SgOmpOrderedClause ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgOmpOrderedClause;  
      SgOmpOrderedClauseStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgOmpPrivateClause ); 
     storageClassIndex = 0 ;
     SgOmpPrivateClauseStorageClass* storageArraySgOmpPrivateClause = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgOmpPrivateClause = new SgOmpPrivateClauseStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgOmpPrivateClause) , sizeof ( SgOmpPrivateClauseStorageClass ) * sizeOfActualPool) ;
        SgOmpPrivateClauseStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgOmpPrivateClauseStorageClass* storageArray = storageArraySgOmpPrivateClause;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgOmpPrivateClause* tmp = new SgOmpPrivateClause ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgOmpPrivateClause;  
      SgOmpPrivateClauseStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgOmpReductionClause ); 
     storageClassIndex = 0 ;
     SgOmpReductionClauseStorageClass* storageArraySgOmpReductionClause = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgOmpReductionClause = new SgOmpReductionClauseStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgOmpReductionClause) , sizeof ( SgOmpReductionClauseStorageClass ) * sizeOfActualPool) ;
        SgOmpReductionClauseStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgOmpReductionClauseStorageClass* storageArray = storageArraySgOmpReductionClause;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgOmpReductionClause* tmp = new SgOmpReductionClause ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgOmpReductionClause;  
      SgOmpReductionClauseStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgOmpScheduleClause ); 
     storageClassIndex = 0 ;
     SgOmpScheduleClauseStorageClass* storageArraySgOmpScheduleClause = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgOmpScheduleClause = new SgOmpScheduleClauseStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgOmpScheduleClause) , sizeof ( SgOmpScheduleClauseStorageClass ) * sizeOfActualPool) ;
        SgOmpScheduleClauseStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgOmpScheduleClauseStorageClass* storageArray = storageArraySgOmpScheduleClause;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgOmpScheduleClause* tmp = new SgOmpScheduleClause ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgOmpScheduleClause;  
      SgOmpScheduleClauseStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgOmpSharedClause ); 
     storageClassIndex = 0 ;
     SgOmpSharedClauseStorageClass* storageArraySgOmpSharedClause = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgOmpSharedClause = new SgOmpSharedClauseStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgOmpSharedClause) , sizeof ( SgOmpSharedClauseStorageClass ) * sizeOfActualPool) ;
        SgOmpSharedClauseStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgOmpSharedClauseStorageClass* storageArray = storageArraySgOmpSharedClause;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgOmpSharedClause* tmp = new SgOmpSharedClause ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgOmpSharedClause;  
      SgOmpSharedClauseStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgOmpUntiedClause ); 
     storageClassIndex = 0 ;
     SgOmpUntiedClauseStorageClass* storageArraySgOmpUntiedClause = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgOmpUntiedClause = new SgOmpUntiedClauseStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgOmpUntiedClause) , sizeof ( SgOmpUntiedClauseStorageClass ) * sizeOfActualPool) ;
        SgOmpUntiedClauseStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgOmpUntiedClauseStorageClass* storageArray = storageArraySgOmpUntiedClause;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgOmpUntiedClause* tmp = new SgOmpUntiedClause ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgOmpUntiedClause;  
      SgOmpUntiedClauseStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgOmpVariablesClause ); 
     storageClassIndex = 0 ;
     SgOmpVariablesClauseStorageClass* storageArraySgOmpVariablesClause = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgOmpVariablesClause = new SgOmpVariablesClauseStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgOmpVariablesClause) , sizeof ( SgOmpVariablesClauseStorageClass ) * sizeOfActualPool) ;
        SgOmpVariablesClauseStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgOmpVariablesClauseStorageClass* storageArray = storageArraySgOmpVariablesClause;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgOmpVariablesClause* tmp = new SgOmpVariablesClause ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgOmpVariablesClause;  
      SgOmpVariablesClauseStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgOpenclAccessModeModifier ); 
     storageClassIndex = 0 ;
     SgOpenclAccessModeModifierStorageClass* storageArraySgOpenclAccessModeModifier = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgOpenclAccessModeModifier = new SgOpenclAccessModeModifierStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgOpenclAccessModeModifier) , sizeof ( SgOpenclAccessModeModifierStorageClass ) * sizeOfActualPool) ;
          SgOpenclAccessModeModifierStorageClass* storageArray = storageArraySgOpenclAccessModeModifier;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgOpenclAccessModeModifier* tmp = new SgOpenclAccessModeModifier ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgOpenclAccessModeModifier;  


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgOpenStatement ); 
     storageClassIndex = 0 ;
     SgOpenStatementStorageClass* storageArraySgOpenStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgOpenStatement = new SgOpenStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgOpenStatement) , sizeof ( SgOpenStatementStorageClass ) * sizeOfActualPool) ;
        SgOpenStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgOpenStatementStorageClass* storageArray = storageArraySgOpenStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgOpenStatement* tmp = new SgOpenStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgOpenStatement;  
      SgOpenStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgOptions ); 
     storageClassIndex = 0 ;
     SgOptionsStorageClass* storageArraySgOptions = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgOptions = new SgOptionsStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgOptions) , sizeof ( SgOptionsStorageClass ) * sizeOfActualPool) ;
          SgOptionsStorageClass* storageArray = storageArraySgOptions;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgOptions* tmp = new SgOptions ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgOptions;  


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgOrOp ); 
     storageClassIndex = 0 ;
     SgOrOpStorageClass* storageArraySgOrOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgOrOp = new SgOrOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgOrOp) , sizeof ( SgOrOpStorageClass ) * sizeOfActualPool) ;
        SgOrOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgOrOpStorageClass* storageArray = storageArraySgOrOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgOrOp* tmp = new SgOrOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgOrOp;  
      SgOrOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgParameterStatement ); 
     storageClassIndex = 0 ;
     SgParameterStatementStorageClass* storageArraySgParameterStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgParameterStatement = new SgParameterStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgParameterStatement) , sizeof ( SgParameterStatementStorageClass ) * sizeOfActualPool) ;
        SgParameterStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgParameterStatementStorageClass* storageArray = storageArraySgParameterStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgParameterStatement* tmp = new SgParameterStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgParameterStatement;  
      SgParameterStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgPartialFunctionModifierType ); 
     storageClassIndex = 0 ;
     SgPartialFunctionModifierTypeStorageClass* storageArraySgPartialFunctionModifierType = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgPartialFunctionModifierType = new SgPartialFunctionModifierTypeStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgPartialFunctionModifierType) , sizeof ( SgPartialFunctionModifierTypeStorageClass ) * sizeOfActualPool) ;
        SgPartialFunctionModifierTypeStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgPartialFunctionModifierTypeStorageClass* storageArray = storageArraySgPartialFunctionModifierType;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgPartialFunctionModifierType* tmp = new SgPartialFunctionModifierType ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgPartialFunctionModifierType;  
      SgPartialFunctionModifierTypeStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgPartialFunctionType ); 
     storageClassIndex = 0 ;
     SgPartialFunctionTypeStorageClass* storageArraySgPartialFunctionType = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgPartialFunctionType = new SgPartialFunctionTypeStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgPartialFunctionType) , sizeof ( SgPartialFunctionTypeStorageClass ) * sizeOfActualPool) ;
        SgPartialFunctionTypeStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgPartialFunctionTypeStorageClass* storageArray = storageArraySgPartialFunctionType;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgPartialFunctionType* tmp = new SgPartialFunctionType ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgPartialFunctionType;  
      SgPartialFunctionTypeStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgPassStatement ); 
     storageClassIndex = 0 ;
     SgPassStatementStorageClass* storageArraySgPassStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgPassStatement = new SgPassStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgPassStatement) , sizeof ( SgPassStatementStorageClass ) * sizeOfActualPool) ;
        SgPassStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgPassStatementStorageClass* storageArray = storageArraySgPassStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgPassStatement* tmp = new SgPassStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgPassStatement;  
      SgPassStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgPlusAssignOp ); 
     storageClassIndex = 0 ;
     SgPlusAssignOpStorageClass* storageArraySgPlusAssignOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgPlusAssignOp = new SgPlusAssignOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgPlusAssignOp) , sizeof ( SgPlusAssignOpStorageClass ) * sizeOfActualPool) ;
        SgPlusAssignOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgPlusAssignOpStorageClass* storageArray = storageArraySgPlusAssignOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgPlusAssignOp* tmp = new SgPlusAssignOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgPlusAssignOp;  
      SgPlusAssignOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgPlusPlusOp ); 
     storageClassIndex = 0 ;
     SgPlusPlusOpStorageClass* storageArraySgPlusPlusOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgPlusPlusOp = new SgPlusPlusOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgPlusPlusOp) , sizeof ( SgPlusPlusOpStorageClass ) * sizeOfActualPool) ;
        SgPlusPlusOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgPlusPlusOpStorageClass* storageArray = storageArraySgPlusPlusOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgPlusPlusOp* tmp = new SgPlusPlusOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgPlusPlusOp;  
      SgPlusPlusOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgPntrArrRefExp ); 
     storageClassIndex = 0 ;
     SgPntrArrRefExpStorageClass* storageArraySgPntrArrRefExp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgPntrArrRefExp = new SgPntrArrRefExpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgPntrArrRefExp) , sizeof ( SgPntrArrRefExpStorageClass ) * sizeOfActualPool) ;
        SgPntrArrRefExpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgPntrArrRefExpStorageClass* storageArray = storageArraySgPntrArrRefExp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgPntrArrRefExp* tmp = new SgPntrArrRefExp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgPntrArrRefExp;  
      SgPntrArrRefExpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgPointerAssignOp ); 
     storageClassIndex = 0 ;
     SgPointerAssignOpStorageClass* storageArraySgPointerAssignOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgPointerAssignOp = new SgPointerAssignOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgPointerAssignOp) , sizeof ( SgPointerAssignOpStorageClass ) * sizeOfActualPool) ;
        SgPointerAssignOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgPointerAssignOpStorageClass* storageArray = storageArraySgPointerAssignOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgPointerAssignOp* tmp = new SgPointerAssignOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgPointerAssignOp;  
      SgPointerAssignOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgPointerDerefExp ); 
     storageClassIndex = 0 ;
     SgPointerDerefExpStorageClass* storageArraySgPointerDerefExp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgPointerDerefExp = new SgPointerDerefExpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgPointerDerefExp) , sizeof ( SgPointerDerefExpStorageClass ) * sizeOfActualPool) ;
        SgPointerDerefExpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgPointerDerefExpStorageClass* storageArray = storageArraySgPointerDerefExp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgPointerDerefExp* tmp = new SgPointerDerefExp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgPointerDerefExp;  
      SgPointerDerefExpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgPointerMemberType ); 
     storageClassIndex = 0 ;
     SgPointerMemberTypeStorageClass* storageArraySgPointerMemberType = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgPointerMemberType = new SgPointerMemberTypeStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgPointerMemberType) , sizeof ( SgPointerMemberTypeStorageClass ) * sizeOfActualPool) ;
        SgPointerMemberTypeStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgPointerMemberTypeStorageClass* storageArray = storageArraySgPointerMemberType;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgPointerMemberType* tmp = new SgPointerMemberType ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgPointerMemberType;  
      SgPointerMemberTypeStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgPointerType ); 
     storageClassIndex = 0 ;
     SgPointerTypeStorageClass* storageArraySgPointerType = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgPointerType = new SgPointerTypeStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgPointerType) , sizeof ( SgPointerTypeStorageClass ) * sizeOfActualPool) ;
        SgPointerTypeStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgPointerTypeStorageClass* storageArray = storageArraySgPointerType;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgPointerType* tmp = new SgPointerType ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgPointerType;  
      SgPointerTypeStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgPragma ); 
     storageClassIndex = 0 ;
     SgPragmaStorageClass* storageArraySgPragma = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgPragma = new SgPragmaStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgPragma) , sizeof ( SgPragmaStorageClass ) * sizeOfActualPool) ;
        SgPragmaStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgPragmaStorageClass* storageArray = storageArraySgPragma;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgPragma* tmp = new SgPragma ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgPragma;  
      SgPragmaStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgPragmaDeclaration ); 
     storageClassIndex = 0 ;
     SgPragmaDeclarationStorageClass* storageArraySgPragmaDeclaration = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgPragmaDeclaration = new SgPragmaDeclarationStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgPragmaDeclaration) , sizeof ( SgPragmaDeclarationStorageClass ) * sizeOfActualPool) ;
        SgPragmaDeclarationStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgPragmaDeclarationStorageClass* storageArray = storageArraySgPragmaDeclaration;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgPragmaDeclaration* tmp = new SgPragmaDeclaration ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgPragmaDeclaration;  
      SgPragmaDeclarationStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgPrintStatement ); 
     storageClassIndex = 0 ;
     SgPrintStatementStorageClass* storageArraySgPrintStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgPrintStatement = new SgPrintStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgPrintStatement) , sizeof ( SgPrintStatementStorageClass ) * sizeOfActualPool) ;
        SgPrintStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgPrintStatementStorageClass* storageArray = storageArraySgPrintStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgPrintStatement* tmp = new SgPrintStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgPrintStatement;  
      SgPrintStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgProcedureHeaderStatement ); 
     storageClassIndex = 0 ;
     SgProcedureHeaderStatementStorageClass* storageArraySgProcedureHeaderStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgProcedureHeaderStatement = new SgProcedureHeaderStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgProcedureHeaderStatement) , sizeof ( SgProcedureHeaderStatementStorageClass ) * sizeOfActualPool) ;
        SgProcedureHeaderStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgProcedureHeaderStatementStorageClass* storageArray = storageArraySgProcedureHeaderStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgProcedureHeaderStatement* tmp = new SgProcedureHeaderStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgProcedureHeaderStatement;  
      SgProcedureHeaderStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgProgramHeaderStatement ); 
     storageClassIndex = 0 ;
     SgProgramHeaderStatementStorageClass* storageArraySgProgramHeaderStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgProgramHeaderStatement = new SgProgramHeaderStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgProgramHeaderStatement) , sizeof ( SgProgramHeaderStatementStorageClass ) * sizeOfActualPool) ;
        SgProgramHeaderStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgProgramHeaderStatementStorageClass* storageArray = storageArraySgProgramHeaderStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgProgramHeaderStatement* tmp = new SgProgramHeaderStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgProgramHeaderStatement;  
      SgProgramHeaderStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgProject ); 
     storageClassIndex = 0 ;
     SgProjectStorageClass* storageArraySgProject = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgProject = new SgProjectStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgProject) , sizeof ( SgProjectStorageClass ) * sizeOfActualPool) ;
        SgProjectStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgProjectStorageClass* storageArray = storageArraySgProject;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgProject* tmp = new SgProject ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgProject;  
      SgProjectStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgPseudoDestructorRefExp ); 
     storageClassIndex = 0 ;
     SgPseudoDestructorRefExpStorageClass* storageArraySgPseudoDestructorRefExp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgPseudoDestructorRefExp = new SgPseudoDestructorRefExpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgPseudoDestructorRefExp) , sizeof ( SgPseudoDestructorRefExpStorageClass ) * sizeOfActualPool) ;
        SgPseudoDestructorRefExpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgPseudoDestructorRefExpStorageClass* storageArray = storageArraySgPseudoDestructorRefExp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgPseudoDestructorRefExp* tmp = new SgPseudoDestructorRefExp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgPseudoDestructorRefExp;  
      SgPseudoDestructorRefExpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgPythonGlobalStmt ); 
     storageClassIndex = 0 ;
     SgPythonGlobalStmtStorageClass* storageArraySgPythonGlobalStmt = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgPythonGlobalStmt = new SgPythonGlobalStmtStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgPythonGlobalStmt) , sizeof ( SgPythonGlobalStmtStorageClass ) * sizeOfActualPool) ;
        SgPythonGlobalStmtStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgPythonGlobalStmtStorageClass* storageArray = storageArraySgPythonGlobalStmt;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgPythonGlobalStmt* tmp = new SgPythonGlobalStmt ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgPythonGlobalStmt;  
      SgPythonGlobalStmtStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgPythonPrintStmt ); 
     storageClassIndex = 0 ;
     SgPythonPrintStmtStorageClass* storageArraySgPythonPrintStmt = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgPythonPrintStmt = new SgPythonPrintStmtStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgPythonPrintStmt) , sizeof ( SgPythonPrintStmtStorageClass ) * sizeOfActualPool) ;
        SgPythonPrintStmtStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgPythonPrintStmtStorageClass* storageArray = storageArraySgPythonPrintStmt;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgPythonPrintStmt* tmp = new SgPythonPrintStmt ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgPythonPrintStmt;  
      SgPythonPrintStmtStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgQualifiedName ); 
     storageClassIndex = 0 ;
     SgQualifiedNameStorageClass* storageArraySgQualifiedName = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgQualifiedName = new SgQualifiedNameStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgQualifiedName) , sizeof ( SgQualifiedNameStorageClass ) * sizeOfActualPool) ;
          SgQualifiedNameStorageClass* storageArray = storageArraySgQualifiedName;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgQualifiedName* tmp = new SgQualifiedName ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgQualifiedName;  


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgQualifiedNameType ); 
     storageClassIndex = 0 ;
     SgQualifiedNameTypeStorageClass* storageArraySgQualifiedNameType = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgQualifiedNameType = new SgQualifiedNameTypeStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgQualifiedNameType) , sizeof ( SgQualifiedNameTypeStorageClass ) * sizeOfActualPool) ;
        SgQualifiedNameTypeStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgQualifiedNameTypeStorageClass* storageArray = storageArraySgQualifiedNameType;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgQualifiedNameType* tmp = new SgQualifiedNameType ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgQualifiedNameType;  
      SgQualifiedNameTypeStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgReadStatement ); 
     storageClassIndex = 0 ;
     SgReadStatementStorageClass* storageArraySgReadStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgReadStatement = new SgReadStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgReadStatement) , sizeof ( SgReadStatementStorageClass ) * sizeOfActualPool) ;
        SgReadStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgReadStatementStorageClass* storageArray = storageArraySgReadStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgReadStatement* tmp = new SgReadStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgReadStatement;  
      SgReadStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgRealPartOp ); 
     storageClassIndex = 0 ;
     SgRealPartOpStorageClass* storageArraySgRealPartOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgRealPartOp = new SgRealPartOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgRealPartOp) , sizeof ( SgRealPartOpStorageClass ) * sizeOfActualPool) ;
        SgRealPartOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgRealPartOpStorageClass* storageArray = storageArraySgRealPartOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgRealPartOp* tmp = new SgRealPartOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgRealPartOp;  
      SgRealPartOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgRefExp ); 
     storageClassIndex = 0 ;
     SgRefExpStorageClass* storageArraySgRefExp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgRefExp = new SgRefExpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgRefExp) , sizeof ( SgRefExpStorageClass ) * sizeOfActualPool) ;
        SgRefExpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgRefExpStorageClass* storageArray = storageArraySgRefExp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgRefExp* tmp = new SgRefExp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgRefExp;  
      SgRefExpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgReferenceType ); 
     storageClassIndex = 0 ;
     SgReferenceTypeStorageClass* storageArraySgReferenceType = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgReferenceType = new SgReferenceTypeStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgReferenceType) , sizeof ( SgReferenceTypeStorageClass ) * sizeOfActualPool) ;
        SgReferenceTypeStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgReferenceTypeStorageClass* storageArray = storageArraySgReferenceType;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgReferenceType* tmp = new SgReferenceType ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgReferenceType;  
      SgReferenceTypeStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgRenamePair ); 
     storageClassIndex = 0 ;
     SgRenamePairStorageClass* storageArraySgRenamePair = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgRenamePair = new SgRenamePairStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgRenamePair) , sizeof ( SgRenamePairStorageClass ) * sizeOfActualPool) ;
        SgRenamePairStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgRenamePairStorageClass* storageArray = storageArraySgRenamePair;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgRenamePair* tmp = new SgRenamePair ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgRenamePair;  
      SgRenamePairStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgRenameSymbol ); 
     storageClassIndex = 0 ;
     SgRenameSymbolStorageClass* storageArraySgRenameSymbol = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgRenameSymbol = new SgRenameSymbolStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgRenameSymbol) , sizeof ( SgRenameSymbolStorageClass ) * sizeOfActualPool) ;
        SgRenameSymbolStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgRenameSymbolStorageClass* storageArray = storageArraySgRenameSymbol;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgRenameSymbol* tmp = new SgRenameSymbol ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgRenameSymbol;  
      SgRenameSymbolStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgReturnStmt ); 
     storageClassIndex = 0 ;
     SgReturnStmtStorageClass* storageArraySgReturnStmt = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgReturnStmt = new SgReturnStmtStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgReturnStmt) , sizeof ( SgReturnStmtStorageClass ) * sizeOfActualPool) ;
        SgReturnStmtStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgReturnStmtStorageClass* storageArray = storageArraySgReturnStmt;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgReturnStmt* tmp = new SgReturnStmt ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgReturnStmt;  
      SgReturnStmtStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgRewindStatement ); 
     storageClassIndex = 0 ;
     SgRewindStatementStorageClass* storageArraySgRewindStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgRewindStatement = new SgRewindStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgRewindStatement) , sizeof ( SgRewindStatementStorageClass ) * sizeOfActualPool) ;
        SgRewindStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgRewindStatementStorageClass* storageArray = storageArraySgRewindStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgRewindStatement* tmp = new SgRewindStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgRewindStatement;  
      SgRewindStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgRshiftAssignOp ); 
     storageClassIndex = 0 ;
     SgRshiftAssignOpStorageClass* storageArraySgRshiftAssignOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgRshiftAssignOp = new SgRshiftAssignOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgRshiftAssignOp) , sizeof ( SgRshiftAssignOpStorageClass ) * sizeOfActualPool) ;
        SgRshiftAssignOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgRshiftAssignOpStorageClass* storageArray = storageArraySgRshiftAssignOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgRshiftAssignOp* tmp = new SgRshiftAssignOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgRshiftAssignOp;  
      SgRshiftAssignOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgRshiftOp ); 
     storageClassIndex = 0 ;
     SgRshiftOpStorageClass* storageArraySgRshiftOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgRshiftOp = new SgRshiftOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgRshiftOp) , sizeof ( SgRshiftOpStorageClass ) * sizeOfActualPool) ;
        SgRshiftOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgRshiftOpStorageClass* storageArray = storageArraySgRshiftOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgRshiftOp* tmp = new SgRshiftOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgRshiftOp;  
      SgRshiftOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgJavaUnsignedRshiftAssignOp ); 
     storageClassIndex = 0 ;
     SgJavaUnsignedRshiftAssignOpStorageClass* storageArraySgJavaUnsignedRshiftAssignOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgJavaUnsignedRshiftAssignOp = new SgJavaUnsignedRshiftAssignOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgJavaUnsignedRshiftAssignOp) , sizeof ( SgJavaUnsignedRshiftAssignOpStorageClass ) * sizeOfActualPool) ;
        SgJavaUnsignedRshiftAssignOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgJavaUnsignedRshiftAssignOpStorageClass* storageArray = storageArraySgJavaUnsignedRshiftAssignOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgJavaUnsignedRshiftAssignOp* tmp = new SgJavaUnsignedRshiftAssignOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgJavaUnsignedRshiftAssignOp;  
      SgJavaUnsignedRshiftAssignOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgJavaUnsignedRshiftOp ); 
     storageClassIndex = 0 ;
     SgJavaUnsignedRshiftOpStorageClass* storageArraySgJavaUnsignedRshiftOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgJavaUnsignedRshiftOp = new SgJavaUnsignedRshiftOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgJavaUnsignedRshiftOp) , sizeof ( SgJavaUnsignedRshiftOpStorageClass ) * sizeOfActualPool) ;
        SgJavaUnsignedRshiftOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgJavaUnsignedRshiftOpStorageClass* storageArray = storageArraySgJavaUnsignedRshiftOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgJavaUnsignedRshiftOp* tmp = new SgJavaUnsignedRshiftOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgJavaUnsignedRshiftOp;  
      SgJavaUnsignedRshiftOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgScopeOp ); 
     storageClassIndex = 0 ;
     SgScopeOpStorageClass* storageArraySgScopeOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgScopeOp = new SgScopeOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgScopeOp) , sizeof ( SgScopeOpStorageClass ) * sizeOfActualPool) ;
        SgScopeOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgScopeOpStorageClass* storageArray = storageArraySgScopeOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgScopeOp* tmp = new SgScopeOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgScopeOp;  
      SgScopeOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgScopeStatement ); 
     storageClassIndex = 0 ;
     SgScopeStatementStorageClass* storageArraySgScopeStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgScopeStatement = new SgScopeStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgScopeStatement) , sizeof ( SgScopeStatementStorageClass ) * sizeOfActualPool) ;
        SgScopeStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgScopeStatementStorageClass* storageArray = storageArraySgScopeStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgScopeStatement* tmp = new SgScopeStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgScopeStatement;  
      SgScopeStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgSequenceStatement ); 
     storageClassIndex = 0 ;
     SgSequenceStatementStorageClass* storageArraySgSequenceStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgSequenceStatement = new SgSequenceStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgSequenceStatement) , sizeof ( SgSequenceStatementStorageClass ) * sizeOfActualPool) ;
        SgSequenceStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgSequenceStatementStorageClass* storageArray = storageArraySgSequenceStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgSequenceStatement* tmp = new SgSequenceStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgSequenceStatement;  
      SgSequenceStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgSetComprehension ); 
     storageClassIndex = 0 ;
     SgSetComprehensionStorageClass* storageArraySgSetComprehension = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgSetComprehension = new SgSetComprehensionStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgSetComprehension) , sizeof ( SgSetComprehensionStorageClass ) * sizeOfActualPool) ;
        SgSetComprehensionStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgSetComprehensionStorageClass* storageArray = storageArraySgSetComprehension;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgSetComprehension* tmp = new SgSetComprehension ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgSetComprehension;  
      SgSetComprehensionStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgShortVal ); 
     storageClassIndex = 0 ;
     SgShortValStorageClass* storageArraySgShortVal = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgShortVal = new SgShortValStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgShortVal) , sizeof ( SgShortValStorageClass ) * sizeOfActualPool) ;
        SgShortValStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgShortValStorageClass* storageArray = storageArraySgShortVal;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgShortVal* tmp = new SgShortVal ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgShortVal;  
      SgShortValStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgSizeOfOp ); 
     storageClassIndex = 0 ;
     SgSizeOfOpStorageClass* storageArraySgSizeOfOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgSizeOfOp = new SgSizeOfOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgSizeOfOp) , sizeof ( SgSizeOfOpStorageClass ) * sizeOfActualPool) ;
        SgSizeOfOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgSizeOfOpStorageClass* storageArray = storageArraySgSizeOfOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgSizeOfOp* tmp = new SgSizeOfOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgSizeOfOp;  
      SgSizeOfOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgJavaInstanceOfOp ); 
     storageClassIndex = 0 ;
     SgJavaInstanceOfOpStorageClass* storageArraySgJavaInstanceOfOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgJavaInstanceOfOp = new SgJavaInstanceOfOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgJavaInstanceOfOp) , sizeof ( SgJavaInstanceOfOpStorageClass ) * sizeOfActualPool) ;
        SgJavaInstanceOfOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgJavaInstanceOfOpStorageClass* storageArray = storageArraySgJavaInstanceOfOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgJavaInstanceOfOp* tmp = new SgJavaInstanceOfOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgJavaInstanceOfOp;  
      SgJavaInstanceOfOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgSourceFile ); 
     storageClassIndex = 0 ;
     SgSourceFileStorageClass* storageArraySgSourceFile = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgSourceFile = new SgSourceFileStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgSourceFile) , sizeof ( SgSourceFileStorageClass ) * sizeOfActualPool) ;
        SgSourceFileStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgSourceFileStorageClass* storageArray = storageArraySgSourceFile;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgSourceFile* tmp = new SgSourceFile ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgSourceFile;  
      SgSourceFileStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgSpawnStmt ); 
     storageClassIndex = 0 ;
     SgSpawnStmtStorageClass* storageArraySgSpawnStmt = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgSpawnStmt = new SgSpawnStmtStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgSpawnStmt) , sizeof ( SgSpawnStmtStorageClass ) * sizeOfActualPool) ;
        SgSpawnStmtStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgSpawnStmtStorageClass* storageArray = storageArraySgSpawnStmt;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgSpawnStmt* tmp = new SgSpawnStmt ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgSpawnStmt;  
      SgSpawnStmtStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgJavaThrowStatement ); 
     storageClassIndex = 0 ;
     SgJavaThrowStatementStorageClass* storageArraySgJavaThrowStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgJavaThrowStatement = new SgJavaThrowStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgJavaThrowStatement) , sizeof ( SgJavaThrowStatementStorageClass ) * sizeOfActualPool) ;
        SgJavaThrowStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgJavaThrowStatementStorageClass* storageArray = storageArraySgJavaThrowStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgJavaThrowStatement* tmp = new SgJavaThrowStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgJavaThrowStatement;  
      SgJavaThrowStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgJavaForEachStatement ); 
     storageClassIndex = 0 ;
     SgJavaForEachStatementStorageClass* storageArraySgJavaForEachStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgJavaForEachStatement = new SgJavaForEachStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgJavaForEachStatement) , sizeof ( SgJavaForEachStatementStorageClass ) * sizeOfActualPool) ;
        SgJavaForEachStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgJavaForEachStatementStorageClass* storageArray = storageArraySgJavaForEachStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgJavaForEachStatement* tmp = new SgJavaForEachStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgJavaForEachStatement;  
      SgJavaForEachStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgJavaSynchronizedStatement ); 
     storageClassIndex = 0 ;
     SgJavaSynchronizedStatementStorageClass* storageArraySgJavaSynchronizedStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgJavaSynchronizedStatement = new SgJavaSynchronizedStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgJavaSynchronizedStatement) , sizeof ( SgJavaSynchronizedStatementStorageClass ) * sizeOfActualPool) ;
        SgJavaSynchronizedStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgJavaSynchronizedStatementStorageClass* storageArray = storageArraySgJavaSynchronizedStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgJavaSynchronizedStatement* tmp = new SgJavaSynchronizedStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgJavaSynchronizedStatement;  
      SgJavaSynchronizedStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgJavaParameterizedType ); 
     storageClassIndex = 0 ;
     SgJavaParameterizedTypeStorageClass* storageArraySgJavaParameterizedType = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgJavaParameterizedType = new SgJavaParameterizedTypeStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgJavaParameterizedType) , sizeof ( SgJavaParameterizedTypeStorageClass ) * sizeOfActualPool) ;
        SgJavaParameterizedTypeStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgJavaParameterizedTypeStorageClass* storageArray = storageArraySgJavaParameterizedType;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgJavaParameterizedType* tmp = new SgJavaParameterizedType ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgJavaParameterizedType;  
      SgJavaParameterizedTypeStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgSpecialFunctionModifier ); 
     storageClassIndex = 0 ;
     SgSpecialFunctionModifierStorageClass* storageArraySgSpecialFunctionModifier = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgSpecialFunctionModifier = new SgSpecialFunctionModifierStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgSpecialFunctionModifier) , sizeof ( SgSpecialFunctionModifierStorageClass ) * sizeOfActualPool) ;
        SgSpecialFunctionModifierStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgSpecialFunctionModifierStorageClass* storageArray = storageArraySgSpecialFunctionModifier;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgSpecialFunctionModifier* tmp = new SgSpecialFunctionModifier ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgSpecialFunctionModifier;  
      SgSpecialFunctionModifierStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgStatement ); 
     storageClassIndex = 0 ;
     SgStatementStorageClass* storageArraySgStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgStatement = new SgStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgStatement) , sizeof ( SgStatementStorageClass ) * sizeOfActualPool) ;
        SgStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgStatementStorageClass* storageArray = storageArraySgStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgStatement* tmp = new SgStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgStatement;  
      SgStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgStmtDeclarationStatement ); 
     storageClassIndex = 0 ;
     SgStmtDeclarationStatementStorageClass* storageArraySgStmtDeclarationStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgStmtDeclarationStatement = new SgStmtDeclarationStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgStmtDeclarationStatement) , sizeof ( SgStmtDeclarationStatementStorageClass ) * sizeOfActualPool) ;
        SgStmtDeclarationStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgStmtDeclarationStatementStorageClass* storageArray = storageArraySgStmtDeclarationStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgStmtDeclarationStatement* tmp = new SgStmtDeclarationStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgStmtDeclarationStatement;  
      SgStmtDeclarationStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgStatementExpression ); 
     storageClassIndex = 0 ;
     SgStatementExpressionStorageClass* storageArraySgStatementExpression = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgStatementExpression = new SgStatementExpressionStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgStatementExpression) , sizeof ( SgStatementExpressionStorageClass ) * sizeOfActualPool) ;
        SgStatementExpressionStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgStatementExpressionStorageClass* storageArray = storageArraySgStatementExpression;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgStatementExpression* tmp = new SgStatementExpression ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgStatementExpression;  
      SgStatementExpressionStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgStatementFunctionStatement ); 
     storageClassIndex = 0 ;
     SgStatementFunctionStatementStorageClass* storageArraySgStatementFunctionStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgStatementFunctionStatement = new SgStatementFunctionStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgStatementFunctionStatement) , sizeof ( SgStatementFunctionStatementStorageClass ) * sizeOfActualPool) ;
        SgStatementFunctionStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgStatementFunctionStatementStorageClass* storageArray = storageArraySgStatementFunctionStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgStatementFunctionStatement* tmp = new SgStatementFunctionStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgStatementFunctionStatement;  
      SgStatementFunctionStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgStopOrPauseStatement ); 
     storageClassIndex = 0 ;
     SgStopOrPauseStatementStorageClass* storageArraySgStopOrPauseStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgStopOrPauseStatement = new SgStopOrPauseStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgStopOrPauseStatement) , sizeof ( SgStopOrPauseStatementStorageClass ) * sizeOfActualPool) ;
        SgStopOrPauseStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgStopOrPauseStatementStorageClass* storageArray = storageArraySgStopOrPauseStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgStopOrPauseStatement* tmp = new SgStopOrPauseStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgStopOrPauseStatement;  
      SgStopOrPauseStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgStorageModifier ); 
     storageClassIndex = 0 ;
     SgStorageModifierStorageClass* storageArraySgStorageModifier = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgStorageModifier = new SgStorageModifierStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgStorageModifier) , sizeof ( SgStorageModifierStorageClass ) * sizeOfActualPool) ;
          SgStorageModifierStorageClass* storageArray = storageArraySgStorageModifier;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgStorageModifier* tmp = new SgStorageModifier ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgStorageModifier;  


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgStringConversion ); 
     storageClassIndex = 0 ;
     SgStringConversionStorageClass* storageArraySgStringConversion = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgStringConversion = new SgStringConversionStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgStringConversion) , sizeof ( SgStringConversionStorageClass ) * sizeOfActualPool) ;
        SgStringConversionStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgStringConversionStorageClass* storageArray = storageArraySgStringConversion;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgStringConversion* tmp = new SgStringConversion ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgStringConversion;  
      SgStringConversionStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgStringKeyedBidirectionalGraph ); 
     storageClassIndex = 0 ;
     SgStringKeyedBidirectionalGraphStorageClass* storageArraySgStringKeyedBidirectionalGraph = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgStringKeyedBidirectionalGraph = new SgStringKeyedBidirectionalGraphStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgStringKeyedBidirectionalGraph) , sizeof ( SgStringKeyedBidirectionalGraphStorageClass ) * sizeOfActualPool) ;
        SgStringKeyedBidirectionalGraphStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgStringKeyedBidirectionalGraphStorageClass* storageArray = storageArraySgStringKeyedBidirectionalGraph;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgStringKeyedBidirectionalGraph* tmp = new SgStringKeyedBidirectionalGraph ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgStringKeyedBidirectionalGraph;  
      SgStringKeyedBidirectionalGraphStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgStringVal ); 
     storageClassIndex = 0 ;
     SgStringValStorageClass* storageArraySgStringVal = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgStringVal = new SgStringValStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgStringVal) , sizeof ( SgStringValStorageClass ) * sizeOfActualPool) ;
        SgStringValStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgStringValStorageClass* storageArray = storageArraySgStringVal;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgStringVal* tmp = new SgStringVal ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgStringVal;  
      SgStringValStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgSubscriptExpression ); 
     storageClassIndex = 0 ;
     SgSubscriptExpressionStorageClass* storageArraySgSubscriptExpression = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgSubscriptExpression = new SgSubscriptExpressionStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgSubscriptExpression) , sizeof ( SgSubscriptExpressionStorageClass ) * sizeOfActualPool) ;
        SgSubscriptExpressionStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgSubscriptExpressionStorageClass* storageArray = storageArraySgSubscriptExpression;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgSubscriptExpression* tmp = new SgSubscriptExpression ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgSubscriptExpression;  
      SgSubscriptExpressionStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgSubtractOp ); 
     storageClassIndex = 0 ;
     SgSubtractOpStorageClass* storageArraySgSubtractOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgSubtractOp = new SgSubtractOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgSubtractOp) , sizeof ( SgSubtractOpStorageClass ) * sizeOfActualPool) ;
        SgSubtractOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgSubtractOpStorageClass* storageArray = storageArraySgSubtractOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgSubtractOp* tmp = new SgSubtractOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgSubtractOp;  
      SgSubtractOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgSupport ); 
     storageClassIndex = 0 ;
     SgSupportStorageClass* storageArraySgSupport = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgSupport = new SgSupportStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgSupport) , sizeof ( SgSupportStorageClass ) * sizeOfActualPool) ;
          SgSupportStorageClass* storageArray = storageArraySgSupport;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgSupport* tmp = new SgSupport ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgSupport;  


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgSwitchStatement ); 
     storageClassIndex = 0 ;
     SgSwitchStatementStorageClass* storageArraySgSwitchStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgSwitchStatement = new SgSwitchStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgSwitchStatement) , sizeof ( SgSwitchStatementStorageClass ) * sizeOfActualPool) ;
        SgSwitchStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgSwitchStatementStorageClass* storageArray = storageArraySgSwitchStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgSwitchStatement* tmp = new SgSwitchStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgSwitchStatement;  
      SgSwitchStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgSymbolTable ); 
     storageClassIndex = 0 ;
     SgSymbolTableStorageClass* storageArraySgSymbolTable = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgSymbolTable = new SgSymbolTableStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgSymbolTable) , sizeof ( SgSymbolTableStorageClass ) * sizeOfActualPool) ;
        SgSymbolTableStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgSymbolTableStorageClass* storageArray = storageArraySgSymbolTable;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgSymbolTable* tmp = new SgSymbolTable ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgSymbolTable;  
      SgSymbolTableStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgTemplateArgument ); 
     storageClassIndex = 0 ;
     SgTemplateArgumentStorageClass* storageArraySgTemplateArgument = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgTemplateArgument = new SgTemplateArgumentStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgTemplateArgument) , sizeof ( SgTemplateArgumentStorageClass ) * sizeOfActualPool) ;
          SgTemplateArgumentStorageClass* storageArray = storageArraySgTemplateArgument;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgTemplateArgument* tmp = new SgTemplateArgument ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgTemplateArgument;  


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgTemplateArgumentList ); 
     storageClassIndex = 0 ;
     SgTemplateArgumentListStorageClass* storageArraySgTemplateArgumentList = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgTemplateArgumentList = new SgTemplateArgumentListStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgTemplateArgumentList) , sizeof ( SgTemplateArgumentListStorageClass ) * sizeOfActualPool) ;
        SgTemplateArgumentListStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgTemplateArgumentListStorageClass* storageArray = storageArraySgTemplateArgumentList;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgTemplateArgumentList* tmp = new SgTemplateArgumentList ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgTemplateArgumentList;  
      SgTemplateArgumentListStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgTemplateDeclaration ); 
     storageClassIndex = 0 ;
     SgTemplateDeclarationStorageClass* storageArraySgTemplateDeclaration = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgTemplateDeclaration = new SgTemplateDeclarationStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgTemplateDeclaration) , sizeof ( SgTemplateDeclarationStorageClass ) * sizeOfActualPool) ;
        SgTemplateDeclarationStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgTemplateDeclarationStorageClass* storageArray = storageArraySgTemplateDeclaration;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgTemplateDeclaration* tmp = new SgTemplateDeclaration ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgTemplateDeclaration;  
      SgTemplateDeclarationStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgTemplateClassDeclaration ); 
     storageClassIndex = 0 ;
     SgTemplateClassDeclarationStorageClass* storageArraySgTemplateClassDeclaration = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgTemplateClassDeclaration = new SgTemplateClassDeclarationStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgTemplateClassDeclaration) , sizeof ( SgTemplateClassDeclarationStorageClass ) * sizeOfActualPool) ;
        SgTemplateClassDeclarationStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgTemplateClassDeclarationStorageClass* storageArray = storageArraySgTemplateClassDeclaration;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgTemplateClassDeclaration* tmp = new SgTemplateClassDeclaration ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgTemplateClassDeclaration;  
      SgTemplateClassDeclarationStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgTemplateFunctionDeclaration ); 
     storageClassIndex = 0 ;
     SgTemplateFunctionDeclarationStorageClass* storageArraySgTemplateFunctionDeclaration = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgTemplateFunctionDeclaration = new SgTemplateFunctionDeclarationStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgTemplateFunctionDeclaration) , sizeof ( SgTemplateFunctionDeclarationStorageClass ) * sizeOfActualPool) ;
        SgTemplateFunctionDeclarationStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgTemplateFunctionDeclarationStorageClass* storageArray = storageArraySgTemplateFunctionDeclaration;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgTemplateFunctionDeclaration* tmp = new SgTemplateFunctionDeclaration ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgTemplateFunctionDeclaration;  
      SgTemplateFunctionDeclarationStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgTemplateMemberFunctionDeclaration ); 
     storageClassIndex = 0 ;
     SgTemplateMemberFunctionDeclarationStorageClass* storageArraySgTemplateMemberFunctionDeclaration = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgTemplateMemberFunctionDeclaration = new SgTemplateMemberFunctionDeclarationStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgTemplateMemberFunctionDeclaration) , sizeof ( SgTemplateMemberFunctionDeclarationStorageClass ) * sizeOfActualPool) ;
        SgTemplateMemberFunctionDeclarationStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgTemplateMemberFunctionDeclarationStorageClass* storageArray = storageArraySgTemplateMemberFunctionDeclaration;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgTemplateMemberFunctionDeclaration* tmp = new SgTemplateMemberFunctionDeclaration ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgTemplateMemberFunctionDeclaration;  
      SgTemplateMemberFunctionDeclarationStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgTemplateClassDefinition ); 
     storageClassIndex = 0 ;
     SgTemplateClassDefinitionStorageClass* storageArraySgTemplateClassDefinition = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgTemplateClassDefinition = new SgTemplateClassDefinitionStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgTemplateClassDefinition) , sizeof ( SgTemplateClassDefinitionStorageClass ) * sizeOfActualPool) ;
        SgTemplateClassDefinitionStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgTemplateClassDefinitionStorageClass* storageArray = storageArraySgTemplateClassDefinition;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgTemplateClassDefinition* tmp = new SgTemplateClassDefinition ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgTemplateClassDefinition;  
      SgTemplateClassDefinitionStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgTemplateFunctionDefinition ); 
     storageClassIndex = 0 ;
     SgTemplateFunctionDefinitionStorageClass* storageArraySgTemplateFunctionDefinition = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgTemplateFunctionDefinition = new SgTemplateFunctionDefinitionStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgTemplateFunctionDefinition) , sizeof ( SgTemplateFunctionDefinitionStorageClass ) * sizeOfActualPool) ;
        SgTemplateFunctionDefinitionStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgTemplateFunctionDefinitionStorageClass* storageArray = storageArraySgTemplateFunctionDefinition;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgTemplateFunctionDefinition* tmp = new SgTemplateFunctionDefinition ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgTemplateFunctionDefinition;  
      SgTemplateFunctionDefinitionStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgTemplateInstantiationDecl ); 
     storageClassIndex = 0 ;
     SgTemplateInstantiationDeclStorageClass* storageArraySgTemplateInstantiationDecl = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgTemplateInstantiationDecl = new SgTemplateInstantiationDeclStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgTemplateInstantiationDecl) , sizeof ( SgTemplateInstantiationDeclStorageClass ) * sizeOfActualPool) ;
        SgTemplateInstantiationDeclStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgTemplateInstantiationDeclStorageClass* storageArray = storageArraySgTemplateInstantiationDecl;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgTemplateInstantiationDecl* tmp = new SgTemplateInstantiationDecl ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgTemplateInstantiationDecl;  
      SgTemplateInstantiationDeclStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgTemplateInstantiationDefn ); 
     storageClassIndex = 0 ;
     SgTemplateInstantiationDefnStorageClass* storageArraySgTemplateInstantiationDefn = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgTemplateInstantiationDefn = new SgTemplateInstantiationDefnStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgTemplateInstantiationDefn) , sizeof ( SgTemplateInstantiationDefnStorageClass ) * sizeOfActualPool) ;
        SgTemplateInstantiationDefnStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgTemplateInstantiationDefnStorageClass* storageArray = storageArraySgTemplateInstantiationDefn;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgTemplateInstantiationDefn* tmp = new SgTemplateInstantiationDefn ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgTemplateInstantiationDefn;  
      SgTemplateInstantiationDefnStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgTemplateInstantiationDirectiveStatement ); 
     storageClassIndex = 0 ;
     SgTemplateInstantiationDirectiveStatementStorageClass* storageArraySgTemplateInstantiationDirectiveStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgTemplateInstantiationDirectiveStatement = new SgTemplateInstantiationDirectiveStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgTemplateInstantiationDirectiveStatement) , sizeof ( SgTemplateInstantiationDirectiveStatementStorageClass ) * sizeOfActualPool) ;
        SgTemplateInstantiationDirectiveStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgTemplateInstantiationDirectiveStatementStorageClass* storageArray = storageArraySgTemplateInstantiationDirectiveStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgTemplateInstantiationDirectiveStatement* tmp = new SgTemplateInstantiationDirectiveStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgTemplateInstantiationDirectiveStatement;  
      SgTemplateInstantiationDirectiveStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgTemplateInstantiationFunctionDecl ); 
     storageClassIndex = 0 ;
     SgTemplateInstantiationFunctionDeclStorageClass* storageArraySgTemplateInstantiationFunctionDecl = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgTemplateInstantiationFunctionDecl = new SgTemplateInstantiationFunctionDeclStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgTemplateInstantiationFunctionDecl) , sizeof ( SgTemplateInstantiationFunctionDeclStorageClass ) * sizeOfActualPool) ;
        SgTemplateInstantiationFunctionDeclStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgTemplateInstantiationFunctionDeclStorageClass* storageArray = storageArraySgTemplateInstantiationFunctionDecl;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgTemplateInstantiationFunctionDecl* tmp = new SgTemplateInstantiationFunctionDecl ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgTemplateInstantiationFunctionDecl;  
      SgTemplateInstantiationFunctionDeclStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgTemplateInstantiationMemberFunctionDecl ); 
     storageClassIndex = 0 ;
     SgTemplateInstantiationMemberFunctionDeclStorageClass* storageArraySgTemplateInstantiationMemberFunctionDecl = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgTemplateInstantiationMemberFunctionDecl = new SgTemplateInstantiationMemberFunctionDeclStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgTemplateInstantiationMemberFunctionDecl) , sizeof ( SgTemplateInstantiationMemberFunctionDeclStorageClass ) * sizeOfActualPool) ;
        SgTemplateInstantiationMemberFunctionDeclStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgTemplateInstantiationMemberFunctionDeclStorageClass* storageArray = storageArraySgTemplateInstantiationMemberFunctionDecl;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgTemplateInstantiationMemberFunctionDecl* tmp = new SgTemplateInstantiationMemberFunctionDecl ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgTemplateInstantiationMemberFunctionDecl;  
      SgTemplateInstantiationMemberFunctionDeclStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgTemplateParameter ); 
     storageClassIndex = 0 ;
     SgTemplateParameterStorageClass* storageArraySgTemplateParameter = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgTemplateParameter = new SgTemplateParameterStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgTemplateParameter) , sizeof ( SgTemplateParameterStorageClass ) * sizeOfActualPool) ;
          SgTemplateParameterStorageClass* storageArray = storageArraySgTemplateParameter;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgTemplateParameter* tmp = new SgTemplateParameter ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgTemplateParameter;  


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgTemplateParameterList ); 
     storageClassIndex = 0 ;
     SgTemplateParameterListStorageClass* storageArraySgTemplateParameterList = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgTemplateParameterList = new SgTemplateParameterListStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgTemplateParameterList) , sizeof ( SgTemplateParameterListStorageClass ) * sizeOfActualPool) ;
        SgTemplateParameterListStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgTemplateParameterListStorageClass* storageArray = storageArraySgTemplateParameterList;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgTemplateParameterList* tmp = new SgTemplateParameterList ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgTemplateParameterList;  
      SgTemplateParameterListStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgTemplateSymbol ); 
     storageClassIndex = 0 ;
     SgTemplateSymbolStorageClass* storageArraySgTemplateSymbol = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgTemplateSymbol = new SgTemplateSymbolStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgTemplateSymbol) , sizeof ( SgTemplateSymbolStorageClass ) * sizeOfActualPool) ;
        SgTemplateSymbolStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgTemplateSymbolStorageClass* storageArray = storageArraySgTemplateSymbol;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgTemplateSymbol* tmp = new SgTemplateSymbol ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgTemplateSymbol;  
      SgTemplateSymbolStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgTemplateType ); 
     storageClassIndex = 0 ;
     SgTemplateTypeStorageClass* storageArraySgTemplateType = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgTemplateType = new SgTemplateTypeStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgTemplateType) , sizeof ( SgTemplateTypeStorageClass ) * sizeOfActualPool) ;
        SgTemplateTypeStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgTemplateTypeStorageClass* storageArray = storageArraySgTemplateType;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgTemplateType* tmp = new SgTemplateType ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgTemplateType;  
      SgTemplateTypeStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgThisExp ); 
     storageClassIndex = 0 ;
     SgThisExpStorageClass* storageArraySgThisExp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgThisExp = new SgThisExpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgThisExp) , sizeof ( SgThisExpStorageClass ) * sizeOfActualPool) ;
        SgThisExpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgThisExpStorageClass* storageArray = storageArraySgThisExp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgThisExp* tmp = new SgThisExp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgThisExp;  
      SgThisExpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgSuperExp ); 
     storageClassIndex = 0 ;
     SgSuperExpStorageClass* storageArraySgSuperExp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgSuperExp = new SgSuperExpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgSuperExp) , sizeof ( SgSuperExpStorageClass ) * sizeOfActualPool) ;
        SgSuperExpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgSuperExpStorageClass* storageArray = storageArraySgSuperExp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgSuperExp* tmp = new SgSuperExp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgSuperExp;  
      SgSuperExpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgThrowOp ); 
     storageClassIndex = 0 ;
     SgThrowOpStorageClass* storageArraySgThrowOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgThrowOp = new SgThrowOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgThrowOp) , sizeof ( SgThrowOpStorageClass ) * sizeOfActualPool) ;
        SgThrowOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgThrowOpStorageClass* storageArray = storageArraySgThrowOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgThrowOp* tmp = new SgThrowOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgThrowOp;  
      SgThrowOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgToken ); 
     storageClassIndex = 0 ;
     SgTokenStorageClass* storageArraySgToken = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgToken = new SgTokenStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgToken) , sizeof ( SgTokenStorageClass ) * sizeOfActualPool) ;
        SgTokenStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgTokenStorageClass* storageArray = storageArraySgToken;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgToken* tmp = new SgToken ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgToken;  
      SgTokenStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgTryStmt ); 
     storageClassIndex = 0 ;
     SgTryStmtStorageClass* storageArraySgTryStmt = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgTryStmt = new SgTryStmtStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgTryStmt) , sizeof ( SgTryStmtStorageClass ) * sizeOfActualPool) ;
        SgTryStmtStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgTryStmtStorageClass* storageArray = storageArraySgTryStmt;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgTryStmt* tmp = new SgTryStmt ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgTryStmt;  
      SgTryStmtStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgTupleExp ); 
     storageClassIndex = 0 ;
     SgTupleExpStorageClass* storageArraySgTupleExp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgTupleExp = new SgTupleExpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgTupleExp) , sizeof ( SgTupleExpStorageClass ) * sizeOfActualPool) ;
        SgTupleExpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgTupleExpStorageClass* storageArray = storageArraySgTupleExp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgTupleExp* tmp = new SgTupleExp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgTupleExp;  
      SgTupleExpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgType ); 
     storageClassIndex = 0 ;
     SgTypeStorageClass* storageArraySgType = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgType = new SgTypeStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgType) , sizeof ( SgTypeStorageClass ) * sizeOfActualPool) ;
        SgTypeStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgTypeStorageClass* storageArray = storageArraySgType;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgType* tmp = new SgType ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgType;  
      SgTypeStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgTypeBool ); 
     storageClassIndex = 0 ;
     SgTypeBoolStorageClass* storageArraySgTypeBool = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgTypeBool = new SgTypeBoolStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgTypeBool) , sizeof ( SgTypeBoolStorageClass ) * sizeOfActualPool) ;
        SgTypeBoolStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgTypeBoolStorageClass* storageArray = storageArraySgTypeBool;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgTypeBool* tmp = new SgTypeBool ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgTypeBool;  
      SgTypeBoolStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgTypeChar ); 
     storageClassIndex = 0 ;
     SgTypeCharStorageClass* storageArraySgTypeChar = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgTypeChar = new SgTypeCharStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgTypeChar) , sizeof ( SgTypeCharStorageClass ) * sizeOfActualPool) ;
        SgTypeCharStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgTypeCharStorageClass* storageArray = storageArraySgTypeChar;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgTypeChar* tmp = new SgTypeChar ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgTypeChar;  
      SgTypeCharStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgTypeComplex ); 
     storageClassIndex = 0 ;
     SgTypeComplexStorageClass* storageArraySgTypeComplex = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgTypeComplex = new SgTypeComplexStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgTypeComplex) , sizeof ( SgTypeComplexStorageClass ) * sizeOfActualPool) ;
        SgTypeComplexStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgTypeComplexStorageClass* storageArray = storageArraySgTypeComplex;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgTypeComplex* tmp = new SgTypeComplex ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgTypeComplex;  
      SgTypeComplexStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgTypeDefault ); 
     storageClassIndex = 0 ;
     SgTypeDefaultStorageClass* storageArraySgTypeDefault = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgTypeDefault = new SgTypeDefaultStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgTypeDefault) , sizeof ( SgTypeDefaultStorageClass ) * sizeOfActualPool) ;
        SgTypeDefaultStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgTypeDefaultStorageClass* storageArray = storageArraySgTypeDefault;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgTypeDefault* tmp = new SgTypeDefault ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgTypeDefault;  
      SgTypeDefaultStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgTypeLabel ); 
     storageClassIndex = 0 ;
     SgTypeLabelStorageClass* storageArraySgTypeLabel = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgTypeLabel = new SgTypeLabelStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgTypeLabel) , sizeof ( SgTypeLabelStorageClass ) * sizeOfActualPool) ;
        SgTypeLabelStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgTypeLabelStorageClass* storageArray = storageArraySgTypeLabel;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgTypeLabel* tmp = new SgTypeLabel ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgTypeLabel;  
      SgTypeLabelStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgTypeDouble ); 
     storageClassIndex = 0 ;
     SgTypeDoubleStorageClass* storageArraySgTypeDouble = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgTypeDouble = new SgTypeDoubleStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgTypeDouble) , sizeof ( SgTypeDoubleStorageClass ) * sizeOfActualPool) ;
        SgTypeDoubleStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgTypeDoubleStorageClass* storageArray = storageArraySgTypeDouble;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgTypeDouble* tmp = new SgTypeDouble ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgTypeDouble;  
      SgTypeDoubleStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgTypeEllipse ); 
     storageClassIndex = 0 ;
     SgTypeEllipseStorageClass* storageArraySgTypeEllipse = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgTypeEllipse = new SgTypeEllipseStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgTypeEllipse) , sizeof ( SgTypeEllipseStorageClass ) * sizeOfActualPool) ;
        SgTypeEllipseStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgTypeEllipseStorageClass* storageArray = storageArraySgTypeEllipse;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgTypeEllipse* tmp = new SgTypeEllipse ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgTypeEllipse;  
      SgTypeEllipseStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgTypeFloat ); 
     storageClassIndex = 0 ;
     SgTypeFloatStorageClass* storageArraySgTypeFloat = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgTypeFloat = new SgTypeFloatStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgTypeFloat) , sizeof ( SgTypeFloatStorageClass ) * sizeOfActualPool) ;
        SgTypeFloatStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgTypeFloatStorageClass* storageArray = storageArraySgTypeFloat;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgTypeFloat* tmp = new SgTypeFloat ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgTypeFloat;  
      SgTypeFloatStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgTypeGlobalVoid ); 
     storageClassIndex = 0 ;
     SgTypeGlobalVoidStorageClass* storageArraySgTypeGlobalVoid = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgTypeGlobalVoid = new SgTypeGlobalVoidStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgTypeGlobalVoid) , sizeof ( SgTypeGlobalVoidStorageClass ) * sizeOfActualPool) ;
        SgTypeGlobalVoidStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgTypeGlobalVoidStorageClass* storageArray = storageArraySgTypeGlobalVoid;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgTypeGlobalVoid* tmp = new SgTypeGlobalVoid ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgTypeGlobalVoid;  
      SgTypeGlobalVoidStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgTypeIdOp ); 
     storageClassIndex = 0 ;
     SgTypeIdOpStorageClass* storageArraySgTypeIdOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgTypeIdOp = new SgTypeIdOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgTypeIdOp) , sizeof ( SgTypeIdOpStorageClass ) * sizeOfActualPool) ;
        SgTypeIdOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgTypeIdOpStorageClass* storageArray = storageArraySgTypeIdOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgTypeIdOp* tmp = new SgTypeIdOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgTypeIdOp;  
      SgTypeIdOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgTypeImaginary ); 
     storageClassIndex = 0 ;
     SgTypeImaginaryStorageClass* storageArraySgTypeImaginary = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgTypeImaginary = new SgTypeImaginaryStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgTypeImaginary) , sizeof ( SgTypeImaginaryStorageClass ) * sizeOfActualPool) ;
        SgTypeImaginaryStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgTypeImaginaryStorageClass* storageArray = storageArraySgTypeImaginary;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgTypeImaginary* tmp = new SgTypeImaginary ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgTypeImaginary;  
      SgTypeImaginaryStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgTypeInt ); 
     storageClassIndex = 0 ;
     SgTypeIntStorageClass* storageArraySgTypeInt = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgTypeInt = new SgTypeIntStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgTypeInt) , sizeof ( SgTypeIntStorageClass ) * sizeOfActualPool) ;
        SgTypeIntStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgTypeIntStorageClass* storageArray = storageArraySgTypeInt;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgTypeInt* tmp = new SgTypeInt ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgTypeInt;  
      SgTypeIntStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgTypeLong ); 
     storageClassIndex = 0 ;
     SgTypeLongStorageClass* storageArraySgTypeLong = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgTypeLong = new SgTypeLongStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgTypeLong) , sizeof ( SgTypeLongStorageClass ) * sizeOfActualPool) ;
        SgTypeLongStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgTypeLongStorageClass* storageArray = storageArraySgTypeLong;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgTypeLong* tmp = new SgTypeLong ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgTypeLong;  
      SgTypeLongStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgTypeLongDouble ); 
     storageClassIndex = 0 ;
     SgTypeLongDoubleStorageClass* storageArraySgTypeLongDouble = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgTypeLongDouble = new SgTypeLongDoubleStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgTypeLongDouble) , sizeof ( SgTypeLongDoubleStorageClass ) * sizeOfActualPool) ;
        SgTypeLongDoubleStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgTypeLongDoubleStorageClass* storageArray = storageArraySgTypeLongDouble;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgTypeLongDouble* tmp = new SgTypeLongDouble ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgTypeLongDouble;  
      SgTypeLongDoubleStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgTypeLongLong ); 
     storageClassIndex = 0 ;
     SgTypeLongLongStorageClass* storageArraySgTypeLongLong = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgTypeLongLong = new SgTypeLongLongStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgTypeLongLong) , sizeof ( SgTypeLongLongStorageClass ) * sizeOfActualPool) ;
        SgTypeLongLongStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgTypeLongLongStorageClass* storageArray = storageArraySgTypeLongLong;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgTypeLongLong* tmp = new SgTypeLongLong ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgTypeLongLong;  
      SgTypeLongLongStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgTypeModifier ); 
     storageClassIndex = 0 ;
     SgTypeModifierStorageClass* storageArraySgTypeModifier = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgTypeModifier = new SgTypeModifierStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgTypeModifier) , sizeof ( SgTypeModifierStorageClass ) * sizeOfActualPool) ;
        SgTypeModifierStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgTypeModifierStorageClass* storageArray = storageArraySgTypeModifier;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgTypeModifier* tmp = new SgTypeModifier ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgTypeModifier;  
      SgTypeModifierStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgTypeShort ); 
     storageClassIndex = 0 ;
     SgTypeShortStorageClass* storageArraySgTypeShort = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgTypeShort = new SgTypeShortStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgTypeShort) , sizeof ( SgTypeShortStorageClass ) * sizeOfActualPool) ;
        SgTypeShortStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgTypeShortStorageClass* storageArray = storageArraySgTypeShort;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgTypeShort* tmp = new SgTypeShort ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgTypeShort;  
      SgTypeShortStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgTypeSignedChar ); 
     storageClassIndex = 0 ;
     SgTypeSignedCharStorageClass* storageArraySgTypeSignedChar = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgTypeSignedChar = new SgTypeSignedCharStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgTypeSignedChar) , sizeof ( SgTypeSignedCharStorageClass ) * sizeOfActualPool) ;
        SgTypeSignedCharStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgTypeSignedCharStorageClass* storageArray = storageArraySgTypeSignedChar;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgTypeSignedChar* tmp = new SgTypeSignedChar ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgTypeSignedChar;  
      SgTypeSignedCharStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgTypeSignedInt ); 
     storageClassIndex = 0 ;
     SgTypeSignedIntStorageClass* storageArraySgTypeSignedInt = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgTypeSignedInt = new SgTypeSignedIntStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgTypeSignedInt) , sizeof ( SgTypeSignedIntStorageClass ) * sizeOfActualPool) ;
        SgTypeSignedIntStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgTypeSignedIntStorageClass* storageArray = storageArraySgTypeSignedInt;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgTypeSignedInt* tmp = new SgTypeSignedInt ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgTypeSignedInt;  
      SgTypeSignedIntStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgTypeSignedLong ); 
     storageClassIndex = 0 ;
     SgTypeSignedLongStorageClass* storageArraySgTypeSignedLong = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgTypeSignedLong = new SgTypeSignedLongStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgTypeSignedLong) , sizeof ( SgTypeSignedLongStorageClass ) * sizeOfActualPool) ;
        SgTypeSignedLongStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgTypeSignedLongStorageClass* storageArray = storageArraySgTypeSignedLong;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgTypeSignedLong* tmp = new SgTypeSignedLong ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgTypeSignedLong;  
      SgTypeSignedLongStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgTypeSignedLongLong ); 
     storageClassIndex = 0 ;
     SgTypeSignedLongLongStorageClass* storageArraySgTypeSignedLongLong = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgTypeSignedLongLong = new SgTypeSignedLongLongStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgTypeSignedLongLong) , sizeof ( SgTypeSignedLongLongStorageClass ) * sizeOfActualPool) ;
        SgTypeSignedLongLongStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgTypeSignedLongLongStorageClass* storageArray = storageArraySgTypeSignedLongLong;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgTypeSignedLongLong* tmp = new SgTypeSignedLongLong ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgTypeSignedLongLong;  
      SgTypeSignedLongLongStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgTypeSignedShort ); 
     storageClassIndex = 0 ;
     SgTypeSignedShortStorageClass* storageArraySgTypeSignedShort = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgTypeSignedShort = new SgTypeSignedShortStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgTypeSignedShort) , sizeof ( SgTypeSignedShortStorageClass ) * sizeOfActualPool) ;
        SgTypeSignedShortStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgTypeSignedShortStorageClass* storageArray = storageArraySgTypeSignedShort;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgTypeSignedShort* tmp = new SgTypeSignedShort ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgTypeSignedShort;  
      SgTypeSignedShortStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgTypeString ); 
     storageClassIndex = 0 ;
     SgTypeStringStorageClass* storageArraySgTypeString = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgTypeString = new SgTypeStringStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgTypeString) , sizeof ( SgTypeStringStorageClass ) * sizeOfActualPool) ;
        SgTypeStringStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgTypeStringStorageClass* storageArray = storageArraySgTypeString;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgTypeString* tmp = new SgTypeString ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgTypeString;  
      SgTypeStringStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgTypeUnknown ); 
     storageClassIndex = 0 ;
     SgTypeUnknownStorageClass* storageArraySgTypeUnknown = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgTypeUnknown = new SgTypeUnknownStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgTypeUnknown) , sizeof ( SgTypeUnknownStorageClass ) * sizeOfActualPool) ;
        SgTypeUnknownStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgTypeUnknownStorageClass* storageArray = storageArraySgTypeUnknown;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgTypeUnknown* tmp = new SgTypeUnknown ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgTypeUnknown;  
      SgTypeUnknownStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgTypeUnsignedChar ); 
     storageClassIndex = 0 ;
     SgTypeUnsignedCharStorageClass* storageArraySgTypeUnsignedChar = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgTypeUnsignedChar = new SgTypeUnsignedCharStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgTypeUnsignedChar) , sizeof ( SgTypeUnsignedCharStorageClass ) * sizeOfActualPool) ;
        SgTypeUnsignedCharStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgTypeUnsignedCharStorageClass* storageArray = storageArraySgTypeUnsignedChar;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgTypeUnsignedChar* tmp = new SgTypeUnsignedChar ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgTypeUnsignedChar;  
      SgTypeUnsignedCharStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgTypeUnsignedInt ); 
     storageClassIndex = 0 ;
     SgTypeUnsignedIntStorageClass* storageArraySgTypeUnsignedInt = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgTypeUnsignedInt = new SgTypeUnsignedIntStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgTypeUnsignedInt) , sizeof ( SgTypeUnsignedIntStorageClass ) * sizeOfActualPool) ;
        SgTypeUnsignedIntStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgTypeUnsignedIntStorageClass* storageArray = storageArraySgTypeUnsignedInt;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgTypeUnsignedInt* tmp = new SgTypeUnsignedInt ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgTypeUnsignedInt;  
      SgTypeUnsignedIntStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgTypeUnsignedLong ); 
     storageClassIndex = 0 ;
     SgTypeUnsignedLongStorageClass* storageArraySgTypeUnsignedLong = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgTypeUnsignedLong = new SgTypeUnsignedLongStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgTypeUnsignedLong) , sizeof ( SgTypeUnsignedLongStorageClass ) * sizeOfActualPool) ;
        SgTypeUnsignedLongStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgTypeUnsignedLongStorageClass* storageArray = storageArraySgTypeUnsignedLong;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgTypeUnsignedLong* tmp = new SgTypeUnsignedLong ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgTypeUnsignedLong;  
      SgTypeUnsignedLongStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgTypeUnsignedLongLong ); 
     storageClassIndex = 0 ;
     SgTypeUnsignedLongLongStorageClass* storageArraySgTypeUnsignedLongLong = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgTypeUnsignedLongLong = new SgTypeUnsignedLongLongStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgTypeUnsignedLongLong) , sizeof ( SgTypeUnsignedLongLongStorageClass ) * sizeOfActualPool) ;
        SgTypeUnsignedLongLongStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgTypeUnsignedLongLongStorageClass* storageArray = storageArraySgTypeUnsignedLongLong;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgTypeUnsignedLongLong* tmp = new SgTypeUnsignedLongLong ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgTypeUnsignedLongLong;  
      SgTypeUnsignedLongLongStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgTypeUnsignedShort ); 
     storageClassIndex = 0 ;
     SgTypeUnsignedShortStorageClass* storageArraySgTypeUnsignedShort = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgTypeUnsignedShort = new SgTypeUnsignedShortStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgTypeUnsignedShort) , sizeof ( SgTypeUnsignedShortStorageClass ) * sizeOfActualPool) ;
        SgTypeUnsignedShortStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgTypeUnsignedShortStorageClass* storageArray = storageArraySgTypeUnsignedShort;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgTypeUnsignedShort* tmp = new SgTypeUnsignedShort ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgTypeUnsignedShort;  
      SgTypeUnsignedShortStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgTypeVoid ); 
     storageClassIndex = 0 ;
     SgTypeVoidStorageClass* storageArraySgTypeVoid = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgTypeVoid = new SgTypeVoidStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgTypeVoid) , sizeof ( SgTypeVoidStorageClass ) * sizeOfActualPool) ;
        SgTypeVoidStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgTypeVoidStorageClass* storageArray = storageArraySgTypeVoid;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgTypeVoid* tmp = new SgTypeVoid ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgTypeVoid;  
      SgTypeVoidStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgTypeWchar ); 
     storageClassIndex = 0 ;
     SgTypeWcharStorageClass* storageArraySgTypeWchar = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgTypeWchar = new SgTypeWcharStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgTypeWchar) , sizeof ( SgTypeWcharStorageClass ) * sizeOfActualPool) ;
        SgTypeWcharStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgTypeWcharStorageClass* storageArray = storageArraySgTypeWchar;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgTypeWchar* tmp = new SgTypeWchar ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgTypeWchar;  
      SgTypeWcharStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgTypedefDeclaration ); 
     storageClassIndex = 0 ;
     SgTypedefDeclarationStorageClass* storageArraySgTypedefDeclaration = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgTypedefDeclaration = new SgTypedefDeclarationStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgTypedefDeclaration) , sizeof ( SgTypedefDeclarationStorageClass ) * sizeOfActualPool) ;
        SgTypedefDeclarationStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgTypedefDeclarationStorageClass* storageArray = storageArraySgTypedefDeclaration;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgTypedefDeclaration* tmp = new SgTypedefDeclaration ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgTypedefDeclaration;  
      SgTypedefDeclarationStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgTypedefSeq ); 
     storageClassIndex = 0 ;
     SgTypedefSeqStorageClass* storageArraySgTypedefSeq = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgTypedefSeq = new SgTypedefSeqStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgTypedefSeq) , sizeof ( SgTypedefSeqStorageClass ) * sizeOfActualPool) ;
        SgTypedefSeqStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgTypedefSeqStorageClass* storageArray = storageArraySgTypedefSeq;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgTypedefSeq* tmp = new SgTypedefSeq ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgTypedefSeq;  
      SgTypedefSeqStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgTypedefSymbol ); 
     storageClassIndex = 0 ;
     SgTypedefSymbolStorageClass* storageArraySgTypedefSymbol = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgTypedefSymbol = new SgTypedefSymbolStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgTypedefSymbol) , sizeof ( SgTypedefSymbolStorageClass ) * sizeOfActualPool) ;
        SgTypedefSymbolStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgTypedefSymbolStorageClass* storageArray = storageArraySgTypedefSymbol;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgTypedefSymbol* tmp = new SgTypedefSymbol ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgTypedefSymbol;  
      SgTypedefSymbolStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgTypedefType ); 
     storageClassIndex = 0 ;
     SgTypedefTypeStorageClass* storageArraySgTypedefType = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgTypedefType = new SgTypedefTypeStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgTypedefType) , sizeof ( SgTypedefTypeStorageClass ) * sizeOfActualPool) ;
        SgTypedefTypeStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgTypedefTypeStorageClass* storageArray = storageArraySgTypedefType;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgTypedefType* tmp = new SgTypedefType ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgTypedefType;  
      SgTypedefTypeStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgUPC_AccessModifier ); 
     storageClassIndex = 0 ;
     SgUPC_AccessModifierStorageClass* storageArraySgUPC_AccessModifier = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgUPC_AccessModifier = new SgUPC_AccessModifierStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgUPC_AccessModifier) , sizeof ( SgUPC_AccessModifierStorageClass ) * sizeOfActualPool) ;
          SgUPC_AccessModifierStorageClass* storageArray = storageArraySgUPC_AccessModifier;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgUPC_AccessModifier* tmp = new SgUPC_AccessModifier ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgUPC_AccessModifier;  


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgUnaryAddOp ); 
     storageClassIndex = 0 ;
     SgUnaryAddOpStorageClass* storageArraySgUnaryAddOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgUnaryAddOp = new SgUnaryAddOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgUnaryAddOp) , sizeof ( SgUnaryAddOpStorageClass ) * sizeOfActualPool) ;
        SgUnaryAddOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgUnaryAddOpStorageClass* storageArray = storageArraySgUnaryAddOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgUnaryAddOp* tmp = new SgUnaryAddOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgUnaryAddOp;  
      SgUnaryAddOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgUnaryOp ); 
     storageClassIndex = 0 ;
     SgUnaryOpStorageClass* storageArraySgUnaryOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgUnaryOp = new SgUnaryOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgUnaryOp) , sizeof ( SgUnaryOpStorageClass ) * sizeOfActualPool) ;
        SgUnaryOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgUnaryOpStorageClass* storageArray = storageArraySgUnaryOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgUnaryOp* tmp = new SgUnaryOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgUnaryOp;  
      SgUnaryOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgUndefDirectiveStatement ); 
     storageClassIndex = 0 ;
     SgUndefDirectiveStatementStorageClass* storageArraySgUndefDirectiveStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgUndefDirectiveStatement = new SgUndefDirectiveStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgUndefDirectiveStatement) , sizeof ( SgUndefDirectiveStatementStorageClass ) * sizeOfActualPool) ;
        SgUndefDirectiveStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgUndefDirectiveStatementStorageClass* storageArray = storageArraySgUndefDirectiveStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgUndefDirectiveStatement* tmp = new SgUndefDirectiveStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgUndefDirectiveStatement;  
      SgUndefDirectiveStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgUndirectedGraphEdge ); 
     storageClassIndex = 0 ;
     SgUndirectedGraphEdgeStorageClass* storageArraySgUndirectedGraphEdge = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgUndirectedGraphEdge = new SgUndirectedGraphEdgeStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgUndirectedGraphEdge) , sizeof ( SgUndirectedGraphEdgeStorageClass ) * sizeOfActualPool) ;
        SgUndirectedGraphEdgeStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgUndirectedGraphEdgeStorageClass* storageArray = storageArraySgUndirectedGraphEdge;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgUndirectedGraphEdge* tmp = new SgUndirectedGraphEdge ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgUndirectedGraphEdge;  
      SgUndirectedGraphEdgeStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgUnknownArrayOrFunctionReference ); 
     storageClassIndex = 0 ;
     SgUnknownArrayOrFunctionReferenceStorageClass* storageArraySgUnknownArrayOrFunctionReference = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgUnknownArrayOrFunctionReference = new SgUnknownArrayOrFunctionReferenceStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgUnknownArrayOrFunctionReference) , sizeof ( SgUnknownArrayOrFunctionReferenceStorageClass ) * sizeOfActualPool) ;
        SgUnknownArrayOrFunctionReferenceStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgUnknownArrayOrFunctionReferenceStorageClass* storageArray = storageArraySgUnknownArrayOrFunctionReference;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgUnknownArrayOrFunctionReference* tmp = new SgUnknownArrayOrFunctionReference ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgUnknownArrayOrFunctionReference;  
      SgUnknownArrayOrFunctionReferenceStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgUnknownFile ); 
     storageClassIndex = 0 ;
     SgUnknownFileStorageClass* storageArraySgUnknownFile = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgUnknownFile = new SgUnknownFileStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgUnknownFile) , sizeof ( SgUnknownFileStorageClass ) * sizeOfActualPool) ;
        SgUnknownFileStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgUnknownFileStorageClass* storageArray = storageArraySgUnknownFile;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgUnknownFile* tmp = new SgUnknownFile ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgUnknownFile;  
      SgUnknownFileStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgUnparse_Info ); 
     storageClassIndex = 0 ;
     SgUnparse_InfoStorageClass* storageArraySgUnparse_Info = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgUnparse_Info = new SgUnparse_InfoStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgUnparse_Info) , sizeof ( SgUnparse_InfoStorageClass ) * sizeOfActualPool) ;
        SgUnparse_InfoStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgUnparse_InfoStorageClass* storageArray = storageArraySgUnparse_Info;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgUnparse_Info* tmp = new SgUnparse_Info ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgUnparse_Info;  
      SgUnparse_InfoStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgUnsignedCharVal ); 
     storageClassIndex = 0 ;
     SgUnsignedCharValStorageClass* storageArraySgUnsignedCharVal = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgUnsignedCharVal = new SgUnsignedCharValStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgUnsignedCharVal) , sizeof ( SgUnsignedCharValStorageClass ) * sizeOfActualPool) ;
        SgUnsignedCharValStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgUnsignedCharValStorageClass* storageArray = storageArraySgUnsignedCharVal;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgUnsignedCharVal* tmp = new SgUnsignedCharVal ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgUnsignedCharVal;  
      SgUnsignedCharValStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgUnsignedIntVal ); 
     storageClassIndex = 0 ;
     SgUnsignedIntValStorageClass* storageArraySgUnsignedIntVal = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgUnsignedIntVal = new SgUnsignedIntValStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgUnsignedIntVal) , sizeof ( SgUnsignedIntValStorageClass ) * sizeOfActualPool) ;
        SgUnsignedIntValStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgUnsignedIntValStorageClass* storageArray = storageArraySgUnsignedIntVal;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgUnsignedIntVal* tmp = new SgUnsignedIntVal ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgUnsignedIntVal;  
      SgUnsignedIntValStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgUnsignedLongLongIntVal ); 
     storageClassIndex = 0 ;
     SgUnsignedLongLongIntValStorageClass* storageArraySgUnsignedLongLongIntVal = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgUnsignedLongLongIntVal = new SgUnsignedLongLongIntValStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgUnsignedLongLongIntVal) , sizeof ( SgUnsignedLongLongIntValStorageClass ) * sizeOfActualPool) ;
        SgUnsignedLongLongIntValStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgUnsignedLongLongIntValStorageClass* storageArray = storageArraySgUnsignedLongLongIntVal;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgUnsignedLongLongIntVal* tmp = new SgUnsignedLongLongIntVal ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgUnsignedLongLongIntVal;  
      SgUnsignedLongLongIntValStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgUnsignedLongVal ); 
     storageClassIndex = 0 ;
     SgUnsignedLongValStorageClass* storageArraySgUnsignedLongVal = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgUnsignedLongVal = new SgUnsignedLongValStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgUnsignedLongVal) , sizeof ( SgUnsignedLongValStorageClass ) * sizeOfActualPool) ;
        SgUnsignedLongValStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgUnsignedLongValStorageClass* storageArray = storageArraySgUnsignedLongVal;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgUnsignedLongVal* tmp = new SgUnsignedLongVal ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgUnsignedLongVal;  
      SgUnsignedLongValStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgUnsignedShortVal ); 
     storageClassIndex = 0 ;
     SgUnsignedShortValStorageClass* storageArraySgUnsignedShortVal = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgUnsignedShortVal = new SgUnsignedShortValStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgUnsignedShortVal) , sizeof ( SgUnsignedShortValStorageClass ) * sizeOfActualPool) ;
        SgUnsignedShortValStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgUnsignedShortValStorageClass* storageArray = storageArraySgUnsignedShortVal;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgUnsignedShortVal* tmp = new SgUnsignedShortVal ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgUnsignedShortVal;  
      SgUnsignedShortValStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgUpcBarrierStatement ); 
     storageClassIndex = 0 ;
     SgUpcBarrierStatementStorageClass* storageArraySgUpcBarrierStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgUpcBarrierStatement = new SgUpcBarrierStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgUpcBarrierStatement) , sizeof ( SgUpcBarrierStatementStorageClass ) * sizeOfActualPool) ;
        SgUpcBarrierStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgUpcBarrierStatementStorageClass* storageArray = storageArraySgUpcBarrierStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgUpcBarrierStatement* tmp = new SgUpcBarrierStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgUpcBarrierStatement;  
      SgUpcBarrierStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgUpcBlocksizeofExpression ); 
     storageClassIndex = 0 ;
     SgUpcBlocksizeofExpressionStorageClass* storageArraySgUpcBlocksizeofExpression = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgUpcBlocksizeofExpression = new SgUpcBlocksizeofExpressionStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgUpcBlocksizeofExpression) , sizeof ( SgUpcBlocksizeofExpressionStorageClass ) * sizeOfActualPool) ;
        SgUpcBlocksizeofExpressionStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgUpcBlocksizeofExpressionStorageClass* storageArray = storageArraySgUpcBlocksizeofExpression;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgUpcBlocksizeofExpression* tmp = new SgUpcBlocksizeofExpression ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgUpcBlocksizeofExpression;  
      SgUpcBlocksizeofExpressionStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgUpcElemsizeofExpression ); 
     storageClassIndex = 0 ;
     SgUpcElemsizeofExpressionStorageClass* storageArraySgUpcElemsizeofExpression = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgUpcElemsizeofExpression = new SgUpcElemsizeofExpressionStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgUpcElemsizeofExpression) , sizeof ( SgUpcElemsizeofExpressionStorageClass ) * sizeOfActualPool) ;
        SgUpcElemsizeofExpressionStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgUpcElemsizeofExpressionStorageClass* storageArray = storageArraySgUpcElemsizeofExpression;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgUpcElemsizeofExpression* tmp = new SgUpcElemsizeofExpression ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgUpcElemsizeofExpression;  
      SgUpcElemsizeofExpressionStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgUpcFenceStatement ); 
     storageClassIndex = 0 ;
     SgUpcFenceStatementStorageClass* storageArraySgUpcFenceStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgUpcFenceStatement = new SgUpcFenceStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgUpcFenceStatement) , sizeof ( SgUpcFenceStatementStorageClass ) * sizeOfActualPool) ;
        SgUpcFenceStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgUpcFenceStatementStorageClass* storageArray = storageArraySgUpcFenceStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgUpcFenceStatement* tmp = new SgUpcFenceStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgUpcFenceStatement;  
      SgUpcFenceStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgUpcForAllStatement ); 
     storageClassIndex = 0 ;
     SgUpcForAllStatementStorageClass* storageArraySgUpcForAllStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgUpcForAllStatement = new SgUpcForAllStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgUpcForAllStatement) , sizeof ( SgUpcForAllStatementStorageClass ) * sizeOfActualPool) ;
        SgUpcForAllStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgUpcForAllStatementStorageClass* storageArray = storageArraySgUpcForAllStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgUpcForAllStatement* tmp = new SgUpcForAllStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgUpcForAllStatement;  
      SgUpcForAllStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgUpcLocalsizeofExpression ); 
     storageClassIndex = 0 ;
     SgUpcLocalsizeofExpressionStorageClass* storageArraySgUpcLocalsizeofExpression = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgUpcLocalsizeofExpression = new SgUpcLocalsizeofExpressionStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgUpcLocalsizeofExpression) , sizeof ( SgUpcLocalsizeofExpressionStorageClass ) * sizeOfActualPool) ;
        SgUpcLocalsizeofExpressionStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgUpcLocalsizeofExpressionStorageClass* storageArray = storageArraySgUpcLocalsizeofExpression;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgUpcLocalsizeofExpression* tmp = new SgUpcLocalsizeofExpression ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgUpcLocalsizeofExpression;  
      SgUpcLocalsizeofExpressionStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgUpcMythread ); 
     storageClassIndex = 0 ;
     SgUpcMythreadStorageClass* storageArraySgUpcMythread = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgUpcMythread = new SgUpcMythreadStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgUpcMythread) , sizeof ( SgUpcMythreadStorageClass ) * sizeOfActualPool) ;
        SgUpcMythreadStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgUpcMythreadStorageClass* storageArray = storageArraySgUpcMythread;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgUpcMythread* tmp = new SgUpcMythread ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgUpcMythread;  
      SgUpcMythreadStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgUpcNotifyStatement ); 
     storageClassIndex = 0 ;
     SgUpcNotifyStatementStorageClass* storageArraySgUpcNotifyStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgUpcNotifyStatement = new SgUpcNotifyStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgUpcNotifyStatement) , sizeof ( SgUpcNotifyStatementStorageClass ) * sizeOfActualPool) ;
        SgUpcNotifyStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgUpcNotifyStatementStorageClass* storageArray = storageArraySgUpcNotifyStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgUpcNotifyStatement* tmp = new SgUpcNotifyStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgUpcNotifyStatement;  
      SgUpcNotifyStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgUpcThreads ); 
     storageClassIndex = 0 ;
     SgUpcThreadsStorageClass* storageArraySgUpcThreads = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgUpcThreads = new SgUpcThreadsStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgUpcThreads) , sizeof ( SgUpcThreadsStorageClass ) * sizeOfActualPool) ;
        SgUpcThreadsStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgUpcThreadsStorageClass* storageArray = storageArraySgUpcThreads;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgUpcThreads* tmp = new SgUpcThreads ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgUpcThreads;  
      SgUpcThreadsStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgUpcWaitStatement ); 
     storageClassIndex = 0 ;
     SgUpcWaitStatementStorageClass* storageArraySgUpcWaitStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgUpcWaitStatement = new SgUpcWaitStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgUpcWaitStatement) , sizeof ( SgUpcWaitStatementStorageClass ) * sizeOfActualPool) ;
        SgUpcWaitStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgUpcWaitStatementStorageClass* storageArray = storageArraySgUpcWaitStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgUpcWaitStatement* tmp = new SgUpcWaitStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgUpcWaitStatement;  
      SgUpcWaitStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgUseStatement ); 
     storageClassIndex = 0 ;
     SgUseStatementStorageClass* storageArraySgUseStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgUseStatement = new SgUseStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgUseStatement) , sizeof ( SgUseStatementStorageClass ) * sizeOfActualPool) ;
        SgUseStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgUseStatementStorageClass* storageArray = storageArraySgUseStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgUseStatement* tmp = new SgUseStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgUseStatement;  
      SgUseStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgUserDefinedBinaryOp ); 
     storageClassIndex = 0 ;
     SgUserDefinedBinaryOpStorageClass* storageArraySgUserDefinedBinaryOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgUserDefinedBinaryOp = new SgUserDefinedBinaryOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgUserDefinedBinaryOp) , sizeof ( SgUserDefinedBinaryOpStorageClass ) * sizeOfActualPool) ;
        SgUserDefinedBinaryOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgUserDefinedBinaryOpStorageClass* storageArray = storageArraySgUserDefinedBinaryOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgUserDefinedBinaryOp* tmp = new SgUserDefinedBinaryOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgUserDefinedBinaryOp;  
      SgUserDefinedBinaryOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgUserDefinedUnaryOp ); 
     storageClassIndex = 0 ;
     SgUserDefinedUnaryOpStorageClass* storageArraySgUserDefinedUnaryOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgUserDefinedUnaryOp = new SgUserDefinedUnaryOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgUserDefinedUnaryOp) , sizeof ( SgUserDefinedUnaryOpStorageClass ) * sizeOfActualPool) ;
        SgUserDefinedUnaryOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgUserDefinedUnaryOpStorageClass* storageArray = storageArraySgUserDefinedUnaryOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgUserDefinedUnaryOp* tmp = new SgUserDefinedUnaryOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgUserDefinedUnaryOp;  
      SgUserDefinedUnaryOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgUsingDeclarationStatement ); 
     storageClassIndex = 0 ;
     SgUsingDeclarationStatementStorageClass* storageArraySgUsingDeclarationStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgUsingDeclarationStatement = new SgUsingDeclarationStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgUsingDeclarationStatement) , sizeof ( SgUsingDeclarationStatementStorageClass ) * sizeOfActualPool) ;
        SgUsingDeclarationStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgUsingDeclarationStatementStorageClass* storageArray = storageArraySgUsingDeclarationStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgUsingDeclarationStatement* tmp = new SgUsingDeclarationStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgUsingDeclarationStatement;  
      SgUsingDeclarationStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgUsingDirectiveStatement ); 
     storageClassIndex = 0 ;
     SgUsingDirectiveStatementStorageClass* storageArraySgUsingDirectiveStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgUsingDirectiveStatement = new SgUsingDirectiveStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgUsingDirectiveStatement) , sizeof ( SgUsingDirectiveStatementStorageClass ) * sizeOfActualPool) ;
        SgUsingDirectiveStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgUsingDirectiveStatementStorageClass* storageArray = storageArraySgUsingDirectiveStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgUsingDirectiveStatement* tmp = new SgUsingDirectiveStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgUsingDirectiveStatement;  
      SgUsingDirectiveStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgValueExp ); 
     storageClassIndex = 0 ;
     SgValueExpStorageClass* storageArraySgValueExp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgValueExp = new SgValueExpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgValueExp) , sizeof ( SgValueExpStorageClass ) * sizeOfActualPool) ;
        SgValueExpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgValueExpStorageClass* storageArray = storageArraySgValueExp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgValueExp* tmp = new SgValueExp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgValueExp;  
      SgValueExpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgVarArgCopyOp ); 
     storageClassIndex = 0 ;
     SgVarArgCopyOpStorageClass* storageArraySgVarArgCopyOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgVarArgCopyOp = new SgVarArgCopyOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgVarArgCopyOp) , sizeof ( SgVarArgCopyOpStorageClass ) * sizeOfActualPool) ;
        SgVarArgCopyOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgVarArgCopyOpStorageClass* storageArray = storageArraySgVarArgCopyOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgVarArgCopyOp* tmp = new SgVarArgCopyOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgVarArgCopyOp;  
      SgVarArgCopyOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgVarArgEndOp ); 
     storageClassIndex = 0 ;
     SgVarArgEndOpStorageClass* storageArraySgVarArgEndOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgVarArgEndOp = new SgVarArgEndOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgVarArgEndOp) , sizeof ( SgVarArgEndOpStorageClass ) * sizeOfActualPool) ;
        SgVarArgEndOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgVarArgEndOpStorageClass* storageArray = storageArraySgVarArgEndOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgVarArgEndOp* tmp = new SgVarArgEndOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgVarArgEndOp;  
      SgVarArgEndOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgVarArgOp ); 
     storageClassIndex = 0 ;
     SgVarArgOpStorageClass* storageArraySgVarArgOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgVarArgOp = new SgVarArgOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgVarArgOp) , sizeof ( SgVarArgOpStorageClass ) * sizeOfActualPool) ;
        SgVarArgOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgVarArgOpStorageClass* storageArray = storageArraySgVarArgOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgVarArgOp* tmp = new SgVarArgOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgVarArgOp;  
      SgVarArgOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgVarArgStartOneOperandOp ); 
     storageClassIndex = 0 ;
     SgVarArgStartOneOperandOpStorageClass* storageArraySgVarArgStartOneOperandOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgVarArgStartOneOperandOp = new SgVarArgStartOneOperandOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgVarArgStartOneOperandOp) , sizeof ( SgVarArgStartOneOperandOpStorageClass ) * sizeOfActualPool) ;
        SgVarArgStartOneOperandOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgVarArgStartOneOperandOpStorageClass* storageArray = storageArraySgVarArgStartOneOperandOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgVarArgStartOneOperandOp* tmp = new SgVarArgStartOneOperandOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgVarArgStartOneOperandOp;  
      SgVarArgStartOneOperandOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgVarArgStartOp ); 
     storageClassIndex = 0 ;
     SgVarArgStartOpStorageClass* storageArraySgVarArgStartOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgVarArgStartOp = new SgVarArgStartOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgVarArgStartOp) , sizeof ( SgVarArgStartOpStorageClass ) * sizeOfActualPool) ;
        SgVarArgStartOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgVarArgStartOpStorageClass* storageArray = storageArraySgVarArgStartOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgVarArgStartOp* tmp = new SgVarArgStartOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgVarArgStartOp;  
      SgVarArgStartOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgVarRefExp ); 
     storageClassIndex = 0 ;
     SgVarRefExpStorageClass* storageArraySgVarRefExp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgVarRefExp = new SgVarRefExpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgVarRefExp) , sizeof ( SgVarRefExpStorageClass ) * sizeOfActualPool) ;
        SgVarRefExpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgVarRefExpStorageClass* storageArray = storageArraySgVarRefExp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgVarRefExp* tmp = new SgVarRefExp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgVarRefExp;  
      SgVarRefExpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgVariableDeclaration ); 
     storageClassIndex = 0 ;
     SgVariableDeclarationStorageClass* storageArraySgVariableDeclaration = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgVariableDeclaration = new SgVariableDeclarationStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgVariableDeclaration) , sizeof ( SgVariableDeclarationStorageClass ) * sizeOfActualPool) ;
        SgVariableDeclarationStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgVariableDeclarationStorageClass* storageArray = storageArraySgVariableDeclaration;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgVariableDeclaration* tmp = new SgVariableDeclaration ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgVariableDeclaration;  
      SgVariableDeclarationStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgVariableDefinition ); 
     storageClassIndex = 0 ;
     SgVariableDefinitionStorageClass* storageArraySgVariableDefinition = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgVariableDefinition = new SgVariableDefinitionStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgVariableDefinition) , sizeof ( SgVariableDefinitionStorageClass ) * sizeOfActualPool) ;
        SgVariableDefinitionStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgVariableDefinitionStorageClass* storageArray = storageArraySgVariableDefinition;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgVariableDefinition* tmp = new SgVariableDefinition ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgVariableDefinition;  
      SgVariableDefinitionStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgVariableSymbol ); 
     storageClassIndex = 0 ;
     SgVariableSymbolStorageClass* storageArraySgVariableSymbol = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgVariableSymbol = new SgVariableSymbolStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgVariableSymbol) , sizeof ( SgVariableSymbolStorageClass ) * sizeOfActualPool) ;
        SgVariableSymbolStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgVariableSymbolStorageClass* storageArray = storageArraySgVariableSymbol;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgVariableSymbol* tmp = new SgVariableSymbol ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgVariableSymbol;  
      SgVariableSymbolStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgVariantExpression ); 
     storageClassIndex = 0 ;
     SgVariantExpressionStorageClass* storageArraySgVariantExpression = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgVariantExpression = new SgVariantExpressionStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgVariantExpression) , sizeof ( SgVariantExpressionStorageClass ) * sizeOfActualPool) ;
        SgVariantExpressionStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgVariantExpressionStorageClass* storageArray = storageArraySgVariantExpression;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgVariantExpression* tmp = new SgVariantExpression ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgVariantExpression;  
      SgVariantExpressionStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgVariantStatement ); 
     storageClassIndex = 0 ;
     SgVariantStatementStorageClass* storageArraySgVariantStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgVariantStatement = new SgVariantStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgVariantStatement) , sizeof ( SgVariantStatementStorageClass ) * sizeOfActualPool) ;
        SgVariantStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgVariantStatementStorageClass* storageArray = storageArraySgVariantStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgVariantStatement* tmp = new SgVariantStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgVariantStatement;  
      SgVariantStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgWaitStatement ); 
     storageClassIndex = 0 ;
     SgWaitStatementStorageClass* storageArraySgWaitStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgWaitStatement = new SgWaitStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgWaitStatement) , sizeof ( SgWaitStatementStorageClass ) * sizeOfActualPool) ;
        SgWaitStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgWaitStatementStorageClass* storageArray = storageArraySgWaitStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgWaitStatement* tmp = new SgWaitStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgWaitStatement;  
      SgWaitStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgWarningDirectiveStatement ); 
     storageClassIndex = 0 ;
     SgWarningDirectiveStatementStorageClass* storageArraySgWarningDirectiveStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgWarningDirectiveStatement = new SgWarningDirectiveStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgWarningDirectiveStatement) , sizeof ( SgWarningDirectiveStatementStorageClass ) * sizeOfActualPool) ;
        SgWarningDirectiveStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgWarningDirectiveStatementStorageClass* storageArray = storageArraySgWarningDirectiveStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgWarningDirectiveStatement* tmp = new SgWarningDirectiveStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgWarningDirectiveStatement;  
      SgWarningDirectiveStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgWithStatement ); 
     storageClassIndex = 0 ;
     SgWithStatementStorageClass* storageArraySgWithStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgWithStatement = new SgWithStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgWithStatement) , sizeof ( SgWithStatementStorageClass ) * sizeOfActualPool) ;
        SgWithStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgWithStatementStorageClass* storageArray = storageArraySgWithStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgWithStatement* tmp = new SgWithStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgWithStatement;  
      SgWithStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgWcharVal ); 
     storageClassIndex = 0 ;
     SgWcharValStorageClass* storageArraySgWcharVal = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgWcharVal = new SgWcharValStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgWcharVal) , sizeof ( SgWcharValStorageClass ) * sizeOfActualPool) ;
        SgWcharValStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgWcharValStorageClass* storageArray = storageArraySgWcharVal;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgWcharVal* tmp = new SgWcharVal ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgWcharVal;  
      SgWcharValStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgWhereStatement ); 
     storageClassIndex = 0 ;
     SgWhereStatementStorageClass* storageArraySgWhereStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgWhereStatement = new SgWhereStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgWhereStatement) , sizeof ( SgWhereStatementStorageClass ) * sizeOfActualPool) ;
        SgWhereStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgWhereStatementStorageClass* storageArray = storageArraySgWhereStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgWhereStatement* tmp = new SgWhereStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgWhereStatement;  
      SgWhereStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgWhileStmt ); 
     storageClassIndex = 0 ;
     SgWhileStmtStorageClass* storageArraySgWhileStmt = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgWhileStmt = new SgWhileStmtStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgWhileStmt) , sizeof ( SgWhileStmtStorageClass ) * sizeOfActualPool) ;
        SgWhileStmtStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgWhileStmtStorageClass* storageArray = storageArraySgWhileStmt;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgWhileStmt* tmp = new SgWhileStmt ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgWhileStmt;  
      SgWhileStmtStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgWriteStatement ); 
     storageClassIndex = 0 ;
     SgWriteStatementStorageClass* storageArraySgWriteStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgWriteStatement = new SgWriteStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgWriteStatement) , sizeof ( SgWriteStatementStorageClass ) * sizeOfActualPool) ;
        SgWriteStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgWriteStatementStorageClass* storageArray = storageArraySgWriteStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgWriteStatement* tmp = new SgWriteStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgWriteStatement;  
      SgWriteStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgXorAssignOp ); 
     storageClassIndex = 0 ;
     SgXorAssignOpStorageClass* storageArraySgXorAssignOp = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgXorAssignOp = new SgXorAssignOpStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgXorAssignOp) , sizeof ( SgXorAssignOpStorageClass ) * sizeOfActualPool) ;
        SgXorAssignOpStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgXorAssignOpStorageClass* storageArray = storageArraySgXorAssignOp;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgXorAssignOp* tmp = new SgXorAssignOp ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgXorAssignOp;  
      SgXorAssignOpStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgYieldExpression ); 
     storageClassIndex = 0 ;
     SgYieldExpressionStorageClass* storageArraySgYieldExpression = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgYieldExpression = new SgYieldExpressionStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgYieldExpression) , sizeof ( SgYieldExpressionStorageClass ) * sizeOfActualPool) ;
        SgYieldExpressionStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgYieldExpressionStorageClass* storageArray = storageArraySgYieldExpression;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgYieldExpression* tmp = new SgYieldExpression ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgYieldExpression;  
      SgYieldExpressionStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_Sg_File_Info ); 
     storageClassIndex = 0 ;
     Sg_File_InfoStorageClass* storageArraySg_File_Info = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySg_File_Info = new Sg_File_InfoStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySg_File_Info) , sizeof ( Sg_File_InfoStorageClass ) * sizeOfActualPool) ;
        Sg_File_InfoStorageClass :: readEasyStorageDataFromFile(inFile) ;
          Sg_File_InfoStorageClass* storageArray = storageArraySg_File_Info;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               Sg_File_Info* tmp = new Sg_File_Info ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySg_File_Info;  
      Sg_File_InfoStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgTypeCAFTeam ); 
     storageClassIndex = 0 ;
     SgTypeCAFTeamStorageClass* storageArraySgTypeCAFTeam = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgTypeCAFTeam = new SgTypeCAFTeamStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgTypeCAFTeam) , sizeof ( SgTypeCAFTeamStorageClass ) * sizeOfActualPool) ;
        SgTypeCAFTeamStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgTypeCAFTeamStorageClass* storageArray = storageArraySgTypeCAFTeam;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgTypeCAFTeam* tmp = new SgTypeCAFTeam ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgTypeCAFTeam;  
      SgTypeCAFTeamStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgCAFWithTeamStatement ); 
     storageClassIndex = 0 ;
     SgCAFWithTeamStatementStorageClass* storageArraySgCAFWithTeamStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgCAFWithTeamStatement = new SgCAFWithTeamStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgCAFWithTeamStatement) , sizeof ( SgCAFWithTeamStatementStorageClass ) * sizeOfActualPool) ;
        SgCAFWithTeamStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgCAFWithTeamStatementStorageClass* storageArray = storageArraySgCAFWithTeamStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgCAFWithTeamStatement* tmp = new SgCAFWithTeamStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgCAFWithTeamStatement;  
      SgCAFWithTeamStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgCAFCoExpression ); 
     storageClassIndex = 0 ;
     SgCAFCoExpressionStorageClass* storageArraySgCAFCoExpression = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgCAFCoExpression = new SgCAFCoExpressionStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgCAFCoExpression) , sizeof ( SgCAFCoExpressionStorageClass ) * sizeOfActualPool) ;
        SgCAFCoExpressionStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgCAFCoExpressionStorageClass* storageArray = storageArraySgCAFCoExpression;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgCAFCoExpression* tmp = new SgCAFCoExpression ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgCAFCoExpression;  
      SgCAFCoExpressionStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgCallExpression ); 
     storageClassIndex = 0 ;
     SgCallExpressionStorageClass* storageArraySgCallExpression = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgCallExpression = new SgCallExpressionStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgCallExpression) , sizeof ( SgCallExpressionStorageClass ) * sizeOfActualPool) ;
        SgCallExpressionStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgCallExpressionStorageClass* storageArray = storageArraySgCallExpression;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgCallExpression* tmp = new SgCallExpression ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgCallExpression;  
      SgCallExpressionStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgTypeCrayPointer ); 
     storageClassIndex = 0 ;
     SgTypeCrayPointerStorageClass* storageArraySgTypeCrayPointer = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgTypeCrayPointer = new SgTypeCrayPointerStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgTypeCrayPointer) , sizeof ( SgTypeCrayPointerStorageClass ) * sizeOfActualPool) ;
        SgTypeCrayPointerStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgTypeCrayPointerStorageClass* storageArray = storageArraySgTypeCrayPointer;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgTypeCrayPointer* tmp = new SgTypeCrayPointer ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgTypeCrayPointer;  
      SgTypeCrayPointerStorageClass :: deleteStaticDataOfEasyStorageClasses();


     sizeOfActualPool = getPoolSizeOfNewAst(V_SgJavaImportStatement ); 
     storageClassIndex = 0 ;
     SgJavaImportStatementStorageClass* storageArraySgJavaImportStatement = NULL;
     if ( 0 < sizeOfActualPool ) 
        {  
          storageArraySgJavaImportStatement = new SgJavaImportStatementStorageClass[sizeOfActualPool] ;
          inFile.read ( (char*) (storageArraySgJavaImportStatement) , sizeof ( SgJavaImportStatementStorageClass ) * sizeOfActualPool) ;
        SgJavaImportStatementStorageClass :: readEasyStorageDataFromFile(inFile) ;
          SgJavaImportStatementStorageClass* storageArray = storageArraySgJavaImportStatement;
          for ( unsigned int i = 0;  i < sizeOfActualPool; ++i )
             {
               SgJavaImportStatement* tmp = new SgJavaImportStatement ( *storageArray ) ; 
               ROSE_ASSERT(tmp->p_freepointer == AST_FileIO::IS_VALID_POINTER() ); 
               storageArray++ ; 
             }
        }  
      delete [] storageArraySgJavaImportStatement;  
      SgJavaImportStatementStorageClass :: deleteStaticDataOfEasyStorageClasses();



/* #line 860 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarAST_FileIoSource.code" */

     }

     {
  // DQ (4/22/2006): Added timer information for AST File I/O
     TimingPerformance nested_timer ("AST_FILE_IO::readASTFromStream() rebuild AST (part 3):");

     for ( int i = 0; i < totalNumberOfIRNodes; ++i)
        {
          listOfMemoryPoolSizes[i] += getPoolSizeOfNewAst(i);
        }
     listOfMemoryPoolSizes[totalNumberOfIRNodes] += getTotalNumberOfNodesOfNewAst();

     freepointersOfCurrentAstAreSetToGlobalIndices = false;
     std::string endString = "ROSE_AST_BINARY_END";
     char* endChar = new char [ endString.size() + 1];
     endChar[ endString.size() ] = '\0';
     inFile.read ( endChar , endString.size() );
     assert (inFile);
     assert ( string(endChar) == endString );
     delete [] endChar;
     }

     SgProject* returnPointer = actualRebuildAst->getRootOfAst();
     assert ( returnPointer != NULL );
     
#if FILE_IO_EXTRA_CHECK
  // DQ (4/22/2006): Added timer information for AST File I/O
     TimingPerformance nested_timer ("AST_FILE_IO::readASTFromStream() FILE_IO_EXTRA_CHECK:");

     if ( SgProject::get_verbose() > 0 )
          std::cout << " Checking the ast via pool entries .... " << std::endl;

#if 0
     MemoryCheckingTraversalForAstFileIO memoryCheckingTraversal;
     memoryCheckingTraversal.traverseMemoryPool();
#endif
#endif

     return returnPointer;
   }

/* JH (01/03/2006) This method reads an AST in binary format from the file 
*/
SgProject*
AST_FILE_IO :: readASTFromFile ( std::string fileName )
  {
  // DQ (4/22/2006): Added timer information for AST File I/O
     TimingPerformance timer ("AST_FILE_IO::readASTFromFile() time (sec) = ");
 
     std::ifstream inFile;
     inFile.open ( fileName.c_str(), std::ios::in | std::ios::binary );
     if ( inFile == NULL )
        {
          std::cout << "Problems opening file " << fileName << " for reading AST!" << std::endl;
          exit(-1);
        }
     SgProject* returnPointer = AST_FILE_IO::readASTFromStream(inFile);

     inFile.close() ;

     return returnPointer;
   }

SgProject*
AST_FILE_IO :: readASTFromString ( const std::string& s )
  {
    std::istringstream inFile(s);
    return AST_FILE_IO::readASTFromStream(inFile);
  }


// DQ (2/27/2010): Reset the AST File I/O data structures to permit writing a file after the reading and merging of files.
void
AST_FILE_IO::reset()
   {
  // This function reset the static data in AST_FILE_IO so that files read can 
  // be written out again (e.g. after a merge of reading multiple files).

     freepointersOfCurrentAstAreSetToGlobalIndices = false;

     for (int i = 0; i < V_SgNumVariants; i++)
        {
       // listOfMemoryPoolSizes[i] = 0;
        }

     registeredAttributes.clear();

     for (size_t i = 0; i < vectorOfASTs.size(); i++)
        {
          vectorOfASTs[i] = NULL;
        }
     vectorOfASTs.clear();

     actualRebuildAst = NULL;
   }


// DQ (2/27/2010): Show what the values are for debugging (e.g. write after read).
void
AST_FILE_IO::display(const std::string & label)
   {
  // This function is useful for viewing the static (private) data member in the AST_FILE_IO class.

     printf ("In AST_FILE_IO::display (label = %s) \n",label.c_str());

     printf ("freepointersOfCurrentAstAreSetToGlobalIndices = %s \n",freepointersOfCurrentAstAreSetToGlobalIndices ? "true" : "false");

     int numberOfDifferentIRnodes = 0;
     for (int i = 0; i < V_SgNumVariants; i++)
        {
          if (listOfMemoryPoolSizes[i] > 0)
             {
               printf ("listOfMemoryPoolSizes [%s] = %lu \n",roseGlobalVariantNameList[i],listOfMemoryPoolSizes[i]);
               numberOfDifferentIRnodes++;
             }
        }
     printf ("Number of different types of IR nodes = %d \n",numberOfDifferentIRnodes);

     printf ("registeredAttributes.size() = %zu \n",registeredAttributes.size());
     for (std::map <std::string,CONSTRUCTOR>::iterator i = registeredAttributes.begin(); i != registeredAttributes.end(); i++)
        {
       // This is a map of strings to function pointers (registered pack and unpack functions).
          printf ("i->first = %s  i->second = member function \n",i->first.c_str());
        }

     printf ("vectorOfASTs.size() = %zu \n",vectorOfASTs.size());
     for (size_t i = 0; i < vectorOfASTs.size(); i++)
        {
       // This is a map of strings to function pointers (registered pack and unpack functions).
          printf ("vectorOfASTs[%zu] = %p \n",i,vectorOfASTs[i]);
        }

     printf ("actualRebuildAst = %p \n",actualRebuildAst);
   }


