/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStaticDataManagingClassSource.macro" */
/* JH (01/01/2006) This file is generated using ROSETTA. It should never be 
   manipulated by hand. The generation is located in buildStorageClasses.C!

    This file contains all decfinitions for the StorageClasses used for the ast file IO.
*/

#ifndef STORAGE_CLASSES_H
#define STORAGE_CLASSES_H

#include "sage3basic.hhh" // static data managing

/* JH (02/02/2006) REMARK: Since the declarations, definitions and use of the static member functions of 
   the templated EasyStorage classes is spread over the files below, we need to compile them all together 
   at this point. The splitting into several files is just to simplify and separate their contents! 
*/

#include "rosedefs.h"
#include "Cxx_Grammar.h"

#include "AST_FILE_IO.h"
#include "Cxx_GrammarMemoryPoolSupport.h"
#include "StorageClasses.h"

// DQ (3/7/2010): Added to support debugging.
#include "AstDiagnostics.h"

#include "StorageClassMemoryManagement.C"
#include "SourcesOfIRNodesAstFileIOSupport.C"


SgProject* 
AstSpecificDataManagingClass::getRootOfAst () const
   {
     return rootOfAst;
   }

unsigned long 
AstSpecificDataManagingClass::getNumberOfAccumulatedNodes (const int position) const
   {
     return listOfAccumulatedPoolSizes[position];
   }

unsigned long
AstSpecificDataManagingClass::getMemoryPoolSize (const int position) const
   {
     return listOfAccumulatedPoolSizes[position + 1] - listOfAccumulatedPoolSizes[position];
   }

unsigned long 
AstSpecificDataManagingClass::getTotalNumberOfASTIRNodes ( ) const
   {
     return listOfAccumulatedPoolSizes[ 710 ] ;
   }

int 
AstSpecificDataManagingClass::get_AstIndex() const
   {
     return astIndex;
   }


/* #line 64 "../../../src/frontend/SageIII//StorageClasses.C" */
SgFunctionTypeTable*
AstSpecificDataManagingClass::get_SgNode_globalFunctionTypeTable() const
  {
    return SgNode_globalFunctionTypeTable;
  }

SgTypeTable*
AstSpecificDataManagingClass::get_SgNode_globalTypeTable() const
  {
    return SgNode_globalTypeTable;
  }

std::map<SgNode*,std::string>
AstSpecificDataManagingClass::get_SgNode_globalMangledNameMap() const
  {
    return SgNode_globalMangledNameMap;
  }

std::map<std::string, int>
AstSpecificDataManagingClass::get_SgNode_shortMangledNameCache() const
  {
    return SgNode_shortMangledNameCache;
  }

std::map<SgNode*,std::string>
AstSpecificDataManagingClass::get_SgNode_globalQualifiedNameMapForNames() const
  {
    return SgNode_globalQualifiedNameMapForNames;
  }

std::map<SgNode*,std::string>
AstSpecificDataManagingClass::get_SgNode_globalQualifiedNameMapForTypes() const
  {
    return SgNode_globalQualifiedNameMapForTypes;
  }

std::map<SgNode*,std::string>
AstSpecificDataManagingClass::get_SgNode_globalTypeNameMap() const
  {
    return SgNode_globalTypeNameMap;
  }

std::map<int, std::string>
AstSpecificDataManagingClass::get_Sg_File_Info_fileidtoname_map() const
  {
    return Sg_File_Info_fileidtoname_map;
  }

std::map<std::string, int>
AstSpecificDataManagingClass::get_Sg_File_Info_nametofileid_map() const
  {
    return Sg_File_Info_nametofileid_map;
  }

SgTypePtrList
AstSpecificDataManagingClass::get_SgUnparse_Info_structureTagProcessingList() const
  {
    return SgUnparse_Info_structureTagProcessingList;
  }

bool
AstSpecificDataManagingClass::get_SgUnparse_Info_forceDefaultConstructorToTriggerError() const
  {
    return SgUnparse_Info_forceDefaultConstructorToTriggerError;
  }

int
AstSpecificDataManagingClass::get_SgGraph_index_counter() const
  {
    return SgGraph_index_counter;
  }

int
AstSpecificDataManagingClass::get_SgGraphNode_index_counter() const
  {
    return SgGraphNode_index_counter;
  }

int
AstSpecificDataManagingClass::get_SgGraphEdge_index_counter() const
  {
    return SgGraphEdge_index_counter;
  }

SgTypeUnknown*
AstSpecificDataManagingClass::get_SgTypeUnknown_builtin_type() const
  {
    return SgTypeUnknown_builtin_type;
  }

SgTypeChar*
AstSpecificDataManagingClass::get_SgTypeChar_builtin_type() const
  {
    return SgTypeChar_builtin_type;
  }

SgTypeSignedChar*
AstSpecificDataManagingClass::get_SgTypeSignedChar_builtin_type() const
  {
    return SgTypeSignedChar_builtin_type;
  }

SgTypeUnsignedChar*
AstSpecificDataManagingClass::get_SgTypeUnsignedChar_builtin_type() const
  {
    return SgTypeUnsignedChar_builtin_type;
  }

SgTypeShort*
AstSpecificDataManagingClass::get_SgTypeShort_builtin_type() const
  {
    return SgTypeShort_builtin_type;
  }

SgTypeSignedShort*
AstSpecificDataManagingClass::get_SgTypeSignedShort_builtin_type() const
  {
    return SgTypeSignedShort_builtin_type;
  }

SgTypeUnsignedShort*
AstSpecificDataManagingClass::get_SgTypeUnsignedShort_builtin_type() const
  {
    return SgTypeUnsignedShort_builtin_type;
  }

SgTypeInt*
AstSpecificDataManagingClass::get_SgTypeInt_builtin_type() const
  {
    return SgTypeInt_builtin_type;
  }

SgTypeSignedInt*
AstSpecificDataManagingClass::get_SgTypeSignedInt_builtin_type() const
  {
    return SgTypeSignedInt_builtin_type;
  }

SgTypeUnsignedInt*
AstSpecificDataManagingClass::get_SgTypeUnsignedInt_builtin_type() const
  {
    return SgTypeUnsignedInt_builtin_type;
  }

SgTypeLong*
AstSpecificDataManagingClass::get_SgTypeLong_builtin_type() const
  {
    return SgTypeLong_builtin_type;
  }

SgTypeSignedLong*
AstSpecificDataManagingClass::get_SgTypeSignedLong_builtin_type() const
  {
    return SgTypeSignedLong_builtin_type;
  }

SgTypeUnsignedLong*
AstSpecificDataManagingClass::get_SgTypeUnsignedLong_builtin_type() const
  {
    return SgTypeUnsignedLong_builtin_type;
  }

SgTypeVoid*
AstSpecificDataManagingClass::get_SgTypeVoid_builtin_type() const
  {
    return SgTypeVoid_builtin_type;
  }

SgTypeGlobalVoid*
AstSpecificDataManagingClass::get_SgTypeGlobalVoid_builtin_type() const
  {
    return SgTypeGlobalVoid_builtin_type;
  }

SgTypeWchar*
AstSpecificDataManagingClass::get_SgTypeWchar_builtin_type() const
  {
    return SgTypeWchar_builtin_type;
  }

SgTypeFloat*
AstSpecificDataManagingClass::get_SgTypeFloat_builtin_type() const
  {
    return SgTypeFloat_builtin_type;
  }

SgTypeDouble*
AstSpecificDataManagingClass::get_SgTypeDouble_builtin_type() const
  {
    return SgTypeDouble_builtin_type;
  }

SgTypeLongLong*
AstSpecificDataManagingClass::get_SgTypeLongLong_builtin_type() const
  {
    return SgTypeLongLong_builtin_type;
  }

SgTypeSignedLongLong*
AstSpecificDataManagingClass::get_SgTypeSignedLongLong_builtin_type() const
  {
    return SgTypeSignedLongLong_builtin_type;
  }

SgTypeUnsignedLongLong*
AstSpecificDataManagingClass::get_SgTypeUnsignedLongLong_builtin_type() const
  {
    return SgTypeUnsignedLongLong_builtin_type;
  }

SgTypeLongDouble*
AstSpecificDataManagingClass::get_SgTypeLongDouble_builtin_type() const
  {
    return SgTypeLongDouble_builtin_type;
  }

SgTypeBool*
AstSpecificDataManagingClass::get_SgTypeBool_builtin_type() const
  {
    return SgTypeBool_builtin_type;
  }

SgNamedType*
AstSpecificDataManagingClass::get_SgNamedType_builtin_type() const
  {
    return SgNamedType_builtin_type;
  }

SgPartialFunctionModifierType*
AstSpecificDataManagingClass::get_SgPartialFunctionModifierType_builtin_type() const
  {
    return SgPartialFunctionModifierType_builtin_type;
  }

SgTypeEllipse*
AstSpecificDataManagingClass::get_SgTypeEllipse_builtin_type() const
  {
    return SgTypeEllipse_builtin_type;
  }

SgTypeDefault*
AstSpecificDataManagingClass::get_SgTypeDefault_builtin_type() const
  {
    return SgTypeDefault_builtin_type;
  }

SgTypeCAFTeam*
AstSpecificDataManagingClass::get_SgTypeCAFTeam_builtin_type() const
  {
    return SgTypeCAFTeam_builtin_type;
  }

SgTypeCrayPointer*
AstSpecificDataManagingClass::get_SgTypeCrayPointer_builtin_type() const
  {
    return SgTypeCrayPointer_builtin_type;
  }

SgTypeLabel*
AstSpecificDataManagingClass::get_SgTypeLabel_builtin_type() const
  {
    return SgTypeLabel_builtin_type;
  }

SgAsmTypeByte*
AstSpecificDataManagingClass::get_SgAsmTypeByte_builtin_type() const
  {
    return SgAsmTypeByte_builtin_type;
  }

SgAsmTypeWord*
AstSpecificDataManagingClass::get_SgAsmTypeWord_builtin_type() const
  {
    return SgAsmTypeWord_builtin_type;
  }

SgAsmTypeDoubleWord*
AstSpecificDataManagingClass::get_SgAsmTypeDoubleWord_builtin_type() const
  {
    return SgAsmTypeDoubleWord_builtin_type;
  }

SgAsmTypeQuadWord*
AstSpecificDataManagingClass::get_SgAsmTypeQuadWord_builtin_type() const
  {
    return SgAsmTypeQuadWord_builtin_type;
  }

SgAsmTypeDoubleQuadWord*
AstSpecificDataManagingClass::get_SgAsmTypeDoubleQuadWord_builtin_type() const
  {
    return SgAsmTypeDoubleQuadWord_builtin_type;
  }

SgAsmType80bitFloat*
AstSpecificDataManagingClass::get_SgAsmType80bitFloat_builtin_type() const
  {
    return SgAsmType80bitFloat_builtin_type;
  }

SgAsmType128bitFloat*
AstSpecificDataManagingClass::get_SgAsmType128bitFloat_builtin_type() const
  {
    return SgAsmType128bitFloat_builtin_type;
  }

SgAsmTypeSingleFloat*
AstSpecificDataManagingClass::get_SgAsmTypeSingleFloat_builtin_type() const
  {
    return SgAsmTypeSingleFloat_builtin_type;
  }

SgAsmTypeDoubleFloat*
AstSpecificDataManagingClass::get_SgAsmTypeDoubleFloat_builtin_type() const
  {
    return SgAsmTypeDoubleFloat_builtin_type;
  }

AstSpecificDataManagingClass::AstSpecificDataManagingClass( SgProject* root )
   {
     rootOfAst = root;
     astIndex = AST_FILE_IO::getNumberOfAsts(); 
     SgNode_globalFunctionTypeTable = SgNode::p_globalFunctionTypeTable;
     SgNode_globalTypeTable = SgNode::p_globalTypeTable;
     SgNode_globalMangledNameMap = SgNode::p_globalMangledNameMap;
     SgNode_shortMangledNameCache = SgNode::p_shortMangledNameCache;
     SgNode_globalQualifiedNameMapForNames = SgNode::p_globalQualifiedNameMapForNames;
     SgNode_globalQualifiedNameMapForTypes = SgNode::p_globalQualifiedNameMapForTypes;
     SgNode_globalTypeNameMap = SgNode::p_globalTypeNameMap;
     Sg_File_Info_fileidtoname_map = Sg_File_Info::p_fileidtoname_map;
     Sg_File_Info_nametofileid_map = Sg_File_Info::p_nametofileid_map;
     SgUnparse_Info_structureTagProcessingList = SgUnparse_Info::p_structureTagProcessingList;
     SgUnparse_Info_forceDefaultConstructorToTriggerError = SgUnparse_Info::p_forceDefaultConstructorToTriggerError;
     SgGraph_index_counter = SgGraph::p_index_counter;
     SgGraphNode_index_counter = SgGraphNode::p_index_counter;
     SgGraphEdge_index_counter = SgGraphEdge::p_index_counter;
     SgTypeUnknown_builtin_type = SgTypeUnknown::p_builtin_type;
     SgTypeChar_builtin_type = SgTypeChar::p_builtin_type;
     SgTypeSignedChar_builtin_type = SgTypeSignedChar::p_builtin_type;
     SgTypeUnsignedChar_builtin_type = SgTypeUnsignedChar::p_builtin_type;
     SgTypeShort_builtin_type = SgTypeShort::p_builtin_type;
     SgTypeSignedShort_builtin_type = SgTypeSignedShort::p_builtin_type;
     SgTypeUnsignedShort_builtin_type = SgTypeUnsignedShort::p_builtin_type;
     SgTypeInt_builtin_type = SgTypeInt::p_builtin_type;
     SgTypeSignedInt_builtin_type = SgTypeSignedInt::p_builtin_type;
     SgTypeUnsignedInt_builtin_type = SgTypeUnsignedInt::p_builtin_type;
     SgTypeLong_builtin_type = SgTypeLong::p_builtin_type;
     SgTypeSignedLong_builtin_type = SgTypeSignedLong::p_builtin_type;
     SgTypeUnsignedLong_builtin_type = SgTypeUnsignedLong::p_builtin_type;
     SgTypeVoid_builtin_type = SgTypeVoid::p_builtin_type;
     SgTypeGlobalVoid_builtin_type = SgTypeGlobalVoid::p_builtin_type;
     SgTypeWchar_builtin_type = SgTypeWchar::p_builtin_type;
     SgTypeFloat_builtin_type = SgTypeFloat::p_builtin_type;
     SgTypeDouble_builtin_type = SgTypeDouble::p_builtin_type;
     SgTypeLongLong_builtin_type = SgTypeLongLong::p_builtin_type;
     SgTypeSignedLongLong_builtin_type = SgTypeSignedLongLong::p_builtin_type;
     SgTypeUnsignedLongLong_builtin_type = SgTypeUnsignedLongLong::p_builtin_type;
     SgTypeLongDouble_builtin_type = SgTypeLongDouble::p_builtin_type;
     SgTypeBool_builtin_type = SgTypeBool::p_builtin_type;
     SgNamedType_builtin_type = SgNamedType::p_builtin_type;
     SgPartialFunctionModifierType_builtin_type = SgPartialFunctionModifierType::p_builtin_type;
     SgTypeEllipse_builtin_type = SgTypeEllipse::p_builtin_type;
     SgTypeDefault_builtin_type = SgTypeDefault::p_builtin_type;
     SgTypeCAFTeam_builtin_type = SgTypeCAFTeam::p_builtin_type;
     SgTypeCrayPointer_builtin_type = SgTypeCrayPointer::p_builtin_type;
     SgTypeLabel_builtin_type = SgTypeLabel::p_builtin_type;
     SgAsmTypeByte_builtin_type = SgAsmTypeByte::p_builtin_type;
     SgAsmTypeWord_builtin_type = SgAsmTypeWord::p_builtin_type;
     SgAsmTypeDoubleWord_builtin_type = SgAsmTypeDoubleWord::p_builtin_type;
     SgAsmTypeQuadWord_builtin_type = SgAsmTypeQuadWord::p_builtin_type;
     SgAsmTypeDoubleQuadWord_builtin_type = SgAsmTypeDoubleQuadWord::p_builtin_type;
     SgAsmType80bitFloat_builtin_type = SgAsmType80bitFloat::p_builtin_type;
     SgAsmType128bitFloat_builtin_type = SgAsmType128bitFloat::p_builtin_type;
     SgAsmTypeSingleFloat_builtin_type = SgAsmTypeSingleFloat::p_builtin_type;
     SgAsmTypeDoubleFloat_builtin_type = SgAsmTypeDoubleFloat::p_builtin_type;
   }

void
AstSpecificDataManagingClass::setStaticDataMembersOfIRNodes ( ) const
   {
     if ( SgNode_globalFunctionTypeTable != NULL ) 
        {
          if (SgNode::p_globalFunctionTypeTable == NULL)
             {
               SgNode::p_globalFunctionTypeTable = SgNode_globalFunctionTypeTable;
             }
        }
     if ( SgNode_globalTypeTable != NULL ) 
        {
          if (SgNode::p_globalTypeTable == NULL)
             {
               SgNode::p_globalTypeTable = SgNode_globalTypeTable;
             }
        }
     SgNode::p_globalMangledNameMap = SgNode_globalMangledNameMap;
     SgNode::p_shortMangledNameCache = SgNode_shortMangledNameCache;
     SgNode::p_globalQualifiedNameMapForNames = SgNode_globalQualifiedNameMapForNames;
     SgNode::p_globalQualifiedNameMapForTypes = SgNode_globalQualifiedNameMapForTypes;
     SgNode::p_globalTypeNameMap = SgNode_globalTypeNameMap;
     Sg_File_Info::p_fileidtoname_map = Sg_File_Info_fileidtoname_map;
     Sg_File_Info::p_nametofileid_map = Sg_File_Info_nametofileid_map;
     SgUnparse_Info::p_structureTagProcessingList = SgUnparse_Info_structureTagProcessingList;
     SgUnparse_Info::p_forceDefaultConstructorToTriggerError = SgUnparse_Info_forceDefaultConstructorToTriggerError;
     SgGraph::p_index_counter = SgGraph_index_counter;
     SgGraphNode::p_index_counter = SgGraphNode_index_counter;
     SgGraphEdge::p_index_counter = SgGraphEdge_index_counter;
     if ( SgTypeUnknown_builtin_type != NULL ) 
        {
          if (SgTypeUnknown::p_builtin_type == NULL)
             {
               SgTypeUnknown::p_builtin_type = SgTypeUnknown_builtin_type;
             }
        }
     if ( SgTypeChar_builtin_type != NULL ) 
        {
          if (SgTypeChar::p_builtin_type == NULL)
             {
               SgTypeChar::p_builtin_type = SgTypeChar_builtin_type;
             }
        }
     if ( SgTypeSignedChar_builtin_type != NULL ) 
        {
          if (SgTypeSignedChar::p_builtin_type == NULL)
             {
               SgTypeSignedChar::p_builtin_type = SgTypeSignedChar_builtin_type;
             }
        }
     if ( SgTypeUnsignedChar_builtin_type != NULL ) 
        {
          if (SgTypeUnsignedChar::p_builtin_type == NULL)
             {
               SgTypeUnsignedChar::p_builtin_type = SgTypeUnsignedChar_builtin_type;
             }
        }
     if ( SgTypeShort_builtin_type != NULL ) 
        {
          if (SgTypeShort::p_builtin_type == NULL)
             {
               SgTypeShort::p_builtin_type = SgTypeShort_builtin_type;
             }
        }
     if ( SgTypeSignedShort_builtin_type != NULL ) 
        {
          if (SgTypeSignedShort::p_builtin_type == NULL)
             {
               SgTypeSignedShort::p_builtin_type = SgTypeSignedShort_builtin_type;
             }
        }
     if ( SgTypeUnsignedShort_builtin_type != NULL ) 
        {
          if (SgTypeUnsignedShort::p_builtin_type == NULL)
             {
               SgTypeUnsignedShort::p_builtin_type = SgTypeUnsignedShort_builtin_type;
             }
        }
     if ( SgTypeInt_builtin_type != NULL ) 
        {
          if (SgTypeInt::p_builtin_type == NULL)
             {
               SgTypeInt::p_builtin_type = SgTypeInt_builtin_type;
             }
        }
     if ( SgTypeSignedInt_builtin_type != NULL ) 
        {
          if (SgTypeSignedInt::p_builtin_type == NULL)
             {
               SgTypeSignedInt::p_builtin_type = SgTypeSignedInt_builtin_type;
             }
        }
     if ( SgTypeUnsignedInt_builtin_type != NULL ) 
        {
          if (SgTypeUnsignedInt::p_builtin_type == NULL)
             {
               SgTypeUnsignedInt::p_builtin_type = SgTypeUnsignedInt_builtin_type;
             }
        }
     if ( SgTypeLong_builtin_type != NULL ) 
        {
          if (SgTypeLong::p_builtin_type == NULL)
             {
               SgTypeLong::p_builtin_type = SgTypeLong_builtin_type;
             }
        }
     if ( SgTypeSignedLong_builtin_type != NULL ) 
        {
          if (SgTypeSignedLong::p_builtin_type == NULL)
             {
               SgTypeSignedLong::p_builtin_type = SgTypeSignedLong_builtin_type;
             }
        }
     if ( SgTypeUnsignedLong_builtin_type != NULL ) 
        {
          if (SgTypeUnsignedLong::p_builtin_type == NULL)
             {
               SgTypeUnsignedLong::p_builtin_type = SgTypeUnsignedLong_builtin_type;
             }
        }
     if ( SgTypeVoid_builtin_type != NULL ) 
        {
          if (SgTypeVoid::p_builtin_type == NULL)
             {
               SgTypeVoid::p_builtin_type = SgTypeVoid_builtin_type;
             }
        }
     if ( SgTypeGlobalVoid_builtin_type != NULL ) 
        {
          if (SgTypeGlobalVoid::p_builtin_type == NULL)
             {
               SgTypeGlobalVoid::p_builtin_type = SgTypeGlobalVoid_builtin_type;
             }
        }
     if ( SgTypeWchar_builtin_type != NULL ) 
        {
          if (SgTypeWchar::p_builtin_type == NULL)
             {
               SgTypeWchar::p_builtin_type = SgTypeWchar_builtin_type;
             }
        }
     if ( SgTypeFloat_builtin_type != NULL ) 
        {
          if (SgTypeFloat::p_builtin_type == NULL)
             {
               SgTypeFloat::p_builtin_type = SgTypeFloat_builtin_type;
             }
        }
     if ( SgTypeDouble_builtin_type != NULL ) 
        {
          if (SgTypeDouble::p_builtin_type == NULL)
             {
               SgTypeDouble::p_builtin_type = SgTypeDouble_builtin_type;
             }
        }
     if ( SgTypeLongLong_builtin_type != NULL ) 
        {
          if (SgTypeLongLong::p_builtin_type == NULL)
             {
               SgTypeLongLong::p_builtin_type = SgTypeLongLong_builtin_type;
             }
        }
     if ( SgTypeSignedLongLong_builtin_type != NULL ) 
        {
          if (SgTypeSignedLongLong::p_builtin_type == NULL)
             {
               SgTypeSignedLongLong::p_builtin_type = SgTypeSignedLongLong_builtin_type;
             }
        }
     if ( SgTypeUnsignedLongLong_builtin_type != NULL ) 
        {
          if (SgTypeUnsignedLongLong::p_builtin_type == NULL)
             {
               SgTypeUnsignedLongLong::p_builtin_type = SgTypeUnsignedLongLong_builtin_type;
             }
        }
     if ( SgTypeLongDouble_builtin_type != NULL ) 
        {
          if (SgTypeLongDouble::p_builtin_type == NULL)
             {
               SgTypeLongDouble::p_builtin_type = SgTypeLongDouble_builtin_type;
             }
        }
     if ( SgTypeBool_builtin_type != NULL ) 
        {
          if (SgTypeBool::p_builtin_type == NULL)
             {
               SgTypeBool::p_builtin_type = SgTypeBool_builtin_type;
             }
        }
     if ( SgNamedType_builtin_type != NULL ) 
        {
          if (SgNamedType::p_builtin_type == NULL)
             {
               SgNamedType::p_builtin_type = SgNamedType_builtin_type;
             }
        }
     if ( SgPartialFunctionModifierType_builtin_type != NULL ) 
        {
          if (SgPartialFunctionModifierType::p_builtin_type == NULL)
             {
               SgPartialFunctionModifierType::p_builtin_type = SgPartialFunctionModifierType_builtin_type;
             }
        }
     if ( SgTypeEllipse_builtin_type != NULL ) 
        {
          if (SgTypeEllipse::p_builtin_type == NULL)
             {
               SgTypeEllipse::p_builtin_type = SgTypeEllipse_builtin_type;
             }
        }
     if ( SgTypeDefault_builtin_type != NULL ) 
        {
          if (SgTypeDefault::p_builtin_type == NULL)
             {
               SgTypeDefault::p_builtin_type = SgTypeDefault_builtin_type;
             }
        }
     if ( SgTypeCAFTeam_builtin_type != NULL ) 
        {
          if (SgTypeCAFTeam::p_builtin_type == NULL)
             {
               SgTypeCAFTeam::p_builtin_type = SgTypeCAFTeam_builtin_type;
             }
        }
     if ( SgTypeCrayPointer_builtin_type != NULL ) 
        {
          if (SgTypeCrayPointer::p_builtin_type == NULL)
             {
               SgTypeCrayPointer::p_builtin_type = SgTypeCrayPointer_builtin_type;
             }
        }
     if ( SgTypeLabel_builtin_type != NULL ) 
        {
          if (SgTypeLabel::p_builtin_type == NULL)
             {
               SgTypeLabel::p_builtin_type = SgTypeLabel_builtin_type;
             }
        }
     if ( SgAsmTypeByte_builtin_type != NULL ) 
        {
          if (SgAsmTypeByte::p_builtin_type == NULL)
             {
               SgAsmTypeByte::p_builtin_type = SgAsmTypeByte_builtin_type;
             }
        }
     if ( SgAsmTypeWord_builtin_type != NULL ) 
        {
          if (SgAsmTypeWord::p_builtin_type == NULL)
             {
               SgAsmTypeWord::p_builtin_type = SgAsmTypeWord_builtin_type;
             }
        }
     if ( SgAsmTypeDoubleWord_builtin_type != NULL ) 
        {
          if (SgAsmTypeDoubleWord::p_builtin_type == NULL)
             {
               SgAsmTypeDoubleWord::p_builtin_type = SgAsmTypeDoubleWord_builtin_type;
             }
        }
     if ( SgAsmTypeQuadWord_builtin_type != NULL ) 
        {
          if (SgAsmTypeQuadWord::p_builtin_type == NULL)
             {
               SgAsmTypeQuadWord::p_builtin_type = SgAsmTypeQuadWord_builtin_type;
             }
        }
     if ( SgAsmTypeDoubleQuadWord_builtin_type != NULL ) 
        {
          if (SgAsmTypeDoubleQuadWord::p_builtin_type == NULL)
             {
               SgAsmTypeDoubleQuadWord::p_builtin_type = SgAsmTypeDoubleQuadWord_builtin_type;
             }
        }
     if ( SgAsmType80bitFloat_builtin_type != NULL ) 
        {
          if (SgAsmType80bitFloat::p_builtin_type == NULL)
             {
               SgAsmType80bitFloat::p_builtin_type = SgAsmType80bitFloat_builtin_type;
             }
        }
     if ( SgAsmType128bitFloat_builtin_type != NULL ) 
        {
          if (SgAsmType128bitFloat::p_builtin_type == NULL)
             {
               SgAsmType128bitFloat::p_builtin_type = SgAsmType128bitFloat_builtin_type;
             }
        }
     if ( SgAsmTypeSingleFloat_builtin_type != NULL ) 
        {
          if (SgAsmTypeSingleFloat::p_builtin_type == NULL)
             {
               SgAsmTypeSingleFloat::p_builtin_type = SgAsmTypeSingleFloat_builtin_type;
             }
        }
     if ( SgAsmTypeDoubleFloat_builtin_type != NULL ) 
        {
          if (SgAsmTypeDoubleFloat::p_builtin_type == NULL)
             {
               SgAsmTypeDoubleFloat::p_builtin_type = SgAsmTypeDoubleFloat_builtin_type;
             }
        }
   }

void
AstSpecificDataManagingClassStorageClass::pickOutIRNodeData ( AstSpecificDataManagingClass* source )
   {
     for(int i =  0; i < 710 + 1; ++ i )
        {
          listOfAccumulatedPoolSizes[i] = source->listOfAccumulatedPoolSizes[i];
        }
     rootOfAst =  AST_FILE_IO::getGlobalIndexFromSgClassPointer (source->rootOfAst);
     storageOf_SgNode_globalFunctionTypeTable = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->SgNode_globalFunctionTypeTable );
     storageOf_SgNode_globalTypeTable = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->SgNode_globalTypeTable );
     storageOf_SgNode_globalMangledNameMap.storeDataInEasyStorageClass( source->SgNode_globalMangledNameMap);
     storageOf_SgNode_shortMangledNameCache.storeDataInEasyStorageClass( source->SgNode_shortMangledNameCache);
     storageOf_SgNode_globalQualifiedNameMapForNames.storeDataInEasyStorageClass( source->SgNode_globalQualifiedNameMapForNames);
     storageOf_SgNode_globalQualifiedNameMapForTypes.storeDataInEasyStorageClass( source->SgNode_globalQualifiedNameMapForTypes);
     storageOf_SgNode_globalTypeNameMap.storeDataInEasyStorageClass( source->SgNode_globalTypeNameMap);
     storageOf_Sg_File_Info_fileidtoname_map.storeDataInEasyStorageClass( source->Sg_File_Info_fileidtoname_map);
     storageOf_Sg_File_Info_nametofileid_map.storeDataInEasyStorageClass( source->Sg_File_Info_nametofileid_map);
     SgTypePtrList::iterator i_SgUnparse_Info = source->SgUnparse_Info_structureTagProcessingList.begin() ; 
     unsigned int tempListCountSgUnparse_Info = 0; 
     SgTypePtrList::value_type *  tempListSgUnparse_Info = new SgTypePtrList::value_type[ source->SgUnparse_Info_structureTagProcessingList.size() ]; 
     for ( ; i_SgUnparse_Info != source->SgUnparse_Info_structureTagProcessingList.end(); ++i_SgUnparse_Info ) 
        {
          tempListSgUnparse_Info[tempListCountSgUnparse_Info] = *i_SgUnparse_Info;
          tempListCountSgUnparse_Info++; 
          (*i_SgUnparse_Info) = (SgTypePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_SgUnparse_Info ) );
        }
     storageOf_SgUnparse_Info_structureTagProcessingList.storeDataInEasyStorageClass(source->SgUnparse_Info_structureTagProcessingList);
     tempListCountSgUnparse_Info = 0; 
     i_SgUnparse_Info = source->SgUnparse_Info_structureTagProcessingList.begin() ; 
     for ( ; i_SgUnparse_Info != source->SgUnparse_Info_structureTagProcessingList.end(); ++i_SgUnparse_Info ) 
        {
          *i_SgUnparse_Info = tempListSgUnparse_Info[tempListCountSgUnparse_Info] ;
          tempListCountSgUnparse_Info++; 
        }
      delete [] tempListSgUnparse_Info; 
     storageOf_SgUnparse_Info_forceDefaultConstructorToTriggerError =  source->SgUnparse_Info_forceDefaultConstructorToTriggerError ;
     storageOf_SgGraph_index_counter =  source->SgGraph_index_counter ;
     storageOf_SgGraphNode_index_counter =  source->SgGraphNode_index_counter ;
     storageOf_SgGraphEdge_index_counter =  source->SgGraphEdge_index_counter ;
     storageOf_SgTypeUnknown_builtin_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->SgTypeUnknown_builtin_type );
     storageOf_SgTypeChar_builtin_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->SgTypeChar_builtin_type );
     storageOf_SgTypeSignedChar_builtin_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->SgTypeSignedChar_builtin_type );
     storageOf_SgTypeUnsignedChar_builtin_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->SgTypeUnsignedChar_builtin_type );
     storageOf_SgTypeShort_builtin_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->SgTypeShort_builtin_type );
     storageOf_SgTypeSignedShort_builtin_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->SgTypeSignedShort_builtin_type );
     storageOf_SgTypeUnsignedShort_builtin_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->SgTypeUnsignedShort_builtin_type );
     storageOf_SgTypeInt_builtin_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->SgTypeInt_builtin_type );
     storageOf_SgTypeSignedInt_builtin_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->SgTypeSignedInt_builtin_type );
     storageOf_SgTypeUnsignedInt_builtin_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->SgTypeUnsignedInt_builtin_type );
     storageOf_SgTypeLong_builtin_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->SgTypeLong_builtin_type );
     storageOf_SgTypeSignedLong_builtin_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->SgTypeSignedLong_builtin_type );
     storageOf_SgTypeUnsignedLong_builtin_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->SgTypeUnsignedLong_builtin_type );
     storageOf_SgTypeVoid_builtin_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->SgTypeVoid_builtin_type );
     storageOf_SgTypeGlobalVoid_builtin_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->SgTypeGlobalVoid_builtin_type );
     storageOf_SgTypeWchar_builtin_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->SgTypeWchar_builtin_type );
     storageOf_SgTypeFloat_builtin_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->SgTypeFloat_builtin_type );
     storageOf_SgTypeDouble_builtin_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->SgTypeDouble_builtin_type );
     storageOf_SgTypeLongLong_builtin_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->SgTypeLongLong_builtin_type );
     storageOf_SgTypeSignedLongLong_builtin_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->SgTypeSignedLongLong_builtin_type );
     storageOf_SgTypeUnsignedLongLong_builtin_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->SgTypeUnsignedLongLong_builtin_type );
     storageOf_SgTypeLongDouble_builtin_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->SgTypeLongDouble_builtin_type );
     storageOf_SgTypeBool_builtin_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->SgTypeBool_builtin_type );
     storageOf_SgNamedType_builtin_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->SgNamedType_builtin_type );
     storageOf_SgPartialFunctionModifierType_builtin_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->SgPartialFunctionModifierType_builtin_type );
     storageOf_SgTypeEllipse_builtin_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->SgTypeEllipse_builtin_type );
     storageOf_SgTypeDefault_builtin_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->SgTypeDefault_builtin_type );
     storageOf_SgTypeCAFTeam_builtin_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->SgTypeCAFTeam_builtin_type );
     storageOf_SgTypeCrayPointer_builtin_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->SgTypeCrayPointer_builtin_type );
     storageOf_SgTypeLabel_builtin_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->SgTypeLabel_builtin_type );
     storageOf_SgAsmTypeByte_builtin_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->SgAsmTypeByte_builtin_type );
     storageOf_SgAsmTypeWord_builtin_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->SgAsmTypeWord_builtin_type );
     storageOf_SgAsmTypeDoubleWord_builtin_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->SgAsmTypeDoubleWord_builtin_type );
     storageOf_SgAsmTypeQuadWord_builtin_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->SgAsmTypeQuadWord_builtin_type );
     storageOf_SgAsmTypeDoubleQuadWord_builtin_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->SgAsmTypeDoubleQuadWord_builtin_type );
     storageOf_SgAsmType80bitFloat_builtin_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->SgAsmType80bitFloat_builtin_type );
     storageOf_SgAsmType128bitFloat_builtin_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->SgAsmType128bitFloat_builtin_type );
     storageOf_SgAsmTypeSingleFloat_builtin_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->SgAsmTypeSingleFloat_builtin_type );
     storageOf_SgAsmTypeDoubleFloat_builtin_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->SgAsmTypeDoubleFloat_builtin_type );
   }

AstSpecificDataManagingClass::AstSpecificDataManagingClass(const AstSpecificDataManagingClassStorageClass& source)
   {
     for(int i =  0; i < 710 + 1; ++ i )
        {
          listOfAccumulatedPoolSizes[i] = source.listOfAccumulatedPoolSizes[i];
        }
     astIndex = AST_FILE_IO::getNumberOfAsts();
     AST_FILE_IO::addNewAst(this);

  // Note that this call is required to define the locations of IR nodes as addresses 
  // which will be used to reset pointers from global IDs to pointer valuses within the 
  // AST FILE I/O (reading binary ASTs) 
     AST_FILE_IO::extendMemoryPoolsForRebuildingAST();

     rootOfAst = (SgProject*)(AST_FILE_IO::getSgClassPointerFromGlobalIndex (source.rootOfAst));
     SgNode_globalFunctionTypeTable = (SgFunctionTypeTable* ) (AST_FILE_IO::getSgClassPointerFromGlobalIndex (source.storageOf_SgNode_globalFunctionTypeTable ) );
     SgNode_globalTypeTable = (SgTypeTable* ) (AST_FILE_IO::getSgClassPointerFromGlobalIndex (source.storageOf_SgNode_globalTypeTable ) );
     SgNode_globalMangledNameMap = source.storageOf_SgNode_globalMangledNameMap.rebuildDataStoredInEasyStorageClass();
     SgNode_shortMangledNameCache = source.storageOf_SgNode_shortMangledNameCache.rebuildDataStoredInEasyStorageClass();
     SgNode_globalQualifiedNameMapForNames = source.storageOf_SgNode_globalQualifiedNameMapForNames.rebuildDataStoredInEasyStorageClass();
     SgNode_globalQualifiedNameMapForTypes = source.storageOf_SgNode_globalQualifiedNameMapForTypes.rebuildDataStoredInEasyStorageClass();
     SgNode_globalTypeNameMap = source.storageOf_SgNode_globalTypeNameMap.rebuildDataStoredInEasyStorageClass();
     Sg_File_Info_fileidtoname_map = source.storageOf_Sg_File_Info_fileidtoname_map.rebuildDataStoredInEasyStorageClass();
     Sg_File_Info_nametofileid_map = source.storageOf_Sg_File_Info_nametofileid_map.rebuildDataStoredInEasyStorageClass();
     SgUnparse_Info_structureTagProcessingList = source.storageOf_SgUnparse_Info_structureTagProcessingList.rebuildDataStoredInEasyStorageClass();
     SgTypePtrList::iterator i_SgUnparse_Info = SgUnparse_Info_structureTagProcessingList.begin() ; 
     for ( ; i_SgUnparse_Info != SgUnparse_Info_structureTagProcessingList.end(); ++i_SgUnparse_Info ) 
        {
          (*i_SgUnparse_Info) = (SgTypePtrList::value_type)(AST_FILE_IO::getSgClassPointerFromGlobalIndex ( (unsigned long) (*i_SgUnparse_Info )  ) );
        }
     SgUnparse_Info_forceDefaultConstructorToTriggerError = source.storageOf_SgUnparse_Info_forceDefaultConstructorToTriggerError;
     SgGraph_index_counter = source.storageOf_SgGraph_index_counter;
     SgGraphNode_index_counter = source.storageOf_SgGraphNode_index_counter;
     SgGraphEdge_index_counter = source.storageOf_SgGraphEdge_index_counter;
     SgTypeUnknown_builtin_type = (SgTypeUnknown* ) (AST_FILE_IO::getSgClassPointerFromGlobalIndex (source.storageOf_SgTypeUnknown_builtin_type ) );
     SgTypeChar_builtin_type = (SgTypeChar* ) (AST_FILE_IO::getSgClassPointerFromGlobalIndex (source.storageOf_SgTypeChar_builtin_type ) );
     SgTypeSignedChar_builtin_type = (SgTypeSignedChar* ) (AST_FILE_IO::getSgClassPointerFromGlobalIndex (source.storageOf_SgTypeSignedChar_builtin_type ) );
     SgTypeUnsignedChar_builtin_type = (SgTypeUnsignedChar* ) (AST_FILE_IO::getSgClassPointerFromGlobalIndex (source.storageOf_SgTypeUnsignedChar_builtin_type ) );
     SgTypeShort_builtin_type = (SgTypeShort* ) (AST_FILE_IO::getSgClassPointerFromGlobalIndex (source.storageOf_SgTypeShort_builtin_type ) );
     SgTypeSignedShort_builtin_type = (SgTypeSignedShort* ) (AST_FILE_IO::getSgClassPointerFromGlobalIndex (source.storageOf_SgTypeSignedShort_builtin_type ) );
     SgTypeUnsignedShort_builtin_type = (SgTypeUnsignedShort* ) (AST_FILE_IO::getSgClassPointerFromGlobalIndex (source.storageOf_SgTypeUnsignedShort_builtin_type ) );
     SgTypeInt_builtin_type = (SgTypeInt* ) (AST_FILE_IO::getSgClassPointerFromGlobalIndex (source.storageOf_SgTypeInt_builtin_type ) );
     SgTypeSignedInt_builtin_type = (SgTypeSignedInt* ) (AST_FILE_IO::getSgClassPointerFromGlobalIndex (source.storageOf_SgTypeSignedInt_builtin_type ) );
     SgTypeUnsignedInt_builtin_type = (SgTypeUnsignedInt* ) (AST_FILE_IO::getSgClassPointerFromGlobalIndex (source.storageOf_SgTypeUnsignedInt_builtin_type ) );
     SgTypeLong_builtin_type = (SgTypeLong* ) (AST_FILE_IO::getSgClassPointerFromGlobalIndex (source.storageOf_SgTypeLong_builtin_type ) );
     SgTypeSignedLong_builtin_type = (SgTypeSignedLong* ) (AST_FILE_IO::getSgClassPointerFromGlobalIndex (source.storageOf_SgTypeSignedLong_builtin_type ) );
     SgTypeUnsignedLong_builtin_type = (SgTypeUnsignedLong* ) (AST_FILE_IO::getSgClassPointerFromGlobalIndex (source.storageOf_SgTypeUnsignedLong_builtin_type ) );
     SgTypeVoid_builtin_type = (SgTypeVoid* ) (AST_FILE_IO::getSgClassPointerFromGlobalIndex (source.storageOf_SgTypeVoid_builtin_type ) );
     SgTypeGlobalVoid_builtin_type = (SgTypeGlobalVoid* ) (AST_FILE_IO::getSgClassPointerFromGlobalIndex (source.storageOf_SgTypeGlobalVoid_builtin_type ) );
     SgTypeWchar_builtin_type = (SgTypeWchar* ) (AST_FILE_IO::getSgClassPointerFromGlobalIndex (source.storageOf_SgTypeWchar_builtin_type ) );
     SgTypeFloat_builtin_type = (SgTypeFloat* ) (AST_FILE_IO::getSgClassPointerFromGlobalIndex (source.storageOf_SgTypeFloat_builtin_type ) );
     SgTypeDouble_builtin_type = (SgTypeDouble* ) (AST_FILE_IO::getSgClassPointerFromGlobalIndex (source.storageOf_SgTypeDouble_builtin_type ) );
     SgTypeLongLong_builtin_type = (SgTypeLongLong* ) (AST_FILE_IO::getSgClassPointerFromGlobalIndex (source.storageOf_SgTypeLongLong_builtin_type ) );
     SgTypeSignedLongLong_builtin_type = (SgTypeSignedLongLong* ) (AST_FILE_IO::getSgClassPointerFromGlobalIndex (source.storageOf_SgTypeSignedLongLong_builtin_type ) );
     SgTypeUnsignedLongLong_builtin_type = (SgTypeUnsignedLongLong* ) (AST_FILE_IO::getSgClassPointerFromGlobalIndex (source.storageOf_SgTypeUnsignedLongLong_builtin_type ) );
     SgTypeLongDouble_builtin_type = (SgTypeLongDouble* ) (AST_FILE_IO::getSgClassPointerFromGlobalIndex (source.storageOf_SgTypeLongDouble_builtin_type ) );
     SgTypeBool_builtin_type = (SgTypeBool* ) (AST_FILE_IO::getSgClassPointerFromGlobalIndex (source.storageOf_SgTypeBool_builtin_type ) );
     SgNamedType_builtin_type = (SgNamedType* ) (AST_FILE_IO::getSgClassPointerFromGlobalIndex (source.storageOf_SgNamedType_builtin_type ) );
     SgPartialFunctionModifierType_builtin_type = (SgPartialFunctionModifierType* ) (AST_FILE_IO::getSgClassPointerFromGlobalIndex (source.storageOf_SgPartialFunctionModifierType_builtin_type ) );
     SgTypeEllipse_builtin_type = (SgTypeEllipse* ) (AST_FILE_IO::getSgClassPointerFromGlobalIndex (source.storageOf_SgTypeEllipse_builtin_type ) );
     SgTypeDefault_builtin_type = (SgTypeDefault* ) (AST_FILE_IO::getSgClassPointerFromGlobalIndex (source.storageOf_SgTypeDefault_builtin_type ) );
     SgTypeCAFTeam_builtin_type = (SgTypeCAFTeam* ) (AST_FILE_IO::getSgClassPointerFromGlobalIndex (source.storageOf_SgTypeCAFTeam_builtin_type ) );
     SgTypeCrayPointer_builtin_type = (SgTypeCrayPointer* ) (AST_FILE_IO::getSgClassPointerFromGlobalIndex (source.storageOf_SgTypeCrayPointer_builtin_type ) );
     SgTypeLabel_builtin_type = (SgTypeLabel* ) (AST_FILE_IO::getSgClassPointerFromGlobalIndex (source.storageOf_SgTypeLabel_builtin_type ) );
     SgAsmTypeByte_builtin_type = (SgAsmTypeByte* ) (AST_FILE_IO::getSgClassPointerFromGlobalIndex (source.storageOf_SgAsmTypeByte_builtin_type ) );
     SgAsmTypeWord_builtin_type = (SgAsmTypeWord* ) (AST_FILE_IO::getSgClassPointerFromGlobalIndex (source.storageOf_SgAsmTypeWord_builtin_type ) );
     SgAsmTypeDoubleWord_builtin_type = (SgAsmTypeDoubleWord* ) (AST_FILE_IO::getSgClassPointerFromGlobalIndex (source.storageOf_SgAsmTypeDoubleWord_builtin_type ) );
     SgAsmTypeQuadWord_builtin_type = (SgAsmTypeQuadWord* ) (AST_FILE_IO::getSgClassPointerFromGlobalIndex (source.storageOf_SgAsmTypeQuadWord_builtin_type ) );
     SgAsmTypeDoubleQuadWord_builtin_type = (SgAsmTypeDoubleQuadWord* ) (AST_FILE_IO::getSgClassPointerFromGlobalIndex (source.storageOf_SgAsmTypeDoubleQuadWord_builtin_type ) );
     SgAsmType80bitFloat_builtin_type = (SgAsmType80bitFloat* ) (AST_FILE_IO::getSgClassPointerFromGlobalIndex (source.storageOf_SgAsmType80bitFloat_builtin_type ) );
     SgAsmType128bitFloat_builtin_type = (SgAsmType128bitFloat* ) (AST_FILE_IO::getSgClassPointerFromGlobalIndex (source.storageOf_SgAsmType128bitFloat_builtin_type ) );
     SgAsmTypeSingleFloat_builtin_type = (SgAsmTypeSingleFloat* ) (AST_FILE_IO::getSgClassPointerFromGlobalIndex (source.storageOf_SgAsmTypeSingleFloat_builtin_type ) );
     SgAsmTypeDoubleFloat_builtin_type = (SgAsmTypeDoubleFloat* ) (AST_FILE_IO::getSgClassPointerFromGlobalIndex (source.storageOf_SgAsmTypeDoubleFloat_builtin_type ) );
   }

void
AstSpecificDataManagingClassStorageClass:: writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage<std::map<SgNode*,std::string> > :: writeToFile(out);
     EasyStorage<std::map<std::string, int> > :: writeToFile(out);
     EasyStorage<std::map<int, std::string> > :: writeToFile(out);
     EasyStorage<std::map<std::string, int> > :: writeToFile(out);
     EasyStorage<SgTypePtrList > :: writeToFile(out);
   }

void
AstSpecificDataManagingClassStorageClass:: readEasyStorageDataFromFile (std::istream& in)
   {
     EasyStorage<std::map<SgNode*,std::string> > :: readFromFile(in) ;
     EasyStorage<std::map<std::string, int> > :: readFromFile(in) ;
     EasyStorage<std::map<int, std::string> > :: readFromFile(in) ;
     EasyStorage<std::map<std::string, int> > :: readFromFile(in) ;
     EasyStorage<SgTypePtrList > :: readFromFile(in) ;
   }

void
AstSpecificDataManagingClassStorageClass:: arrangeStaticDataOfEasyStorageClassesInOneBlock()
   {
     EasyStorage<std::map<SgNode*,std::string> > :: arrangeMemoryPoolInOneBlock();
     EasyStorage<std::map<std::string, int> > :: arrangeMemoryPoolInOneBlock();
     EasyStorage<std::map<int, std::string> > :: arrangeMemoryPoolInOneBlock();
     EasyStorage<std::map<std::string, int> > :: arrangeMemoryPoolInOneBlock();
     EasyStorage<SgTypePtrList > :: arrangeMemoryPoolInOneBlock();
   }

void
AstSpecificDataManagingClassStorageClass:: deleteStaticDataOfEasyStorageClasses()
   {
     EasyStorage<std::map<SgNode*,std::string> > :: deleteMemoryPool();
     EasyStorage<std::map<std::string, int> > :: deleteMemoryPool();
     EasyStorage<std::map<int, std::string> > :: deleteMemoryPool();
     EasyStorage<std::map<std::string, int> > :: deleteMemoryPool();
     EasyStorage<SgTypePtrList > :: deleteMemoryPool();
   }



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgNodeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 952 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgNodeStorageClass::pickOutIRNodeData ( SgNode* pointer ) 
   { 
     SgNode* source = (SgNode*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }


/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 973 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgSupportStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 986 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgSupportStorageClass::pickOutIRNodeData ( SgSupport* pointer ) 
   { 
     SgSupport* source = (SgSupport*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }


/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 1007 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgModifierStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 1020 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgModifierStorageClass::pickOutIRNodeData ( SgModifier* pointer ) 
   { 
     SgModifier* source = (SgModifier*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }


/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 1041 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgModifierNodesStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 1054 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgModifierNodesStorageClass::pickOutIRNodeData ( SgModifierNodes* pointer ) 
   { 
     SgModifierNodes* source = (SgModifierNodes*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgModifierTypePtrVector::iterator i_nodes = source->p_nodes.begin() ; 
     unsigned int tempListCountnodes = 0; 
     SgModifierTypePtrVector::value_type *  tempListnodes = new SgModifierTypePtrVector::value_type[ source->p_nodes.size() ]; 
     for ( ; i_nodes != source->p_nodes.end(); ++i_nodes ) 
        {
          tempListnodes[tempListCountnodes] = *i_nodes;
          tempListCountnodes++; 
          (*i_nodes) = (SgModifierTypePtrVector::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_nodes ) );
        }
     storageOf_nodes.storeDataInEasyStorageClass(source->p_nodes);
     tempListCountnodes = 0; 
     i_nodes = source->p_nodes.begin() ; 
     for ( ; i_nodes != source->p_nodes.end(); ++i_nodes ) 
        {
          *i_nodes = tempListnodes[tempListCountnodes] ;
          tempListCountnodes++; 
        }
      delete [] tempListnodes; 
     storageOf_next = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_next );
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgModifierNodesStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgModifierTypePtrVector > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgModifierNodesStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgModifierTypePtrVector > :: deleteMemoryPool() ;
   }

void
SgModifierNodesStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgModifierTypePtrVector > :: writeToFile(out) ;
   }


void
SgModifierNodesStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgModifierTypePtrVector > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 1120 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgConstVolatileModifierStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 1133 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgConstVolatileModifierStorageClass::pickOutIRNodeData ( SgConstVolatileModifier* pointer ) 
   { 
     SgConstVolatileModifier* source = (SgConstVolatileModifier*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_modifier =  source->p_modifier ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }


/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 1155 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgStorageModifierStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 1168 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgStorageModifierStorageClass::pickOutIRNodeData ( SgStorageModifier* pointer ) 
   { 
     SgStorageModifier* source = (SgStorageModifier*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_modifier =  source->p_modifier ;
     storageOf_thread_local_storage =  source->p_thread_local_storage ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }


/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 1191 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAccessModifierStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 1204 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAccessModifierStorageClass::pickOutIRNodeData ( SgAccessModifier* pointer ) 
   { 
     SgAccessModifier* source = (SgAccessModifier*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_modifier =  source->p_modifier ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }


/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 1226 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgFunctionModifierStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 1239 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgFunctionModifierStorageClass::pickOutIRNodeData ( SgFunctionModifier* pointer ) 
   { 
     SgFunctionModifier* source = (SgFunctionModifier*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_modifierVector.storeDataInEasyStorageClass(source->p_modifierVector);
     storageOf_gnu_attribute_constructor_destructor_priority =  source->p_gnu_attribute_constructor_destructor_priority ;
     storageOf_gnu_attribute_named_weak_reference.storeDataInEasyStorageClass(source->p_gnu_attribute_named_weak_reference);
     storageOf_gnu_attribute_named_alias.storeDataInEasyStorageClass(source->p_gnu_attribute_named_alias);
     storageOf_opencl_vec_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_opencl_vec_type );
     storageOf_opencl_work_group_size =  source->p_opencl_work_group_size ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgFunctionModifierStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgBitVector > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgFunctionModifierStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgBitVector > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgFunctionModifierStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgBitVector > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgFunctionModifierStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgBitVector > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 1296 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgUPC_AccessModifierStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 1309 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgUPC_AccessModifierStorageClass::pickOutIRNodeData ( SgUPC_AccessModifier* pointer ) 
   { 
     SgUPC_AccessModifier* source = (SgUPC_AccessModifier*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_modifier =  source->p_modifier ;
     storageOf_isShared =  source->p_isShared ;
     storageOf_layout =  source->p_layout ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }


/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 1333 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgSpecialFunctionModifierStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 1346 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgSpecialFunctionModifierStorageClass::pickOutIRNodeData ( SgSpecialFunctionModifier* pointer ) 
   { 
     SgSpecialFunctionModifier* source = (SgSpecialFunctionModifier*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_modifierVector.storeDataInEasyStorageClass(source->p_modifierVector);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgSpecialFunctionModifierStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgBitVector > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgSpecialFunctionModifierStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgBitVector > :: deleteMemoryPool() ;
   }

void
SgSpecialFunctionModifierStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgBitVector > :: writeToFile(out) ;
   }


void
SgSpecialFunctionModifierStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgBitVector > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 1394 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgElaboratedTypeModifierStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 1407 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgElaboratedTypeModifierStorageClass::pickOutIRNodeData ( SgElaboratedTypeModifier* pointer ) 
   { 
     SgElaboratedTypeModifier* source = (SgElaboratedTypeModifier*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_modifier =  source->p_modifier ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }


/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 1429 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgLinkageModifierStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 1442 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgLinkageModifierStorageClass::pickOutIRNodeData ( SgLinkageModifier* pointer ) 
   { 
     SgLinkageModifier* source = (SgLinkageModifier*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_modifier =  source->p_modifier ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }


/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 1464 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgBaseClassModifierStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 1477 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgBaseClassModifierStorageClass::pickOutIRNodeData ( SgBaseClassModifier* pointer ) 
   { 
     SgBaseClassModifier* source = (SgBaseClassModifier*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_modifier =  source->p_modifier ;
     storageOf_accessModifier.pickOutIRNodeData( &(source->p_accessModifier) );
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgBaseClassModifierStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
   }

void
SgBaseClassModifierStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
   }

void
SgBaseClassModifierStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
   }


void
SgBaseClassModifierStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 1522 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTypeModifierStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 1535 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgTypeModifierStorageClass::pickOutIRNodeData ( SgTypeModifier* pointer ) 
   { 
     SgTypeModifier* source = (SgTypeModifier*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_modifierVector.storeDataInEasyStorageClass(source->p_modifierVector);
     storageOf_upcModifier.pickOutIRNodeData( &(source->p_upcModifier) );
     storageOf_constVolatileModifier.pickOutIRNodeData( &(source->p_constVolatileModifier) );
     storageOf_elaboratedTypeModifier.pickOutIRNodeData( &(source->p_elaboratedTypeModifier) );
     storageOf_gnu_extension_machine_mode =  source->p_gnu_extension_machine_mode ;
     storageOf_gnu_attribute_alignment =  source->p_gnu_attribute_alignment ;
     storageOf_gnu_attribute_sentinel =  source->p_gnu_attribute_sentinel ;
     storageOf_address_space_value =  source->p_address_space_value ;
     storageOf_vector_size =  source->p_vector_size ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgTypeModifierStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgBitVector > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTypeModifierStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgBitVector > :: deleteMemoryPool() ;
   }

void
SgTypeModifierStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgBitVector > :: writeToFile(out) ;
   }


void
SgTypeModifierStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgBitVector > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 1591 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgDeclarationModifierStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 1604 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgDeclarationModifierStorageClass::pickOutIRNodeData ( SgDeclarationModifier* pointer ) 
   { 
     SgDeclarationModifier* source = (SgDeclarationModifier*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_modifierVector.storeDataInEasyStorageClass(source->p_modifierVector);
     storageOf_typeModifier.pickOutIRNodeData( &(source->p_typeModifier) );
     storageOf_accessModifier.pickOutIRNodeData( &(source->p_accessModifier) );
     storageOf_storageModifier.pickOutIRNodeData( &(source->p_storageModifier) );
     storageOf_gnu_attribute_section_name.storeDataInEasyStorageClass(source->p_gnu_attribute_section_name);
     storageOf_gnu_attribute_visability =  source->p_gnu_attribute_visability ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgDeclarationModifierStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgBitVector > :: arrangeMemoryPoolInOneBlock() ;
     SgTypeModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgDeclarationModifierStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgBitVector > :: deleteMemoryPool() ;
     SgTypeModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgDeclarationModifierStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgBitVector > :: writeToFile(out) ;
     SgTypeModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgDeclarationModifierStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgBitVector > :: readFromFile(in) ;
     SgTypeModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 1665 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgOpenclAccessModeModifierStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 1678 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgOpenclAccessModeModifierStorageClass::pickOutIRNodeData ( SgOpenclAccessModeModifier* pointer ) 
   { 
     SgOpenclAccessModeModifier* source = (SgOpenclAccessModeModifier*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_modifier =  source->p_modifier ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }


/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 1700 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgNameStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 1713 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgNameStorageClass::pickOutIRNodeData ( SgName* pointer ) 
   { 
     SgName* source = (SgName*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_char.storeDataInEasyStorageClass(source->p_char);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgNameStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgNameStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgNameStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgNameStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 1761 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgSymbolTableStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 1774 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgSymbolTableStorageClass::pickOutIRNodeData ( SgSymbolTable* pointer ) 
   { 
     SgSymbolTable* source = (SgSymbolTable*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_name.pickOutIRNodeData( &(source->p_name) );
     storageOf_no_name =  source->p_no_name ;
     rose_hash_multimap::iterator it; 
     unsigned int tempListCounttable = 0; 
     SgSymbol** tempListtable = new SgSymbol* [ source->p_table->size() ]; 
     for (it = source->p_table->begin(); it != source->p_table->end(); ++it)
        {
          tempListtable[tempListCounttable] = it->second;
          tempListCounttable++; 
          it->second = (SgSymbol*)(AST_FILE_IO::getGlobalIndexFromSgClassPointer(it->second) ); 
        }
     storageOf_table.storeDataInEasyStorageClass(source->p_table);
     tempListCounttable = 0; 
     for (it = source->p_table->begin(); it != source->p_table->end(); ++it) 
        {
          it->second = tempListtable [ tempListCounttable ]; 
          tempListCounttable++; 
        }
      delete [] tempListtable; 
     storageOf_symbolSet.storeDataInEasyStorageClass(source->p_symbolSet);
     storageOf_case_insensitive =  source->p_case_insensitive ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgSymbolTableStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage <  rose_hash_multimap* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgNodeSet > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgSymbolTableStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage <  rose_hash_multimap* > :: deleteMemoryPool() ;
     EasyStorage < SgNodeSet > :: deleteMemoryPool() ;
   }

void
SgSymbolTableStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage <  rose_hash_multimap* > :: writeToFile(out) ;
     EasyStorage < SgNodeSet > :: writeToFile(out) ;
   }


void
SgSymbolTableStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage <  rose_hash_multimap* > :: readFromFile(in) ;
     EasyStorage < SgNodeSet > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 1850 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAttributeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 1863 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAttributeStorageClass::pickOutIRNodeData ( SgAttribute* pointer ) 
   { 
     SgAttribute* source = (SgAttribute*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAttributeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAttributeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAttributeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAttributeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 1911 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgPragmaStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 1924 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgPragmaStorageClass::pickOutIRNodeData ( SgPragma* pointer ) 
   { 
     SgPragma* source = (SgPragma*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_printed =  source->p_printed ;
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgPragmaStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgPragmaStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgPragmaStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgPragmaStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 1979 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgBitAttributeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 1992 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgBitAttributeStorageClass::pickOutIRNodeData ( SgBitAttribute* pointer ) 
   { 
     SgBitAttribute* source = (SgBitAttribute*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_bitflag =  source->p_bitflag ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgBitAttributeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgBitAttributeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgBitAttributeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgBitAttributeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 2041 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgFuncDecl_attrStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 2054 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgFuncDecl_attrStorageClass::pickOutIRNodeData ( SgFuncDecl_attr* pointer ) 
   { 
     SgFuncDecl_attr* source = (SgFuncDecl_attr*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_bitflag =  source->p_bitflag ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgFuncDecl_attrStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgFuncDecl_attrStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgFuncDecl_attrStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgFuncDecl_attrStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 2103 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgClassDecl_attrStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 2116 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgClassDecl_attrStorageClass::pickOutIRNodeData ( SgClassDecl_attr* pointer ) 
   { 
     SgClassDecl_attr* source = (SgClassDecl_attr*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_bitflag =  source->p_bitflag ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgClassDecl_attrStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgClassDecl_attrStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgClassDecl_attrStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgClassDecl_attrStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 2165 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the Sg_File_InfoStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 2178 "../../../src/frontend/SageIII//StorageClasses.C" */


void
Sg_File_InfoStorageClass::pickOutIRNodeData ( Sg_File_Info* pointer ) 
   { 
     Sg_File_Info* source = (Sg_File_Info*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_file_id =  source->p_file_id ;
     storageOf_line =  source->p_line ;
     storageOf_col =  source->p_col ;
     storageOf_classificationBitField =  source->p_classificationBitField ;
     storageOf_fileIDsToUnparse.storeDataInEasyStorageClass(source->p_fileIDsToUnparse);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
Sg_File_InfoStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgFileIdList > :: arrangeMemoryPoolInOneBlock() ;
   }

void
Sg_File_InfoStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgFileIdList > :: deleteMemoryPool() ;
   }

void
Sg_File_InfoStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgFileIdList > :: writeToFile(out) ;
   }


void
Sg_File_InfoStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgFileIdList > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 2230 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgFileStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 2243 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgFileStorageClass::pickOutIRNodeData ( SgFile* pointer ) 
   { 
     SgFile* source = (SgFile*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_originalCommandLineArgumentList.storeDataInEasyStorageClass(source->p_originalCommandLineArgumentList);
     storageOf_verbose =  source->p_verbose ;
     storageOf_output_warnings =  source->p_output_warnings ;
     storageOf_C_only =  source->p_C_only ;
     storageOf_UPC_only =  source->p_UPC_only ;
     storageOf_UPCxx_only =  source->p_UPCxx_only ;
     storageOf_upc_threads =  source->p_upc_threads ;
     storageOf_C99_only =  source->p_C99_only ;
     storageOf_Cxx_only =  source->p_Cxx_only ;
     storageOf_Fortran_only =  source->p_Fortran_only ;
     storageOf_F77_only =  source->p_F77_only ;
     storageOf_F90_only =  source->p_F90_only ;
     storageOf_F95_only =  source->p_F95_only ;
     storageOf_F2003_only =  source->p_F2003_only ;
     storageOf_CoArrayFortran_only =  source->p_CoArrayFortran_only ;
     storageOf_Java_only =  source->p_Java_only ;
     storageOf_PHP_only =  source->p_PHP_only ;
     storageOf_Python_only =  source->p_Python_only ;
     storageOf_Cuda_only =  source->p_Cuda_only ;
     storageOf_OpenCL_only =  source->p_OpenCL_only ;
     storageOf_requires_C_preprocessor =  source->p_requires_C_preprocessor ;
     storageOf_binary_only =  source->p_binary_only ;
     storageOf_inputFormat =  source->p_inputFormat ;
     storageOf_outputFormat =  source->p_outputFormat ;
     storageOf_backendCompileFormat =  source->p_backendCompileFormat ;
     storageOf_fortran_implicit_none =  source->p_fortran_implicit_none ;
     storageOf_openmp =  source->p_openmp ;
     storageOf_openmp_parse_only =  source->p_openmp_parse_only ;
     storageOf_openmp_ast_only =  source->p_openmp_ast_only ;
     storageOf_openmp_lowering =  source->p_openmp_lowering ;
     storageOf_cray_pointer_support =  source->p_cray_pointer_support ;
     storageOf_output_parser_actions =  source->p_output_parser_actions ;
     storageOf_exit_after_parser =  source->p_exit_after_parser ;
     storageOf_skip_syntax_check =  source->p_skip_syntax_check ;
     storageOf_relax_syntax_check =  source->p_relax_syntax_check ;
     storageOf_skip_translation_from_edg_ast_to_rose_ast =  source->p_skip_translation_from_edg_ast_to_rose_ast ;
     storageOf_skip_transformation =  source->p_skip_transformation ;
     storageOf_skip_unparse =  source->p_skip_unparse ;
     storageOf_skipfinalCompileStep =  source->p_skipfinalCompileStep ;
     storageOf_unparse_includes =  source->p_unparse_includes ;
     storageOf_unparse_line_directives =  source->p_unparse_line_directives ;
     storageOf_unparse_instruction_addresses =  source->p_unparse_instruction_addresses ;
     storageOf_unparse_raw_memory_contents =  source->p_unparse_raw_memory_contents ;
     storageOf_unparse_binary_file_format =  source->p_unparse_binary_file_format ;
     storageOf_outputLanguage =  source->p_outputLanguage ;
     storageOf_sourceFileNameWithPath.storeDataInEasyStorageClass(source->p_sourceFileNameWithPath);
     storageOf_sourceFileNameWithoutPath.storeDataInEasyStorageClass(source->p_sourceFileNameWithoutPath);
     storageOf_unparse_output_filename.storeDataInEasyStorageClass(source->p_unparse_output_filename);
     storageOf_useBackendOnly =  source->p_useBackendOnly ;
     storageOf_compileOnly =  source->p_compileOnly ;
     storageOf_savedEdgCommandLine.storeDataInEasyStorageClass(source->p_savedEdgCommandLine);
     storageOf_no_implicit_templates =  source->p_no_implicit_templates ;
     storageOf_no_implicit_inline_templates =  source->p_no_implicit_inline_templates ;
     storageOf_skip_commentsAndDirectives =  source->p_skip_commentsAndDirectives ;
     storageOf_collectAllCommentsAndDirectives =  source->p_collectAllCommentsAndDirectives ;
     storageOf_unparseHeaderFiles =  source->p_unparseHeaderFiles ;
     storageOf_preprocessorDirectivesAndCommentsList.storeDataInEasyStorageClass(source->p_preprocessorDirectivesAndCommentsList);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_KCC_frontend =  source->p_KCC_frontend ;
     storageOf_new_frontend =  source->p_new_frontend ;
     storageOf_disable_edg_backend =  source->p_disable_edg_backend ;
     storageOf_disable_sage_backend =  source->p_disable_sage_backend ;
     storageOf_testingLevel =  source->p_testingLevel ;
     storageOf_preinit_il =  source->p_preinit_il ;
     storageOf_enable_cp_backend =  source->p_enable_cp_backend ;
     storageOf_markGeneratedFiles =  source->p_markGeneratedFiles ;
     storageOf_negative_test =  source->p_negative_test ;
     storageOf_strict_language_handling =  source->p_strict_language_handling ;
     storageOf_wave =  source->p_wave ;
     storageOf_embedColorCodesInGeneratedCode =  source->p_embedColorCodesInGeneratedCode ;
     storageOf_generateSourcePositionCodes =  source->p_generateSourcePositionCodes ;
     storageOf_sourceFileUsesCppFileExtension =  source->p_sourceFileUsesCppFileExtension ;
     storageOf_sourceFileUsesFortranFileExtension =  source->p_sourceFileUsesFortranFileExtension ;
     storageOf_sourceFileUsesFortran77FileExtension =  source->p_sourceFileUsesFortran77FileExtension ;
     storageOf_sourceFileUsesFortran90FileExtension =  source->p_sourceFileUsesFortran90FileExtension ;
     storageOf_sourceFileUsesFortran95FileExtension =  source->p_sourceFileUsesFortran95FileExtension ;
     storageOf_sourceFileUsesFortran2003FileExtension =  source->p_sourceFileUsesFortran2003FileExtension ;
     storageOf_sourceFileUsesCoArrayFortranFileExtension =  source->p_sourceFileUsesCoArrayFortranFileExtension ;
     storageOf_sourceFileUsesPHPFileExtension =  source->p_sourceFileUsesPHPFileExtension ;
     storageOf_sourceFileUsesPythonFileExtension =  source->p_sourceFileUsesPythonFileExtension ;
     storageOf_sourceFileUsesJavaFileExtension =  source->p_sourceFileUsesJavaFileExtension ;
     storageOf_sourceFileUsesBinaryFileExtension =  source->p_sourceFileUsesBinaryFileExtension ;
     storageOf_sourceFileTypeIsUnknown =  source->p_sourceFileTypeIsUnknown ;
     storageOf_detect_dangling_pointers =  source->p_detect_dangling_pointers ;
     storageOf_read_executable_file_format_only =  source->p_read_executable_file_format_only ;
     storageOf_visualize_executable_file_format_skip_symbols =  source->p_visualize_executable_file_format_skip_symbols ;
     storageOf_visualize_dwarf_only =  source->p_visualize_dwarf_only ;
     storageOf_read_instructions_only =  source->p_read_instructions_only ;
     storageOf_skip_unparse_asm_commands =  source->p_skip_unparse_asm_commands ;
     storageOf_libraryArchiveObjectFileNameList.storeDataInEasyStorageClass(source->p_libraryArchiveObjectFileNameList);
     storageOf_isLibraryArchive =  source->p_isLibraryArchive ;
     storageOf_isObjectFile =  source->p_isObjectFile ;
     storageOf_disassemblerSearchHeuristics =  source->p_disassemblerSearchHeuristics ;
     storageOf_partitionerSearchHeuristics =  source->p_partitionerSearchHeuristics ;
     storageOf_partitionerConfigurationFileName.storeDataInEasyStorageClass(source->p_partitionerConfigurationFileName);
     storageOf_output_tokens =  source->p_output_tokens ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgFileStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgStringList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < ROSEAttributesListContainerPtr > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgFileStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgStringList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < ROSEAttributesListContainerPtr > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgFileStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgStringList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < ROSEAttributesListContainerPtr > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgFileStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgStringList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < ROSEAttributesListContainerPtr > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 2399 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgSourceFileStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 2412 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgSourceFileStorageClass::pickOutIRNodeData ( SgSourceFile* pointer ) 
   { 
     SgSourceFile* source = (SgSourceFile*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_globalScope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_globalScope );
     SgModuleStatementPtrList::iterator i_module_list = source->p_module_list.begin() ; 
     unsigned int tempListCountmodule_list = 0; 
     SgModuleStatementPtrList::value_type *  tempListmodule_list = new SgModuleStatementPtrList::value_type[ source->p_module_list.size() ]; 
     for ( ; i_module_list != source->p_module_list.end(); ++i_module_list ) 
        {
          tempListmodule_list[tempListCountmodule_list] = *i_module_list;
          tempListCountmodule_list++; 
          (*i_module_list) = (SgModuleStatementPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_module_list ) );
        }
     storageOf_module_list.storeDataInEasyStorageClass(source->p_module_list);
     tempListCountmodule_list = 0; 
     i_module_list = source->p_module_list.begin() ; 
     for ( ; i_module_list != source->p_module_list.end(); ++i_module_list ) 
        {
          *i_module_list = tempListmodule_list[tempListCountmodule_list] ;
          tempListCountmodule_list++; 
        }
      delete [] tempListmodule_list; 
     SgTokenPtrList::iterator i_token_list = source->p_token_list.begin() ; 
     unsigned int tempListCounttoken_list = 0; 
     SgTokenPtrList::value_type *  tempListtoken_list = new SgTokenPtrList::value_type[ source->p_token_list.size() ]; 
     for ( ; i_token_list != source->p_token_list.end(); ++i_token_list ) 
        {
          tempListtoken_list[tempListCounttoken_list] = *i_token_list;
          tempListCounttoken_list++; 
          (*i_token_list) = (SgTokenPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_token_list ) );
        }
     storageOf_token_list.storeDataInEasyStorageClass(source->p_token_list);
     tempListCounttoken_list = 0; 
     i_token_list = source->p_token_list.begin() ; 
     for ( ; i_token_list != source->p_token_list.end(); ++i_token_list ) 
        {
          *i_token_list = tempListtoken_list[tempListCounttoken_list] ;
          tempListCounttoken_list++; 
        }
      delete [] tempListtoken_list; 
     storageOf_temp_holding_scope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_temp_holding_scope );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_originalCommandLineArgumentList.storeDataInEasyStorageClass(source->p_originalCommandLineArgumentList);
     storageOf_verbose =  source->p_verbose ;
     storageOf_output_warnings =  source->p_output_warnings ;
     storageOf_C_only =  source->p_C_only ;
     storageOf_UPC_only =  source->p_UPC_only ;
     storageOf_UPCxx_only =  source->p_UPCxx_only ;
     storageOf_upc_threads =  source->p_upc_threads ;
     storageOf_C99_only =  source->p_C99_only ;
     storageOf_Cxx_only =  source->p_Cxx_only ;
     storageOf_Fortran_only =  source->p_Fortran_only ;
     storageOf_F77_only =  source->p_F77_only ;
     storageOf_F90_only =  source->p_F90_only ;
     storageOf_F95_only =  source->p_F95_only ;
     storageOf_F2003_only =  source->p_F2003_only ;
     storageOf_CoArrayFortran_only =  source->p_CoArrayFortran_only ;
     storageOf_Java_only =  source->p_Java_only ;
     storageOf_PHP_only =  source->p_PHP_only ;
     storageOf_Python_only =  source->p_Python_only ;
     storageOf_Cuda_only =  source->p_Cuda_only ;
     storageOf_OpenCL_only =  source->p_OpenCL_only ;
     storageOf_requires_C_preprocessor =  source->p_requires_C_preprocessor ;
     storageOf_binary_only =  source->p_binary_only ;
     storageOf_inputFormat =  source->p_inputFormat ;
     storageOf_outputFormat =  source->p_outputFormat ;
     storageOf_backendCompileFormat =  source->p_backendCompileFormat ;
     storageOf_fortran_implicit_none =  source->p_fortran_implicit_none ;
     storageOf_openmp =  source->p_openmp ;
     storageOf_openmp_parse_only =  source->p_openmp_parse_only ;
     storageOf_openmp_ast_only =  source->p_openmp_ast_only ;
     storageOf_openmp_lowering =  source->p_openmp_lowering ;
     storageOf_cray_pointer_support =  source->p_cray_pointer_support ;
     storageOf_output_parser_actions =  source->p_output_parser_actions ;
     storageOf_exit_after_parser =  source->p_exit_after_parser ;
     storageOf_skip_syntax_check =  source->p_skip_syntax_check ;
     storageOf_relax_syntax_check =  source->p_relax_syntax_check ;
     storageOf_skip_translation_from_edg_ast_to_rose_ast =  source->p_skip_translation_from_edg_ast_to_rose_ast ;
     storageOf_skip_transformation =  source->p_skip_transformation ;
     storageOf_skip_unparse =  source->p_skip_unparse ;
     storageOf_skipfinalCompileStep =  source->p_skipfinalCompileStep ;
     storageOf_unparse_includes =  source->p_unparse_includes ;
     storageOf_unparse_line_directives =  source->p_unparse_line_directives ;
     storageOf_unparse_instruction_addresses =  source->p_unparse_instruction_addresses ;
     storageOf_unparse_raw_memory_contents =  source->p_unparse_raw_memory_contents ;
     storageOf_unparse_binary_file_format =  source->p_unparse_binary_file_format ;
     storageOf_outputLanguage =  source->p_outputLanguage ;
     storageOf_sourceFileNameWithPath.storeDataInEasyStorageClass(source->p_sourceFileNameWithPath);
     storageOf_sourceFileNameWithoutPath.storeDataInEasyStorageClass(source->p_sourceFileNameWithoutPath);
     storageOf_unparse_output_filename.storeDataInEasyStorageClass(source->p_unparse_output_filename);
     storageOf_useBackendOnly =  source->p_useBackendOnly ;
     storageOf_compileOnly =  source->p_compileOnly ;
     storageOf_savedEdgCommandLine.storeDataInEasyStorageClass(source->p_savedEdgCommandLine);
     storageOf_no_implicit_templates =  source->p_no_implicit_templates ;
     storageOf_no_implicit_inline_templates =  source->p_no_implicit_inline_templates ;
     storageOf_skip_commentsAndDirectives =  source->p_skip_commentsAndDirectives ;
     storageOf_collectAllCommentsAndDirectives =  source->p_collectAllCommentsAndDirectives ;
     storageOf_unparseHeaderFiles =  source->p_unparseHeaderFiles ;
     storageOf_preprocessorDirectivesAndCommentsList.storeDataInEasyStorageClass(source->p_preprocessorDirectivesAndCommentsList);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_KCC_frontend =  source->p_KCC_frontend ;
     storageOf_new_frontend =  source->p_new_frontend ;
     storageOf_disable_edg_backend =  source->p_disable_edg_backend ;
     storageOf_disable_sage_backend =  source->p_disable_sage_backend ;
     storageOf_testingLevel =  source->p_testingLevel ;
     storageOf_preinit_il =  source->p_preinit_il ;
     storageOf_enable_cp_backend =  source->p_enable_cp_backend ;
     storageOf_markGeneratedFiles =  source->p_markGeneratedFiles ;
     storageOf_negative_test =  source->p_negative_test ;
     storageOf_strict_language_handling =  source->p_strict_language_handling ;
     storageOf_wave =  source->p_wave ;
     storageOf_embedColorCodesInGeneratedCode =  source->p_embedColorCodesInGeneratedCode ;
     storageOf_generateSourcePositionCodes =  source->p_generateSourcePositionCodes ;
     storageOf_sourceFileUsesCppFileExtension =  source->p_sourceFileUsesCppFileExtension ;
     storageOf_sourceFileUsesFortranFileExtension =  source->p_sourceFileUsesFortranFileExtension ;
     storageOf_sourceFileUsesFortran77FileExtension =  source->p_sourceFileUsesFortran77FileExtension ;
     storageOf_sourceFileUsesFortran90FileExtension =  source->p_sourceFileUsesFortran90FileExtension ;
     storageOf_sourceFileUsesFortran95FileExtension =  source->p_sourceFileUsesFortran95FileExtension ;
     storageOf_sourceFileUsesFortran2003FileExtension =  source->p_sourceFileUsesFortran2003FileExtension ;
     storageOf_sourceFileUsesCoArrayFortranFileExtension =  source->p_sourceFileUsesCoArrayFortranFileExtension ;
     storageOf_sourceFileUsesPHPFileExtension =  source->p_sourceFileUsesPHPFileExtension ;
     storageOf_sourceFileUsesPythonFileExtension =  source->p_sourceFileUsesPythonFileExtension ;
     storageOf_sourceFileUsesJavaFileExtension =  source->p_sourceFileUsesJavaFileExtension ;
     storageOf_sourceFileUsesBinaryFileExtension =  source->p_sourceFileUsesBinaryFileExtension ;
     storageOf_sourceFileTypeIsUnknown =  source->p_sourceFileTypeIsUnknown ;
     storageOf_detect_dangling_pointers =  source->p_detect_dangling_pointers ;
     storageOf_read_executable_file_format_only =  source->p_read_executable_file_format_only ;
     storageOf_visualize_executable_file_format_skip_symbols =  source->p_visualize_executable_file_format_skip_symbols ;
     storageOf_visualize_dwarf_only =  source->p_visualize_dwarf_only ;
     storageOf_read_instructions_only =  source->p_read_instructions_only ;
     storageOf_skip_unparse_asm_commands =  source->p_skip_unparse_asm_commands ;
     storageOf_libraryArchiveObjectFileNameList.storeDataInEasyStorageClass(source->p_libraryArchiveObjectFileNameList);
     storageOf_isLibraryArchive =  source->p_isLibraryArchive ;
     storageOf_isObjectFile =  source->p_isObjectFile ;
     storageOf_disassemblerSearchHeuristics =  source->p_disassemblerSearchHeuristics ;
     storageOf_partitionerSearchHeuristics =  source->p_partitionerSearchHeuristics ;
     storageOf_partitionerConfigurationFileName.storeDataInEasyStorageClass(source->p_partitionerConfigurationFileName);
     storageOf_output_tokens =  source->p_output_tokens ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgSourceFileStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgModuleStatementPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgTokenPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgStringList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < ROSEAttributesListContainerPtr > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgSourceFileStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgModuleStatementPtrList > :: deleteMemoryPool() ;
     EasyStorage < SgTokenPtrList > :: deleteMemoryPool() ;
     EasyStorage < SgStringList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < ROSEAttributesListContainerPtr > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgSourceFileStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgModuleStatementPtrList > :: writeToFile(out) ;
     EasyStorage < SgTokenPtrList > :: writeToFile(out) ;
     EasyStorage < SgStringList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < ROSEAttributesListContainerPtr > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgSourceFileStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgModuleStatementPtrList > :: readFromFile(in) ;
     EasyStorage < SgTokenPtrList > :: readFromFile(in) ;
     EasyStorage < SgStringList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < ROSEAttributesListContainerPtr > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 2614 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgBinaryCompositeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 2627 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgBinaryCompositeStorageClass::pickOutIRNodeData ( SgBinaryComposite* pointer ) 
   { 
     SgBinaryComposite* source = (SgBinaryComposite*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_genericFileList = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_genericFileList );
     storageOf_interpretations = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_interpretations );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_originalCommandLineArgumentList.storeDataInEasyStorageClass(source->p_originalCommandLineArgumentList);
     storageOf_verbose =  source->p_verbose ;
     storageOf_output_warnings =  source->p_output_warnings ;
     storageOf_C_only =  source->p_C_only ;
     storageOf_UPC_only =  source->p_UPC_only ;
     storageOf_UPCxx_only =  source->p_UPCxx_only ;
     storageOf_upc_threads =  source->p_upc_threads ;
     storageOf_C99_only =  source->p_C99_only ;
     storageOf_Cxx_only =  source->p_Cxx_only ;
     storageOf_Fortran_only =  source->p_Fortran_only ;
     storageOf_F77_only =  source->p_F77_only ;
     storageOf_F90_only =  source->p_F90_only ;
     storageOf_F95_only =  source->p_F95_only ;
     storageOf_F2003_only =  source->p_F2003_only ;
     storageOf_CoArrayFortran_only =  source->p_CoArrayFortran_only ;
     storageOf_Java_only =  source->p_Java_only ;
     storageOf_PHP_only =  source->p_PHP_only ;
     storageOf_Python_only =  source->p_Python_only ;
     storageOf_Cuda_only =  source->p_Cuda_only ;
     storageOf_OpenCL_only =  source->p_OpenCL_only ;
     storageOf_requires_C_preprocessor =  source->p_requires_C_preprocessor ;
     storageOf_binary_only =  source->p_binary_only ;
     storageOf_inputFormat =  source->p_inputFormat ;
     storageOf_outputFormat =  source->p_outputFormat ;
     storageOf_backendCompileFormat =  source->p_backendCompileFormat ;
     storageOf_fortran_implicit_none =  source->p_fortran_implicit_none ;
     storageOf_openmp =  source->p_openmp ;
     storageOf_openmp_parse_only =  source->p_openmp_parse_only ;
     storageOf_openmp_ast_only =  source->p_openmp_ast_only ;
     storageOf_openmp_lowering =  source->p_openmp_lowering ;
     storageOf_cray_pointer_support =  source->p_cray_pointer_support ;
     storageOf_output_parser_actions =  source->p_output_parser_actions ;
     storageOf_exit_after_parser =  source->p_exit_after_parser ;
     storageOf_skip_syntax_check =  source->p_skip_syntax_check ;
     storageOf_relax_syntax_check =  source->p_relax_syntax_check ;
     storageOf_skip_translation_from_edg_ast_to_rose_ast =  source->p_skip_translation_from_edg_ast_to_rose_ast ;
     storageOf_skip_transformation =  source->p_skip_transformation ;
     storageOf_skip_unparse =  source->p_skip_unparse ;
     storageOf_skipfinalCompileStep =  source->p_skipfinalCompileStep ;
     storageOf_unparse_includes =  source->p_unparse_includes ;
     storageOf_unparse_line_directives =  source->p_unparse_line_directives ;
     storageOf_unparse_instruction_addresses =  source->p_unparse_instruction_addresses ;
     storageOf_unparse_raw_memory_contents =  source->p_unparse_raw_memory_contents ;
     storageOf_unparse_binary_file_format =  source->p_unparse_binary_file_format ;
     storageOf_outputLanguage =  source->p_outputLanguage ;
     storageOf_sourceFileNameWithPath.storeDataInEasyStorageClass(source->p_sourceFileNameWithPath);
     storageOf_sourceFileNameWithoutPath.storeDataInEasyStorageClass(source->p_sourceFileNameWithoutPath);
     storageOf_unparse_output_filename.storeDataInEasyStorageClass(source->p_unparse_output_filename);
     storageOf_useBackendOnly =  source->p_useBackendOnly ;
     storageOf_compileOnly =  source->p_compileOnly ;
     storageOf_savedEdgCommandLine.storeDataInEasyStorageClass(source->p_savedEdgCommandLine);
     storageOf_no_implicit_templates =  source->p_no_implicit_templates ;
     storageOf_no_implicit_inline_templates =  source->p_no_implicit_inline_templates ;
     storageOf_skip_commentsAndDirectives =  source->p_skip_commentsAndDirectives ;
     storageOf_collectAllCommentsAndDirectives =  source->p_collectAllCommentsAndDirectives ;
     storageOf_unparseHeaderFiles =  source->p_unparseHeaderFiles ;
     storageOf_preprocessorDirectivesAndCommentsList.storeDataInEasyStorageClass(source->p_preprocessorDirectivesAndCommentsList);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_KCC_frontend =  source->p_KCC_frontend ;
     storageOf_new_frontend =  source->p_new_frontend ;
     storageOf_disable_edg_backend =  source->p_disable_edg_backend ;
     storageOf_disable_sage_backend =  source->p_disable_sage_backend ;
     storageOf_testingLevel =  source->p_testingLevel ;
     storageOf_preinit_il =  source->p_preinit_il ;
     storageOf_enable_cp_backend =  source->p_enable_cp_backend ;
     storageOf_markGeneratedFiles =  source->p_markGeneratedFiles ;
     storageOf_negative_test =  source->p_negative_test ;
     storageOf_strict_language_handling =  source->p_strict_language_handling ;
     storageOf_wave =  source->p_wave ;
     storageOf_embedColorCodesInGeneratedCode =  source->p_embedColorCodesInGeneratedCode ;
     storageOf_generateSourcePositionCodes =  source->p_generateSourcePositionCodes ;
     storageOf_sourceFileUsesCppFileExtension =  source->p_sourceFileUsesCppFileExtension ;
     storageOf_sourceFileUsesFortranFileExtension =  source->p_sourceFileUsesFortranFileExtension ;
     storageOf_sourceFileUsesFortran77FileExtension =  source->p_sourceFileUsesFortran77FileExtension ;
     storageOf_sourceFileUsesFortran90FileExtension =  source->p_sourceFileUsesFortran90FileExtension ;
     storageOf_sourceFileUsesFortran95FileExtension =  source->p_sourceFileUsesFortran95FileExtension ;
     storageOf_sourceFileUsesFortran2003FileExtension =  source->p_sourceFileUsesFortran2003FileExtension ;
     storageOf_sourceFileUsesCoArrayFortranFileExtension =  source->p_sourceFileUsesCoArrayFortranFileExtension ;
     storageOf_sourceFileUsesPHPFileExtension =  source->p_sourceFileUsesPHPFileExtension ;
     storageOf_sourceFileUsesPythonFileExtension =  source->p_sourceFileUsesPythonFileExtension ;
     storageOf_sourceFileUsesJavaFileExtension =  source->p_sourceFileUsesJavaFileExtension ;
     storageOf_sourceFileUsesBinaryFileExtension =  source->p_sourceFileUsesBinaryFileExtension ;
     storageOf_sourceFileTypeIsUnknown =  source->p_sourceFileTypeIsUnknown ;
     storageOf_detect_dangling_pointers =  source->p_detect_dangling_pointers ;
     storageOf_read_executable_file_format_only =  source->p_read_executable_file_format_only ;
     storageOf_visualize_executable_file_format_skip_symbols =  source->p_visualize_executable_file_format_skip_symbols ;
     storageOf_visualize_dwarf_only =  source->p_visualize_dwarf_only ;
     storageOf_read_instructions_only =  source->p_read_instructions_only ;
     storageOf_skip_unparse_asm_commands =  source->p_skip_unparse_asm_commands ;
     storageOf_libraryArchiveObjectFileNameList.storeDataInEasyStorageClass(source->p_libraryArchiveObjectFileNameList);
     storageOf_isLibraryArchive =  source->p_isLibraryArchive ;
     storageOf_isObjectFile =  source->p_isObjectFile ;
     storageOf_disassemblerSearchHeuristics =  source->p_disassemblerSearchHeuristics ;
     storageOf_partitionerSearchHeuristics =  source->p_partitionerSearchHeuristics ;
     storageOf_partitionerConfigurationFileName.storeDataInEasyStorageClass(source->p_partitionerConfigurationFileName);
     storageOf_output_tokens =  source->p_output_tokens ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgBinaryCompositeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgStringList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < ROSEAttributesListContainerPtr > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgBinaryCompositeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgStringList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < ROSEAttributesListContainerPtr > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgBinaryCompositeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgStringList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < ROSEAttributesListContainerPtr > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgBinaryCompositeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgStringList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < ROSEAttributesListContainerPtr > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 2785 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgUnknownFileStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 2798 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgUnknownFileStorageClass::pickOutIRNodeData ( SgUnknownFile* pointer ) 
   { 
     SgUnknownFile* source = (SgUnknownFile*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_globalScope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_globalScope );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_originalCommandLineArgumentList.storeDataInEasyStorageClass(source->p_originalCommandLineArgumentList);
     storageOf_verbose =  source->p_verbose ;
     storageOf_output_warnings =  source->p_output_warnings ;
     storageOf_C_only =  source->p_C_only ;
     storageOf_UPC_only =  source->p_UPC_only ;
     storageOf_UPCxx_only =  source->p_UPCxx_only ;
     storageOf_upc_threads =  source->p_upc_threads ;
     storageOf_C99_only =  source->p_C99_only ;
     storageOf_Cxx_only =  source->p_Cxx_only ;
     storageOf_Fortran_only =  source->p_Fortran_only ;
     storageOf_F77_only =  source->p_F77_only ;
     storageOf_F90_only =  source->p_F90_only ;
     storageOf_F95_only =  source->p_F95_only ;
     storageOf_F2003_only =  source->p_F2003_only ;
     storageOf_CoArrayFortran_only =  source->p_CoArrayFortran_only ;
     storageOf_Java_only =  source->p_Java_only ;
     storageOf_PHP_only =  source->p_PHP_only ;
     storageOf_Python_only =  source->p_Python_only ;
     storageOf_Cuda_only =  source->p_Cuda_only ;
     storageOf_OpenCL_only =  source->p_OpenCL_only ;
     storageOf_requires_C_preprocessor =  source->p_requires_C_preprocessor ;
     storageOf_binary_only =  source->p_binary_only ;
     storageOf_inputFormat =  source->p_inputFormat ;
     storageOf_outputFormat =  source->p_outputFormat ;
     storageOf_backendCompileFormat =  source->p_backendCompileFormat ;
     storageOf_fortran_implicit_none =  source->p_fortran_implicit_none ;
     storageOf_openmp =  source->p_openmp ;
     storageOf_openmp_parse_only =  source->p_openmp_parse_only ;
     storageOf_openmp_ast_only =  source->p_openmp_ast_only ;
     storageOf_openmp_lowering =  source->p_openmp_lowering ;
     storageOf_cray_pointer_support =  source->p_cray_pointer_support ;
     storageOf_output_parser_actions =  source->p_output_parser_actions ;
     storageOf_exit_after_parser =  source->p_exit_after_parser ;
     storageOf_skip_syntax_check =  source->p_skip_syntax_check ;
     storageOf_relax_syntax_check =  source->p_relax_syntax_check ;
     storageOf_skip_translation_from_edg_ast_to_rose_ast =  source->p_skip_translation_from_edg_ast_to_rose_ast ;
     storageOf_skip_transformation =  source->p_skip_transformation ;
     storageOf_skip_unparse =  source->p_skip_unparse ;
     storageOf_skipfinalCompileStep =  source->p_skipfinalCompileStep ;
     storageOf_unparse_includes =  source->p_unparse_includes ;
     storageOf_unparse_line_directives =  source->p_unparse_line_directives ;
     storageOf_unparse_instruction_addresses =  source->p_unparse_instruction_addresses ;
     storageOf_unparse_raw_memory_contents =  source->p_unparse_raw_memory_contents ;
     storageOf_unparse_binary_file_format =  source->p_unparse_binary_file_format ;
     storageOf_outputLanguage =  source->p_outputLanguage ;
     storageOf_sourceFileNameWithPath.storeDataInEasyStorageClass(source->p_sourceFileNameWithPath);
     storageOf_sourceFileNameWithoutPath.storeDataInEasyStorageClass(source->p_sourceFileNameWithoutPath);
     storageOf_unparse_output_filename.storeDataInEasyStorageClass(source->p_unparse_output_filename);
     storageOf_useBackendOnly =  source->p_useBackendOnly ;
     storageOf_compileOnly =  source->p_compileOnly ;
     storageOf_savedEdgCommandLine.storeDataInEasyStorageClass(source->p_savedEdgCommandLine);
     storageOf_no_implicit_templates =  source->p_no_implicit_templates ;
     storageOf_no_implicit_inline_templates =  source->p_no_implicit_inline_templates ;
     storageOf_skip_commentsAndDirectives =  source->p_skip_commentsAndDirectives ;
     storageOf_collectAllCommentsAndDirectives =  source->p_collectAllCommentsAndDirectives ;
     storageOf_unparseHeaderFiles =  source->p_unparseHeaderFiles ;
     storageOf_preprocessorDirectivesAndCommentsList.storeDataInEasyStorageClass(source->p_preprocessorDirectivesAndCommentsList);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_KCC_frontend =  source->p_KCC_frontend ;
     storageOf_new_frontend =  source->p_new_frontend ;
     storageOf_disable_edg_backend =  source->p_disable_edg_backend ;
     storageOf_disable_sage_backend =  source->p_disable_sage_backend ;
     storageOf_testingLevel =  source->p_testingLevel ;
     storageOf_preinit_il =  source->p_preinit_il ;
     storageOf_enable_cp_backend =  source->p_enable_cp_backend ;
     storageOf_markGeneratedFiles =  source->p_markGeneratedFiles ;
     storageOf_negative_test =  source->p_negative_test ;
     storageOf_strict_language_handling =  source->p_strict_language_handling ;
     storageOf_wave =  source->p_wave ;
     storageOf_embedColorCodesInGeneratedCode =  source->p_embedColorCodesInGeneratedCode ;
     storageOf_generateSourcePositionCodes =  source->p_generateSourcePositionCodes ;
     storageOf_sourceFileUsesCppFileExtension =  source->p_sourceFileUsesCppFileExtension ;
     storageOf_sourceFileUsesFortranFileExtension =  source->p_sourceFileUsesFortranFileExtension ;
     storageOf_sourceFileUsesFortran77FileExtension =  source->p_sourceFileUsesFortran77FileExtension ;
     storageOf_sourceFileUsesFortran90FileExtension =  source->p_sourceFileUsesFortran90FileExtension ;
     storageOf_sourceFileUsesFortran95FileExtension =  source->p_sourceFileUsesFortran95FileExtension ;
     storageOf_sourceFileUsesFortran2003FileExtension =  source->p_sourceFileUsesFortran2003FileExtension ;
     storageOf_sourceFileUsesCoArrayFortranFileExtension =  source->p_sourceFileUsesCoArrayFortranFileExtension ;
     storageOf_sourceFileUsesPHPFileExtension =  source->p_sourceFileUsesPHPFileExtension ;
     storageOf_sourceFileUsesPythonFileExtension =  source->p_sourceFileUsesPythonFileExtension ;
     storageOf_sourceFileUsesJavaFileExtension =  source->p_sourceFileUsesJavaFileExtension ;
     storageOf_sourceFileUsesBinaryFileExtension =  source->p_sourceFileUsesBinaryFileExtension ;
     storageOf_sourceFileTypeIsUnknown =  source->p_sourceFileTypeIsUnknown ;
     storageOf_detect_dangling_pointers =  source->p_detect_dangling_pointers ;
     storageOf_read_executable_file_format_only =  source->p_read_executable_file_format_only ;
     storageOf_visualize_executable_file_format_skip_symbols =  source->p_visualize_executable_file_format_skip_symbols ;
     storageOf_visualize_dwarf_only =  source->p_visualize_dwarf_only ;
     storageOf_read_instructions_only =  source->p_read_instructions_only ;
     storageOf_skip_unparse_asm_commands =  source->p_skip_unparse_asm_commands ;
     storageOf_libraryArchiveObjectFileNameList.storeDataInEasyStorageClass(source->p_libraryArchiveObjectFileNameList);
     storageOf_isLibraryArchive =  source->p_isLibraryArchive ;
     storageOf_isObjectFile =  source->p_isObjectFile ;
     storageOf_disassemblerSearchHeuristics =  source->p_disassemblerSearchHeuristics ;
     storageOf_partitionerSearchHeuristics =  source->p_partitionerSearchHeuristics ;
     storageOf_partitionerConfigurationFileName.storeDataInEasyStorageClass(source->p_partitionerConfigurationFileName);
     storageOf_output_tokens =  source->p_output_tokens ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgUnknownFileStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgStringList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < ROSEAttributesListContainerPtr > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgUnknownFileStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgStringList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < ROSEAttributesListContainerPtr > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgUnknownFileStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgStringList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < ROSEAttributesListContainerPtr > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgUnknownFileStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgStringList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < ROSEAttributesListContainerPtr > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 2955 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgProjectStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 2968 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgProjectStorageClass::pickOutIRNodeData ( SgProject* pointer ) 
   { 
     SgProject* source = (SgProject*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_fileList_ptr = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_fileList_ptr );
     storageOf_originalCommandLineArgumentList.storeDataInEasyStorageClass(source->p_originalCommandLineArgumentList);
     storageOf_frontendErrorCode =  source->p_frontendErrorCode ;
     storageOf_backendErrorCode =  source->p_backendErrorCode ;
     storageOf_outputFileName.storeDataInEasyStorageClass(source->p_outputFileName);
     storageOf_sourceFileNameList.storeDataInEasyStorageClass(source->p_sourceFileNameList);
     storageOf_objectFileNameList.storeDataInEasyStorageClass(source->p_objectFileNameList);
     storageOf_libraryFileList.storeDataInEasyStorageClass(source->p_libraryFileList);
     storageOf_librarySpecifierList.storeDataInEasyStorageClass(source->p_librarySpecifierList);
     storageOf_libraryDirectorySpecifierList.storeDataInEasyStorageClass(source->p_libraryDirectorySpecifierList);
     storageOf_includeDirectorySpecifierList.storeDataInEasyStorageClass(source->p_includeDirectorySpecifierList);
     storageOf_macroSpecifierList.storeDataInEasyStorageClass(source->p_macroSpecifierList);
     storageOf_preincludeFileList.storeDataInEasyStorageClass(source->p_preincludeFileList);
     storageOf_preincludeDirectoryList.storeDataInEasyStorageClass(source->p_preincludeDirectoryList);
     storageOf_compileOnly =  source->p_compileOnly ;
     storageOf_wave =  source->p_wave ;
     storageOf_prelink =  source->p_prelink ;
     storageOf_template_instantiation_mode =  source->p_template_instantiation_mode ;
     storageOf_astMerge =  source->p_astMerge ;
     storageOf_astMergeCommandFile.storeDataInEasyStorageClass(source->p_astMergeCommandFile);
     storageOf_C_PreprocessorOnly =  source->p_C_PreprocessorOnly ;
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_compilationPerformanceFile.storeDataInEasyStorageClass(source->p_compilationPerformanceFile);
     storageOf_includePathList.storeDataInEasyStorageClass(source->p_includePathList);
     storageOf_excludePathList.storeDataInEasyStorageClass(source->p_excludePathList);
     storageOf_includeFileList.storeDataInEasyStorageClass(source->p_includeFileList);
     storageOf_excludeFileList.storeDataInEasyStorageClass(source->p_excludeFileList);
     storageOf_binary_only =  source->p_binary_only ;
     storageOf_dataBaseFilename.storeDataInEasyStorageClass(source->p_dataBaseFilename);
     storageOf_directoryList = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_directoryList );
     storageOf_C_only =  source->p_C_only ;
     storageOf_Cxx_only =  source->p_Cxx_only ;
     storageOf_Fortran_only =  source->p_Fortran_only ;
     storageOf_Java_only =  source->p_Java_only ;
     storageOf_openmp_linking =  source->p_openmp_linking ;
     storageOf_Java_classpath.storeDataInEasyStorageClass(source->p_Java_classpath);
     storageOf_Java_sourcepath.storeDataInEasyStorageClass(source->p_Java_sourcepath);
     storageOf_Java_destdir.storeDataInEasyStorageClass(source->p_Java_destdir);
     storageOf_addCppDirectivesToAST =  source->p_addCppDirectivesToAST ;
     storageOf_includingPreprocessingInfosMap.storeDataInEasyStorageClass(source->p_includingPreprocessingInfosMap);
     storageOf_quotedIncludesSearchPaths.storeDataInEasyStorageClass(source->p_quotedIncludesSearchPaths);
     storageOf_bracketedIncludesSearchPaths.storeDataInEasyStorageClass(source->p_bracketedIncludesSearchPaths);
     storageOf_unparseHeaderFilesRootFolder.storeDataInEasyStorageClass(source->p_unparseHeaderFilesRootFolder);
     storageOf_frontendConstantFolding =  source->p_frontendConstantFolding ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgProjectStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgStringList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::list<std::string> > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::map<std::string, std::set<PreprocessingInfo*> > > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgProjectStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgStringList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
     EasyStorage < std::list<std::string> > :: deleteMemoryPool() ;
     EasyStorage < std::map<std::string, std::set<PreprocessingInfo*> > > :: deleteMemoryPool() ;
   }

void
SgProjectStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgStringList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
     EasyStorage < std::list<std::string> > :: writeToFile(out) ;
     EasyStorage < std::map<std::string, std::set<PreprocessingInfo*> > > :: writeToFile(out) ;
   }


void
SgProjectStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgStringList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
     EasyStorage < std::list<std::string> > :: readFromFile(in) ;
     EasyStorage < std::map<std::string, std::set<PreprocessingInfo*> > > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 3075 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgOptionsStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 3088 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgOptionsStorageClass::pickOutIRNodeData ( SgOptions* pointer ) 
   { 
     SgOptions* source = (SgOptions*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_debug_level =  source->p_debug_level ;
     storageOf_logging_level =  source->p_logging_level ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }


/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 3111 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgUnparse_InfoStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 3124 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgUnparse_InfoStorageClass::pickOutIRNodeData ( SgUnparse_Info* pointer ) 
   { 
     SgUnparse_Info* source = (SgUnparse_Info*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_unparse_attribute.storeDataInEasyStorageClass(source->p_unparse_attribute);
     storageOf_access_attribute =  source->p_access_attribute ;
     storageOf_nested_expression =  source->p_nested_expression ;
     storageOf_operator_name.storeDataInEasyStorageClass(source->p_operator_name);
     storageOf_var_name.pickOutIRNodeData( &(source->p_var_name) );
     storageOf_declstatement_ptr = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declstatement_ptr );
     storageOf_current_context = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_current_context );
     storageOf_array_index_list.pickOutIRNodeData( &(source->p_array_index_list) );
     storageOf_current_namespace = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_current_namespace );
     storageOf_outputCodeGenerationFormatDelimiters =  source->p_outputCodeGenerationFormatDelimiters ;
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_current_function_call = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_current_function_call );
     storageOf_current_scope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_current_scope );
     storageOf_reference_node_for_qualification = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_reference_node_for_qualification );
     storageOf_name_qualification_length =  source->p_name_qualification_length ;
     storageOf_type_elaboration_required =  source->p_type_elaboration_required ;
     storageOf_global_qualification_required =  source->p_global_qualification_required ;
     storageOf_nestingLevel =  source->p_nestingLevel ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgUnparse_InfoStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgBitVector > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgUnparse_InfoStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgBitVector > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
   }

void
SgUnparse_InfoStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgBitVector > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
   }


void
SgUnparse_InfoStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgBitVector > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 3218 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgBaseClassStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 3231 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgBaseClassStorageClass::pickOutIRNodeData ( SgBaseClass* pointer ) 
   { 
     SgBaseClass* source = (SgBaseClass*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_base_class = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_base_class );
     storageOf_isDirectBaseClass =  source->p_isDirectBaseClass ;
     storageOf_baseClassModifier = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_baseClassModifier );
     storageOf_name_qualification_length =  source->p_name_qualification_length ;
     storageOf_type_elaboration_required =  source->p_type_elaboration_required ;
     storageOf_global_qualification_required =  source->p_global_qualification_required ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }


/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 3258 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgExpBaseClassStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 3271 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgExpBaseClassStorageClass::pickOutIRNodeData ( SgExpBaseClass* pointer ) 
   { 
     SgExpBaseClass* source = (SgExpBaseClass*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_base_class_exp = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_base_class_exp );
     storageOf_base_class = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_base_class );
     storageOf_isDirectBaseClass =  source->p_isDirectBaseClass ;
     storageOf_baseClassModifier = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_baseClassModifier );
     storageOf_name_qualification_length =  source->p_name_qualification_length ;
     storageOf_type_elaboration_required =  source->p_type_elaboration_required ;
     storageOf_global_qualification_required =  source->p_global_qualification_required ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }


/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 3299 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTypedefSeqStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 3312 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgTypedefSeqStorageClass::pickOutIRNodeData ( SgTypedefSeq* pointer ) 
   { 
     SgTypedefSeq* source = (SgTypedefSeq*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgTypePtrList::iterator i_typedefs = source->p_typedefs.begin() ; 
     unsigned int tempListCounttypedefs = 0; 
     SgTypePtrList::value_type *  tempListtypedefs = new SgTypePtrList::value_type[ source->p_typedefs.size() ]; 
     for ( ; i_typedefs != source->p_typedefs.end(); ++i_typedefs ) 
        {
          tempListtypedefs[tempListCounttypedefs] = *i_typedefs;
          tempListCounttypedefs++; 
          (*i_typedefs) = (SgTypePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_typedefs ) );
        }
     storageOf_typedefs.storeDataInEasyStorageClass(source->p_typedefs);
     tempListCounttypedefs = 0; 
     i_typedefs = source->p_typedefs.begin() ; 
     for ( ; i_typedefs != source->p_typedefs.end(); ++i_typedefs ) 
        {
          *i_typedefs = tempListtypedefs[tempListCounttypedefs] ;
          tempListCounttypedefs++; 
        }
      delete [] tempListtypedefs; 
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgTypedefSeqStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgTypePtrList > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTypedefSeqStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgTypePtrList > :: deleteMemoryPool() ;
   }

void
SgTypedefSeqStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgTypePtrList > :: writeToFile(out) ;
   }


void
SgTypedefSeqStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgTypePtrList > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 3377 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTemplateParameterStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 3390 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgTemplateParameterStorageClass::pickOutIRNodeData ( SgTemplateParameter* pointer ) 
   { 
     SgTemplateParameter* source = (SgTemplateParameter*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_parameterType =  source->p_parameterType ;
     storageOf_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type );
     storageOf_defaultTypeParameter = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_defaultTypeParameter );
     storageOf_expression = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression );
     storageOf_defaultExpressionParameter = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_defaultExpressionParameter );
     storageOf_templateDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_templateDeclaration );
     storageOf_defaultTemplateDeclarationParameter = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_defaultTemplateDeclarationParameter );
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }


/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 3418 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTemplateArgumentStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 3431 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgTemplateArgumentStorageClass::pickOutIRNodeData ( SgTemplateArgument* pointer ) 
   { 
     SgTemplateArgument* source = (SgTemplateArgument*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_argumentType =  source->p_argumentType ;
     storageOf_isArrayBoundUnknownType =  source->p_isArrayBoundUnknownType ;
     storageOf_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type );
     storageOf_expression = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression );
     storageOf_templateDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_templateDeclaration );
     storageOf_explicitlySpecified =  source->p_explicitlySpecified ;
     storageOf_name_qualification_length =  source->p_name_qualification_length ;
     storageOf_type_elaboration_required =  source->p_type_elaboration_required ;
     storageOf_global_qualification_required =  source->p_global_qualification_required ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }


/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 3461 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgDirectoryStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 3474 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgDirectoryStorageClass::pickOutIRNodeData ( SgDirectory* pointer ) 
   { 
     SgDirectory* source = (SgDirectory*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_fileList = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_fileList );
     storageOf_directoryList = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_directoryList );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgDirectoryStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgDirectoryStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgDirectoryStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgDirectoryStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 3529 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgFileListStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 3542 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgFileListStorageClass::pickOutIRNodeData ( SgFileList* pointer ) 
   { 
     SgFileList* source = (SgFileList*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgFilePtrList::iterator i_listOfFiles = source->p_listOfFiles.begin() ; 
     unsigned int tempListCountlistOfFiles = 0; 
     SgFilePtrList::value_type *  tempListlistOfFiles = new SgFilePtrList::value_type[ source->p_listOfFiles.size() ]; 
     for ( ; i_listOfFiles != source->p_listOfFiles.end(); ++i_listOfFiles ) 
        {
          tempListlistOfFiles[tempListCountlistOfFiles] = *i_listOfFiles;
          tempListCountlistOfFiles++; 
          (*i_listOfFiles) = (SgFilePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_listOfFiles ) );
        }
     storageOf_listOfFiles.storeDataInEasyStorageClass(source->p_listOfFiles);
     tempListCountlistOfFiles = 0; 
     i_listOfFiles = source->p_listOfFiles.begin() ; 
     for ( ; i_listOfFiles != source->p_listOfFiles.end(); ++i_listOfFiles ) 
        {
          *i_listOfFiles = tempListlistOfFiles[tempListCountlistOfFiles] ;
          tempListCountlistOfFiles++; 
        }
      delete [] tempListlistOfFiles; 
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgFileListStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgFilePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgFileListStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgFilePtrList > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgFileListStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgFilePtrList > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgFileListStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgFilePtrList > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 3612 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgDirectoryListStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 3625 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgDirectoryListStorageClass::pickOutIRNodeData ( SgDirectoryList* pointer ) 
   { 
     SgDirectoryList* source = (SgDirectoryList*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgDirectoryPtrList::iterator i_listOfDirectories = source->p_listOfDirectories.begin() ; 
     unsigned int tempListCountlistOfDirectories = 0; 
     SgDirectoryPtrList::value_type *  tempListlistOfDirectories = new SgDirectoryPtrList::value_type[ source->p_listOfDirectories.size() ]; 
     for ( ; i_listOfDirectories != source->p_listOfDirectories.end(); ++i_listOfDirectories ) 
        {
          tempListlistOfDirectories[tempListCountlistOfDirectories] = *i_listOfDirectories;
          tempListCountlistOfDirectories++; 
          (*i_listOfDirectories) = (SgDirectoryPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_listOfDirectories ) );
        }
     storageOf_listOfDirectories.storeDataInEasyStorageClass(source->p_listOfDirectories);
     tempListCountlistOfDirectories = 0; 
     i_listOfDirectories = source->p_listOfDirectories.begin() ; 
     for ( ; i_listOfDirectories != source->p_listOfDirectories.end(); ++i_listOfDirectories ) 
        {
          *i_listOfDirectories = tempListlistOfDirectories[tempListCountlistOfDirectories] ;
          tempListCountlistOfDirectories++; 
        }
      delete [] tempListlistOfDirectories; 
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgDirectoryListStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgDirectoryPtrList > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgDirectoryListStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgDirectoryPtrList > :: deleteMemoryPool() ;
   }

void
SgDirectoryListStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgDirectoryPtrList > :: writeToFile(out) ;
   }


void
SgDirectoryListStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgDirectoryPtrList > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 3690 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgFunctionParameterTypeListStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 3703 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgFunctionParameterTypeListStorageClass::pickOutIRNodeData ( SgFunctionParameterTypeList* pointer ) 
   { 
     SgFunctionParameterTypeList* source = (SgFunctionParameterTypeList*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgTypePtrList::iterator i_arguments = source->p_arguments.begin() ; 
     unsigned int tempListCountarguments = 0; 
     SgTypePtrList::value_type *  tempListarguments = new SgTypePtrList::value_type[ source->p_arguments.size() ]; 
     for ( ; i_arguments != source->p_arguments.end(); ++i_arguments ) 
        {
          tempListarguments[tempListCountarguments] = *i_arguments;
          tempListCountarguments++; 
          (*i_arguments) = (SgTypePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_arguments ) );
        }
     storageOf_arguments.storeDataInEasyStorageClass(source->p_arguments);
     tempListCountarguments = 0; 
     i_arguments = source->p_arguments.begin() ; 
     for ( ; i_arguments != source->p_arguments.end(); ++i_arguments ) 
        {
          *i_arguments = tempListarguments[tempListCountarguments] ;
          tempListCountarguments++; 
        }
      delete [] tempListarguments; 
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgFunctionParameterTypeListStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgTypePtrList > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgFunctionParameterTypeListStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgTypePtrList > :: deleteMemoryPool() ;
   }

void
SgFunctionParameterTypeListStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgTypePtrList > :: writeToFile(out) ;
   }


void
SgFunctionParameterTypeListStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgTypePtrList > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 3768 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgQualifiedNameStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 3781 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgQualifiedNameStorageClass::pickOutIRNodeData ( SgQualifiedName* pointer ) 
   { 
     SgQualifiedName* source = (SgQualifiedName*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_scope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_scope );
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }


/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 3803 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTemplateArgumentListStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 3816 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgTemplateArgumentListStorageClass::pickOutIRNodeData ( SgTemplateArgumentList* pointer ) 
   { 
     SgTemplateArgumentList* source = (SgTemplateArgumentList*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgTemplateArgumentPtrList::iterator i_args = source->p_args.begin() ; 
     unsigned int tempListCountargs = 0; 
     SgTemplateArgumentPtrList::value_type *  tempListargs = new SgTemplateArgumentPtrList::value_type[ source->p_args.size() ]; 
     for ( ; i_args != source->p_args.end(); ++i_args ) 
        {
          tempListargs[tempListCountargs] = *i_args;
          tempListCountargs++; 
          (*i_args) = (SgTemplateArgumentPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_args ) );
        }
     storageOf_args.storeDataInEasyStorageClass(source->p_args);
     tempListCountargs = 0; 
     i_args = source->p_args.begin() ; 
     for ( ; i_args != source->p_args.end(); ++i_args ) 
        {
          *i_args = tempListargs[tempListCountargs] ;
          tempListCountargs++; 
        }
      delete [] tempListargs; 
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgTemplateArgumentListStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgTemplateArgumentPtrList > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTemplateArgumentListStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgTemplateArgumentPtrList > :: deleteMemoryPool() ;
   }

void
SgTemplateArgumentListStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgTemplateArgumentPtrList > :: writeToFile(out) ;
   }


void
SgTemplateArgumentListStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgTemplateArgumentPtrList > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 3881 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTemplateParameterListStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 3894 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgTemplateParameterListStorageClass::pickOutIRNodeData ( SgTemplateParameterList* pointer ) 
   { 
     SgTemplateParameterList* source = (SgTemplateParameterList*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgTemplateParameterPtrList::iterator i_args = source->p_args.begin() ; 
     unsigned int tempListCountargs = 0; 
     SgTemplateParameterPtrList::value_type *  tempListargs = new SgTemplateParameterPtrList::value_type[ source->p_args.size() ]; 
     for ( ; i_args != source->p_args.end(); ++i_args ) 
        {
          tempListargs[tempListCountargs] = *i_args;
          tempListCountargs++; 
          (*i_args) = (SgTemplateParameterPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_args ) );
        }
     storageOf_args.storeDataInEasyStorageClass(source->p_args);
     tempListCountargs = 0; 
     i_args = source->p_args.begin() ; 
     for ( ; i_args != source->p_args.end(); ++i_args ) 
        {
          *i_args = tempListargs[tempListCountargs] ;
          tempListCountargs++; 
        }
      delete [] tempListargs; 
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgTemplateParameterListStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgTemplateParameterPtrList > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTemplateParameterListStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgTemplateParameterPtrList > :: deleteMemoryPool() ;
   }

void
SgTemplateParameterListStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgTemplateParameterPtrList > :: writeToFile(out) ;
   }


void
SgTemplateParameterListStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgTemplateParameterPtrList > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 3959 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgGraphStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 3972 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgGraphStorageClass::pickOutIRNodeData ( SgGraph* pointer ) 
   { 
     SgGraph* source = (SgGraph*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     rose_graph_integer_node_hash_map::iterator integer_node_it; 
     unsigned int tempListCountnode_index_to_node_map = 0; 
     SgGraphNode** tempListnode_index_to_node_map = new SgGraphNode* [ source->p_node_index_to_node_map.size() ]; 
     for (integer_node_it = source->p_node_index_to_node_map.begin(); integer_node_it != source->p_node_index_to_node_map.end(); ++integer_node_it)
        {
          tempListnode_index_to_node_map[tempListCountnode_index_to_node_map] = integer_node_it->second;
          tempListCountnode_index_to_node_map++; 
          integer_node_it->second = (SgGraphNode*)(AST_FILE_IO::getGlobalIndexFromSgClassPointer(integer_node_it->second) ); 
        }
     storageOf_node_index_to_node_map.storeDataInEasyStorageClass(source->p_node_index_to_node_map);
     tempListCountnode_index_to_node_map = 0; 
     for (integer_node_it = source->p_node_index_to_node_map.begin(); integer_node_it != source->p_node_index_to_node_map.end(); ++integer_node_it) 
        {
          integer_node_it->second = tempListnode_index_to_node_map [ tempListCountnode_index_to_node_map ]; 
          tempListCountnode_index_to_node_map++; 
        }
      delete [] tempListnode_index_to_node_map; 
     rose_graph_integer_edge_hash_map::iterator integer_edge_it; 
     unsigned int tempListCountedge_index_to_edge_map = 0; 
     SgGraphEdge** tempListedge_index_to_edge_map = new SgGraphEdge* [ source->p_edge_index_to_edge_map.size() ]; 
     for (integer_edge_it = source->p_edge_index_to_edge_map.begin(); integer_edge_it != source->p_edge_index_to_edge_map.end(); ++integer_edge_it)
        {
          tempListedge_index_to_edge_map[tempListCountedge_index_to_edge_map] = integer_edge_it->second;
          tempListCountedge_index_to_edge_map++; 
          integer_edge_it->second = (SgGraphEdge*)(AST_FILE_IO::getGlobalIndexFromSgClassPointer(integer_edge_it->second) ); 
        }
     storageOf_edge_index_to_edge_map.storeDataInEasyStorageClass(source->p_edge_index_to_edge_map);
     tempListCountedge_index_to_edge_map = 0; 
     for (integer_edge_it = source->p_edge_index_to_edge_map.begin(); integer_edge_it != source->p_edge_index_to_edge_map.end(); ++integer_edge_it) 
        {
          integer_edge_it->second = tempListedge_index_to_edge_map [ tempListCountedge_index_to_edge_map ]; 
          tempListCountedge_index_to_edge_map++; 
        }
      delete [] tempListedge_index_to_edge_map; 
     rose_graph_integerpair_edge_hash_multimap::iterator integerpair_edge_it; 
     unsigned int tempListCountnode_index_pair_to_edge_multimap = 0; 
     SgGraphEdge** tempListnode_index_pair_to_edge_multimap = new SgGraphEdge* [ source->p_node_index_pair_to_edge_multimap.size() ]; 
     for (integerpair_edge_it = source->p_node_index_pair_to_edge_multimap.begin(); integerpair_edge_it != source->p_node_index_pair_to_edge_multimap.end(); ++integerpair_edge_it)
        {
          tempListnode_index_pair_to_edge_multimap[tempListCountnode_index_pair_to_edge_multimap] = integerpair_edge_it->second;
          tempListCountnode_index_pair_to_edge_multimap++; 
          integerpair_edge_it->second = (SgGraphEdge*)(AST_FILE_IO::getGlobalIndexFromSgClassPointer(integerpair_edge_it->second) ); 
        }
     storageOf_node_index_pair_to_edge_multimap.storeDataInEasyStorageClass(source->p_node_index_pair_to_edge_multimap);
     tempListCountnode_index_pair_to_edge_multimap = 0; 
     for (integerpair_edge_it = source->p_node_index_pair_to_edge_multimap.begin(); integerpair_edge_it != source->p_node_index_pair_to_edge_multimap.end(); ++integerpair_edge_it) 
        {
          integerpair_edge_it->second = tempListnode_index_pair_to_edge_multimap [ tempListCountnode_index_pair_to_edge_multimap ]; 
          tempListCountnode_index_pair_to_edge_multimap++; 
        }
      delete [] tempListnode_index_pair_to_edge_multimap; 
   {
     rose_graph_string_integer_hash_multimap::iterator string_integer_it; 
     unsigned int tempListCountstring_to_node_index_multimap = 0; 
     int* tempListstring_to_node_index_multimap = new int [ source->p_string_to_node_index_multimap.size() ]; 
     for (string_integer_it = source->p_string_to_node_index_multimap.begin(); string_integer_it != source->p_string_to_node_index_multimap.end(); ++string_integer_it)
        {
          tempListstring_to_node_index_multimap[tempListCountstring_to_node_index_multimap] = string_integer_it->second;
          tempListCountstring_to_node_index_multimap++; 
          string_integer_it->second = 0; printf ("Unimplemented support for rose_graph_string_integer_hash_multimap: Fixme! \n"); ROSE_ASSERT(false); 
        }
     storageOf_string_to_node_index_multimap.storeDataInEasyStorageClass(source->p_string_to_node_index_multimap);
     tempListCountstring_to_node_index_multimap = 0; 
     for (string_integer_it = source->p_string_to_node_index_multimap.begin(); string_integer_it != source->p_string_to_node_index_multimap.end(); ++string_integer_it) 
        {
          string_integer_it->second = tempListstring_to_node_index_multimap [ tempListCountstring_to_node_index_multimap ]; 
          tempListCountstring_to_node_index_multimap++; 
        }
      delete [] tempListstring_to_node_index_multimap; 
    }
   {
     rose_graph_string_integer_hash_multimap::iterator string_integer_it; 
     unsigned int tempListCountstring_to_edge_index_multimap = 0; 
     int* tempListstring_to_edge_index_multimap = new int [ source->p_string_to_edge_index_multimap.size() ]; 
     for (string_integer_it = source->p_string_to_edge_index_multimap.begin(); string_integer_it != source->p_string_to_edge_index_multimap.end(); ++string_integer_it)
        {
          tempListstring_to_edge_index_multimap[tempListCountstring_to_edge_index_multimap] = string_integer_it->second;
          tempListCountstring_to_edge_index_multimap++; 
          string_integer_it->second = 0; printf ("Unimplemented support for rose_graph_string_integer_hash_multimap: Fixme! \n"); ROSE_ASSERT(false); 
        }
     storageOf_string_to_edge_index_multimap.storeDataInEasyStorageClass(source->p_string_to_edge_index_multimap);
     tempListCountstring_to_edge_index_multimap = 0; 
     for (string_integer_it = source->p_string_to_edge_index_multimap.begin(); string_integer_it != source->p_string_to_edge_index_multimap.end(); ++string_integer_it) 
        {
          string_integer_it->second = tempListstring_to_edge_index_multimap [ tempListCountstring_to_edge_index_multimap ]; 
          tempListCountstring_to_edge_index_multimap++; 
        }
      delete [] tempListstring_to_edge_index_multimap; 
    }
   {
     rose_graph_integer_edge_hash_multimap::iterator integer_edge_it2; 
     unsigned int tempListCountnode_index_to_edge_multimap = 0; 
     SgGraphEdge** tempListnode_index_to_edge_multimap = new SgGraphEdge* [ source->p_node_index_to_edge_multimap.size() ]; 
     for (integer_edge_it2 = source->p_node_index_to_edge_multimap.begin(); integer_edge_it2 != source->p_node_index_to_edge_multimap.end(); ++integer_edge_it2)
        {
          tempListnode_index_to_edge_multimap[tempListCountnode_index_to_edge_multimap] = integer_edge_it2->second;
          tempListCountnode_index_to_edge_multimap++; 
          integer_edge_it2->second = (SgGraphEdge*)(AST_FILE_IO::getGlobalIndexFromSgClassPointer(integer_edge_it2->second) ); 
        }
     storageOf_node_index_to_edge_multimap.storeDataInEasyStorageClass(source->p_node_index_to_edge_multimap);
     tempListCountnode_index_to_edge_multimap = 0; 
     for (integer_edge_it2 = source->p_node_index_to_edge_multimap.begin(); integer_edge_it2 != source->p_node_index_to_edge_multimap.end(); ++integer_edge_it2) 
        {
          integer_edge_it2->second = tempListnode_index_to_edge_multimap [ tempListCountnode_index_to_edge_multimap ]; 
          tempListCountnode_index_to_edge_multimap++; 
        }
      delete [] tempListnode_index_to_edge_multimap; 
    }
     storageOf_index =  source->p_index ;
     storageOf_boost_edges.storeDataInEasyStorageClass(source->p_boost_edges);
     storageOf_boost_edge_weights.storeDataInEasyStorageClass(source->p_boost_edge_weights);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_properties.storeDataInEasyStorageClass(source->p_properties);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgGraphStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < rose_graph_integer_node_hash_map > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < rose_graph_integer_edge_hash_map > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < rose_graph_integerpair_edge_hash_multimap > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < rose_graph_string_integer_hash_multimap > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < rose_graph_integer_edge_hash_multimap > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgBoostEdgeList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgBoostEdgeWeightList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::map<int, std::string> > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgGraphStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < rose_graph_integer_node_hash_map > :: deleteMemoryPool() ;
     EasyStorage < rose_graph_integer_edge_hash_map > :: deleteMemoryPool() ;
     EasyStorage < rose_graph_integerpair_edge_hash_multimap > :: deleteMemoryPool() ;
     EasyStorage < rose_graph_string_integer_hash_multimap > :: deleteMemoryPool() ;
     EasyStorage < rose_graph_integer_edge_hash_multimap > :: deleteMemoryPool() ;
     EasyStorage < SgBoostEdgeList > :: deleteMemoryPool() ;
     EasyStorage < SgBoostEdgeWeightList > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
     EasyStorage < std::map<int, std::string> > :: deleteMemoryPool() ;
   }

void
SgGraphStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < rose_graph_integer_node_hash_map > :: writeToFile(out) ;
     EasyStorage < rose_graph_integer_edge_hash_map > :: writeToFile(out) ;
     EasyStorage < rose_graph_integerpair_edge_hash_multimap > :: writeToFile(out) ;
     EasyStorage < rose_graph_string_integer_hash_multimap > :: writeToFile(out) ;
     EasyStorage < rose_graph_integer_edge_hash_multimap > :: writeToFile(out) ;
     EasyStorage < SgBoostEdgeList > :: writeToFile(out) ;
     EasyStorage < SgBoostEdgeWeightList > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
     EasyStorage < std::map<int, std::string> > :: writeToFile(out) ;
   }


void
SgGraphStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < rose_graph_integer_node_hash_map > :: readFromFile(in) ;
     EasyStorage < rose_graph_integer_edge_hash_map > :: readFromFile(in) ;
     EasyStorage < rose_graph_integerpair_edge_hash_multimap > :: readFromFile(in) ;
     EasyStorage < rose_graph_string_integer_hash_multimap > :: readFromFile(in) ;
     EasyStorage < rose_graph_integer_edge_hash_multimap > :: readFromFile(in) ;
     EasyStorage < SgBoostEdgeList > :: readFromFile(in) ;
     EasyStorage < SgBoostEdgeWeightList > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
     EasyStorage < std::map<int, std::string> > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 4169 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgIncidenceDirectedGraphStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 4182 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgIncidenceDirectedGraphStorageClass::pickOutIRNodeData ( SgIncidenceDirectedGraph* pointer ) 
   { 
     SgIncidenceDirectedGraph* source = (SgIncidenceDirectedGraph*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
   {
     rose_graph_integer_edge_hash_multimap::iterator integer_edge_it2; 
     unsigned int tempListCountnode_index_to_edge_multimap_edgesOut = 0; 
     SgGraphEdge** tempListnode_index_to_edge_multimap_edgesOut = new SgGraphEdge* [ source->p_node_index_to_edge_multimap_edgesOut.size() ]; 
     for (integer_edge_it2 = source->p_node_index_to_edge_multimap_edgesOut.begin(); integer_edge_it2 != source->p_node_index_to_edge_multimap_edgesOut.end(); ++integer_edge_it2)
        {
          tempListnode_index_to_edge_multimap_edgesOut[tempListCountnode_index_to_edge_multimap_edgesOut] = integer_edge_it2->second;
          tempListCountnode_index_to_edge_multimap_edgesOut++; 
          integer_edge_it2->second = (SgGraphEdge*)(AST_FILE_IO::getGlobalIndexFromSgClassPointer(integer_edge_it2->second) ); 
        }
     storageOf_node_index_to_edge_multimap_edgesOut.storeDataInEasyStorageClass(source->p_node_index_to_edge_multimap_edgesOut);
     tempListCountnode_index_to_edge_multimap_edgesOut = 0; 
     for (integer_edge_it2 = source->p_node_index_to_edge_multimap_edgesOut.begin(); integer_edge_it2 != source->p_node_index_to_edge_multimap_edgesOut.end(); ++integer_edge_it2) 
        {
          integer_edge_it2->second = tempListnode_index_to_edge_multimap_edgesOut [ tempListCountnode_index_to_edge_multimap_edgesOut ]; 
          tempListCountnode_index_to_edge_multimap_edgesOut++; 
        }
      delete [] tempListnode_index_to_edge_multimap_edgesOut; 
    }
   {
     rose_graph_integer_edge_hash_multimap::iterator integer_edge_it2; 
     unsigned int tempListCountnode_index_to_edge_multimap_edgesIn = 0; 
     SgGraphEdge** tempListnode_index_to_edge_multimap_edgesIn = new SgGraphEdge* [ source->p_node_index_to_edge_multimap_edgesIn.size() ]; 
     for (integer_edge_it2 = source->p_node_index_to_edge_multimap_edgesIn.begin(); integer_edge_it2 != source->p_node_index_to_edge_multimap_edgesIn.end(); ++integer_edge_it2)
        {
          tempListnode_index_to_edge_multimap_edgesIn[tempListCountnode_index_to_edge_multimap_edgesIn] = integer_edge_it2->second;
          tempListCountnode_index_to_edge_multimap_edgesIn++; 
          integer_edge_it2->second = (SgGraphEdge*)(AST_FILE_IO::getGlobalIndexFromSgClassPointer(integer_edge_it2->second) ); 
        }
     storageOf_node_index_to_edge_multimap_edgesIn.storeDataInEasyStorageClass(source->p_node_index_to_edge_multimap_edgesIn);
     tempListCountnode_index_to_edge_multimap_edgesIn = 0; 
     for (integer_edge_it2 = source->p_node_index_to_edge_multimap_edgesIn.begin(); integer_edge_it2 != source->p_node_index_to_edge_multimap_edgesIn.end(); ++integer_edge_it2) 
        {
          integer_edge_it2->second = tempListnode_index_to_edge_multimap_edgesIn [ tempListCountnode_index_to_edge_multimap_edgesIn ]; 
          tempListCountnode_index_to_edge_multimap_edgesIn++; 
        }
      delete [] tempListnode_index_to_edge_multimap_edgesIn; 
    }
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     rose_graph_integer_node_hash_map::iterator integer_node_it; 
     unsigned int tempListCountnode_index_to_node_map = 0; 
     SgGraphNode** tempListnode_index_to_node_map = new SgGraphNode* [ source->p_node_index_to_node_map.size() ]; 
     for (integer_node_it = source->p_node_index_to_node_map.begin(); integer_node_it != source->p_node_index_to_node_map.end(); ++integer_node_it)
        {
          tempListnode_index_to_node_map[tempListCountnode_index_to_node_map] = integer_node_it->second;
          tempListCountnode_index_to_node_map++; 
          integer_node_it->second = (SgGraphNode*)(AST_FILE_IO::getGlobalIndexFromSgClassPointer(integer_node_it->second) ); 
        }
     storageOf_node_index_to_node_map.storeDataInEasyStorageClass(source->p_node_index_to_node_map);
     tempListCountnode_index_to_node_map = 0; 
     for (integer_node_it = source->p_node_index_to_node_map.begin(); integer_node_it != source->p_node_index_to_node_map.end(); ++integer_node_it) 
        {
          integer_node_it->second = tempListnode_index_to_node_map [ tempListCountnode_index_to_node_map ]; 
          tempListCountnode_index_to_node_map++; 
        }
      delete [] tempListnode_index_to_node_map; 
     rose_graph_integer_edge_hash_map::iterator integer_edge_it; 
     unsigned int tempListCountedge_index_to_edge_map = 0; 
     SgGraphEdge** tempListedge_index_to_edge_map = new SgGraphEdge* [ source->p_edge_index_to_edge_map.size() ]; 
     for (integer_edge_it = source->p_edge_index_to_edge_map.begin(); integer_edge_it != source->p_edge_index_to_edge_map.end(); ++integer_edge_it)
        {
          tempListedge_index_to_edge_map[tempListCountedge_index_to_edge_map] = integer_edge_it->second;
          tempListCountedge_index_to_edge_map++; 
          integer_edge_it->second = (SgGraphEdge*)(AST_FILE_IO::getGlobalIndexFromSgClassPointer(integer_edge_it->second) ); 
        }
     storageOf_edge_index_to_edge_map.storeDataInEasyStorageClass(source->p_edge_index_to_edge_map);
     tempListCountedge_index_to_edge_map = 0; 
     for (integer_edge_it = source->p_edge_index_to_edge_map.begin(); integer_edge_it != source->p_edge_index_to_edge_map.end(); ++integer_edge_it) 
        {
          integer_edge_it->second = tempListedge_index_to_edge_map [ tempListCountedge_index_to_edge_map ]; 
          tempListCountedge_index_to_edge_map++; 
        }
      delete [] tempListedge_index_to_edge_map; 
     rose_graph_integerpair_edge_hash_multimap::iterator integerpair_edge_it; 
     unsigned int tempListCountnode_index_pair_to_edge_multimap = 0; 
     SgGraphEdge** tempListnode_index_pair_to_edge_multimap = new SgGraphEdge* [ source->p_node_index_pair_to_edge_multimap.size() ]; 
     for (integerpair_edge_it = source->p_node_index_pair_to_edge_multimap.begin(); integerpair_edge_it != source->p_node_index_pair_to_edge_multimap.end(); ++integerpair_edge_it)
        {
          tempListnode_index_pair_to_edge_multimap[tempListCountnode_index_pair_to_edge_multimap] = integerpair_edge_it->second;
          tempListCountnode_index_pair_to_edge_multimap++; 
          integerpair_edge_it->second = (SgGraphEdge*)(AST_FILE_IO::getGlobalIndexFromSgClassPointer(integerpair_edge_it->second) ); 
        }
     storageOf_node_index_pair_to_edge_multimap.storeDataInEasyStorageClass(source->p_node_index_pair_to_edge_multimap);
     tempListCountnode_index_pair_to_edge_multimap = 0; 
     for (integerpair_edge_it = source->p_node_index_pair_to_edge_multimap.begin(); integerpair_edge_it != source->p_node_index_pair_to_edge_multimap.end(); ++integerpair_edge_it) 
        {
          integerpair_edge_it->second = tempListnode_index_pair_to_edge_multimap [ tempListCountnode_index_pair_to_edge_multimap ]; 
          tempListCountnode_index_pair_to_edge_multimap++; 
        }
      delete [] tempListnode_index_pair_to_edge_multimap; 
   {
     rose_graph_string_integer_hash_multimap::iterator string_integer_it; 
     unsigned int tempListCountstring_to_node_index_multimap = 0; 
     int* tempListstring_to_node_index_multimap = new int [ source->p_string_to_node_index_multimap.size() ]; 
     for (string_integer_it = source->p_string_to_node_index_multimap.begin(); string_integer_it != source->p_string_to_node_index_multimap.end(); ++string_integer_it)
        {
          tempListstring_to_node_index_multimap[tempListCountstring_to_node_index_multimap] = string_integer_it->second;
          tempListCountstring_to_node_index_multimap++; 
          string_integer_it->second = 0; printf ("Unimplemented support for rose_graph_string_integer_hash_multimap: Fixme! \n"); ROSE_ASSERT(false); 
        }
     storageOf_string_to_node_index_multimap.storeDataInEasyStorageClass(source->p_string_to_node_index_multimap);
     tempListCountstring_to_node_index_multimap = 0; 
     for (string_integer_it = source->p_string_to_node_index_multimap.begin(); string_integer_it != source->p_string_to_node_index_multimap.end(); ++string_integer_it) 
        {
          string_integer_it->second = tempListstring_to_node_index_multimap [ tempListCountstring_to_node_index_multimap ]; 
          tempListCountstring_to_node_index_multimap++; 
        }
      delete [] tempListstring_to_node_index_multimap; 
    }
   {
     rose_graph_string_integer_hash_multimap::iterator string_integer_it; 
     unsigned int tempListCountstring_to_edge_index_multimap = 0; 
     int* tempListstring_to_edge_index_multimap = new int [ source->p_string_to_edge_index_multimap.size() ]; 
     for (string_integer_it = source->p_string_to_edge_index_multimap.begin(); string_integer_it != source->p_string_to_edge_index_multimap.end(); ++string_integer_it)
        {
          tempListstring_to_edge_index_multimap[tempListCountstring_to_edge_index_multimap] = string_integer_it->second;
          tempListCountstring_to_edge_index_multimap++; 
          string_integer_it->second = 0; printf ("Unimplemented support for rose_graph_string_integer_hash_multimap: Fixme! \n"); ROSE_ASSERT(false); 
        }
     storageOf_string_to_edge_index_multimap.storeDataInEasyStorageClass(source->p_string_to_edge_index_multimap);
     tempListCountstring_to_edge_index_multimap = 0; 
     for (string_integer_it = source->p_string_to_edge_index_multimap.begin(); string_integer_it != source->p_string_to_edge_index_multimap.end(); ++string_integer_it) 
        {
          string_integer_it->second = tempListstring_to_edge_index_multimap [ tempListCountstring_to_edge_index_multimap ]; 
          tempListCountstring_to_edge_index_multimap++; 
        }
      delete [] tempListstring_to_edge_index_multimap; 
    }
   {
     rose_graph_integer_edge_hash_multimap::iterator integer_edge_it2; 
     unsigned int tempListCountnode_index_to_edge_multimap = 0; 
     SgGraphEdge** tempListnode_index_to_edge_multimap = new SgGraphEdge* [ source->p_node_index_to_edge_multimap.size() ]; 
     for (integer_edge_it2 = source->p_node_index_to_edge_multimap.begin(); integer_edge_it2 != source->p_node_index_to_edge_multimap.end(); ++integer_edge_it2)
        {
          tempListnode_index_to_edge_multimap[tempListCountnode_index_to_edge_multimap] = integer_edge_it2->second;
          tempListCountnode_index_to_edge_multimap++; 
          integer_edge_it2->second = (SgGraphEdge*)(AST_FILE_IO::getGlobalIndexFromSgClassPointer(integer_edge_it2->second) ); 
        }
     storageOf_node_index_to_edge_multimap.storeDataInEasyStorageClass(source->p_node_index_to_edge_multimap);
     tempListCountnode_index_to_edge_multimap = 0; 
     for (integer_edge_it2 = source->p_node_index_to_edge_multimap.begin(); integer_edge_it2 != source->p_node_index_to_edge_multimap.end(); ++integer_edge_it2) 
        {
          integer_edge_it2->second = tempListnode_index_to_edge_multimap [ tempListCountnode_index_to_edge_multimap ]; 
          tempListCountnode_index_to_edge_multimap++; 
        }
      delete [] tempListnode_index_to_edge_multimap; 
    }
     storageOf_index =  source->p_index ;
     storageOf_boost_edges.storeDataInEasyStorageClass(source->p_boost_edges);
     storageOf_boost_edge_weights.storeDataInEasyStorageClass(source->p_boost_edge_weights);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_properties.storeDataInEasyStorageClass(source->p_properties);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgIncidenceDirectedGraphStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < rose_graph_integer_edge_hash_multimap > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < rose_graph_integer_node_hash_map > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < rose_graph_integer_edge_hash_map > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < rose_graph_integerpair_edge_hash_multimap > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < rose_graph_string_integer_hash_multimap > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgBoostEdgeList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgBoostEdgeWeightList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::map<int, std::string> > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgIncidenceDirectedGraphStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < rose_graph_integer_edge_hash_multimap > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < rose_graph_integer_node_hash_map > :: deleteMemoryPool() ;
     EasyStorage < rose_graph_integer_edge_hash_map > :: deleteMemoryPool() ;
     EasyStorage < rose_graph_integerpair_edge_hash_multimap > :: deleteMemoryPool() ;
     EasyStorage < rose_graph_string_integer_hash_multimap > :: deleteMemoryPool() ;
     EasyStorage < SgBoostEdgeList > :: deleteMemoryPool() ;
     EasyStorage < SgBoostEdgeWeightList > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
     EasyStorage < std::map<int, std::string> > :: deleteMemoryPool() ;
   }

void
SgIncidenceDirectedGraphStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < rose_graph_integer_edge_hash_multimap > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < rose_graph_integer_node_hash_map > :: writeToFile(out) ;
     EasyStorage < rose_graph_integer_edge_hash_map > :: writeToFile(out) ;
     EasyStorage < rose_graph_integerpair_edge_hash_multimap > :: writeToFile(out) ;
     EasyStorage < rose_graph_string_integer_hash_multimap > :: writeToFile(out) ;
     EasyStorage < SgBoostEdgeList > :: writeToFile(out) ;
     EasyStorage < SgBoostEdgeWeightList > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
     EasyStorage < std::map<int, std::string> > :: writeToFile(out) ;
   }


void
SgIncidenceDirectedGraphStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < rose_graph_integer_edge_hash_multimap > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < rose_graph_integer_node_hash_map > :: readFromFile(in) ;
     EasyStorage < rose_graph_integer_edge_hash_map > :: readFromFile(in) ;
     EasyStorage < rose_graph_integerpair_edge_hash_multimap > :: readFromFile(in) ;
     EasyStorage < rose_graph_string_integer_hash_multimap > :: readFromFile(in) ;
     EasyStorage < SgBoostEdgeList > :: readFromFile(in) ;
     EasyStorage < SgBoostEdgeWeightList > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
     EasyStorage < std::map<int, std::string> > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 4417 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgBidirectionalGraphStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 4430 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgBidirectionalGraphStorageClass::pickOutIRNodeData ( SgBidirectionalGraph* pointer ) 
   { 
     SgBidirectionalGraph* source = (SgBidirectionalGraph*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
   {
     rose_graph_integer_edge_hash_multimap::iterator integer_edge_it2; 
     unsigned int tempListCountnode_index_to_edge_multimap_edgesOut = 0; 
     SgGraphEdge** tempListnode_index_to_edge_multimap_edgesOut = new SgGraphEdge* [ source->p_node_index_to_edge_multimap_edgesOut.size() ]; 
     for (integer_edge_it2 = source->p_node_index_to_edge_multimap_edgesOut.begin(); integer_edge_it2 != source->p_node_index_to_edge_multimap_edgesOut.end(); ++integer_edge_it2)
        {
          tempListnode_index_to_edge_multimap_edgesOut[tempListCountnode_index_to_edge_multimap_edgesOut] = integer_edge_it2->second;
          tempListCountnode_index_to_edge_multimap_edgesOut++; 
          integer_edge_it2->second = (SgGraphEdge*)(AST_FILE_IO::getGlobalIndexFromSgClassPointer(integer_edge_it2->second) ); 
        }
     storageOf_node_index_to_edge_multimap_edgesOut.storeDataInEasyStorageClass(source->p_node_index_to_edge_multimap_edgesOut);
     tempListCountnode_index_to_edge_multimap_edgesOut = 0; 
     for (integer_edge_it2 = source->p_node_index_to_edge_multimap_edgesOut.begin(); integer_edge_it2 != source->p_node_index_to_edge_multimap_edgesOut.end(); ++integer_edge_it2) 
        {
          integer_edge_it2->second = tempListnode_index_to_edge_multimap_edgesOut [ tempListCountnode_index_to_edge_multimap_edgesOut ]; 
          tempListCountnode_index_to_edge_multimap_edgesOut++; 
        }
      delete [] tempListnode_index_to_edge_multimap_edgesOut; 
    }
   {
     rose_graph_integer_edge_hash_multimap::iterator integer_edge_it2; 
     unsigned int tempListCountnode_index_to_edge_multimap_edgesIn = 0; 
     SgGraphEdge** tempListnode_index_to_edge_multimap_edgesIn = new SgGraphEdge* [ source->p_node_index_to_edge_multimap_edgesIn.size() ]; 
     for (integer_edge_it2 = source->p_node_index_to_edge_multimap_edgesIn.begin(); integer_edge_it2 != source->p_node_index_to_edge_multimap_edgesIn.end(); ++integer_edge_it2)
        {
          tempListnode_index_to_edge_multimap_edgesIn[tempListCountnode_index_to_edge_multimap_edgesIn] = integer_edge_it2->second;
          tempListCountnode_index_to_edge_multimap_edgesIn++; 
          integer_edge_it2->second = (SgGraphEdge*)(AST_FILE_IO::getGlobalIndexFromSgClassPointer(integer_edge_it2->second) ); 
        }
     storageOf_node_index_to_edge_multimap_edgesIn.storeDataInEasyStorageClass(source->p_node_index_to_edge_multimap_edgesIn);
     tempListCountnode_index_to_edge_multimap_edgesIn = 0; 
     for (integer_edge_it2 = source->p_node_index_to_edge_multimap_edgesIn.begin(); integer_edge_it2 != source->p_node_index_to_edge_multimap_edgesIn.end(); ++integer_edge_it2) 
        {
          integer_edge_it2->second = tempListnode_index_to_edge_multimap_edgesIn [ tempListCountnode_index_to_edge_multimap_edgesIn ]; 
          tempListCountnode_index_to_edge_multimap_edgesIn++; 
        }
      delete [] tempListnode_index_to_edge_multimap_edgesIn; 
    }
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     rose_graph_integer_node_hash_map::iterator integer_node_it; 
     unsigned int tempListCountnode_index_to_node_map = 0; 
     SgGraphNode** tempListnode_index_to_node_map = new SgGraphNode* [ source->p_node_index_to_node_map.size() ]; 
     for (integer_node_it = source->p_node_index_to_node_map.begin(); integer_node_it != source->p_node_index_to_node_map.end(); ++integer_node_it)
        {
          tempListnode_index_to_node_map[tempListCountnode_index_to_node_map] = integer_node_it->second;
          tempListCountnode_index_to_node_map++; 
          integer_node_it->second = (SgGraphNode*)(AST_FILE_IO::getGlobalIndexFromSgClassPointer(integer_node_it->second) ); 
        }
     storageOf_node_index_to_node_map.storeDataInEasyStorageClass(source->p_node_index_to_node_map);
     tempListCountnode_index_to_node_map = 0; 
     for (integer_node_it = source->p_node_index_to_node_map.begin(); integer_node_it != source->p_node_index_to_node_map.end(); ++integer_node_it) 
        {
          integer_node_it->second = tempListnode_index_to_node_map [ tempListCountnode_index_to_node_map ]; 
          tempListCountnode_index_to_node_map++; 
        }
      delete [] tempListnode_index_to_node_map; 
     rose_graph_integer_edge_hash_map::iterator integer_edge_it; 
     unsigned int tempListCountedge_index_to_edge_map = 0; 
     SgGraphEdge** tempListedge_index_to_edge_map = new SgGraphEdge* [ source->p_edge_index_to_edge_map.size() ]; 
     for (integer_edge_it = source->p_edge_index_to_edge_map.begin(); integer_edge_it != source->p_edge_index_to_edge_map.end(); ++integer_edge_it)
        {
          tempListedge_index_to_edge_map[tempListCountedge_index_to_edge_map] = integer_edge_it->second;
          tempListCountedge_index_to_edge_map++; 
          integer_edge_it->second = (SgGraphEdge*)(AST_FILE_IO::getGlobalIndexFromSgClassPointer(integer_edge_it->second) ); 
        }
     storageOf_edge_index_to_edge_map.storeDataInEasyStorageClass(source->p_edge_index_to_edge_map);
     tempListCountedge_index_to_edge_map = 0; 
     for (integer_edge_it = source->p_edge_index_to_edge_map.begin(); integer_edge_it != source->p_edge_index_to_edge_map.end(); ++integer_edge_it) 
        {
          integer_edge_it->second = tempListedge_index_to_edge_map [ tempListCountedge_index_to_edge_map ]; 
          tempListCountedge_index_to_edge_map++; 
        }
      delete [] tempListedge_index_to_edge_map; 
     rose_graph_integerpair_edge_hash_multimap::iterator integerpair_edge_it; 
     unsigned int tempListCountnode_index_pair_to_edge_multimap = 0; 
     SgGraphEdge** tempListnode_index_pair_to_edge_multimap = new SgGraphEdge* [ source->p_node_index_pair_to_edge_multimap.size() ]; 
     for (integerpair_edge_it = source->p_node_index_pair_to_edge_multimap.begin(); integerpair_edge_it != source->p_node_index_pair_to_edge_multimap.end(); ++integerpair_edge_it)
        {
          tempListnode_index_pair_to_edge_multimap[tempListCountnode_index_pair_to_edge_multimap] = integerpair_edge_it->second;
          tempListCountnode_index_pair_to_edge_multimap++; 
          integerpair_edge_it->second = (SgGraphEdge*)(AST_FILE_IO::getGlobalIndexFromSgClassPointer(integerpair_edge_it->second) ); 
        }
     storageOf_node_index_pair_to_edge_multimap.storeDataInEasyStorageClass(source->p_node_index_pair_to_edge_multimap);
     tempListCountnode_index_pair_to_edge_multimap = 0; 
     for (integerpair_edge_it = source->p_node_index_pair_to_edge_multimap.begin(); integerpair_edge_it != source->p_node_index_pair_to_edge_multimap.end(); ++integerpair_edge_it) 
        {
          integerpair_edge_it->second = tempListnode_index_pair_to_edge_multimap [ tempListCountnode_index_pair_to_edge_multimap ]; 
          tempListCountnode_index_pair_to_edge_multimap++; 
        }
      delete [] tempListnode_index_pair_to_edge_multimap; 
   {
     rose_graph_string_integer_hash_multimap::iterator string_integer_it; 
     unsigned int tempListCountstring_to_node_index_multimap = 0; 
     int* tempListstring_to_node_index_multimap = new int [ source->p_string_to_node_index_multimap.size() ]; 
     for (string_integer_it = source->p_string_to_node_index_multimap.begin(); string_integer_it != source->p_string_to_node_index_multimap.end(); ++string_integer_it)
        {
          tempListstring_to_node_index_multimap[tempListCountstring_to_node_index_multimap] = string_integer_it->second;
          tempListCountstring_to_node_index_multimap++; 
          string_integer_it->second = 0; printf ("Unimplemented support for rose_graph_string_integer_hash_multimap: Fixme! \n"); ROSE_ASSERT(false); 
        }
     storageOf_string_to_node_index_multimap.storeDataInEasyStorageClass(source->p_string_to_node_index_multimap);
     tempListCountstring_to_node_index_multimap = 0; 
     for (string_integer_it = source->p_string_to_node_index_multimap.begin(); string_integer_it != source->p_string_to_node_index_multimap.end(); ++string_integer_it) 
        {
          string_integer_it->second = tempListstring_to_node_index_multimap [ tempListCountstring_to_node_index_multimap ]; 
          tempListCountstring_to_node_index_multimap++; 
        }
      delete [] tempListstring_to_node_index_multimap; 
    }
   {
     rose_graph_string_integer_hash_multimap::iterator string_integer_it; 
     unsigned int tempListCountstring_to_edge_index_multimap = 0; 
     int* tempListstring_to_edge_index_multimap = new int [ source->p_string_to_edge_index_multimap.size() ]; 
     for (string_integer_it = source->p_string_to_edge_index_multimap.begin(); string_integer_it != source->p_string_to_edge_index_multimap.end(); ++string_integer_it)
        {
          tempListstring_to_edge_index_multimap[tempListCountstring_to_edge_index_multimap] = string_integer_it->second;
          tempListCountstring_to_edge_index_multimap++; 
          string_integer_it->second = 0; printf ("Unimplemented support for rose_graph_string_integer_hash_multimap: Fixme! \n"); ROSE_ASSERT(false); 
        }
     storageOf_string_to_edge_index_multimap.storeDataInEasyStorageClass(source->p_string_to_edge_index_multimap);
     tempListCountstring_to_edge_index_multimap = 0; 
     for (string_integer_it = source->p_string_to_edge_index_multimap.begin(); string_integer_it != source->p_string_to_edge_index_multimap.end(); ++string_integer_it) 
        {
          string_integer_it->second = tempListstring_to_edge_index_multimap [ tempListCountstring_to_edge_index_multimap ]; 
          tempListCountstring_to_edge_index_multimap++; 
        }
      delete [] tempListstring_to_edge_index_multimap; 
    }
   {
     rose_graph_integer_edge_hash_multimap::iterator integer_edge_it2; 
     unsigned int tempListCountnode_index_to_edge_multimap = 0; 
     SgGraphEdge** tempListnode_index_to_edge_multimap = new SgGraphEdge* [ source->p_node_index_to_edge_multimap.size() ]; 
     for (integer_edge_it2 = source->p_node_index_to_edge_multimap.begin(); integer_edge_it2 != source->p_node_index_to_edge_multimap.end(); ++integer_edge_it2)
        {
          tempListnode_index_to_edge_multimap[tempListCountnode_index_to_edge_multimap] = integer_edge_it2->second;
          tempListCountnode_index_to_edge_multimap++; 
          integer_edge_it2->second = (SgGraphEdge*)(AST_FILE_IO::getGlobalIndexFromSgClassPointer(integer_edge_it2->second) ); 
        }
     storageOf_node_index_to_edge_multimap.storeDataInEasyStorageClass(source->p_node_index_to_edge_multimap);
     tempListCountnode_index_to_edge_multimap = 0; 
     for (integer_edge_it2 = source->p_node_index_to_edge_multimap.begin(); integer_edge_it2 != source->p_node_index_to_edge_multimap.end(); ++integer_edge_it2) 
        {
          integer_edge_it2->second = tempListnode_index_to_edge_multimap [ tempListCountnode_index_to_edge_multimap ]; 
          tempListCountnode_index_to_edge_multimap++; 
        }
      delete [] tempListnode_index_to_edge_multimap; 
    }
     storageOf_index =  source->p_index ;
     storageOf_boost_edges.storeDataInEasyStorageClass(source->p_boost_edges);
     storageOf_boost_edge_weights.storeDataInEasyStorageClass(source->p_boost_edge_weights);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_properties.storeDataInEasyStorageClass(source->p_properties);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgBidirectionalGraphStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < rose_graph_integer_edge_hash_multimap > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < rose_graph_integer_node_hash_map > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < rose_graph_integer_edge_hash_map > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < rose_graph_integerpair_edge_hash_multimap > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < rose_graph_string_integer_hash_multimap > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgBoostEdgeList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgBoostEdgeWeightList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::map<int, std::string> > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgBidirectionalGraphStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < rose_graph_integer_edge_hash_multimap > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < rose_graph_integer_node_hash_map > :: deleteMemoryPool() ;
     EasyStorage < rose_graph_integer_edge_hash_map > :: deleteMemoryPool() ;
     EasyStorage < rose_graph_integerpair_edge_hash_multimap > :: deleteMemoryPool() ;
     EasyStorage < rose_graph_string_integer_hash_multimap > :: deleteMemoryPool() ;
     EasyStorage < SgBoostEdgeList > :: deleteMemoryPool() ;
     EasyStorage < SgBoostEdgeWeightList > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
     EasyStorage < std::map<int, std::string> > :: deleteMemoryPool() ;
   }

void
SgBidirectionalGraphStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < rose_graph_integer_edge_hash_multimap > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < rose_graph_integer_node_hash_map > :: writeToFile(out) ;
     EasyStorage < rose_graph_integer_edge_hash_map > :: writeToFile(out) ;
     EasyStorage < rose_graph_integerpair_edge_hash_multimap > :: writeToFile(out) ;
     EasyStorage < rose_graph_string_integer_hash_multimap > :: writeToFile(out) ;
     EasyStorage < SgBoostEdgeList > :: writeToFile(out) ;
     EasyStorage < SgBoostEdgeWeightList > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
     EasyStorage < std::map<int, std::string> > :: writeToFile(out) ;
   }


void
SgBidirectionalGraphStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < rose_graph_integer_edge_hash_multimap > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < rose_graph_integer_node_hash_map > :: readFromFile(in) ;
     EasyStorage < rose_graph_integer_edge_hash_map > :: readFromFile(in) ;
     EasyStorage < rose_graph_integerpair_edge_hash_multimap > :: readFromFile(in) ;
     EasyStorage < rose_graph_string_integer_hash_multimap > :: readFromFile(in) ;
     EasyStorage < SgBoostEdgeList > :: readFromFile(in) ;
     EasyStorage < SgBoostEdgeWeightList > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
     EasyStorage < std::map<int, std::string> > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 4665 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgStringKeyedBidirectionalGraphStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 4678 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgStringKeyedBidirectionalGraphStorageClass::pickOutIRNodeData ( SgStringKeyedBidirectionalGraph* pointer ) 
   { 
     SgStringKeyedBidirectionalGraph* source = (SgStringKeyedBidirectionalGraph*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
   {
     rose_graph_integer_edge_hash_multimap::iterator integer_edge_it2; 
     unsigned int tempListCountnode_index_to_edge_multimap_edgesOut = 0; 
     SgGraphEdge** tempListnode_index_to_edge_multimap_edgesOut = new SgGraphEdge* [ source->p_node_index_to_edge_multimap_edgesOut.size() ]; 
     for (integer_edge_it2 = source->p_node_index_to_edge_multimap_edgesOut.begin(); integer_edge_it2 != source->p_node_index_to_edge_multimap_edgesOut.end(); ++integer_edge_it2)
        {
          tempListnode_index_to_edge_multimap_edgesOut[tempListCountnode_index_to_edge_multimap_edgesOut] = integer_edge_it2->second;
          tempListCountnode_index_to_edge_multimap_edgesOut++; 
          integer_edge_it2->second = (SgGraphEdge*)(AST_FILE_IO::getGlobalIndexFromSgClassPointer(integer_edge_it2->second) ); 
        }
     storageOf_node_index_to_edge_multimap_edgesOut.storeDataInEasyStorageClass(source->p_node_index_to_edge_multimap_edgesOut);
     tempListCountnode_index_to_edge_multimap_edgesOut = 0; 
     for (integer_edge_it2 = source->p_node_index_to_edge_multimap_edgesOut.begin(); integer_edge_it2 != source->p_node_index_to_edge_multimap_edgesOut.end(); ++integer_edge_it2) 
        {
          integer_edge_it2->second = tempListnode_index_to_edge_multimap_edgesOut [ tempListCountnode_index_to_edge_multimap_edgesOut ]; 
          tempListCountnode_index_to_edge_multimap_edgesOut++; 
        }
      delete [] tempListnode_index_to_edge_multimap_edgesOut; 
    }
   {
     rose_graph_integer_edge_hash_multimap::iterator integer_edge_it2; 
     unsigned int tempListCountnode_index_to_edge_multimap_edgesIn = 0; 
     SgGraphEdge** tempListnode_index_to_edge_multimap_edgesIn = new SgGraphEdge* [ source->p_node_index_to_edge_multimap_edgesIn.size() ]; 
     for (integer_edge_it2 = source->p_node_index_to_edge_multimap_edgesIn.begin(); integer_edge_it2 != source->p_node_index_to_edge_multimap_edgesIn.end(); ++integer_edge_it2)
        {
          tempListnode_index_to_edge_multimap_edgesIn[tempListCountnode_index_to_edge_multimap_edgesIn] = integer_edge_it2->second;
          tempListCountnode_index_to_edge_multimap_edgesIn++; 
          integer_edge_it2->second = (SgGraphEdge*)(AST_FILE_IO::getGlobalIndexFromSgClassPointer(integer_edge_it2->second) ); 
        }
     storageOf_node_index_to_edge_multimap_edgesIn.storeDataInEasyStorageClass(source->p_node_index_to_edge_multimap_edgesIn);
     tempListCountnode_index_to_edge_multimap_edgesIn = 0; 
     for (integer_edge_it2 = source->p_node_index_to_edge_multimap_edgesIn.begin(); integer_edge_it2 != source->p_node_index_to_edge_multimap_edgesIn.end(); ++integer_edge_it2) 
        {
          integer_edge_it2->second = tempListnode_index_to_edge_multimap_edgesIn [ tempListCountnode_index_to_edge_multimap_edgesIn ]; 
          tempListCountnode_index_to_edge_multimap_edgesIn++; 
        }
      delete [] tempListnode_index_to_edge_multimap_edgesIn; 
    }
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     rose_graph_integer_node_hash_map::iterator integer_node_it; 
     unsigned int tempListCountnode_index_to_node_map = 0; 
     SgGraphNode** tempListnode_index_to_node_map = new SgGraphNode* [ source->p_node_index_to_node_map.size() ]; 
     for (integer_node_it = source->p_node_index_to_node_map.begin(); integer_node_it != source->p_node_index_to_node_map.end(); ++integer_node_it)
        {
          tempListnode_index_to_node_map[tempListCountnode_index_to_node_map] = integer_node_it->second;
          tempListCountnode_index_to_node_map++; 
          integer_node_it->second = (SgGraphNode*)(AST_FILE_IO::getGlobalIndexFromSgClassPointer(integer_node_it->second) ); 
        }
     storageOf_node_index_to_node_map.storeDataInEasyStorageClass(source->p_node_index_to_node_map);
     tempListCountnode_index_to_node_map = 0; 
     for (integer_node_it = source->p_node_index_to_node_map.begin(); integer_node_it != source->p_node_index_to_node_map.end(); ++integer_node_it) 
        {
          integer_node_it->second = tempListnode_index_to_node_map [ tempListCountnode_index_to_node_map ]; 
          tempListCountnode_index_to_node_map++; 
        }
      delete [] tempListnode_index_to_node_map; 
     rose_graph_integer_edge_hash_map::iterator integer_edge_it; 
     unsigned int tempListCountedge_index_to_edge_map = 0; 
     SgGraphEdge** tempListedge_index_to_edge_map = new SgGraphEdge* [ source->p_edge_index_to_edge_map.size() ]; 
     for (integer_edge_it = source->p_edge_index_to_edge_map.begin(); integer_edge_it != source->p_edge_index_to_edge_map.end(); ++integer_edge_it)
        {
          tempListedge_index_to_edge_map[tempListCountedge_index_to_edge_map] = integer_edge_it->second;
          tempListCountedge_index_to_edge_map++; 
          integer_edge_it->second = (SgGraphEdge*)(AST_FILE_IO::getGlobalIndexFromSgClassPointer(integer_edge_it->second) ); 
        }
     storageOf_edge_index_to_edge_map.storeDataInEasyStorageClass(source->p_edge_index_to_edge_map);
     tempListCountedge_index_to_edge_map = 0; 
     for (integer_edge_it = source->p_edge_index_to_edge_map.begin(); integer_edge_it != source->p_edge_index_to_edge_map.end(); ++integer_edge_it) 
        {
          integer_edge_it->second = tempListedge_index_to_edge_map [ tempListCountedge_index_to_edge_map ]; 
          tempListCountedge_index_to_edge_map++; 
        }
      delete [] tempListedge_index_to_edge_map; 
     rose_graph_integerpair_edge_hash_multimap::iterator integerpair_edge_it; 
     unsigned int tempListCountnode_index_pair_to_edge_multimap = 0; 
     SgGraphEdge** tempListnode_index_pair_to_edge_multimap = new SgGraphEdge* [ source->p_node_index_pair_to_edge_multimap.size() ]; 
     for (integerpair_edge_it = source->p_node_index_pair_to_edge_multimap.begin(); integerpair_edge_it != source->p_node_index_pair_to_edge_multimap.end(); ++integerpair_edge_it)
        {
          tempListnode_index_pair_to_edge_multimap[tempListCountnode_index_pair_to_edge_multimap] = integerpair_edge_it->second;
          tempListCountnode_index_pair_to_edge_multimap++; 
          integerpair_edge_it->second = (SgGraphEdge*)(AST_FILE_IO::getGlobalIndexFromSgClassPointer(integerpair_edge_it->second) ); 
        }
     storageOf_node_index_pair_to_edge_multimap.storeDataInEasyStorageClass(source->p_node_index_pair_to_edge_multimap);
     tempListCountnode_index_pair_to_edge_multimap = 0; 
     for (integerpair_edge_it = source->p_node_index_pair_to_edge_multimap.begin(); integerpair_edge_it != source->p_node_index_pair_to_edge_multimap.end(); ++integerpair_edge_it) 
        {
          integerpair_edge_it->second = tempListnode_index_pair_to_edge_multimap [ tempListCountnode_index_pair_to_edge_multimap ]; 
          tempListCountnode_index_pair_to_edge_multimap++; 
        }
      delete [] tempListnode_index_pair_to_edge_multimap; 
   {
     rose_graph_string_integer_hash_multimap::iterator string_integer_it; 
     unsigned int tempListCountstring_to_node_index_multimap = 0; 
     int* tempListstring_to_node_index_multimap = new int [ source->p_string_to_node_index_multimap.size() ]; 
     for (string_integer_it = source->p_string_to_node_index_multimap.begin(); string_integer_it != source->p_string_to_node_index_multimap.end(); ++string_integer_it)
        {
          tempListstring_to_node_index_multimap[tempListCountstring_to_node_index_multimap] = string_integer_it->second;
          tempListCountstring_to_node_index_multimap++; 
          string_integer_it->second = 0; printf ("Unimplemented support for rose_graph_string_integer_hash_multimap: Fixme! \n"); ROSE_ASSERT(false); 
        }
     storageOf_string_to_node_index_multimap.storeDataInEasyStorageClass(source->p_string_to_node_index_multimap);
     tempListCountstring_to_node_index_multimap = 0; 
     for (string_integer_it = source->p_string_to_node_index_multimap.begin(); string_integer_it != source->p_string_to_node_index_multimap.end(); ++string_integer_it) 
        {
          string_integer_it->second = tempListstring_to_node_index_multimap [ tempListCountstring_to_node_index_multimap ]; 
          tempListCountstring_to_node_index_multimap++; 
        }
      delete [] tempListstring_to_node_index_multimap; 
    }
   {
     rose_graph_string_integer_hash_multimap::iterator string_integer_it; 
     unsigned int tempListCountstring_to_edge_index_multimap = 0; 
     int* tempListstring_to_edge_index_multimap = new int [ source->p_string_to_edge_index_multimap.size() ]; 
     for (string_integer_it = source->p_string_to_edge_index_multimap.begin(); string_integer_it != source->p_string_to_edge_index_multimap.end(); ++string_integer_it)
        {
          tempListstring_to_edge_index_multimap[tempListCountstring_to_edge_index_multimap] = string_integer_it->second;
          tempListCountstring_to_edge_index_multimap++; 
          string_integer_it->second = 0; printf ("Unimplemented support for rose_graph_string_integer_hash_multimap: Fixme! \n"); ROSE_ASSERT(false); 
        }
     storageOf_string_to_edge_index_multimap.storeDataInEasyStorageClass(source->p_string_to_edge_index_multimap);
     tempListCountstring_to_edge_index_multimap = 0; 
     for (string_integer_it = source->p_string_to_edge_index_multimap.begin(); string_integer_it != source->p_string_to_edge_index_multimap.end(); ++string_integer_it) 
        {
          string_integer_it->second = tempListstring_to_edge_index_multimap [ tempListCountstring_to_edge_index_multimap ]; 
          tempListCountstring_to_edge_index_multimap++; 
        }
      delete [] tempListstring_to_edge_index_multimap; 
    }
   {
     rose_graph_integer_edge_hash_multimap::iterator integer_edge_it2; 
     unsigned int tempListCountnode_index_to_edge_multimap = 0; 
     SgGraphEdge** tempListnode_index_to_edge_multimap = new SgGraphEdge* [ source->p_node_index_to_edge_multimap.size() ]; 
     for (integer_edge_it2 = source->p_node_index_to_edge_multimap.begin(); integer_edge_it2 != source->p_node_index_to_edge_multimap.end(); ++integer_edge_it2)
        {
          tempListnode_index_to_edge_multimap[tempListCountnode_index_to_edge_multimap] = integer_edge_it2->second;
          tempListCountnode_index_to_edge_multimap++; 
          integer_edge_it2->second = (SgGraphEdge*)(AST_FILE_IO::getGlobalIndexFromSgClassPointer(integer_edge_it2->second) ); 
        }
     storageOf_node_index_to_edge_multimap.storeDataInEasyStorageClass(source->p_node_index_to_edge_multimap);
     tempListCountnode_index_to_edge_multimap = 0; 
     for (integer_edge_it2 = source->p_node_index_to_edge_multimap.begin(); integer_edge_it2 != source->p_node_index_to_edge_multimap.end(); ++integer_edge_it2) 
        {
          integer_edge_it2->second = tempListnode_index_to_edge_multimap [ tempListCountnode_index_to_edge_multimap ]; 
          tempListCountnode_index_to_edge_multimap++; 
        }
      delete [] tempListnode_index_to_edge_multimap; 
    }
     storageOf_index =  source->p_index ;
     storageOf_boost_edges.storeDataInEasyStorageClass(source->p_boost_edges);
     storageOf_boost_edge_weights.storeDataInEasyStorageClass(source->p_boost_edge_weights);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_properties.storeDataInEasyStorageClass(source->p_properties);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgStringKeyedBidirectionalGraphStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < rose_graph_integer_edge_hash_multimap > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < rose_graph_integer_node_hash_map > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < rose_graph_integer_edge_hash_map > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < rose_graph_integerpair_edge_hash_multimap > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < rose_graph_string_integer_hash_multimap > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgBoostEdgeList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgBoostEdgeWeightList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::map<int, std::string> > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgStringKeyedBidirectionalGraphStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < rose_graph_integer_edge_hash_multimap > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < rose_graph_integer_node_hash_map > :: deleteMemoryPool() ;
     EasyStorage < rose_graph_integer_edge_hash_map > :: deleteMemoryPool() ;
     EasyStorage < rose_graph_integerpair_edge_hash_multimap > :: deleteMemoryPool() ;
     EasyStorage < rose_graph_string_integer_hash_multimap > :: deleteMemoryPool() ;
     EasyStorage < SgBoostEdgeList > :: deleteMemoryPool() ;
     EasyStorage < SgBoostEdgeWeightList > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
     EasyStorage < std::map<int, std::string> > :: deleteMemoryPool() ;
   }

void
SgStringKeyedBidirectionalGraphStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < rose_graph_integer_edge_hash_multimap > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < rose_graph_integer_node_hash_map > :: writeToFile(out) ;
     EasyStorage < rose_graph_integer_edge_hash_map > :: writeToFile(out) ;
     EasyStorage < rose_graph_integerpair_edge_hash_multimap > :: writeToFile(out) ;
     EasyStorage < rose_graph_string_integer_hash_multimap > :: writeToFile(out) ;
     EasyStorage < SgBoostEdgeList > :: writeToFile(out) ;
     EasyStorage < SgBoostEdgeWeightList > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
     EasyStorage < std::map<int, std::string> > :: writeToFile(out) ;
   }


void
SgStringKeyedBidirectionalGraphStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < rose_graph_integer_edge_hash_multimap > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < rose_graph_integer_node_hash_map > :: readFromFile(in) ;
     EasyStorage < rose_graph_integer_edge_hash_map > :: readFromFile(in) ;
     EasyStorage < rose_graph_integerpair_edge_hash_multimap > :: readFromFile(in) ;
     EasyStorage < rose_graph_string_integer_hash_multimap > :: readFromFile(in) ;
     EasyStorage < SgBoostEdgeList > :: readFromFile(in) ;
     EasyStorage < SgBoostEdgeWeightList > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
     EasyStorage < std::map<int, std::string> > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 4913 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgIntKeyedBidirectionalGraphStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 4926 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgIntKeyedBidirectionalGraphStorageClass::pickOutIRNodeData ( SgIntKeyedBidirectionalGraph* pointer ) 
   { 
     SgIntKeyedBidirectionalGraph* source = (SgIntKeyedBidirectionalGraph*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
   {
     rose_graph_integer_edge_hash_multimap::iterator integer_edge_it2; 
     unsigned int tempListCountnode_index_to_edge_multimap_edgesOut = 0; 
     SgGraphEdge** tempListnode_index_to_edge_multimap_edgesOut = new SgGraphEdge* [ source->p_node_index_to_edge_multimap_edgesOut.size() ]; 
     for (integer_edge_it2 = source->p_node_index_to_edge_multimap_edgesOut.begin(); integer_edge_it2 != source->p_node_index_to_edge_multimap_edgesOut.end(); ++integer_edge_it2)
        {
          tempListnode_index_to_edge_multimap_edgesOut[tempListCountnode_index_to_edge_multimap_edgesOut] = integer_edge_it2->second;
          tempListCountnode_index_to_edge_multimap_edgesOut++; 
          integer_edge_it2->second = (SgGraphEdge*)(AST_FILE_IO::getGlobalIndexFromSgClassPointer(integer_edge_it2->second) ); 
        }
     storageOf_node_index_to_edge_multimap_edgesOut.storeDataInEasyStorageClass(source->p_node_index_to_edge_multimap_edgesOut);
     tempListCountnode_index_to_edge_multimap_edgesOut = 0; 
     for (integer_edge_it2 = source->p_node_index_to_edge_multimap_edgesOut.begin(); integer_edge_it2 != source->p_node_index_to_edge_multimap_edgesOut.end(); ++integer_edge_it2) 
        {
          integer_edge_it2->second = tempListnode_index_to_edge_multimap_edgesOut [ tempListCountnode_index_to_edge_multimap_edgesOut ]; 
          tempListCountnode_index_to_edge_multimap_edgesOut++; 
        }
      delete [] tempListnode_index_to_edge_multimap_edgesOut; 
    }
   {
     rose_graph_integer_edge_hash_multimap::iterator integer_edge_it2; 
     unsigned int tempListCountnode_index_to_edge_multimap_edgesIn = 0; 
     SgGraphEdge** tempListnode_index_to_edge_multimap_edgesIn = new SgGraphEdge* [ source->p_node_index_to_edge_multimap_edgesIn.size() ]; 
     for (integer_edge_it2 = source->p_node_index_to_edge_multimap_edgesIn.begin(); integer_edge_it2 != source->p_node_index_to_edge_multimap_edgesIn.end(); ++integer_edge_it2)
        {
          tempListnode_index_to_edge_multimap_edgesIn[tempListCountnode_index_to_edge_multimap_edgesIn] = integer_edge_it2->second;
          tempListCountnode_index_to_edge_multimap_edgesIn++; 
          integer_edge_it2->second = (SgGraphEdge*)(AST_FILE_IO::getGlobalIndexFromSgClassPointer(integer_edge_it2->second) ); 
        }
     storageOf_node_index_to_edge_multimap_edgesIn.storeDataInEasyStorageClass(source->p_node_index_to_edge_multimap_edgesIn);
     tempListCountnode_index_to_edge_multimap_edgesIn = 0; 
     for (integer_edge_it2 = source->p_node_index_to_edge_multimap_edgesIn.begin(); integer_edge_it2 != source->p_node_index_to_edge_multimap_edgesIn.end(); ++integer_edge_it2) 
        {
          integer_edge_it2->second = tempListnode_index_to_edge_multimap_edgesIn [ tempListCountnode_index_to_edge_multimap_edgesIn ]; 
          tempListCountnode_index_to_edge_multimap_edgesIn++; 
        }
      delete [] tempListnode_index_to_edge_multimap_edgesIn; 
    }
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     rose_graph_integer_node_hash_map::iterator integer_node_it; 
     unsigned int tempListCountnode_index_to_node_map = 0; 
     SgGraphNode** tempListnode_index_to_node_map = new SgGraphNode* [ source->p_node_index_to_node_map.size() ]; 
     for (integer_node_it = source->p_node_index_to_node_map.begin(); integer_node_it != source->p_node_index_to_node_map.end(); ++integer_node_it)
        {
          tempListnode_index_to_node_map[tempListCountnode_index_to_node_map] = integer_node_it->second;
          tempListCountnode_index_to_node_map++; 
          integer_node_it->second = (SgGraphNode*)(AST_FILE_IO::getGlobalIndexFromSgClassPointer(integer_node_it->second) ); 
        }
     storageOf_node_index_to_node_map.storeDataInEasyStorageClass(source->p_node_index_to_node_map);
     tempListCountnode_index_to_node_map = 0; 
     for (integer_node_it = source->p_node_index_to_node_map.begin(); integer_node_it != source->p_node_index_to_node_map.end(); ++integer_node_it) 
        {
          integer_node_it->second = tempListnode_index_to_node_map [ tempListCountnode_index_to_node_map ]; 
          tempListCountnode_index_to_node_map++; 
        }
      delete [] tempListnode_index_to_node_map; 
     rose_graph_integer_edge_hash_map::iterator integer_edge_it; 
     unsigned int tempListCountedge_index_to_edge_map = 0; 
     SgGraphEdge** tempListedge_index_to_edge_map = new SgGraphEdge* [ source->p_edge_index_to_edge_map.size() ]; 
     for (integer_edge_it = source->p_edge_index_to_edge_map.begin(); integer_edge_it != source->p_edge_index_to_edge_map.end(); ++integer_edge_it)
        {
          tempListedge_index_to_edge_map[tempListCountedge_index_to_edge_map] = integer_edge_it->second;
          tempListCountedge_index_to_edge_map++; 
          integer_edge_it->second = (SgGraphEdge*)(AST_FILE_IO::getGlobalIndexFromSgClassPointer(integer_edge_it->second) ); 
        }
     storageOf_edge_index_to_edge_map.storeDataInEasyStorageClass(source->p_edge_index_to_edge_map);
     tempListCountedge_index_to_edge_map = 0; 
     for (integer_edge_it = source->p_edge_index_to_edge_map.begin(); integer_edge_it != source->p_edge_index_to_edge_map.end(); ++integer_edge_it) 
        {
          integer_edge_it->second = tempListedge_index_to_edge_map [ tempListCountedge_index_to_edge_map ]; 
          tempListCountedge_index_to_edge_map++; 
        }
      delete [] tempListedge_index_to_edge_map; 
     rose_graph_integerpair_edge_hash_multimap::iterator integerpair_edge_it; 
     unsigned int tempListCountnode_index_pair_to_edge_multimap = 0; 
     SgGraphEdge** tempListnode_index_pair_to_edge_multimap = new SgGraphEdge* [ source->p_node_index_pair_to_edge_multimap.size() ]; 
     for (integerpair_edge_it = source->p_node_index_pair_to_edge_multimap.begin(); integerpair_edge_it != source->p_node_index_pair_to_edge_multimap.end(); ++integerpair_edge_it)
        {
          tempListnode_index_pair_to_edge_multimap[tempListCountnode_index_pair_to_edge_multimap] = integerpair_edge_it->second;
          tempListCountnode_index_pair_to_edge_multimap++; 
          integerpair_edge_it->second = (SgGraphEdge*)(AST_FILE_IO::getGlobalIndexFromSgClassPointer(integerpair_edge_it->second) ); 
        }
     storageOf_node_index_pair_to_edge_multimap.storeDataInEasyStorageClass(source->p_node_index_pair_to_edge_multimap);
     tempListCountnode_index_pair_to_edge_multimap = 0; 
     for (integerpair_edge_it = source->p_node_index_pair_to_edge_multimap.begin(); integerpair_edge_it != source->p_node_index_pair_to_edge_multimap.end(); ++integerpair_edge_it) 
        {
          integerpair_edge_it->second = tempListnode_index_pair_to_edge_multimap [ tempListCountnode_index_pair_to_edge_multimap ]; 
          tempListCountnode_index_pair_to_edge_multimap++; 
        }
      delete [] tempListnode_index_pair_to_edge_multimap; 
   {
     rose_graph_string_integer_hash_multimap::iterator string_integer_it; 
     unsigned int tempListCountstring_to_node_index_multimap = 0; 
     int* tempListstring_to_node_index_multimap = new int [ source->p_string_to_node_index_multimap.size() ]; 
     for (string_integer_it = source->p_string_to_node_index_multimap.begin(); string_integer_it != source->p_string_to_node_index_multimap.end(); ++string_integer_it)
        {
          tempListstring_to_node_index_multimap[tempListCountstring_to_node_index_multimap] = string_integer_it->second;
          tempListCountstring_to_node_index_multimap++; 
          string_integer_it->second = 0; printf ("Unimplemented support for rose_graph_string_integer_hash_multimap: Fixme! \n"); ROSE_ASSERT(false); 
        }
     storageOf_string_to_node_index_multimap.storeDataInEasyStorageClass(source->p_string_to_node_index_multimap);
     tempListCountstring_to_node_index_multimap = 0; 
     for (string_integer_it = source->p_string_to_node_index_multimap.begin(); string_integer_it != source->p_string_to_node_index_multimap.end(); ++string_integer_it) 
        {
          string_integer_it->second = tempListstring_to_node_index_multimap [ tempListCountstring_to_node_index_multimap ]; 
          tempListCountstring_to_node_index_multimap++; 
        }
      delete [] tempListstring_to_node_index_multimap; 
    }
   {
     rose_graph_string_integer_hash_multimap::iterator string_integer_it; 
     unsigned int tempListCountstring_to_edge_index_multimap = 0; 
     int* tempListstring_to_edge_index_multimap = new int [ source->p_string_to_edge_index_multimap.size() ]; 
     for (string_integer_it = source->p_string_to_edge_index_multimap.begin(); string_integer_it != source->p_string_to_edge_index_multimap.end(); ++string_integer_it)
        {
          tempListstring_to_edge_index_multimap[tempListCountstring_to_edge_index_multimap] = string_integer_it->second;
          tempListCountstring_to_edge_index_multimap++; 
          string_integer_it->second = 0; printf ("Unimplemented support for rose_graph_string_integer_hash_multimap: Fixme! \n"); ROSE_ASSERT(false); 
        }
     storageOf_string_to_edge_index_multimap.storeDataInEasyStorageClass(source->p_string_to_edge_index_multimap);
     tempListCountstring_to_edge_index_multimap = 0; 
     for (string_integer_it = source->p_string_to_edge_index_multimap.begin(); string_integer_it != source->p_string_to_edge_index_multimap.end(); ++string_integer_it) 
        {
          string_integer_it->second = tempListstring_to_edge_index_multimap [ tempListCountstring_to_edge_index_multimap ]; 
          tempListCountstring_to_edge_index_multimap++; 
        }
      delete [] tempListstring_to_edge_index_multimap; 
    }
   {
     rose_graph_integer_edge_hash_multimap::iterator integer_edge_it2; 
     unsigned int tempListCountnode_index_to_edge_multimap = 0; 
     SgGraphEdge** tempListnode_index_to_edge_multimap = new SgGraphEdge* [ source->p_node_index_to_edge_multimap.size() ]; 
     for (integer_edge_it2 = source->p_node_index_to_edge_multimap.begin(); integer_edge_it2 != source->p_node_index_to_edge_multimap.end(); ++integer_edge_it2)
        {
          tempListnode_index_to_edge_multimap[tempListCountnode_index_to_edge_multimap] = integer_edge_it2->second;
          tempListCountnode_index_to_edge_multimap++; 
          integer_edge_it2->second = (SgGraphEdge*)(AST_FILE_IO::getGlobalIndexFromSgClassPointer(integer_edge_it2->second) ); 
        }
     storageOf_node_index_to_edge_multimap.storeDataInEasyStorageClass(source->p_node_index_to_edge_multimap);
     tempListCountnode_index_to_edge_multimap = 0; 
     for (integer_edge_it2 = source->p_node_index_to_edge_multimap.begin(); integer_edge_it2 != source->p_node_index_to_edge_multimap.end(); ++integer_edge_it2) 
        {
          integer_edge_it2->second = tempListnode_index_to_edge_multimap [ tempListCountnode_index_to_edge_multimap ]; 
          tempListCountnode_index_to_edge_multimap++; 
        }
      delete [] tempListnode_index_to_edge_multimap; 
    }
     storageOf_index =  source->p_index ;
     storageOf_boost_edges.storeDataInEasyStorageClass(source->p_boost_edges);
     storageOf_boost_edge_weights.storeDataInEasyStorageClass(source->p_boost_edge_weights);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_properties.storeDataInEasyStorageClass(source->p_properties);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgIntKeyedBidirectionalGraphStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < rose_graph_integer_edge_hash_multimap > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < rose_graph_integer_node_hash_map > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < rose_graph_integer_edge_hash_map > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < rose_graph_integerpair_edge_hash_multimap > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < rose_graph_string_integer_hash_multimap > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgBoostEdgeList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgBoostEdgeWeightList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::map<int, std::string> > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgIntKeyedBidirectionalGraphStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < rose_graph_integer_edge_hash_multimap > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < rose_graph_integer_node_hash_map > :: deleteMemoryPool() ;
     EasyStorage < rose_graph_integer_edge_hash_map > :: deleteMemoryPool() ;
     EasyStorage < rose_graph_integerpair_edge_hash_multimap > :: deleteMemoryPool() ;
     EasyStorage < rose_graph_string_integer_hash_multimap > :: deleteMemoryPool() ;
     EasyStorage < SgBoostEdgeList > :: deleteMemoryPool() ;
     EasyStorage < SgBoostEdgeWeightList > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
     EasyStorage < std::map<int, std::string> > :: deleteMemoryPool() ;
   }

void
SgIntKeyedBidirectionalGraphStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < rose_graph_integer_edge_hash_multimap > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < rose_graph_integer_node_hash_map > :: writeToFile(out) ;
     EasyStorage < rose_graph_integer_edge_hash_map > :: writeToFile(out) ;
     EasyStorage < rose_graph_integerpair_edge_hash_multimap > :: writeToFile(out) ;
     EasyStorage < rose_graph_string_integer_hash_multimap > :: writeToFile(out) ;
     EasyStorage < SgBoostEdgeList > :: writeToFile(out) ;
     EasyStorage < SgBoostEdgeWeightList > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
     EasyStorage < std::map<int, std::string> > :: writeToFile(out) ;
   }


void
SgIntKeyedBidirectionalGraphStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < rose_graph_integer_edge_hash_multimap > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < rose_graph_integer_node_hash_map > :: readFromFile(in) ;
     EasyStorage < rose_graph_integer_edge_hash_map > :: readFromFile(in) ;
     EasyStorage < rose_graph_integerpair_edge_hash_multimap > :: readFromFile(in) ;
     EasyStorage < rose_graph_string_integer_hash_multimap > :: readFromFile(in) ;
     EasyStorage < SgBoostEdgeList > :: readFromFile(in) ;
     EasyStorage < SgBoostEdgeWeightList > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
     EasyStorage < std::map<int, std::string> > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 5161 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgIncidenceUndirectedGraphStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 5174 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgIncidenceUndirectedGraphStorageClass::pickOutIRNodeData ( SgIncidenceUndirectedGraph* pointer ) 
   { 
     SgIncidenceUndirectedGraph* source = (SgIncidenceUndirectedGraph*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     rose_graph_integer_node_hash_map::iterator integer_node_it; 
     unsigned int tempListCountnode_index_to_node_map = 0; 
     SgGraphNode** tempListnode_index_to_node_map = new SgGraphNode* [ source->p_node_index_to_node_map.size() ]; 
     for (integer_node_it = source->p_node_index_to_node_map.begin(); integer_node_it != source->p_node_index_to_node_map.end(); ++integer_node_it)
        {
          tempListnode_index_to_node_map[tempListCountnode_index_to_node_map] = integer_node_it->second;
          tempListCountnode_index_to_node_map++; 
          integer_node_it->second = (SgGraphNode*)(AST_FILE_IO::getGlobalIndexFromSgClassPointer(integer_node_it->second) ); 
        }
     storageOf_node_index_to_node_map.storeDataInEasyStorageClass(source->p_node_index_to_node_map);
     tempListCountnode_index_to_node_map = 0; 
     for (integer_node_it = source->p_node_index_to_node_map.begin(); integer_node_it != source->p_node_index_to_node_map.end(); ++integer_node_it) 
        {
          integer_node_it->second = tempListnode_index_to_node_map [ tempListCountnode_index_to_node_map ]; 
          tempListCountnode_index_to_node_map++; 
        }
      delete [] tempListnode_index_to_node_map; 
     rose_graph_integer_edge_hash_map::iterator integer_edge_it; 
     unsigned int tempListCountedge_index_to_edge_map = 0; 
     SgGraphEdge** tempListedge_index_to_edge_map = new SgGraphEdge* [ source->p_edge_index_to_edge_map.size() ]; 
     for (integer_edge_it = source->p_edge_index_to_edge_map.begin(); integer_edge_it != source->p_edge_index_to_edge_map.end(); ++integer_edge_it)
        {
          tempListedge_index_to_edge_map[tempListCountedge_index_to_edge_map] = integer_edge_it->second;
          tempListCountedge_index_to_edge_map++; 
          integer_edge_it->second = (SgGraphEdge*)(AST_FILE_IO::getGlobalIndexFromSgClassPointer(integer_edge_it->second) ); 
        }
     storageOf_edge_index_to_edge_map.storeDataInEasyStorageClass(source->p_edge_index_to_edge_map);
     tempListCountedge_index_to_edge_map = 0; 
     for (integer_edge_it = source->p_edge_index_to_edge_map.begin(); integer_edge_it != source->p_edge_index_to_edge_map.end(); ++integer_edge_it) 
        {
          integer_edge_it->second = tempListedge_index_to_edge_map [ tempListCountedge_index_to_edge_map ]; 
          tempListCountedge_index_to_edge_map++; 
        }
      delete [] tempListedge_index_to_edge_map; 
     rose_graph_integerpair_edge_hash_multimap::iterator integerpair_edge_it; 
     unsigned int tempListCountnode_index_pair_to_edge_multimap = 0; 
     SgGraphEdge** tempListnode_index_pair_to_edge_multimap = new SgGraphEdge* [ source->p_node_index_pair_to_edge_multimap.size() ]; 
     for (integerpair_edge_it = source->p_node_index_pair_to_edge_multimap.begin(); integerpair_edge_it != source->p_node_index_pair_to_edge_multimap.end(); ++integerpair_edge_it)
        {
          tempListnode_index_pair_to_edge_multimap[tempListCountnode_index_pair_to_edge_multimap] = integerpair_edge_it->second;
          tempListCountnode_index_pair_to_edge_multimap++; 
          integerpair_edge_it->second = (SgGraphEdge*)(AST_FILE_IO::getGlobalIndexFromSgClassPointer(integerpair_edge_it->second) ); 
        }
     storageOf_node_index_pair_to_edge_multimap.storeDataInEasyStorageClass(source->p_node_index_pair_to_edge_multimap);
     tempListCountnode_index_pair_to_edge_multimap = 0; 
     for (integerpair_edge_it = source->p_node_index_pair_to_edge_multimap.begin(); integerpair_edge_it != source->p_node_index_pair_to_edge_multimap.end(); ++integerpair_edge_it) 
        {
          integerpair_edge_it->second = tempListnode_index_pair_to_edge_multimap [ tempListCountnode_index_pair_to_edge_multimap ]; 
          tempListCountnode_index_pair_to_edge_multimap++; 
        }
      delete [] tempListnode_index_pair_to_edge_multimap; 
   {
     rose_graph_string_integer_hash_multimap::iterator string_integer_it; 
     unsigned int tempListCountstring_to_node_index_multimap = 0; 
     int* tempListstring_to_node_index_multimap = new int [ source->p_string_to_node_index_multimap.size() ]; 
     for (string_integer_it = source->p_string_to_node_index_multimap.begin(); string_integer_it != source->p_string_to_node_index_multimap.end(); ++string_integer_it)
        {
          tempListstring_to_node_index_multimap[tempListCountstring_to_node_index_multimap] = string_integer_it->second;
          tempListCountstring_to_node_index_multimap++; 
          string_integer_it->second = 0; printf ("Unimplemented support for rose_graph_string_integer_hash_multimap: Fixme! \n"); ROSE_ASSERT(false); 
        }
     storageOf_string_to_node_index_multimap.storeDataInEasyStorageClass(source->p_string_to_node_index_multimap);
     tempListCountstring_to_node_index_multimap = 0; 
     for (string_integer_it = source->p_string_to_node_index_multimap.begin(); string_integer_it != source->p_string_to_node_index_multimap.end(); ++string_integer_it) 
        {
          string_integer_it->second = tempListstring_to_node_index_multimap [ tempListCountstring_to_node_index_multimap ]; 
          tempListCountstring_to_node_index_multimap++; 
        }
      delete [] tempListstring_to_node_index_multimap; 
    }
   {
     rose_graph_string_integer_hash_multimap::iterator string_integer_it; 
     unsigned int tempListCountstring_to_edge_index_multimap = 0; 
     int* tempListstring_to_edge_index_multimap = new int [ source->p_string_to_edge_index_multimap.size() ]; 
     for (string_integer_it = source->p_string_to_edge_index_multimap.begin(); string_integer_it != source->p_string_to_edge_index_multimap.end(); ++string_integer_it)
        {
          tempListstring_to_edge_index_multimap[tempListCountstring_to_edge_index_multimap] = string_integer_it->second;
          tempListCountstring_to_edge_index_multimap++; 
          string_integer_it->second = 0; printf ("Unimplemented support for rose_graph_string_integer_hash_multimap: Fixme! \n"); ROSE_ASSERT(false); 
        }
     storageOf_string_to_edge_index_multimap.storeDataInEasyStorageClass(source->p_string_to_edge_index_multimap);
     tempListCountstring_to_edge_index_multimap = 0; 
     for (string_integer_it = source->p_string_to_edge_index_multimap.begin(); string_integer_it != source->p_string_to_edge_index_multimap.end(); ++string_integer_it) 
        {
          string_integer_it->second = tempListstring_to_edge_index_multimap [ tempListCountstring_to_edge_index_multimap ]; 
          tempListCountstring_to_edge_index_multimap++; 
        }
      delete [] tempListstring_to_edge_index_multimap; 
    }
   {
     rose_graph_integer_edge_hash_multimap::iterator integer_edge_it2; 
     unsigned int tempListCountnode_index_to_edge_multimap = 0; 
     SgGraphEdge** tempListnode_index_to_edge_multimap = new SgGraphEdge* [ source->p_node_index_to_edge_multimap.size() ]; 
     for (integer_edge_it2 = source->p_node_index_to_edge_multimap.begin(); integer_edge_it2 != source->p_node_index_to_edge_multimap.end(); ++integer_edge_it2)
        {
          tempListnode_index_to_edge_multimap[tempListCountnode_index_to_edge_multimap] = integer_edge_it2->second;
          tempListCountnode_index_to_edge_multimap++; 
          integer_edge_it2->second = (SgGraphEdge*)(AST_FILE_IO::getGlobalIndexFromSgClassPointer(integer_edge_it2->second) ); 
        }
     storageOf_node_index_to_edge_multimap.storeDataInEasyStorageClass(source->p_node_index_to_edge_multimap);
     tempListCountnode_index_to_edge_multimap = 0; 
     for (integer_edge_it2 = source->p_node_index_to_edge_multimap.begin(); integer_edge_it2 != source->p_node_index_to_edge_multimap.end(); ++integer_edge_it2) 
        {
          integer_edge_it2->second = tempListnode_index_to_edge_multimap [ tempListCountnode_index_to_edge_multimap ]; 
          tempListCountnode_index_to_edge_multimap++; 
        }
      delete [] tempListnode_index_to_edge_multimap; 
    }
     storageOf_index =  source->p_index ;
     storageOf_boost_edges.storeDataInEasyStorageClass(source->p_boost_edges);
     storageOf_boost_edge_weights.storeDataInEasyStorageClass(source->p_boost_edge_weights);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_properties.storeDataInEasyStorageClass(source->p_properties);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgIncidenceUndirectedGraphStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < rose_graph_integer_node_hash_map > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < rose_graph_integer_edge_hash_map > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < rose_graph_integerpair_edge_hash_multimap > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < rose_graph_string_integer_hash_multimap > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < rose_graph_integer_edge_hash_multimap > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgBoostEdgeList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgBoostEdgeWeightList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::map<int, std::string> > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgIncidenceUndirectedGraphStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < rose_graph_integer_node_hash_map > :: deleteMemoryPool() ;
     EasyStorage < rose_graph_integer_edge_hash_map > :: deleteMemoryPool() ;
     EasyStorage < rose_graph_integerpair_edge_hash_multimap > :: deleteMemoryPool() ;
     EasyStorage < rose_graph_string_integer_hash_multimap > :: deleteMemoryPool() ;
     EasyStorage < rose_graph_integer_edge_hash_multimap > :: deleteMemoryPool() ;
     EasyStorage < SgBoostEdgeList > :: deleteMemoryPool() ;
     EasyStorage < SgBoostEdgeWeightList > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
     EasyStorage < std::map<int, std::string> > :: deleteMemoryPool() ;
   }

void
SgIncidenceUndirectedGraphStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < rose_graph_integer_node_hash_map > :: writeToFile(out) ;
     EasyStorage < rose_graph_integer_edge_hash_map > :: writeToFile(out) ;
     EasyStorage < rose_graph_integerpair_edge_hash_multimap > :: writeToFile(out) ;
     EasyStorage < rose_graph_string_integer_hash_multimap > :: writeToFile(out) ;
     EasyStorage < rose_graph_integer_edge_hash_multimap > :: writeToFile(out) ;
     EasyStorage < SgBoostEdgeList > :: writeToFile(out) ;
     EasyStorage < SgBoostEdgeWeightList > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
     EasyStorage < std::map<int, std::string> > :: writeToFile(out) ;
   }


void
SgIncidenceUndirectedGraphStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < rose_graph_integer_node_hash_map > :: readFromFile(in) ;
     EasyStorage < rose_graph_integer_edge_hash_map > :: readFromFile(in) ;
     EasyStorage < rose_graph_integerpair_edge_hash_multimap > :: readFromFile(in) ;
     EasyStorage < rose_graph_string_integer_hash_multimap > :: readFromFile(in) ;
     EasyStorage < rose_graph_integer_edge_hash_multimap > :: readFromFile(in) ;
     EasyStorage < SgBoostEdgeList > :: readFromFile(in) ;
     EasyStorage < SgBoostEdgeWeightList > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
     EasyStorage < std::map<int, std::string> > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 5371 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgGraphNodeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 5384 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgGraphNodeStorageClass::pickOutIRNodeData ( SgGraphNode* pointer ) 
   { 
     SgGraphNode* source = (SgGraphNode*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_SgNode = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_SgNode );
     storageOf_index =  source->p_index ;
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_properties.storeDataInEasyStorageClass(source->p_properties);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgGraphNodeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::map<int, std::string> > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgGraphNodeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
     EasyStorage < std::map<int, std::string> > :: deleteMemoryPool() ;
   }

void
SgGraphNodeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
     EasyStorage < std::map<int, std::string> > :: writeToFile(out) ;
   }


void
SgGraphNodeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
     EasyStorage < std::map<int, std::string> > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 5444 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgGraphEdgeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 5457 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgGraphEdgeStorageClass::pickOutIRNodeData ( SgGraphEdge* pointer ) 
   { 
     SgGraphEdge* source = (SgGraphEdge*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_node_A = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_node_A );
     storageOf_node_B = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_node_B );
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_index =  source->p_index ;
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_properties.storeDataInEasyStorageClass(source->p_properties);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgGraphEdgeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::map<int, std::string> > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgGraphEdgeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
     EasyStorage < std::map<int, std::string> > :: deleteMemoryPool() ;
   }

void
SgGraphEdgeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
     EasyStorage < std::map<int, std::string> > :: writeToFile(out) ;
   }


void
SgGraphEdgeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
     EasyStorage < std::map<int, std::string> > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 5518 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgDirectedGraphEdgeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 5531 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgDirectedGraphEdgeStorageClass::pickOutIRNodeData ( SgDirectedGraphEdge* pointer ) 
   { 
     SgDirectedGraphEdge* source = (SgDirectedGraphEdge*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_node_A = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_node_A );
     storageOf_node_B = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_node_B );
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_index =  source->p_index ;
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_properties.storeDataInEasyStorageClass(source->p_properties);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgDirectedGraphEdgeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::map<int, std::string> > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgDirectedGraphEdgeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
     EasyStorage < std::map<int, std::string> > :: deleteMemoryPool() ;
   }

void
SgDirectedGraphEdgeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
     EasyStorage < std::map<int, std::string> > :: writeToFile(out) ;
   }


void
SgDirectedGraphEdgeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
     EasyStorage < std::map<int, std::string> > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 5592 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgUndirectedGraphEdgeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 5605 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgUndirectedGraphEdgeStorageClass::pickOutIRNodeData ( SgUndirectedGraphEdge* pointer ) 
   { 
     SgUndirectedGraphEdge* source = (SgUndirectedGraphEdge*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_node_A = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_node_A );
     storageOf_node_B = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_node_B );
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_index =  source->p_index ;
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_properties.storeDataInEasyStorageClass(source->p_properties);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgUndirectedGraphEdgeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::map<int, std::string> > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgUndirectedGraphEdgeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
     EasyStorage < std::map<int, std::string> > :: deleteMemoryPool() ;
   }

void
SgUndirectedGraphEdgeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
     EasyStorage < std::map<int, std::string> > :: writeToFile(out) ;
   }


void
SgUndirectedGraphEdgeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
     EasyStorage < std::map<int, std::string> > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 5666 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgGraphNodeListStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 5679 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgGraphNodeListStorageClass::pickOutIRNodeData ( SgGraphNodeList* pointer ) 
   { 
     SgGraphNodeList* source = (SgGraphNodeList*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }


/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 5700 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgGraphEdgeListStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 5713 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgGraphEdgeListStorageClass::pickOutIRNodeData ( SgGraphEdgeList* pointer ) 
   { 
     SgGraphEdgeList* source = (SgGraphEdgeList*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }


/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 5734 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTypeTableStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 5747 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgTypeTableStorageClass::pickOutIRNodeData ( SgTypeTable* pointer ) 
   { 
     SgTypeTable* source = (SgTypeTable*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_type_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_table );
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }


/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 5769 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgNameGroupStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 5782 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgNameGroupStorageClass::pickOutIRNodeData ( SgNameGroup* pointer ) 
   { 
     SgNameGroup* source = (SgNameGroup*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_group_name.storeDataInEasyStorageClass(source->p_group_name);
     storageOf_name_list.storeDataInEasyStorageClass(source->p_name_list);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgNameGroupStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgStringList > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgNameGroupStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < SgStringList > :: deleteMemoryPool() ;
   }

void
SgNameGroupStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < SgStringList > :: writeToFile(out) ;
   }


void
SgNameGroupStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < SgStringList > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 5835 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgDimensionObjectStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 5848 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgDimensionObjectStorageClass::pickOutIRNodeData ( SgDimensionObject* pointer ) 
   { 
     SgDimensionObject* source = (SgDimensionObject*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_array = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_array );
     storageOf_shape = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_shape );
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }


/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 5871 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgFormatItemStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 5884 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgFormatItemStorageClass::pickOutIRNodeData ( SgFormatItem* pointer ) 
   { 
     SgFormatItem* source = (SgFormatItem*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_repeat_specification =  source->p_repeat_specification ;
     storageOf_data = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_data );
     storageOf_format_item_list = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_format_item_list );
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }


/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 5908 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgFormatItemListStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 5921 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgFormatItemListStorageClass::pickOutIRNodeData ( SgFormatItemList* pointer ) 
   { 
     SgFormatItemList* source = (SgFormatItemList*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgFormatItemPtrList::iterator i_format_item_list = source->p_format_item_list.begin() ; 
     unsigned int tempListCountformat_item_list = 0; 
     SgFormatItemPtrList::value_type *  tempListformat_item_list = new SgFormatItemPtrList::value_type[ source->p_format_item_list.size() ]; 
     for ( ; i_format_item_list != source->p_format_item_list.end(); ++i_format_item_list ) 
        {
          tempListformat_item_list[tempListCountformat_item_list] = *i_format_item_list;
          tempListCountformat_item_list++; 
          (*i_format_item_list) = (SgFormatItemPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_format_item_list ) );
        }
     storageOf_format_item_list.storeDataInEasyStorageClass(source->p_format_item_list);
     tempListCountformat_item_list = 0; 
     i_format_item_list = source->p_format_item_list.begin() ; 
     for ( ; i_format_item_list != source->p_format_item_list.end(); ++i_format_item_list ) 
        {
          *i_format_item_list = tempListformat_item_list[tempListCountformat_item_list] ;
          tempListCountformat_item_list++; 
        }
      delete [] tempListformat_item_list; 
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgFormatItemListStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgFormatItemPtrList > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgFormatItemListStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgFormatItemPtrList > :: deleteMemoryPool() ;
   }

void
SgFormatItemListStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgFormatItemPtrList > :: writeToFile(out) ;
   }


void
SgFormatItemListStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgFormatItemPtrList > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 5986 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgDataStatementGroupStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 5999 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgDataStatementGroupStorageClass::pickOutIRNodeData ( SgDataStatementGroup* pointer ) 
   { 
     SgDataStatementGroup* source = (SgDataStatementGroup*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgDataStatementObjectPtrList::iterator i_object_list = source->p_object_list.begin() ; 
     unsigned int tempListCountobject_list = 0; 
     SgDataStatementObjectPtrList::value_type *  tempListobject_list = new SgDataStatementObjectPtrList::value_type[ source->p_object_list.size() ]; 
     for ( ; i_object_list != source->p_object_list.end(); ++i_object_list ) 
        {
          tempListobject_list[tempListCountobject_list] = *i_object_list;
          tempListCountobject_list++; 
          (*i_object_list) = (SgDataStatementObjectPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_object_list ) );
        }
     storageOf_object_list.storeDataInEasyStorageClass(source->p_object_list);
     tempListCountobject_list = 0; 
     i_object_list = source->p_object_list.begin() ; 
     for ( ; i_object_list != source->p_object_list.end(); ++i_object_list ) 
        {
          *i_object_list = tempListobject_list[tempListCountobject_list] ;
          tempListCountobject_list++; 
        }
      delete [] tempListobject_list; 
     SgDataStatementValuePtrList::iterator i_value_list = source->p_value_list.begin() ; 
     unsigned int tempListCountvalue_list = 0; 
     SgDataStatementValuePtrList::value_type *  tempListvalue_list = new SgDataStatementValuePtrList::value_type[ source->p_value_list.size() ]; 
     for ( ; i_value_list != source->p_value_list.end(); ++i_value_list ) 
        {
          tempListvalue_list[tempListCountvalue_list] = *i_value_list;
          tempListCountvalue_list++; 
          (*i_value_list) = (SgDataStatementValuePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_value_list ) );
        }
     storageOf_value_list.storeDataInEasyStorageClass(source->p_value_list);
     tempListCountvalue_list = 0; 
     i_value_list = source->p_value_list.begin() ; 
     for ( ; i_value_list != source->p_value_list.end(); ++i_value_list ) 
        {
          *i_value_list = tempListvalue_list[tempListCountvalue_list] ;
          tempListCountvalue_list++; 
        }
      delete [] tempListvalue_list; 
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgDataStatementGroupStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgDataStatementObjectPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgDataStatementValuePtrList > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgDataStatementGroupStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgDataStatementObjectPtrList > :: deleteMemoryPool() ;
     EasyStorage < SgDataStatementValuePtrList > :: deleteMemoryPool() ;
   }

void
SgDataStatementGroupStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgDataStatementObjectPtrList > :: writeToFile(out) ;
     EasyStorage < SgDataStatementValuePtrList > :: writeToFile(out) ;
   }


void
SgDataStatementGroupStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgDataStatementObjectPtrList > :: readFromFile(in) ;
     EasyStorage < SgDataStatementValuePtrList > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 6086 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgDataStatementObjectStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 6099 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgDataStatementObjectStorageClass::pickOutIRNodeData ( SgDataStatementObject* pointer ) 
   { 
     SgDataStatementObject* source = (SgDataStatementObject*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_variableReference_list = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_variableReference_list );
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }


/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 6121 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgDataStatementValueStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 6134 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgDataStatementValueStorageClass::pickOutIRNodeData ( SgDataStatementValue* pointer ) 
   { 
     SgDataStatementValue* source = (SgDataStatementValue*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_data_initialization_format =  source->p_data_initialization_format ;
     storageOf_initializer_list = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_initializer_list );
     storageOf_repeat_expression = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_repeat_expression );
     storageOf_constant_expression = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_constant_expression );
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }


/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 6159 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 6172 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgTypeStorageClass::pickOutIRNodeData ( SgType* pointer ) 
   { 
     SgType* source = (SgType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 6227 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTypeUnknownStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 6240 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgTypeUnknownStorageClass::pickOutIRNodeData ( SgTypeUnknown* pointer ) 
   { 
     SgTypeUnknown* source = (SgTypeUnknown*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgTypeUnknownStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTypeUnknownStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTypeUnknownStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTypeUnknownStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 6295 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTypeCharStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 6308 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgTypeCharStorageClass::pickOutIRNodeData ( SgTypeChar* pointer ) 
   { 
     SgTypeChar* source = (SgTypeChar*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgTypeCharStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTypeCharStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTypeCharStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTypeCharStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 6363 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTypeSignedCharStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 6376 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgTypeSignedCharStorageClass::pickOutIRNodeData ( SgTypeSignedChar* pointer ) 
   { 
     SgTypeSignedChar* source = (SgTypeSignedChar*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgTypeSignedCharStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTypeSignedCharStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTypeSignedCharStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTypeSignedCharStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 6431 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTypeUnsignedCharStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 6444 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgTypeUnsignedCharStorageClass::pickOutIRNodeData ( SgTypeUnsignedChar* pointer ) 
   { 
     SgTypeUnsignedChar* source = (SgTypeUnsignedChar*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgTypeUnsignedCharStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTypeUnsignedCharStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTypeUnsignedCharStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTypeUnsignedCharStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 6499 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTypeShortStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 6512 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgTypeShortStorageClass::pickOutIRNodeData ( SgTypeShort* pointer ) 
   { 
     SgTypeShort* source = (SgTypeShort*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgTypeShortStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTypeShortStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTypeShortStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTypeShortStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 6567 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTypeSignedShortStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 6580 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgTypeSignedShortStorageClass::pickOutIRNodeData ( SgTypeSignedShort* pointer ) 
   { 
     SgTypeSignedShort* source = (SgTypeSignedShort*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgTypeSignedShortStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTypeSignedShortStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTypeSignedShortStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTypeSignedShortStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 6635 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTypeUnsignedShortStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 6648 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgTypeUnsignedShortStorageClass::pickOutIRNodeData ( SgTypeUnsignedShort* pointer ) 
   { 
     SgTypeUnsignedShort* source = (SgTypeUnsignedShort*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgTypeUnsignedShortStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTypeUnsignedShortStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTypeUnsignedShortStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTypeUnsignedShortStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 6703 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTypeIntStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 6716 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgTypeIntStorageClass::pickOutIRNodeData ( SgTypeInt* pointer ) 
   { 
     SgTypeInt* source = (SgTypeInt*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_field_size =  source->p_field_size ;
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgTypeIntStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTypeIntStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTypeIntStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTypeIntStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 6772 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTypeSignedIntStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 6785 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgTypeSignedIntStorageClass::pickOutIRNodeData ( SgTypeSignedInt* pointer ) 
   { 
     SgTypeSignedInt* source = (SgTypeSignedInt*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgTypeSignedIntStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTypeSignedIntStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTypeSignedIntStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTypeSignedIntStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 6840 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTypeUnsignedIntStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 6853 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgTypeUnsignedIntStorageClass::pickOutIRNodeData ( SgTypeUnsignedInt* pointer ) 
   { 
     SgTypeUnsignedInt* source = (SgTypeUnsignedInt*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgTypeUnsignedIntStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTypeUnsignedIntStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTypeUnsignedIntStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTypeUnsignedIntStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 6908 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTypeLongStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 6921 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgTypeLongStorageClass::pickOutIRNodeData ( SgTypeLong* pointer ) 
   { 
     SgTypeLong* source = (SgTypeLong*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgTypeLongStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTypeLongStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTypeLongStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTypeLongStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 6976 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTypeSignedLongStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 6989 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgTypeSignedLongStorageClass::pickOutIRNodeData ( SgTypeSignedLong* pointer ) 
   { 
     SgTypeSignedLong* source = (SgTypeSignedLong*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgTypeSignedLongStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTypeSignedLongStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTypeSignedLongStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTypeSignedLongStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 7044 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTypeUnsignedLongStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 7057 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgTypeUnsignedLongStorageClass::pickOutIRNodeData ( SgTypeUnsignedLong* pointer ) 
   { 
     SgTypeUnsignedLong* source = (SgTypeUnsignedLong*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgTypeUnsignedLongStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTypeUnsignedLongStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTypeUnsignedLongStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTypeUnsignedLongStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 7112 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTypeVoidStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 7125 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgTypeVoidStorageClass::pickOutIRNodeData ( SgTypeVoid* pointer ) 
   { 
     SgTypeVoid* source = (SgTypeVoid*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgTypeVoidStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTypeVoidStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTypeVoidStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTypeVoidStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 7180 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTypeGlobalVoidStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 7193 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgTypeGlobalVoidStorageClass::pickOutIRNodeData ( SgTypeGlobalVoid* pointer ) 
   { 
     SgTypeGlobalVoid* source = (SgTypeGlobalVoid*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgTypeGlobalVoidStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTypeGlobalVoidStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTypeGlobalVoidStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTypeGlobalVoidStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 7248 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTypeWcharStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 7261 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgTypeWcharStorageClass::pickOutIRNodeData ( SgTypeWchar* pointer ) 
   { 
     SgTypeWchar* source = (SgTypeWchar*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgTypeWcharStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTypeWcharStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTypeWcharStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTypeWcharStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 7316 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTypeFloatStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 7329 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgTypeFloatStorageClass::pickOutIRNodeData ( SgTypeFloat* pointer ) 
   { 
     SgTypeFloat* source = (SgTypeFloat*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgTypeFloatStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTypeFloatStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTypeFloatStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTypeFloatStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 7384 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTypeDoubleStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 7397 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgTypeDoubleStorageClass::pickOutIRNodeData ( SgTypeDouble* pointer ) 
   { 
     SgTypeDouble* source = (SgTypeDouble*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgTypeDoubleStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTypeDoubleStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTypeDoubleStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTypeDoubleStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 7452 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTypeLongLongStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 7465 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgTypeLongLongStorageClass::pickOutIRNodeData ( SgTypeLongLong* pointer ) 
   { 
     SgTypeLongLong* source = (SgTypeLongLong*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgTypeLongLongStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTypeLongLongStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTypeLongLongStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTypeLongLongStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 7520 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTypeSignedLongLongStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 7533 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgTypeSignedLongLongStorageClass::pickOutIRNodeData ( SgTypeSignedLongLong* pointer ) 
   { 
     SgTypeSignedLongLong* source = (SgTypeSignedLongLong*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgTypeSignedLongLongStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTypeSignedLongLongStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTypeSignedLongLongStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTypeSignedLongLongStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 7588 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTypeUnsignedLongLongStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 7601 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgTypeUnsignedLongLongStorageClass::pickOutIRNodeData ( SgTypeUnsignedLongLong* pointer ) 
   { 
     SgTypeUnsignedLongLong* source = (SgTypeUnsignedLongLong*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgTypeUnsignedLongLongStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTypeUnsignedLongLongStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTypeUnsignedLongLongStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTypeUnsignedLongLongStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 7656 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTypeLongDoubleStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 7669 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgTypeLongDoubleStorageClass::pickOutIRNodeData ( SgTypeLongDouble* pointer ) 
   { 
     SgTypeLongDouble* source = (SgTypeLongDouble*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgTypeLongDoubleStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTypeLongDoubleStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTypeLongDoubleStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTypeLongDoubleStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 7724 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTypeStringStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 7737 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgTypeStringStorageClass::pickOutIRNodeData ( SgTypeString* pointer ) 
   { 
     SgTypeString* source = (SgTypeString*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_lengthExpression = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lengthExpression );
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgTypeStringStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTypeStringStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTypeStringStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTypeStringStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 7793 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTypeBoolStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 7806 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgTypeBoolStorageClass::pickOutIRNodeData ( SgTypeBool* pointer ) 
   { 
     SgTypeBool* source = (SgTypeBool*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgTypeBoolStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTypeBoolStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTypeBoolStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTypeBoolStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 7861 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgPointerTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 7874 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgPointerTypeStorageClass::pickOutIRNodeData ( SgPointerType* pointer ) 
   { 
     SgPointerType* source = (SgPointerType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_base_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_base_type );
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgPointerTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgPointerTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgPointerTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgPointerTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 7930 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgPointerMemberTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 7943 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgPointerMemberTypeStorageClass::pickOutIRNodeData ( SgPointerMemberType* pointer ) 
   { 
     SgPointerMemberType* source = (SgPointerMemberType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_class_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_class_type );
     storageOf_base_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_base_type );
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgPointerMemberTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgPointerMemberTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgPointerMemberTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgPointerMemberTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 8000 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgReferenceTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 8013 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgReferenceTypeStorageClass::pickOutIRNodeData ( SgReferenceType* pointer ) 
   { 
     SgReferenceType* source = (SgReferenceType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_base_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_base_type );
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgReferenceTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgReferenceTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgReferenceTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgReferenceTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 8069 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgNamedTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 8082 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgNamedTypeStorageClass::pickOutIRNodeData ( SgNamedType* pointer ) 
   { 
     SgNamedType* source = (SgNamedType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_declaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declaration );
     storageOf_autonomous_declaration =  source->p_autonomous_declaration ;
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgNamedTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgNamedTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgNamedTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgNamedTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 8139 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgClassTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 8152 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgClassTypeStorageClass::pickOutIRNodeData ( SgClassType* pointer ) 
   { 
     SgClassType* source = (SgClassType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_declaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declaration );
     storageOf_autonomous_declaration =  source->p_autonomous_declaration ;
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgClassTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgClassTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgClassTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgClassTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 8209 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgJavaParameterizedTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 8222 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgJavaParameterizedTypeStorageClass::pickOutIRNodeData ( SgJavaParameterizedType* pointer ) 
   { 
     SgJavaParameterizedType* source = (SgJavaParameterizedType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_raw_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_raw_type );
     storageOf_type_list = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_list );
     storageOf_declaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declaration );
     storageOf_autonomous_declaration =  source->p_autonomous_declaration ;
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgJavaParameterizedTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgJavaParameterizedTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgJavaParameterizedTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgJavaParameterizedTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 8281 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgEnumTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 8294 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgEnumTypeStorageClass::pickOutIRNodeData ( SgEnumType* pointer ) 
   { 
     SgEnumType* source = (SgEnumType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_declaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declaration );
     storageOf_autonomous_declaration =  source->p_autonomous_declaration ;
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgEnumTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgEnumTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgEnumTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgEnumTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 8351 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTypedefTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 8364 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgTypedefTypeStorageClass::pickOutIRNodeData ( SgTypedefType* pointer ) 
   { 
     SgTypedefType* source = (SgTypedefType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_parent_scope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent_scope );
     storageOf_declaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declaration );
     storageOf_autonomous_declaration =  source->p_autonomous_declaration ;
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgTypedefTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTypedefTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTypedefTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTypedefTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 8422 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgModifierTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 8435 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgModifierTypeStorageClass::pickOutIRNodeData ( SgModifierType* pointer ) 
   { 
     SgModifierType* source = (SgModifierType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_base_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_base_type );
     storageOf_typeModifier.pickOutIRNodeData( &(source->p_typeModifier) );
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgModifierTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgTypeModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgModifierTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgTypeModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgModifierTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgTypeModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgModifierTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgTypeModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 8496 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgFunctionTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 8509 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgFunctionTypeStorageClass::pickOutIRNodeData ( SgFunctionType* pointer ) 
   { 
     SgFunctionType* source = (SgFunctionType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_return_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_return_type );
     storageOf_has_ellipses =  source->p_has_ellipses ;
     storageOf_orig_return_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_orig_return_type );
     storageOf_argument_list = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_argument_list );
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgFunctionTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgFunctionTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgFunctionTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgFunctionTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 8568 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgMemberFunctionTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 8581 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgMemberFunctionTypeStorageClass::pickOutIRNodeData ( SgMemberFunctionType* pointer ) 
   { 
     SgMemberFunctionType* source = (SgMemberFunctionType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_class_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_class_type );
     storageOf_mfunc_specifier =  source->p_mfunc_specifier ;
     storageOf_return_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_return_type );
     storageOf_has_ellipses =  source->p_has_ellipses ;
     storageOf_orig_return_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_orig_return_type );
     storageOf_argument_list = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_argument_list );
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgMemberFunctionTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgMemberFunctionTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgMemberFunctionTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgMemberFunctionTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 8642 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgPartialFunctionTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 8655 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgPartialFunctionTypeStorageClass::pickOutIRNodeData ( SgPartialFunctionType* pointer ) 
   { 
     SgPartialFunctionType* source = (SgPartialFunctionType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_class_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_class_type );
     storageOf_mfunc_specifier =  source->p_mfunc_specifier ;
     storageOf_return_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_return_type );
     storageOf_has_ellipses =  source->p_has_ellipses ;
     storageOf_orig_return_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_orig_return_type );
     storageOf_argument_list = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_argument_list );
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgPartialFunctionTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgPartialFunctionTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgPartialFunctionTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgPartialFunctionTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 8716 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgPartialFunctionModifierTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 8729 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgPartialFunctionModifierTypeStorageClass::pickOutIRNodeData ( SgPartialFunctionModifierType* pointer ) 
   { 
     SgPartialFunctionModifierType* source = (SgPartialFunctionModifierType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_class_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_class_type );
     storageOf_mfunc_specifier =  source->p_mfunc_specifier ;
     storageOf_return_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_return_type );
     storageOf_has_ellipses =  source->p_has_ellipses ;
     storageOf_orig_return_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_orig_return_type );
     storageOf_argument_list = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_argument_list );
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgPartialFunctionModifierTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgPartialFunctionModifierTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgPartialFunctionModifierTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgPartialFunctionModifierTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 8790 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgArrayTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 8803 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgArrayTypeStorageClass::pickOutIRNodeData ( SgArrayType* pointer ) 
   { 
     SgArrayType* source = (SgArrayType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_base_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_base_type );
     storageOf_index = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_index );
     storageOf_dim_info = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_dim_info );
     storageOf_rank =  source->p_rank ;
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgArrayTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgArrayTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgArrayTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgArrayTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 8862 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTypeEllipseStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 8875 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgTypeEllipseStorageClass::pickOutIRNodeData ( SgTypeEllipse* pointer ) 
   { 
     SgTypeEllipse* source = (SgTypeEllipse*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgTypeEllipseStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTypeEllipseStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTypeEllipseStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTypeEllipseStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 8930 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTemplateTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 8943 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgTemplateTypeStorageClass::pickOutIRNodeData ( SgTemplateType* pointer ) 
   { 
     SgTemplateType* source = (SgTemplateType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgTemplateTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTemplateTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTemplateTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTemplateTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 8998 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgQualifiedNameTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 9011 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgQualifiedNameTypeStorageClass::pickOutIRNodeData ( SgQualifiedNameType* pointer ) 
   { 
     SgQualifiedNameType* source = (SgQualifiedNameType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_base_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_base_type );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgQualifiedNameTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgQualifiedNameTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgQualifiedNameTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgQualifiedNameTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 9089 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTypeComplexStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 9102 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgTypeComplexStorageClass::pickOutIRNodeData ( SgTypeComplex* pointer ) 
   { 
     SgTypeComplex* source = (SgTypeComplex*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_base_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_base_type );
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgTypeComplexStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTypeComplexStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTypeComplexStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTypeComplexStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 9158 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTypeImaginaryStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 9171 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgTypeImaginaryStorageClass::pickOutIRNodeData ( SgTypeImaginary* pointer ) 
   { 
     SgTypeImaginary* source = (SgTypeImaginary*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_base_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_base_type );
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgTypeImaginaryStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTypeImaginaryStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTypeImaginaryStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTypeImaginaryStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 9227 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTypeDefaultStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 9240 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgTypeDefaultStorageClass::pickOutIRNodeData ( SgTypeDefault* pointer ) 
   { 
     SgTypeDefault* source = (SgTypeDefault*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_name.pickOutIRNodeData( &(source->p_name) );
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgTypeDefaultStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTypeDefaultStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTypeDefaultStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTypeDefaultStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 9300 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTypeCAFTeamStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 9313 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgTypeCAFTeamStorageClass::pickOutIRNodeData ( SgTypeCAFTeam* pointer ) 
   { 
     SgTypeCAFTeam* source = (SgTypeCAFTeam*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgTypeCAFTeamStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTypeCAFTeamStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTypeCAFTeamStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTypeCAFTeamStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 9368 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTypeCrayPointerStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 9381 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgTypeCrayPointerStorageClass::pickOutIRNodeData ( SgTypeCrayPointer* pointer ) 
   { 
     SgTypeCrayPointer* source = (SgTypeCrayPointer*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgTypeCrayPointerStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTypeCrayPointerStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTypeCrayPointerStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTypeCrayPointerStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 9436 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTypeLabelStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 9449 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgTypeLabelStorageClass::pickOutIRNodeData ( SgTypeLabel* pointer ) 
   { 
     SgTypeLabel* source = (SgTypeLabel*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_name.pickOutIRNodeData( &(source->p_name) );
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgTypeLabelStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTypeLabelStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTypeLabelStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTypeLabelStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 9509 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgLocatedNodeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 9522 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgLocatedNodeStorageClass::pickOutIRNodeData ( SgLocatedNode* pointer ) 
   { 
     SgLocatedNode* source = (SgLocatedNode*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgLocatedNodeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgLocatedNodeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgLocatedNodeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgLocatedNodeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 9577 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgLocatedNodeSupportStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 9590 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgLocatedNodeSupportStorageClass::pickOutIRNodeData ( SgLocatedNodeSupport* pointer ) 
   { 
     SgLocatedNodeSupport* source = (SgLocatedNodeSupport*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgLocatedNodeSupportStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgLocatedNodeSupportStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgLocatedNodeSupportStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgLocatedNodeSupportStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 9645 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgCommonBlockObjectStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 9658 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgCommonBlockObjectStorageClass::pickOutIRNodeData ( SgCommonBlockObject* pointer ) 
   { 
     SgCommonBlockObject* source = (SgCommonBlockObject*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_block_name.storeDataInEasyStorageClass(source->p_block_name);
     storageOf_variable_reference_list = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_variable_reference_list );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgCommonBlockObjectStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgCommonBlockObjectStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgCommonBlockObjectStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgCommonBlockObjectStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 9719 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgInitializedNameStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 9732 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgInitializedNameStorageClass::pickOutIRNodeData ( SgInitializedName* pointer ) 
   { 
     SgInitializedName* source = (SgInitializedName*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_name.pickOutIRNodeData( &(source->p_name) );
     storageOf_typeptr = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typeptr );
     storageOf_initptr = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_initptr );
     storageOf_prev_decl_item = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_prev_decl_item );
     storageOf_is_initializer =  source->p_is_initializer ;
     storageOf_declptr = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declptr );
     storageOf_storageModifier = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_storageModifier );
     storageOf_scope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_scope );
     storageOf_preinitialization =  source->p_preinitialization ;
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_register_name_code =  source->p_register_name_code ;
     storageOf_excess_specifier =  source->p_excess_specifier ;
     storageOf_register_name_string.storeDataInEasyStorageClass(source->p_register_name_string);
     storageOf_requiresGlobalNameQualificationOnType =  source->p_requiresGlobalNameQualificationOnType ;
     storageOf_shapeDeferred =  source->p_shapeDeferred ;
     storageOf_initializationDeferred =  source->p_initializationDeferred ;
     storageOf_gnu_attribute_modifierVector.storeDataInEasyStorageClass(source->p_gnu_attribute_modifierVector);
     storageOf_gnu_attribute_initialization_priority =  source->p_gnu_attribute_initialization_priority ;
     storageOf_gnu_attribute_named_weak_reference.storeDataInEasyStorageClass(source->p_gnu_attribute_named_weak_reference);
     storageOf_gnu_attribute_named_alias.storeDataInEasyStorageClass(source->p_gnu_attribute_named_alias);
     storageOf_gnu_attribute_cleanup_function.storeDataInEasyStorageClass(source->p_gnu_attribute_cleanup_function);
     storageOf_gnu_attribute_section_name.storeDataInEasyStorageClass(source->p_gnu_attribute_section_name);
     storageOf_gnu_attribute_alignment =  source->p_gnu_attribute_alignment ;
     storageOf_gnu_attribute_visability =  source->p_gnu_attribute_visability ;
     storageOf_protected_declaration =  source->p_protected_declaration ;
     storageOf_name_qualification_length_for_type =  source->p_name_qualification_length_for_type ;
     storageOf_type_elaboration_required_for_type =  source->p_type_elaboration_required_for_type ;
     storageOf_global_qualification_required_for_type =  source->p_global_qualification_required_for_type ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgInitializedNameStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgBitVector > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgInitializedNameStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < SgBitVector > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgInitializedNameStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < SgBitVector > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgInitializedNameStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < SgBitVector > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 9827 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgInterfaceBodyStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 9840 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgInterfaceBodyStorageClass::pickOutIRNodeData ( SgInterfaceBody* pointer ) 
   { 
     SgInterfaceBody* source = (SgInterfaceBody*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_function_name.pickOutIRNodeData( &(source->p_function_name) );
     storageOf_functionDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_functionDeclaration );
     storageOf_use_function_name =  source->p_use_function_name ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgInterfaceBodyStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgInterfaceBodyStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgInterfaceBodyStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgInterfaceBodyStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 9902 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgHeaderFileBodyStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 9915 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgHeaderFileBodyStorageClass::pickOutIRNodeData ( SgHeaderFileBody* pointer ) 
   { 
     SgHeaderFileBody* source = (SgHeaderFileBody*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgHeaderFileBodyStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgHeaderFileBodyStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgHeaderFileBodyStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgHeaderFileBodyStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 9970 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgRenamePairStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 9983 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgRenamePairStorageClass::pickOutIRNodeData ( SgRenamePair* pointer ) 
   { 
     SgRenamePair* source = (SgRenamePair*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_local_name.pickOutIRNodeData( &(source->p_local_name) );
     storageOf_use_name.pickOutIRNodeData( &(source->p_use_name) );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgRenamePairStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgRenamePairStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgRenamePairStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgRenamePairStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 10044 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgOmpClauseStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 10057 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgOmpClauseStorageClass::pickOutIRNodeData ( SgOmpClause* pointer ) 
   { 
     SgOmpClause* source = (SgOmpClause*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgOmpClauseStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgOmpClauseStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgOmpClauseStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgOmpClauseStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 10112 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgOmpOrderedClauseStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 10125 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgOmpOrderedClauseStorageClass::pickOutIRNodeData ( SgOmpOrderedClause* pointer ) 
   { 
     SgOmpOrderedClause* source = (SgOmpOrderedClause*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgOmpOrderedClauseStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgOmpOrderedClauseStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgOmpOrderedClauseStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgOmpOrderedClauseStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 10180 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgOmpNowaitClauseStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 10193 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgOmpNowaitClauseStorageClass::pickOutIRNodeData ( SgOmpNowaitClause* pointer ) 
   { 
     SgOmpNowaitClause* source = (SgOmpNowaitClause*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgOmpNowaitClauseStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgOmpNowaitClauseStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgOmpNowaitClauseStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgOmpNowaitClauseStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 10248 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgOmpUntiedClauseStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 10261 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgOmpUntiedClauseStorageClass::pickOutIRNodeData ( SgOmpUntiedClause* pointer ) 
   { 
     SgOmpUntiedClause* source = (SgOmpUntiedClause*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgOmpUntiedClauseStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgOmpUntiedClauseStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgOmpUntiedClauseStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgOmpUntiedClauseStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 10316 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgOmpDefaultClauseStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 10329 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgOmpDefaultClauseStorageClass::pickOutIRNodeData ( SgOmpDefaultClause* pointer ) 
   { 
     SgOmpDefaultClause* source = (SgOmpDefaultClause*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_data_sharing =  source->p_data_sharing ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgOmpDefaultClauseStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgOmpDefaultClauseStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgOmpDefaultClauseStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgOmpDefaultClauseStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 10385 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgOmpExpressionClauseStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 10398 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgOmpExpressionClauseStorageClass::pickOutIRNodeData ( SgOmpExpressionClause* pointer ) 
   { 
     SgOmpExpressionClause* source = (SgOmpExpressionClause*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_expression = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgOmpExpressionClauseStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgOmpExpressionClauseStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgOmpExpressionClauseStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgOmpExpressionClauseStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 10454 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgOmpCollapseClauseStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 10467 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgOmpCollapseClauseStorageClass::pickOutIRNodeData ( SgOmpCollapseClause* pointer ) 
   { 
     SgOmpCollapseClause* source = (SgOmpCollapseClause*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_expression = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgOmpCollapseClauseStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgOmpCollapseClauseStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgOmpCollapseClauseStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgOmpCollapseClauseStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 10523 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgOmpIfClauseStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 10536 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgOmpIfClauseStorageClass::pickOutIRNodeData ( SgOmpIfClause* pointer ) 
   { 
     SgOmpIfClause* source = (SgOmpIfClause*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_expression = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgOmpIfClauseStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgOmpIfClauseStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgOmpIfClauseStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgOmpIfClauseStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 10592 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgOmpNumThreadsClauseStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 10605 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgOmpNumThreadsClauseStorageClass::pickOutIRNodeData ( SgOmpNumThreadsClause* pointer ) 
   { 
     SgOmpNumThreadsClause* source = (SgOmpNumThreadsClause*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_expression = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgOmpNumThreadsClauseStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgOmpNumThreadsClauseStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgOmpNumThreadsClauseStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgOmpNumThreadsClauseStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 10661 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgOmpVariablesClauseStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 10674 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgOmpVariablesClauseStorageClass::pickOutIRNodeData ( SgOmpVariablesClause* pointer ) 
   { 
     SgOmpVariablesClause* source = (SgOmpVariablesClause*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgVarRefExpPtrList::iterator i_variables = source->p_variables.begin() ; 
     unsigned int tempListCountvariables = 0; 
     SgVarRefExpPtrList::value_type *  tempListvariables = new SgVarRefExpPtrList::value_type[ source->p_variables.size() ]; 
     for ( ; i_variables != source->p_variables.end(); ++i_variables ) 
        {
          tempListvariables[tempListCountvariables] = *i_variables;
          tempListCountvariables++; 
          (*i_variables) = (SgVarRefExpPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_variables ) );
        }
     storageOf_variables.storeDataInEasyStorageClass(source->p_variables);
     tempListCountvariables = 0; 
     i_variables = source->p_variables.begin() ; 
     for ( ; i_variables != source->p_variables.end(); ++i_variables ) 
        {
          *i_variables = tempListvariables[tempListCountvariables] ;
          tempListCountvariables++; 
        }
      delete [] tempListvariables; 
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgOmpVariablesClauseStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgVarRefExpPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgOmpVariablesClauseStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgVarRefExpPtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgOmpVariablesClauseStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgVarRefExpPtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgOmpVariablesClauseStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgVarRefExpPtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 10751 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgOmpCopyprivateClauseStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 10764 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgOmpCopyprivateClauseStorageClass::pickOutIRNodeData ( SgOmpCopyprivateClause* pointer ) 
   { 
     SgOmpCopyprivateClause* source = (SgOmpCopyprivateClause*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgVarRefExpPtrList::iterator i_variables = source->p_variables.begin() ; 
     unsigned int tempListCountvariables = 0; 
     SgVarRefExpPtrList::value_type *  tempListvariables = new SgVarRefExpPtrList::value_type[ source->p_variables.size() ]; 
     for ( ; i_variables != source->p_variables.end(); ++i_variables ) 
        {
          tempListvariables[tempListCountvariables] = *i_variables;
          tempListCountvariables++; 
          (*i_variables) = (SgVarRefExpPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_variables ) );
        }
     storageOf_variables.storeDataInEasyStorageClass(source->p_variables);
     tempListCountvariables = 0; 
     i_variables = source->p_variables.begin() ; 
     for ( ; i_variables != source->p_variables.end(); ++i_variables ) 
        {
          *i_variables = tempListvariables[tempListCountvariables] ;
          tempListCountvariables++; 
        }
      delete [] tempListvariables; 
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgOmpCopyprivateClauseStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgVarRefExpPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgOmpCopyprivateClauseStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgVarRefExpPtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgOmpCopyprivateClauseStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgVarRefExpPtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgOmpCopyprivateClauseStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgVarRefExpPtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 10841 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgOmpPrivateClauseStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 10854 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgOmpPrivateClauseStorageClass::pickOutIRNodeData ( SgOmpPrivateClause* pointer ) 
   { 
     SgOmpPrivateClause* source = (SgOmpPrivateClause*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgVarRefExpPtrList::iterator i_variables = source->p_variables.begin() ; 
     unsigned int tempListCountvariables = 0; 
     SgVarRefExpPtrList::value_type *  tempListvariables = new SgVarRefExpPtrList::value_type[ source->p_variables.size() ]; 
     for ( ; i_variables != source->p_variables.end(); ++i_variables ) 
        {
          tempListvariables[tempListCountvariables] = *i_variables;
          tempListCountvariables++; 
          (*i_variables) = (SgVarRefExpPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_variables ) );
        }
     storageOf_variables.storeDataInEasyStorageClass(source->p_variables);
     tempListCountvariables = 0; 
     i_variables = source->p_variables.begin() ; 
     for ( ; i_variables != source->p_variables.end(); ++i_variables ) 
        {
          *i_variables = tempListvariables[tempListCountvariables] ;
          tempListCountvariables++; 
        }
      delete [] tempListvariables; 
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgOmpPrivateClauseStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgVarRefExpPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgOmpPrivateClauseStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgVarRefExpPtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgOmpPrivateClauseStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgVarRefExpPtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgOmpPrivateClauseStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgVarRefExpPtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 10931 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgOmpFirstprivateClauseStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 10944 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgOmpFirstprivateClauseStorageClass::pickOutIRNodeData ( SgOmpFirstprivateClause* pointer ) 
   { 
     SgOmpFirstprivateClause* source = (SgOmpFirstprivateClause*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgVarRefExpPtrList::iterator i_variables = source->p_variables.begin() ; 
     unsigned int tempListCountvariables = 0; 
     SgVarRefExpPtrList::value_type *  tempListvariables = new SgVarRefExpPtrList::value_type[ source->p_variables.size() ]; 
     for ( ; i_variables != source->p_variables.end(); ++i_variables ) 
        {
          tempListvariables[tempListCountvariables] = *i_variables;
          tempListCountvariables++; 
          (*i_variables) = (SgVarRefExpPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_variables ) );
        }
     storageOf_variables.storeDataInEasyStorageClass(source->p_variables);
     tempListCountvariables = 0; 
     i_variables = source->p_variables.begin() ; 
     for ( ; i_variables != source->p_variables.end(); ++i_variables ) 
        {
          *i_variables = tempListvariables[tempListCountvariables] ;
          tempListCountvariables++; 
        }
      delete [] tempListvariables; 
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgOmpFirstprivateClauseStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgVarRefExpPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgOmpFirstprivateClauseStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgVarRefExpPtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgOmpFirstprivateClauseStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgVarRefExpPtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgOmpFirstprivateClauseStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgVarRefExpPtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 11021 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgOmpSharedClauseStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 11034 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgOmpSharedClauseStorageClass::pickOutIRNodeData ( SgOmpSharedClause* pointer ) 
   { 
     SgOmpSharedClause* source = (SgOmpSharedClause*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgVarRefExpPtrList::iterator i_variables = source->p_variables.begin() ; 
     unsigned int tempListCountvariables = 0; 
     SgVarRefExpPtrList::value_type *  tempListvariables = new SgVarRefExpPtrList::value_type[ source->p_variables.size() ]; 
     for ( ; i_variables != source->p_variables.end(); ++i_variables ) 
        {
          tempListvariables[tempListCountvariables] = *i_variables;
          tempListCountvariables++; 
          (*i_variables) = (SgVarRefExpPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_variables ) );
        }
     storageOf_variables.storeDataInEasyStorageClass(source->p_variables);
     tempListCountvariables = 0; 
     i_variables = source->p_variables.begin() ; 
     for ( ; i_variables != source->p_variables.end(); ++i_variables ) 
        {
          *i_variables = tempListvariables[tempListCountvariables] ;
          tempListCountvariables++; 
        }
      delete [] tempListvariables; 
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgOmpSharedClauseStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgVarRefExpPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgOmpSharedClauseStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgVarRefExpPtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgOmpSharedClauseStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgVarRefExpPtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgOmpSharedClauseStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgVarRefExpPtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 11111 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgOmpCopyinClauseStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 11124 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgOmpCopyinClauseStorageClass::pickOutIRNodeData ( SgOmpCopyinClause* pointer ) 
   { 
     SgOmpCopyinClause* source = (SgOmpCopyinClause*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgVarRefExpPtrList::iterator i_variables = source->p_variables.begin() ; 
     unsigned int tempListCountvariables = 0; 
     SgVarRefExpPtrList::value_type *  tempListvariables = new SgVarRefExpPtrList::value_type[ source->p_variables.size() ]; 
     for ( ; i_variables != source->p_variables.end(); ++i_variables ) 
        {
          tempListvariables[tempListCountvariables] = *i_variables;
          tempListCountvariables++; 
          (*i_variables) = (SgVarRefExpPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_variables ) );
        }
     storageOf_variables.storeDataInEasyStorageClass(source->p_variables);
     tempListCountvariables = 0; 
     i_variables = source->p_variables.begin() ; 
     for ( ; i_variables != source->p_variables.end(); ++i_variables ) 
        {
          *i_variables = tempListvariables[tempListCountvariables] ;
          tempListCountvariables++; 
        }
      delete [] tempListvariables; 
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgOmpCopyinClauseStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgVarRefExpPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgOmpCopyinClauseStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgVarRefExpPtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgOmpCopyinClauseStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgVarRefExpPtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgOmpCopyinClauseStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgVarRefExpPtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 11201 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgOmpLastprivateClauseStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 11214 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgOmpLastprivateClauseStorageClass::pickOutIRNodeData ( SgOmpLastprivateClause* pointer ) 
   { 
     SgOmpLastprivateClause* source = (SgOmpLastprivateClause*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgVarRefExpPtrList::iterator i_variables = source->p_variables.begin() ; 
     unsigned int tempListCountvariables = 0; 
     SgVarRefExpPtrList::value_type *  tempListvariables = new SgVarRefExpPtrList::value_type[ source->p_variables.size() ]; 
     for ( ; i_variables != source->p_variables.end(); ++i_variables ) 
        {
          tempListvariables[tempListCountvariables] = *i_variables;
          tempListCountvariables++; 
          (*i_variables) = (SgVarRefExpPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_variables ) );
        }
     storageOf_variables.storeDataInEasyStorageClass(source->p_variables);
     tempListCountvariables = 0; 
     i_variables = source->p_variables.begin() ; 
     for ( ; i_variables != source->p_variables.end(); ++i_variables ) 
        {
          *i_variables = tempListvariables[tempListCountvariables] ;
          tempListCountvariables++; 
        }
      delete [] tempListvariables; 
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgOmpLastprivateClauseStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgVarRefExpPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgOmpLastprivateClauseStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgVarRefExpPtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgOmpLastprivateClauseStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgVarRefExpPtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgOmpLastprivateClauseStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgVarRefExpPtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 11291 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgOmpReductionClauseStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 11304 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgOmpReductionClauseStorageClass::pickOutIRNodeData ( SgOmpReductionClause* pointer ) 
   { 
     SgOmpReductionClause* source = (SgOmpReductionClause*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_operation =  source->p_operation ;
     SgVarRefExpPtrList::iterator i_variables = source->p_variables.begin() ; 
     unsigned int tempListCountvariables = 0; 
     SgVarRefExpPtrList::value_type *  tempListvariables = new SgVarRefExpPtrList::value_type[ source->p_variables.size() ]; 
     for ( ; i_variables != source->p_variables.end(); ++i_variables ) 
        {
          tempListvariables[tempListCountvariables] = *i_variables;
          tempListCountvariables++; 
          (*i_variables) = (SgVarRefExpPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_variables ) );
        }
     storageOf_variables.storeDataInEasyStorageClass(source->p_variables);
     tempListCountvariables = 0; 
     i_variables = source->p_variables.begin() ; 
     for ( ; i_variables != source->p_variables.end(); ++i_variables ) 
        {
          *i_variables = tempListvariables[tempListCountvariables] ;
          tempListCountvariables++; 
        }
      delete [] tempListvariables; 
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgOmpReductionClauseStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgVarRefExpPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgOmpReductionClauseStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgVarRefExpPtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgOmpReductionClauseStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgVarRefExpPtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgOmpReductionClauseStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgVarRefExpPtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 11382 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgOmpScheduleClauseStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 11395 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgOmpScheduleClauseStorageClass::pickOutIRNodeData ( SgOmpScheduleClause* pointer ) 
   { 
     SgOmpScheduleClause* source = (SgOmpScheduleClause*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_kind =  source->p_kind ;
     storageOf_chunk_size = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_chunk_size );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgOmpScheduleClauseStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgOmpScheduleClauseStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgOmpScheduleClauseStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgOmpScheduleClauseStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 11452 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 11465 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgStatementStorageClass::pickOutIRNodeData ( SgStatement* pointer ) 
   { 
     SgStatement* source = (SgStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 11522 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgScopeStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 11535 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgScopeStatementStorageClass::pickOutIRNodeData ( SgScopeStatement* pointer ) 
   { 
     SgScopeStatement* source = (SgScopeStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_symbol_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_symbol_table );
     storageOf_type_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_table );
     storageOf_type_elaboration_list.storeDataInEasyStorageClass(source->p_type_elaboration_list);
     storageOf_hidden_type_list.storeDataInEasyStorageClass(source->p_hidden_type_list);
     storageOf_hidden_declaration_list.storeDataInEasyStorageClass(source->p_hidden_declaration_list);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgScopeStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::set<SgSymbol*> > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgScopeStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::set<SgSymbol*> > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgScopeStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::set<SgSymbol*> > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgScopeStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::set<SgSymbol*> > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 11601 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgGlobalStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 11614 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgGlobalStorageClass::pickOutIRNodeData ( SgGlobal* pointer ) 
   { 
     SgGlobal* source = (SgGlobal*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgDeclarationStatementPtrList::iterator i_declarations = source->p_declarations.begin() ; 
     unsigned int tempListCountdeclarations = 0; 
     SgDeclarationStatementPtrList::value_type *  tempListdeclarations = new SgDeclarationStatementPtrList::value_type[ source->p_declarations.size() ]; 
     for ( ; i_declarations != source->p_declarations.end(); ++i_declarations ) 
        {
          tempListdeclarations[tempListCountdeclarations] = *i_declarations;
          tempListCountdeclarations++; 
          (*i_declarations) = (SgDeclarationStatementPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_declarations ) );
        }
     storageOf_declarations.storeDataInEasyStorageClass(source->p_declarations);
     tempListCountdeclarations = 0; 
     i_declarations = source->p_declarations.begin() ; 
     for ( ; i_declarations != source->p_declarations.end(); ++i_declarations ) 
        {
          *i_declarations = tempListdeclarations[tempListCountdeclarations] ;
          tempListCountdeclarations++; 
        }
      delete [] tempListdeclarations; 
     storageOf_symbol_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_symbol_table );
     storageOf_type_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_table );
     storageOf_type_elaboration_list.storeDataInEasyStorageClass(source->p_type_elaboration_list);
     storageOf_hidden_type_list.storeDataInEasyStorageClass(source->p_hidden_type_list);
     storageOf_hidden_declaration_list.storeDataInEasyStorageClass(source->p_hidden_declaration_list);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgGlobalStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgDeclarationStatementPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::set<SgSymbol*> > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgGlobalStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgDeclarationStatementPtrList > :: deleteMemoryPool() ;
     EasyStorage < std::set<SgSymbol*> > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgGlobalStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgDeclarationStatementPtrList > :: writeToFile(out) ;
     EasyStorage < std::set<SgSymbol*> > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgGlobalStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgDeclarationStatementPtrList > :: readFromFile(in) ;
     EasyStorage < std::set<SgSymbol*> > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 11702 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgBasicBlockStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 11715 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgBasicBlockStorageClass::pickOutIRNodeData ( SgBasicBlock* pointer ) 
   { 
     SgBasicBlock* source = (SgBasicBlock*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgStatementPtrList::iterator i_statements = source->p_statements.begin() ; 
     unsigned int tempListCountstatements = 0; 
     SgStatementPtrList::value_type *  tempListstatements = new SgStatementPtrList::value_type[ source->p_statements.size() ]; 
     for ( ; i_statements != source->p_statements.end(); ++i_statements ) 
        {
          tempListstatements[tempListCountstatements] = *i_statements;
          tempListCountstatements++; 
          (*i_statements) = (SgStatementPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_statements ) );
        }
     storageOf_statements.storeDataInEasyStorageClass(source->p_statements);
     tempListCountstatements = 0; 
     i_statements = source->p_statements.begin() ; 
     for ( ; i_statements != source->p_statements.end(); ++i_statements ) 
        {
          *i_statements = tempListstatements[tempListCountstatements] ;
          tempListCountstatements++; 
        }
      delete [] tempListstatements; 
     storageOf_asm_function_body.storeDataInEasyStorageClass(source->p_asm_function_body);
     storageOf_symbol_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_symbol_table );
     storageOf_type_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_table );
     storageOf_type_elaboration_list.storeDataInEasyStorageClass(source->p_type_elaboration_list);
     storageOf_hidden_type_list.storeDataInEasyStorageClass(source->p_hidden_type_list);
     storageOf_hidden_declaration_list.storeDataInEasyStorageClass(source->p_hidden_declaration_list);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgBasicBlockStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgStatementPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::set<SgSymbol*> > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgBasicBlockStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgStatementPtrList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < std::set<SgSymbol*> > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgBasicBlockStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgStatementPtrList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < std::set<SgSymbol*> > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgBasicBlockStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgStatementPtrList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < std::set<SgSymbol*> > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 11808 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgIfStmtStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 11821 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgIfStmtStorageClass::pickOutIRNodeData ( SgIfStmt* pointer ) 
   { 
     SgIfStmt* source = (SgIfStmt*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_conditional = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_conditional );
     storageOf_true_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_true_body );
     storageOf_false_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_false_body );
     storageOf_else_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_else_numeric_label );
     storageOf_string_label.storeDataInEasyStorageClass(source->p_string_label);
     storageOf_end_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_end_numeric_label );
     storageOf_has_end_statement =  source->p_has_end_statement ;
     storageOf_use_then_keyword =  source->p_use_then_keyword ;
     storageOf_is_else_if_statement =  source->p_is_else_if_statement ;
     storageOf_symbol_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_symbol_table );
     storageOf_type_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_table );
     storageOf_type_elaboration_list.storeDataInEasyStorageClass(source->p_type_elaboration_list);
     storageOf_hidden_type_list.storeDataInEasyStorageClass(source->p_hidden_type_list);
     storageOf_hidden_declaration_list.storeDataInEasyStorageClass(source->p_hidden_declaration_list);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgIfStmtStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::set<SgSymbol*> > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgIfStmtStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < std::set<SgSymbol*> > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgIfStmtStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < std::set<SgSymbol*> > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgIfStmtStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < std::set<SgSymbol*> > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 11900 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgForStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 11913 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgForStatementStorageClass::pickOutIRNodeData ( SgForStatement* pointer ) 
   { 
     SgForStatement* source = (SgForStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_for_init_stmt = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_for_init_stmt );
     storageOf_test = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_test );
     storageOf_increment = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_increment );
     storageOf_loop_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_loop_body );
     storageOf_else_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_else_body );
     storageOf_string_label.storeDataInEasyStorageClass(source->p_string_label);
     storageOf_symbol_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_symbol_table );
     storageOf_type_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_table );
     storageOf_type_elaboration_list.storeDataInEasyStorageClass(source->p_type_elaboration_list);
     storageOf_hidden_type_list.storeDataInEasyStorageClass(source->p_hidden_type_list);
     storageOf_hidden_declaration_list.storeDataInEasyStorageClass(source->p_hidden_declaration_list);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgForStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::set<SgSymbol*> > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgForStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < std::set<SgSymbol*> > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgForStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < std::set<SgSymbol*> > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgForStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < std::set<SgSymbol*> > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 11989 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgFunctionDefinitionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 12002 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgFunctionDefinitionStorageClass::pickOutIRNodeData ( SgFunctionDefinition* pointer ) 
   { 
     SgFunctionDefinition* source = (SgFunctionDefinition*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     storageOf_scope_number_list.storeDataInEasyStorageClass(source->p_scope_number_list);
     storageOf_symbol_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_symbol_table );
     storageOf_type_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_table );
     storageOf_type_elaboration_list.storeDataInEasyStorageClass(source->p_type_elaboration_list);
     storageOf_hidden_type_list.storeDataInEasyStorageClass(source->p_hidden_type_list);
     storageOf_hidden_declaration_list.storeDataInEasyStorageClass(source->p_hidden_declaration_list);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgFunctionDefinitionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::map<SgNode*,int> > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::set<SgSymbol*> > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgFunctionDefinitionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::map<SgNode*,int> > :: deleteMemoryPool() ;
     EasyStorage < std::set<SgSymbol*> > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgFunctionDefinitionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::map<SgNode*,int> > :: writeToFile(out) ;
     EasyStorage < std::set<SgSymbol*> > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgFunctionDefinitionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::map<SgNode*,int> > :: readFromFile(in) ;
     EasyStorage < std::set<SgSymbol*> > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 12074 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTemplateFunctionDefinitionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 12087 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgTemplateFunctionDefinitionStorageClass::pickOutIRNodeData ( SgTemplateFunctionDefinition* pointer ) 
   { 
     SgTemplateFunctionDefinition* source = (SgTemplateFunctionDefinition*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     storageOf_scope_number_list.storeDataInEasyStorageClass(source->p_scope_number_list);
     storageOf_symbol_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_symbol_table );
     storageOf_type_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_table );
     storageOf_type_elaboration_list.storeDataInEasyStorageClass(source->p_type_elaboration_list);
     storageOf_hidden_type_list.storeDataInEasyStorageClass(source->p_hidden_type_list);
     storageOf_hidden_declaration_list.storeDataInEasyStorageClass(source->p_hidden_declaration_list);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgTemplateFunctionDefinitionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::map<SgNode*,int> > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::set<SgSymbol*> > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTemplateFunctionDefinitionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::map<SgNode*,int> > :: deleteMemoryPool() ;
     EasyStorage < std::set<SgSymbol*> > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTemplateFunctionDefinitionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::map<SgNode*,int> > :: writeToFile(out) ;
     EasyStorage < std::set<SgSymbol*> > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTemplateFunctionDefinitionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::map<SgNode*,int> > :: readFromFile(in) ;
     EasyStorage < std::set<SgSymbol*> > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 12159 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgClassDefinitionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 12172 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgClassDefinitionStorageClass::pickOutIRNodeData ( SgClassDefinition* pointer ) 
   { 
     SgClassDefinition* source = (SgClassDefinition*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgDeclarationStatementPtrList::iterator i_members = source->p_members.begin() ; 
     unsigned int tempListCountmembers = 0; 
     SgDeclarationStatementPtrList::value_type *  tempListmembers = new SgDeclarationStatementPtrList::value_type[ source->p_members.size() ]; 
     for ( ; i_members != source->p_members.end(); ++i_members ) 
        {
          tempListmembers[tempListCountmembers] = *i_members;
          tempListCountmembers++; 
          (*i_members) = (SgDeclarationStatementPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_members ) );
        }
     storageOf_members.storeDataInEasyStorageClass(source->p_members);
     tempListCountmembers = 0; 
     i_members = source->p_members.begin() ; 
     for ( ; i_members != source->p_members.end(); ++i_members ) 
        {
          *i_members = tempListmembers[tempListCountmembers] ;
          tempListCountmembers++; 
        }
      delete [] tempListmembers; 
     SgBaseClassPtrList::iterator i_inheritances = source->p_inheritances.begin() ; 
     unsigned int tempListCountinheritances = 0; 
     SgBaseClassPtrList::value_type *  tempListinheritances = new SgBaseClassPtrList::value_type[ source->p_inheritances.size() ]; 
     for ( ; i_inheritances != source->p_inheritances.end(); ++i_inheritances ) 
        {
          tempListinheritances[tempListCountinheritances] = *i_inheritances;
          tempListCountinheritances++; 
          (*i_inheritances) = (SgBaseClassPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_inheritances ) );
        }
     storageOf_inheritances.storeDataInEasyStorageClass(source->p_inheritances);
     tempListCountinheritances = 0; 
     i_inheritances = source->p_inheritances.begin() ; 
     for ( ; i_inheritances != source->p_inheritances.end(); ++i_inheritances ) 
        {
          *i_inheritances = tempListinheritances[tempListCountinheritances] ;
          tempListCountinheritances++; 
        }
      delete [] tempListinheritances; 
     storageOf_packingAlignment =  source->p_packingAlignment ;
     storageOf_isSequence =  source->p_isSequence ;
     storageOf_isPrivate =  source->p_isPrivate ;
     storageOf_isAbstract =  source->p_isAbstract ;
     storageOf_symbol_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_symbol_table );
     storageOf_type_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_table );
     storageOf_type_elaboration_list.storeDataInEasyStorageClass(source->p_type_elaboration_list);
     storageOf_hidden_type_list.storeDataInEasyStorageClass(source->p_hidden_type_list);
     storageOf_hidden_declaration_list.storeDataInEasyStorageClass(source->p_hidden_declaration_list);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgClassDefinitionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgDeclarationStatementPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgBaseClassPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::set<SgSymbol*> > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgClassDefinitionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgDeclarationStatementPtrList > :: deleteMemoryPool() ;
     EasyStorage < SgBaseClassPtrList > :: deleteMemoryPool() ;
     EasyStorage < std::set<SgSymbol*> > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgClassDefinitionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgDeclarationStatementPtrList > :: writeToFile(out) ;
     EasyStorage < SgBaseClassPtrList > :: writeToFile(out) ;
     EasyStorage < std::set<SgSymbol*> > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgClassDefinitionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgDeclarationStatementPtrList > :: readFromFile(in) ;
     EasyStorage < SgBaseClassPtrList > :: readFromFile(in) ;
     EasyStorage < std::set<SgSymbol*> > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 12286 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTemplateInstantiationDefnStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 12299 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgTemplateInstantiationDefnStorageClass::pickOutIRNodeData ( SgTemplateInstantiationDefn* pointer ) 
   { 
     SgTemplateInstantiationDefn* source = (SgTemplateInstantiationDefn*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgDeclarationStatementPtrList::iterator i_members = source->p_members.begin() ; 
     unsigned int tempListCountmembers = 0; 
     SgDeclarationStatementPtrList::value_type *  tempListmembers = new SgDeclarationStatementPtrList::value_type[ source->p_members.size() ]; 
     for ( ; i_members != source->p_members.end(); ++i_members ) 
        {
          tempListmembers[tempListCountmembers] = *i_members;
          tempListCountmembers++; 
          (*i_members) = (SgDeclarationStatementPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_members ) );
        }
     storageOf_members.storeDataInEasyStorageClass(source->p_members);
     tempListCountmembers = 0; 
     i_members = source->p_members.begin() ; 
     for ( ; i_members != source->p_members.end(); ++i_members ) 
        {
          *i_members = tempListmembers[tempListCountmembers] ;
          tempListCountmembers++; 
        }
      delete [] tempListmembers; 
     SgBaseClassPtrList::iterator i_inheritances = source->p_inheritances.begin() ; 
     unsigned int tempListCountinheritances = 0; 
     SgBaseClassPtrList::value_type *  tempListinheritances = new SgBaseClassPtrList::value_type[ source->p_inheritances.size() ]; 
     for ( ; i_inheritances != source->p_inheritances.end(); ++i_inheritances ) 
        {
          tempListinheritances[tempListCountinheritances] = *i_inheritances;
          tempListCountinheritances++; 
          (*i_inheritances) = (SgBaseClassPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_inheritances ) );
        }
     storageOf_inheritances.storeDataInEasyStorageClass(source->p_inheritances);
     tempListCountinheritances = 0; 
     i_inheritances = source->p_inheritances.begin() ; 
     for ( ; i_inheritances != source->p_inheritances.end(); ++i_inheritances ) 
        {
          *i_inheritances = tempListinheritances[tempListCountinheritances] ;
          tempListCountinheritances++; 
        }
      delete [] tempListinheritances; 
     storageOf_packingAlignment =  source->p_packingAlignment ;
     storageOf_isSequence =  source->p_isSequence ;
     storageOf_isPrivate =  source->p_isPrivate ;
     storageOf_isAbstract =  source->p_isAbstract ;
     storageOf_symbol_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_symbol_table );
     storageOf_type_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_table );
     storageOf_type_elaboration_list.storeDataInEasyStorageClass(source->p_type_elaboration_list);
     storageOf_hidden_type_list.storeDataInEasyStorageClass(source->p_hidden_type_list);
     storageOf_hidden_declaration_list.storeDataInEasyStorageClass(source->p_hidden_declaration_list);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgTemplateInstantiationDefnStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgDeclarationStatementPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgBaseClassPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::set<SgSymbol*> > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTemplateInstantiationDefnStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgDeclarationStatementPtrList > :: deleteMemoryPool() ;
     EasyStorage < SgBaseClassPtrList > :: deleteMemoryPool() ;
     EasyStorage < std::set<SgSymbol*> > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTemplateInstantiationDefnStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgDeclarationStatementPtrList > :: writeToFile(out) ;
     EasyStorage < SgBaseClassPtrList > :: writeToFile(out) ;
     EasyStorage < std::set<SgSymbol*> > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTemplateInstantiationDefnStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgDeclarationStatementPtrList > :: readFromFile(in) ;
     EasyStorage < SgBaseClassPtrList > :: readFromFile(in) ;
     EasyStorage < std::set<SgSymbol*> > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 12413 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTemplateClassDefinitionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 12426 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgTemplateClassDefinitionStorageClass::pickOutIRNodeData ( SgTemplateClassDefinition* pointer ) 
   { 
     SgTemplateClassDefinition* source = (SgTemplateClassDefinition*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgDeclarationStatementPtrList::iterator i_members = source->p_members.begin() ; 
     unsigned int tempListCountmembers = 0; 
     SgDeclarationStatementPtrList::value_type *  tempListmembers = new SgDeclarationStatementPtrList::value_type[ source->p_members.size() ]; 
     for ( ; i_members != source->p_members.end(); ++i_members ) 
        {
          tempListmembers[tempListCountmembers] = *i_members;
          tempListCountmembers++; 
          (*i_members) = (SgDeclarationStatementPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_members ) );
        }
     storageOf_members.storeDataInEasyStorageClass(source->p_members);
     tempListCountmembers = 0; 
     i_members = source->p_members.begin() ; 
     for ( ; i_members != source->p_members.end(); ++i_members ) 
        {
          *i_members = tempListmembers[tempListCountmembers] ;
          tempListCountmembers++; 
        }
      delete [] tempListmembers; 
     SgBaseClassPtrList::iterator i_inheritances = source->p_inheritances.begin() ; 
     unsigned int tempListCountinheritances = 0; 
     SgBaseClassPtrList::value_type *  tempListinheritances = new SgBaseClassPtrList::value_type[ source->p_inheritances.size() ]; 
     for ( ; i_inheritances != source->p_inheritances.end(); ++i_inheritances ) 
        {
          tempListinheritances[tempListCountinheritances] = *i_inheritances;
          tempListCountinheritances++; 
          (*i_inheritances) = (SgBaseClassPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_inheritances ) );
        }
     storageOf_inheritances.storeDataInEasyStorageClass(source->p_inheritances);
     tempListCountinheritances = 0; 
     i_inheritances = source->p_inheritances.begin() ; 
     for ( ; i_inheritances != source->p_inheritances.end(); ++i_inheritances ) 
        {
          *i_inheritances = tempListinheritances[tempListCountinheritances] ;
          tempListCountinheritances++; 
        }
      delete [] tempListinheritances; 
     storageOf_packingAlignment =  source->p_packingAlignment ;
     storageOf_isSequence =  source->p_isSequence ;
     storageOf_isPrivate =  source->p_isPrivate ;
     storageOf_isAbstract =  source->p_isAbstract ;
     storageOf_symbol_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_symbol_table );
     storageOf_type_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_table );
     storageOf_type_elaboration_list.storeDataInEasyStorageClass(source->p_type_elaboration_list);
     storageOf_hidden_type_list.storeDataInEasyStorageClass(source->p_hidden_type_list);
     storageOf_hidden_declaration_list.storeDataInEasyStorageClass(source->p_hidden_declaration_list);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgTemplateClassDefinitionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgDeclarationStatementPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgBaseClassPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::set<SgSymbol*> > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTemplateClassDefinitionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgDeclarationStatementPtrList > :: deleteMemoryPool() ;
     EasyStorage < SgBaseClassPtrList > :: deleteMemoryPool() ;
     EasyStorage < std::set<SgSymbol*> > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTemplateClassDefinitionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgDeclarationStatementPtrList > :: writeToFile(out) ;
     EasyStorage < SgBaseClassPtrList > :: writeToFile(out) ;
     EasyStorage < std::set<SgSymbol*> > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTemplateClassDefinitionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgDeclarationStatementPtrList > :: readFromFile(in) ;
     EasyStorage < SgBaseClassPtrList > :: readFromFile(in) ;
     EasyStorage < std::set<SgSymbol*> > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 12540 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgWhileStmtStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 12553 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgWhileStmtStorageClass::pickOutIRNodeData ( SgWhileStmt* pointer ) 
   { 
     SgWhileStmt* source = (SgWhileStmt*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_condition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_condition );
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     storageOf_else_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_else_body );
     storageOf_end_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_end_numeric_label );
     storageOf_string_label.storeDataInEasyStorageClass(source->p_string_label);
     storageOf_has_end_statement =  source->p_has_end_statement ;
     storageOf_symbol_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_symbol_table );
     storageOf_type_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_table );
     storageOf_type_elaboration_list.storeDataInEasyStorageClass(source->p_type_elaboration_list);
     storageOf_hidden_type_list.storeDataInEasyStorageClass(source->p_hidden_type_list);
     storageOf_hidden_declaration_list.storeDataInEasyStorageClass(source->p_hidden_declaration_list);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgWhileStmtStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::set<SgSymbol*> > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgWhileStmtStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < std::set<SgSymbol*> > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgWhileStmtStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < std::set<SgSymbol*> > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgWhileStmtStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < std::set<SgSymbol*> > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 12629 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgDoWhileStmtStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 12642 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgDoWhileStmtStorageClass::pickOutIRNodeData ( SgDoWhileStmt* pointer ) 
   { 
     SgDoWhileStmt* source = (SgDoWhileStmt*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     storageOf_condition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_condition );
     storageOf_symbol_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_symbol_table );
     storageOf_type_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_table );
     storageOf_type_elaboration_list.storeDataInEasyStorageClass(source->p_type_elaboration_list);
     storageOf_hidden_type_list.storeDataInEasyStorageClass(source->p_hidden_type_list);
     storageOf_hidden_declaration_list.storeDataInEasyStorageClass(source->p_hidden_declaration_list);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgDoWhileStmtStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::set<SgSymbol*> > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgDoWhileStmtStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::set<SgSymbol*> > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgDoWhileStmtStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::set<SgSymbol*> > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgDoWhileStmtStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::set<SgSymbol*> > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 12710 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgSwitchStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 12723 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgSwitchStatementStorageClass::pickOutIRNodeData ( SgSwitchStatement* pointer ) 
   { 
     SgSwitchStatement* source = (SgSwitchStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_item_selector = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_item_selector );
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     storageOf_end_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_end_numeric_label );
     storageOf_string_label.storeDataInEasyStorageClass(source->p_string_label);
     storageOf_symbol_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_symbol_table );
     storageOf_type_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_table );
     storageOf_type_elaboration_list.storeDataInEasyStorageClass(source->p_type_elaboration_list);
     storageOf_hidden_type_list.storeDataInEasyStorageClass(source->p_hidden_type_list);
     storageOf_hidden_declaration_list.storeDataInEasyStorageClass(source->p_hidden_declaration_list);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgSwitchStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::set<SgSymbol*> > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgSwitchStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < std::set<SgSymbol*> > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgSwitchStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < std::set<SgSymbol*> > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgSwitchStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < std::set<SgSymbol*> > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 12797 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgCatchOptionStmtStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 12810 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgCatchOptionStmtStorageClass::pickOutIRNodeData ( SgCatchOptionStmt* pointer ) 
   { 
     SgCatchOptionStmt* source = (SgCatchOptionStmt*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_condition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_condition );
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     storageOf_trystmt = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_trystmt );
     storageOf_symbol_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_symbol_table );
     storageOf_type_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_table );
     storageOf_type_elaboration_list.storeDataInEasyStorageClass(source->p_type_elaboration_list);
     storageOf_hidden_type_list.storeDataInEasyStorageClass(source->p_hidden_type_list);
     storageOf_hidden_declaration_list.storeDataInEasyStorageClass(source->p_hidden_declaration_list);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgCatchOptionStmtStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::set<SgSymbol*> > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgCatchOptionStmtStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::set<SgSymbol*> > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgCatchOptionStmtStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::set<SgSymbol*> > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgCatchOptionStmtStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::set<SgSymbol*> > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 12879 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgNamespaceDefinitionStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 12892 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgNamespaceDefinitionStatementStorageClass::pickOutIRNodeData ( SgNamespaceDefinitionStatement* pointer ) 
   { 
     SgNamespaceDefinitionStatement* source = (SgNamespaceDefinitionStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgDeclarationStatementPtrList::iterator i_declarations = source->p_declarations.begin() ; 
     unsigned int tempListCountdeclarations = 0; 
     SgDeclarationStatementPtrList::value_type *  tempListdeclarations = new SgDeclarationStatementPtrList::value_type[ source->p_declarations.size() ]; 
     for ( ; i_declarations != source->p_declarations.end(); ++i_declarations ) 
        {
          tempListdeclarations[tempListCountdeclarations] = *i_declarations;
          tempListCountdeclarations++; 
          (*i_declarations) = (SgDeclarationStatementPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_declarations ) );
        }
     storageOf_declarations.storeDataInEasyStorageClass(source->p_declarations);
     tempListCountdeclarations = 0; 
     i_declarations = source->p_declarations.begin() ; 
     for ( ; i_declarations != source->p_declarations.end(); ++i_declarations ) 
        {
          *i_declarations = tempListdeclarations[tempListCountdeclarations] ;
          tempListCountdeclarations++; 
        }
      delete [] tempListdeclarations; 
     storageOf_namespaceDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_namespaceDeclaration );
     storageOf_previousNamepaceDefinition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_previousNamepaceDefinition );
     storageOf_nextNamepaceDefinition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_nextNamepaceDefinition );
     storageOf_symbol_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_symbol_table );
     storageOf_type_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_table );
     storageOf_type_elaboration_list.storeDataInEasyStorageClass(source->p_type_elaboration_list);
     storageOf_hidden_type_list.storeDataInEasyStorageClass(source->p_hidden_type_list);
     storageOf_hidden_declaration_list.storeDataInEasyStorageClass(source->p_hidden_declaration_list);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgNamespaceDefinitionStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgDeclarationStatementPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::set<SgSymbol*> > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgNamespaceDefinitionStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgDeclarationStatementPtrList > :: deleteMemoryPool() ;
     EasyStorage < std::set<SgSymbol*> > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgNamespaceDefinitionStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgDeclarationStatementPtrList > :: writeToFile(out) ;
     EasyStorage < std::set<SgSymbol*> > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgNamespaceDefinitionStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgDeclarationStatementPtrList > :: readFromFile(in) ;
     EasyStorage < std::set<SgSymbol*> > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 12983 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgBlockDataStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 12996 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgBlockDataStatementStorageClass::pickOutIRNodeData ( SgBlockDataStatement* pointer ) 
   { 
     SgBlockDataStatement* source = (SgBlockDataStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     storageOf_symbol_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_symbol_table );
     storageOf_type_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_table );
     storageOf_type_elaboration_list.storeDataInEasyStorageClass(source->p_type_elaboration_list);
     storageOf_hidden_type_list.storeDataInEasyStorageClass(source->p_hidden_type_list);
     storageOf_hidden_declaration_list.storeDataInEasyStorageClass(source->p_hidden_declaration_list);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgBlockDataStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::set<SgSymbol*> > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgBlockDataStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::set<SgSymbol*> > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgBlockDataStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::set<SgSymbol*> > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgBlockDataStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::set<SgSymbol*> > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 13063 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAssociateStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 13076 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAssociateStatementStorageClass::pickOutIRNodeData ( SgAssociateStatement* pointer ) 
   { 
     SgAssociateStatement* source = (SgAssociateStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_variable_declaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_variable_declaration );
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     storageOf_symbol_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_symbol_table );
     storageOf_type_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_table );
     storageOf_type_elaboration_list.storeDataInEasyStorageClass(source->p_type_elaboration_list);
     storageOf_hidden_type_list.storeDataInEasyStorageClass(source->p_hidden_type_list);
     storageOf_hidden_declaration_list.storeDataInEasyStorageClass(source->p_hidden_declaration_list);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAssociateStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::set<SgSymbol*> > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAssociateStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::set<SgSymbol*> > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAssociateStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::set<SgSymbol*> > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAssociateStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::set<SgSymbol*> > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 13144 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgFortranDoStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 13157 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgFortranDoStorageClass::pickOutIRNodeData ( SgFortranDo* pointer ) 
   { 
     SgFortranDo* source = (SgFortranDo*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_initialization = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_initialization );
     storageOf_bound = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_bound );
     storageOf_increment = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_increment );
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     storageOf_end_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_end_numeric_label );
     storageOf_string_label.storeDataInEasyStorageClass(source->p_string_label);
     storageOf_old_style =  source->p_old_style ;
     storageOf_has_end_statement =  source->p_has_end_statement ;
     storageOf_symbol_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_symbol_table );
     storageOf_type_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_table );
     storageOf_type_elaboration_list.storeDataInEasyStorageClass(source->p_type_elaboration_list);
     storageOf_hidden_type_list.storeDataInEasyStorageClass(source->p_hidden_type_list);
     storageOf_hidden_declaration_list.storeDataInEasyStorageClass(source->p_hidden_declaration_list);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgFortranDoStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::set<SgSymbol*> > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgFortranDoStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < std::set<SgSymbol*> > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgFortranDoStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < std::set<SgSymbol*> > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgFortranDoStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < std::set<SgSymbol*> > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 13235 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgFortranNonblockedDoStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 13248 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgFortranNonblockedDoStorageClass::pickOutIRNodeData ( SgFortranNonblockedDo* pointer ) 
   { 
     SgFortranNonblockedDo* source = (SgFortranNonblockedDo*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_end_statement = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_end_statement );
     storageOf_initialization = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_initialization );
     storageOf_bound = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_bound );
     storageOf_increment = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_increment );
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     storageOf_end_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_end_numeric_label );
     storageOf_string_label.storeDataInEasyStorageClass(source->p_string_label);
     storageOf_old_style =  source->p_old_style ;
     storageOf_has_end_statement =  source->p_has_end_statement ;
     storageOf_symbol_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_symbol_table );
     storageOf_type_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_table );
     storageOf_type_elaboration_list.storeDataInEasyStorageClass(source->p_type_elaboration_list);
     storageOf_hidden_type_list.storeDataInEasyStorageClass(source->p_hidden_type_list);
     storageOf_hidden_declaration_list.storeDataInEasyStorageClass(source->p_hidden_declaration_list);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgFortranNonblockedDoStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::set<SgSymbol*> > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgFortranNonblockedDoStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < std::set<SgSymbol*> > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgFortranNonblockedDoStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < std::set<SgSymbol*> > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgFortranNonblockedDoStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < std::set<SgSymbol*> > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 13327 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgForAllStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 13340 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgForAllStatementStorageClass::pickOutIRNodeData ( SgForAllStatement* pointer ) 
   { 
     SgForAllStatement* source = (SgForAllStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_forall_header = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_forall_header );
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     storageOf_has_end_statement =  source->p_has_end_statement ;
     storageOf_string_label.storeDataInEasyStorageClass(source->p_string_label);
     storageOf_end_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_end_numeric_label );
     storageOf_symbol_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_symbol_table );
     storageOf_type_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_table );
     storageOf_type_elaboration_list.storeDataInEasyStorageClass(source->p_type_elaboration_list);
     storageOf_hidden_type_list.storeDataInEasyStorageClass(source->p_hidden_type_list);
     storageOf_hidden_declaration_list.storeDataInEasyStorageClass(source->p_hidden_declaration_list);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgForAllStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::set<SgSymbol*> > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgForAllStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < std::set<SgSymbol*> > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgForAllStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < std::set<SgSymbol*> > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgForAllStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < std::set<SgSymbol*> > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 13415 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgUpcForAllStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 13428 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgUpcForAllStatementStorageClass::pickOutIRNodeData ( SgUpcForAllStatement* pointer ) 
   { 
     SgUpcForAllStatement* source = (SgUpcForAllStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_for_init_stmt = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_for_init_stmt );
     storageOf_test = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_test );
     storageOf_increment = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_increment );
     storageOf_affinity = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_affinity );
     storageOf_loop_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_loop_body );
     storageOf_symbol_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_symbol_table );
     storageOf_type_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_table );
     storageOf_type_elaboration_list.storeDataInEasyStorageClass(source->p_type_elaboration_list);
     storageOf_hidden_type_list.storeDataInEasyStorageClass(source->p_hidden_type_list);
     storageOf_hidden_declaration_list.storeDataInEasyStorageClass(source->p_hidden_declaration_list);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgUpcForAllStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::set<SgSymbol*> > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgUpcForAllStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::set<SgSymbol*> > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgUpcForAllStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::set<SgSymbol*> > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgUpcForAllStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::set<SgSymbol*> > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 13499 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgCAFWithTeamStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 13512 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgCAFWithTeamStatementStorageClass::pickOutIRNodeData ( SgCAFWithTeamStatement* pointer ) 
   { 
     SgCAFWithTeamStatement* source = (SgCAFWithTeamStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_teamId = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_teamId );
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     storageOf_endHasTeamId =  source->p_endHasTeamId ;
     storageOf_symbol_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_symbol_table );
     storageOf_type_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_table );
     storageOf_type_elaboration_list.storeDataInEasyStorageClass(source->p_type_elaboration_list);
     storageOf_hidden_type_list.storeDataInEasyStorageClass(source->p_hidden_type_list);
     storageOf_hidden_declaration_list.storeDataInEasyStorageClass(source->p_hidden_declaration_list);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgCAFWithTeamStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::set<SgSymbol*> > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgCAFWithTeamStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::set<SgSymbol*> > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgCAFWithTeamStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::set<SgSymbol*> > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgCAFWithTeamStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::set<SgSymbol*> > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 13581 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgJavaForEachStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 13594 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgJavaForEachStatementStorageClass::pickOutIRNodeData ( SgJavaForEachStatement* pointer ) 
   { 
     SgJavaForEachStatement* source = (SgJavaForEachStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_element = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_element );
     storageOf_collection = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_collection );
     storageOf_loop_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_loop_body );
     storageOf_symbol_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_symbol_table );
     storageOf_type_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_table );
     storageOf_type_elaboration_list.storeDataInEasyStorageClass(source->p_type_elaboration_list);
     storageOf_hidden_type_list.storeDataInEasyStorageClass(source->p_hidden_type_list);
     storageOf_hidden_declaration_list.storeDataInEasyStorageClass(source->p_hidden_declaration_list);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgJavaForEachStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::set<SgSymbol*> > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgJavaForEachStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::set<SgSymbol*> > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgJavaForEachStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::set<SgSymbol*> > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgJavaForEachStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::set<SgSymbol*> > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 13663 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgJavaLabelStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 13676 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgJavaLabelStatementStorageClass::pickOutIRNodeData ( SgJavaLabelStatement* pointer ) 
   { 
     SgJavaLabelStatement* source = (SgJavaLabelStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_label.pickOutIRNodeData( &(source->p_label) );
     storageOf_statement = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_statement );
     storageOf_symbol_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_symbol_table );
     storageOf_type_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_table );
     storageOf_type_elaboration_list.storeDataInEasyStorageClass(source->p_type_elaboration_list);
     storageOf_hidden_type_list.storeDataInEasyStorageClass(source->p_hidden_type_list);
     storageOf_hidden_declaration_list.storeDataInEasyStorageClass(source->p_hidden_declaration_list);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgJavaLabelStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < std::set<SgSymbol*> > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgJavaLabelStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < std::set<SgSymbol*> > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgJavaLabelStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < std::set<SgSymbol*> > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgJavaLabelStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < std::set<SgSymbol*> > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 13748 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgFunctionTypeTableStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 13761 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgFunctionTypeTableStorageClass::pickOutIRNodeData ( SgFunctionTypeTable* pointer ) 
   { 
     SgFunctionTypeTable* source = (SgFunctionTypeTable*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_function_type_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_function_type_table );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgFunctionTypeTableStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgFunctionTypeTableStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgFunctionTypeTableStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgFunctionTypeTableStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 13819 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgDeclarationStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 13832 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgDeclarationStatementStorageClass::pickOutIRNodeData ( SgDeclarationStatement* pointer ) 
   { 
     SgDeclarationStatement* source = (SgDeclarationStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgDeclarationStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgDeclarationStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgDeclarationStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgDeclarationStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 13929 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgFunctionParameterListStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 13942 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgFunctionParameterListStorageClass::pickOutIRNodeData ( SgFunctionParameterList* pointer ) 
   { 
     SgFunctionParameterList* source = (SgFunctionParameterList*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgInitializedNamePtrList::iterator i_args = source->p_args.begin() ; 
     unsigned int tempListCountargs = 0; 
     SgInitializedNamePtrList::value_type *  tempListargs = new SgInitializedNamePtrList::value_type[ source->p_args.size() ]; 
     for ( ; i_args != source->p_args.end(); ++i_args ) 
        {
          tempListargs[tempListCountargs] = *i_args;
          tempListCountargs++; 
          (*i_args) = (SgInitializedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_args ) );
        }
     storageOf_args.storeDataInEasyStorageClass(source->p_args);
     tempListCountargs = 0; 
     i_args = source->p_args.begin() ; 
     for ( ; i_args != source->p_args.end(); ++i_args ) 
        {
          *i_args = tempListargs[tempListCountargs] ;
          tempListCountargs++; 
        }
      delete [] tempListargs; 
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgFunctionParameterListStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgInitializedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgFunctionParameterListStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgInitializedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgFunctionParameterListStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgInitializedNamePtrList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgFunctionParameterListStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgInitializedNamePtrList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 14061 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgVariableDeclarationStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 14074 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgVariableDeclarationStorageClass::pickOutIRNodeData ( SgVariableDeclaration* pointer ) 
   { 
     SgVariableDeclaration* source = (SgVariableDeclaration*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_baseTypeDefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_baseTypeDefiningDeclaration );
     SgInitializedNamePtrList::iterator i_variables = source->p_variables.begin() ; 
     unsigned int tempListCountvariables = 0; 
     SgInitializedNamePtrList::value_type *  tempListvariables = new SgInitializedNamePtrList::value_type[ source->p_variables.size() ]; 
     for ( ; i_variables != source->p_variables.end(); ++i_variables ) 
        {
          tempListvariables[tempListCountvariables] = *i_variables;
          tempListCountvariables++; 
          (*i_variables) = (SgInitializedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_variables ) );
        }
     storageOf_variables.storeDataInEasyStorageClass(source->p_variables);
     tempListCountvariables = 0; 
     i_variables = source->p_variables.begin() ; 
     for ( ; i_variables != source->p_variables.end(); ++i_variables ) 
        {
          *i_variables = tempListvariables[tempListCountvariables] ;
          tempListCountvariables++; 
        }
      delete [] tempListvariables; 
     storageOf_variableDeclarationContainsBaseTypeDefiningDeclaration =  source->p_variableDeclarationContainsBaseTypeDefiningDeclaration ;
     storageOf_specialization =  source->p_specialization ;
     storageOf_requiresGlobalNameQualificationOnType =  source->p_requiresGlobalNameQualificationOnType ;
     storageOf_gnu_extension_section.storeDataInEasyStorageClass(source->p_gnu_extension_section);
     storageOf_gnu_extension_alias.storeDataInEasyStorageClass(source->p_gnu_extension_alias);
     storageOf_gnu_extension_initialization_priority =  source->p_gnu_extension_initialization_priority ;
     storageOf_gnu_extension_alignment =  source->p_gnu_extension_alignment ;
     storageOf_gnu_extension_visability =  source->p_gnu_extension_visability ;
     storageOf_gnu_extension_declaration_attribute =  source->p_gnu_extension_declaration_attribute ;
     storageOf_name_qualification_length =  source->p_name_qualification_length ;
     storageOf_type_elaboration_required =  source->p_type_elaboration_required ;
     storageOf_global_qualification_required =  source->p_global_qualification_required ;
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgVariableDeclarationStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgInitializedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgVariableDeclarationStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgInitializedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgVariableDeclarationStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgInitializedNamePtrList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgVariableDeclarationStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgInitializedNamePtrList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 14206 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgVariableDefinitionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 14219 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgVariableDefinitionStorageClass::pickOutIRNodeData ( SgVariableDefinition* pointer ) 
   { 
     SgVariableDefinition* source = (SgVariableDefinition*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_vardefn = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_vardefn );
     storageOf_bitfield = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_bitfield );
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgVariableDefinitionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgVariableDefinitionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgVariableDefinitionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgVariableDefinitionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 14318 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgClinkageDeclarationStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 14331 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgClinkageDeclarationStatementStorageClass::pickOutIRNodeData ( SgClinkageDeclarationStatement* pointer ) 
   { 
     SgClinkageDeclarationStatement* source = (SgClinkageDeclarationStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_languageSpecifier.storeDataInEasyStorageClass(source->p_languageSpecifier);
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgClinkageDeclarationStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgClinkageDeclarationStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgClinkageDeclarationStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgClinkageDeclarationStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 14429 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgClinkageStartStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 14442 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgClinkageStartStatementStorageClass::pickOutIRNodeData ( SgClinkageStartStatement* pointer ) 
   { 
     SgClinkageStartStatement* source = (SgClinkageStartStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_languageSpecifier.storeDataInEasyStorageClass(source->p_languageSpecifier);
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgClinkageStartStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgClinkageStartStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgClinkageStartStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgClinkageStartStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 14540 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgClinkageEndStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 14553 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgClinkageEndStatementStorageClass::pickOutIRNodeData ( SgClinkageEndStatement* pointer ) 
   { 
     SgClinkageEndStatement* source = (SgClinkageEndStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_languageSpecifier.storeDataInEasyStorageClass(source->p_languageSpecifier);
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgClinkageEndStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgClinkageEndStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgClinkageEndStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgClinkageEndStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 14651 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgEnumDeclarationStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 14664 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgEnumDeclarationStorageClass::pickOutIRNodeData ( SgEnumDeclaration* pointer ) 
   { 
     SgEnumDeclaration* source = (SgEnumDeclaration*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_name.pickOutIRNodeData( &(source->p_name) );
     storageOf_embedded =  source->p_embedded ;
     storageOf_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type );
     SgInitializedNamePtrList::iterator i_enumerators = source->p_enumerators.begin() ; 
     unsigned int tempListCountenumerators = 0; 
     SgInitializedNamePtrList::value_type *  tempListenumerators = new SgInitializedNamePtrList::value_type[ source->p_enumerators.size() ]; 
     for ( ; i_enumerators != source->p_enumerators.end(); ++i_enumerators ) 
        {
          tempListenumerators[tempListCountenumerators] = *i_enumerators;
          tempListCountenumerators++; 
          (*i_enumerators) = (SgInitializedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_enumerators ) );
        }
     storageOf_enumerators.storeDataInEasyStorageClass(source->p_enumerators);
     tempListCountenumerators = 0; 
     i_enumerators = source->p_enumerators.begin() ; 
     for ( ; i_enumerators != source->p_enumerators.end(); ++i_enumerators ) 
        {
          *i_enumerators = tempListenumerators[tempListCountenumerators] ;
          tempListCountenumerators++; 
        }
      delete [] tempListenumerators; 
     storageOf_scope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_scope );
     storageOf_isUnNamed =  source->p_isUnNamed ;
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgEnumDeclarationStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgInitializedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgEnumDeclarationStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgInitializedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgEnumDeclarationStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgInitializedNamePtrList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgEnumDeclarationStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgInitializedNamePtrList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 14792 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmStmtStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 14805 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmStmtStorageClass::pickOutIRNodeData ( SgAsmStmt* pointer ) 
   { 
     SgAsmStmt* source = (SgAsmStmt*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_assemblyCode.storeDataInEasyStorageClass(source->p_assemblyCode);
     storageOf_useGnuExtendedFormat =  source->p_useGnuExtendedFormat ;
     SgExpressionPtrList::iterator i_operands = source->p_operands.begin() ; 
     unsigned int tempListCountoperands = 0; 
     SgExpressionPtrList::value_type *  tempListoperands = new SgExpressionPtrList::value_type[ source->p_operands.size() ]; 
     for ( ; i_operands != source->p_operands.end(); ++i_operands ) 
        {
          tempListoperands[tempListCountoperands] = *i_operands;
          tempListCountoperands++; 
          (*i_operands) = (SgExpressionPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_operands ) );
        }
     storageOf_operands.storeDataInEasyStorageClass(source->p_operands);
     tempListCountoperands = 0; 
     i_operands = source->p_operands.begin() ; 
     for ( ; i_operands != source->p_operands.end(); ++i_operands ) 
        {
          *i_operands = tempListoperands[tempListCountoperands] ;
          tempListCountoperands++; 
        }
      delete [] tempListoperands; 
     storageOf_clobberRegisterList.storeDataInEasyStorageClass(source->p_clobberRegisterList);
     storageOf_isVolatile =  source->p_isVolatile ;
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmStmtStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgExpressionPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgAsmStmt::AsmRegisterNameList > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmStmtStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < SgExpressionPtrList > :: deleteMemoryPool() ;
     EasyStorage < SgAsmStmt::AsmRegisterNameList > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmStmtStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < SgExpressionPtrList > :: writeToFile(out) ;
     EasyStorage < SgAsmStmt::AsmRegisterNameList > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmStmtStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < SgExpressionPtrList > :: readFromFile(in) ;
     EasyStorage < SgAsmStmt::AsmRegisterNameList > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 14932 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAttributeSpecificationStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 14945 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAttributeSpecificationStatementStorageClass::pickOutIRNodeData ( SgAttributeSpecificationStatement* pointer ) 
   { 
     SgAttributeSpecificationStatement* source = (SgAttributeSpecificationStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_name_list.storeDataInEasyStorageClass(source->p_name_list);
     storageOf_attribute_kind =  source->p_attribute_kind ;
     storageOf_intent =  source->p_intent ;
     storageOf_parameter_list = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parameter_list );
     SgDataStatementGroupPtrList::iterator i_data_statement_group_list = source->p_data_statement_group_list.begin() ; 
     unsigned int tempListCountdata_statement_group_list = 0; 
     SgDataStatementGroupPtrList::value_type *  tempListdata_statement_group_list = new SgDataStatementGroupPtrList::value_type[ source->p_data_statement_group_list.size() ]; 
     for ( ; i_data_statement_group_list != source->p_data_statement_group_list.end(); ++i_data_statement_group_list ) 
        {
          tempListdata_statement_group_list[tempListCountdata_statement_group_list] = *i_data_statement_group_list;
          tempListCountdata_statement_group_list++; 
          (*i_data_statement_group_list) = (SgDataStatementGroupPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_data_statement_group_list ) );
        }
     storageOf_data_statement_group_list.storeDataInEasyStorageClass(source->p_data_statement_group_list);
     tempListCountdata_statement_group_list = 0; 
     i_data_statement_group_list = source->p_data_statement_group_list.begin() ; 
     for ( ; i_data_statement_group_list != source->p_data_statement_group_list.end(); ++i_data_statement_group_list ) 
        {
          *i_data_statement_group_list = tempListdata_statement_group_list[tempListCountdata_statement_group_list] ;
          tempListCountdata_statement_group_list++; 
        }
      delete [] tempListdata_statement_group_list; 
     storageOf_bind_list = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_bind_list );
     SgDimensionObjectPtrList::iterator i_dimension_object_list = source->p_dimension_object_list.begin() ; 
     unsigned int tempListCountdimension_object_list = 0; 
     SgDimensionObjectPtrList::value_type *  tempListdimension_object_list = new SgDimensionObjectPtrList::value_type[ source->p_dimension_object_list.size() ]; 
     for ( ; i_dimension_object_list != source->p_dimension_object_list.end(); ++i_dimension_object_list ) 
        {
          tempListdimension_object_list[tempListCountdimension_object_list] = *i_dimension_object_list;
          tempListCountdimension_object_list++; 
          (*i_dimension_object_list) = (SgDimensionObjectPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_dimension_object_list ) );
        }
     storageOf_dimension_object_list.storeDataInEasyStorageClass(source->p_dimension_object_list);
     tempListCountdimension_object_list = 0; 
     i_dimension_object_list = source->p_dimension_object_list.begin() ; 
     for ( ; i_dimension_object_list != source->p_dimension_object_list.end(); ++i_dimension_object_list ) 
        {
          *i_dimension_object_list = tempListdimension_object_list[tempListCountdimension_object_list] ;
          tempListCountdimension_object_list++; 
        }
      delete [] tempListdimension_object_list; 
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAttributeSpecificationStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgStringList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgDataStatementGroupPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgDimensionObjectPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAttributeSpecificationStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgStringList > :: deleteMemoryPool() ;
     EasyStorage < SgDataStatementGroupPtrList > :: deleteMemoryPool() ;
     EasyStorage < SgDimensionObjectPtrList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAttributeSpecificationStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgStringList > :: writeToFile(out) ;
     EasyStorage < SgDataStatementGroupPtrList > :: writeToFile(out) ;
     EasyStorage < SgDimensionObjectPtrList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAttributeSpecificationStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgStringList > :: readFromFile(in) ;
     EasyStorage < SgDataStatementGroupPtrList > :: readFromFile(in) ;
     EasyStorage < SgDimensionObjectPtrList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 15095 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgFormatStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 15108 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgFormatStatementStorageClass::pickOutIRNodeData ( SgFormatStatement* pointer ) 
   { 
     SgFormatStatement* source = (SgFormatStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_format_item_list = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_format_item_list );
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgFormatStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgFormatStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgFormatStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgFormatStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 15206 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTemplateDeclarationStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 15219 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgTemplateDeclarationStorageClass::pickOutIRNodeData ( SgTemplateDeclaration* pointer ) 
   { 
     SgTemplateDeclaration* source = (SgTemplateDeclaration*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_name.pickOutIRNodeData( &(source->p_name) );
     storageOf_string.pickOutIRNodeData( &(source->p_string) );
     storageOf_template_kind =  source->p_template_kind ;
     SgTemplateParameterPtrList::iterator i_templateParameters = source->p_templateParameters.begin() ; 
     unsigned int tempListCounttemplateParameters = 0; 
     SgTemplateParameterPtrList::value_type *  tempListtemplateParameters = new SgTemplateParameterPtrList::value_type[ source->p_templateParameters.size() ]; 
     for ( ; i_templateParameters != source->p_templateParameters.end(); ++i_templateParameters ) 
        {
          tempListtemplateParameters[tempListCounttemplateParameters] = *i_templateParameters;
          tempListCounttemplateParameters++; 
          (*i_templateParameters) = (SgTemplateParameterPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_templateParameters ) );
        }
     storageOf_templateParameters.storeDataInEasyStorageClass(source->p_templateParameters);
     tempListCounttemplateParameters = 0; 
     i_templateParameters = source->p_templateParameters.begin() ; 
     for ( ; i_templateParameters != source->p_templateParameters.end(); ++i_templateParameters ) 
        {
          *i_templateParameters = tempListtemplateParameters[tempListCounttemplateParameters] ;
          tempListCounttemplateParameters++; 
        }
      delete [] tempListtemplateParameters; 
     storageOf_scope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_scope );
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgTemplateDeclarationStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgTemplateParameterPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTemplateDeclarationStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgTemplateParameterPtrList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTemplateDeclarationStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgTemplateParameterPtrList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTemplateDeclarationStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgTemplateParameterPtrList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 15346 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTemplateClassDeclarationStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 15359 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgTemplateClassDeclarationStorageClass::pickOutIRNodeData ( SgTemplateClassDeclaration* pointer ) 
   { 
     SgTemplateClassDeclaration* source = (SgTemplateClassDeclaration*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_definition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definition );
     storageOf_name.pickOutIRNodeData( &(source->p_name) );
     storageOf_string.pickOutIRNodeData( &(source->p_string) );
     storageOf_template_kind =  source->p_template_kind ;
     SgTemplateParameterPtrList::iterator i_templateParameters = source->p_templateParameters.begin() ; 
     unsigned int tempListCounttemplateParameters = 0; 
     SgTemplateParameterPtrList::value_type *  tempListtemplateParameters = new SgTemplateParameterPtrList::value_type[ source->p_templateParameters.size() ]; 
     for ( ; i_templateParameters != source->p_templateParameters.end(); ++i_templateParameters ) 
        {
          tempListtemplateParameters[tempListCounttemplateParameters] = *i_templateParameters;
          tempListCounttemplateParameters++; 
          (*i_templateParameters) = (SgTemplateParameterPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_templateParameters ) );
        }
     storageOf_templateParameters.storeDataInEasyStorageClass(source->p_templateParameters);
     tempListCounttemplateParameters = 0; 
     i_templateParameters = source->p_templateParameters.begin() ; 
     for ( ; i_templateParameters != source->p_templateParameters.end(); ++i_templateParameters ) 
        {
          *i_templateParameters = tempListtemplateParameters[tempListCounttemplateParameters] ;
          tempListCounttemplateParameters++; 
        }
      delete [] tempListtemplateParameters; 
     storageOf_scope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_scope );
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgTemplateClassDeclarationStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgTemplateParameterPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTemplateClassDeclarationStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgTemplateParameterPtrList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTemplateClassDeclarationStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgTemplateParameterPtrList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTemplateClassDeclarationStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgTemplateParameterPtrList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 15487 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTemplateFunctionDeclarationStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 15500 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgTemplateFunctionDeclarationStorageClass::pickOutIRNodeData ( SgTemplateFunctionDeclaration* pointer ) 
   { 
     SgTemplateFunctionDeclaration* source = (SgTemplateFunctionDeclaration*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_definition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definition );
     storageOf_name.pickOutIRNodeData( &(source->p_name) );
     storageOf_string.pickOutIRNodeData( &(source->p_string) );
     storageOf_template_kind =  source->p_template_kind ;
     SgTemplateParameterPtrList::iterator i_templateParameters = source->p_templateParameters.begin() ; 
     unsigned int tempListCounttemplateParameters = 0; 
     SgTemplateParameterPtrList::value_type *  tempListtemplateParameters = new SgTemplateParameterPtrList::value_type[ source->p_templateParameters.size() ]; 
     for ( ; i_templateParameters != source->p_templateParameters.end(); ++i_templateParameters ) 
        {
          tempListtemplateParameters[tempListCounttemplateParameters] = *i_templateParameters;
          tempListCounttemplateParameters++; 
          (*i_templateParameters) = (SgTemplateParameterPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_templateParameters ) );
        }
     storageOf_templateParameters.storeDataInEasyStorageClass(source->p_templateParameters);
     tempListCounttemplateParameters = 0; 
     i_templateParameters = source->p_templateParameters.begin() ; 
     for ( ; i_templateParameters != source->p_templateParameters.end(); ++i_templateParameters ) 
        {
          *i_templateParameters = tempListtemplateParameters[tempListCounttemplateParameters] ;
          tempListCounttemplateParameters++; 
        }
      delete [] tempListtemplateParameters; 
     storageOf_scope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_scope );
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgTemplateFunctionDeclarationStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgTemplateParameterPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTemplateFunctionDeclarationStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgTemplateParameterPtrList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTemplateFunctionDeclarationStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgTemplateParameterPtrList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTemplateFunctionDeclarationStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgTemplateParameterPtrList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 15628 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTemplateMemberFunctionDeclarationStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 15641 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgTemplateMemberFunctionDeclarationStorageClass::pickOutIRNodeData ( SgTemplateMemberFunctionDeclaration* pointer ) 
   { 
     SgTemplateMemberFunctionDeclaration* source = (SgTemplateMemberFunctionDeclaration*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_definition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definition );
     storageOf_name.pickOutIRNodeData( &(source->p_name) );
     storageOf_string.pickOutIRNodeData( &(source->p_string) );
     storageOf_template_kind =  source->p_template_kind ;
     SgTemplateParameterPtrList::iterator i_templateParameters = source->p_templateParameters.begin() ; 
     unsigned int tempListCounttemplateParameters = 0; 
     SgTemplateParameterPtrList::value_type *  tempListtemplateParameters = new SgTemplateParameterPtrList::value_type[ source->p_templateParameters.size() ]; 
     for ( ; i_templateParameters != source->p_templateParameters.end(); ++i_templateParameters ) 
        {
          tempListtemplateParameters[tempListCounttemplateParameters] = *i_templateParameters;
          tempListCounttemplateParameters++; 
          (*i_templateParameters) = (SgTemplateParameterPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_templateParameters ) );
        }
     storageOf_templateParameters.storeDataInEasyStorageClass(source->p_templateParameters);
     tempListCounttemplateParameters = 0; 
     i_templateParameters = source->p_templateParameters.begin() ; 
     for ( ; i_templateParameters != source->p_templateParameters.end(); ++i_templateParameters ) 
        {
          *i_templateParameters = tempListtemplateParameters[tempListCounttemplateParameters] ;
          tempListCounttemplateParameters++; 
        }
      delete [] tempListtemplateParameters; 
     storageOf_scope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_scope );
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgTemplateMemberFunctionDeclarationStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgTemplateParameterPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTemplateMemberFunctionDeclarationStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgTemplateParameterPtrList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTemplateMemberFunctionDeclarationStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgTemplateParameterPtrList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTemplateMemberFunctionDeclarationStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgTemplateParameterPtrList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 15769 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTemplateInstantiationDirectiveStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 15782 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgTemplateInstantiationDirectiveStatementStorageClass::pickOutIRNodeData ( SgTemplateInstantiationDirectiveStatement* pointer ) 
   { 
     SgTemplateInstantiationDirectiveStatement* source = (SgTemplateInstantiationDirectiveStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_declaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declaration );
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgTemplateInstantiationDirectiveStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTemplateInstantiationDirectiveStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTemplateInstantiationDirectiveStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTemplateInstantiationDirectiveStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 15880 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgUseStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 15893 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgUseStatementStorageClass::pickOutIRNodeData ( SgUseStatement* pointer ) 
   { 
     SgUseStatement* source = (SgUseStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_name.pickOutIRNodeData( &(source->p_name) );
     storageOf_only_option =  source->p_only_option ;
     SgRenamePairPtrList::iterator i_rename_list = source->p_rename_list.begin() ; 
     unsigned int tempListCountrename_list = 0; 
     SgRenamePairPtrList::value_type *  tempListrename_list = new SgRenamePairPtrList::value_type[ source->p_rename_list.size() ]; 
     for ( ; i_rename_list != source->p_rename_list.end(); ++i_rename_list ) 
        {
          tempListrename_list[tempListCountrename_list] = *i_rename_list;
          tempListCountrename_list++; 
          (*i_rename_list) = (SgRenamePairPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_rename_list ) );
        }
     storageOf_rename_list.storeDataInEasyStorageClass(source->p_rename_list);
     tempListCountrename_list = 0; 
     i_rename_list = source->p_rename_list.begin() ; 
     for ( ; i_rename_list != source->p_rename_list.end(); ++i_rename_list ) 
        {
          *i_rename_list = tempListrename_list[tempListCountrename_list] ;
          tempListCountrename_list++; 
        }
      delete [] tempListrename_list; 
     storageOf_module = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_module );
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgUseStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgRenamePairPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgUseStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgRenamePairPtrList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgUseStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgRenamePairPtrList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgUseStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgRenamePairPtrList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 16019 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgParameterStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 16032 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgParameterStatementStorageClass::pickOutIRNodeData ( SgParameterStatement* pointer ) 
   { 
     SgParameterStatement* source = (SgParameterStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgParameterStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgParameterStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgParameterStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgParameterStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 16129 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgNamespaceDeclarationStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 16142 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgNamespaceDeclarationStatementStorageClass::pickOutIRNodeData ( SgNamespaceDeclarationStatement* pointer ) 
   { 
     SgNamespaceDeclarationStatement* source = (SgNamespaceDeclarationStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_name.pickOutIRNodeData( &(source->p_name) );
     storageOf_definition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definition );
     storageOf_isUnnamedNamespace =  source->p_isUnnamedNamespace ;
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgNamespaceDeclarationStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgNamespaceDeclarationStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgNamespaceDeclarationStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgNamespaceDeclarationStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 16246 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgEquivalenceStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 16259 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgEquivalenceStatementStorageClass::pickOutIRNodeData ( SgEquivalenceStatement* pointer ) 
   { 
     SgEquivalenceStatement* source = (SgEquivalenceStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_equivalence_set_list = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_equivalence_set_list );
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgEquivalenceStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgEquivalenceStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgEquivalenceStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgEquivalenceStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 16357 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgInterfaceStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 16370 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgInterfaceStatementStorageClass::pickOutIRNodeData ( SgInterfaceStatement* pointer ) 
   { 
     SgInterfaceStatement* source = (SgInterfaceStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_name.pickOutIRNodeData( &(source->p_name) );
     storageOf_generic_spec =  source->p_generic_spec ;
     SgInterfaceBodyPtrList::iterator i_interface_body_list = source->p_interface_body_list.begin() ; 
     unsigned int tempListCountinterface_body_list = 0; 
     SgInterfaceBodyPtrList::value_type *  tempListinterface_body_list = new SgInterfaceBodyPtrList::value_type[ source->p_interface_body_list.size() ]; 
     for ( ; i_interface_body_list != source->p_interface_body_list.end(); ++i_interface_body_list ) 
        {
          tempListinterface_body_list[tempListCountinterface_body_list] = *i_interface_body_list;
          tempListCountinterface_body_list++; 
          (*i_interface_body_list) = (SgInterfaceBodyPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_interface_body_list ) );
        }
     storageOf_interface_body_list.storeDataInEasyStorageClass(source->p_interface_body_list);
     tempListCountinterface_body_list = 0; 
     i_interface_body_list = source->p_interface_body_list.begin() ; 
     for ( ; i_interface_body_list != source->p_interface_body_list.end(); ++i_interface_body_list ) 
        {
          *i_interface_body_list = tempListinterface_body_list[tempListCountinterface_body_list] ;
          tempListCountinterface_body_list++; 
        }
      delete [] tempListinterface_body_list; 
     storageOf_end_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_end_numeric_label );
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgInterfaceStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgInterfaceBodyPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgInterfaceStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgInterfaceBodyPtrList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgInterfaceStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgInterfaceBodyPtrList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgInterfaceStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgInterfaceBodyPtrList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 16496 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgNamespaceAliasDeclarationStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 16509 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgNamespaceAliasDeclarationStatementStorageClass::pickOutIRNodeData ( SgNamespaceAliasDeclarationStatement* pointer ) 
   { 
     SgNamespaceAliasDeclarationStatement* source = (SgNamespaceAliasDeclarationStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_name.pickOutIRNodeData( &(source->p_name) );
     storageOf_namespaceDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_namespaceDeclaration );
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgNamespaceAliasDeclarationStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgNamespaceAliasDeclarationStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgNamespaceAliasDeclarationStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgNamespaceAliasDeclarationStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 16612 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgCommonBlockStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 16625 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgCommonBlockStorageClass::pickOutIRNodeData ( SgCommonBlock* pointer ) 
   { 
     SgCommonBlock* source = (SgCommonBlock*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgCommonBlockObjectPtrList::iterator i_block_list = source->p_block_list.begin() ; 
     unsigned int tempListCountblock_list = 0; 
     SgCommonBlockObjectPtrList::value_type *  tempListblock_list = new SgCommonBlockObjectPtrList::value_type[ source->p_block_list.size() ]; 
     for ( ; i_block_list != source->p_block_list.end(); ++i_block_list ) 
        {
          tempListblock_list[tempListCountblock_list] = *i_block_list;
          tempListCountblock_list++; 
          (*i_block_list) = (SgCommonBlockObjectPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_block_list ) );
        }
     storageOf_block_list.storeDataInEasyStorageClass(source->p_block_list);
     tempListCountblock_list = 0; 
     i_block_list = source->p_block_list.begin() ; 
     for ( ; i_block_list != source->p_block_list.end(); ++i_block_list ) 
        {
          *i_block_list = tempListblock_list[tempListCountblock_list] ;
          tempListCountblock_list++; 
        }
      delete [] tempListblock_list; 
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgCommonBlockStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgCommonBlockObjectPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgCommonBlockStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgCommonBlockObjectPtrList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgCommonBlockStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgCommonBlockObjectPtrList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgCommonBlockStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgCommonBlockObjectPtrList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 16744 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTypedefDeclarationStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 16757 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgTypedefDeclarationStorageClass::pickOutIRNodeData ( SgTypedefDeclaration* pointer ) 
   { 
     SgTypedefDeclaration* source = (SgTypedefDeclaration*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_name.pickOutIRNodeData( &(source->p_name) );
     storageOf_base_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_base_type );
     storageOf_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type );
     storageOf_declaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declaration );
     storageOf_parent_scope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent_scope );
     storageOf_typedefBaseTypeContainsDefiningDeclaration =  source->p_typedefBaseTypeContainsDefiningDeclaration ;
     storageOf_scope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_scope );
     storageOf_requiresGlobalNameQualificationOnType =  source->p_requiresGlobalNameQualificationOnType ;
     storageOf_name_qualification_length_for_base_type =  source->p_name_qualification_length_for_base_type ;
     storageOf_type_elaboration_required_for_base_type =  source->p_type_elaboration_required_for_base_type ;
     storageOf_global_qualification_required_for_base_type =  source->p_global_qualification_required_for_base_type ;
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgTypedefDeclarationStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTypedefDeclarationStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTypedefDeclarationStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTypedefDeclarationStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 16869 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgStatementFunctionStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 16882 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgStatementFunctionStatementStorageClass::pickOutIRNodeData ( SgStatementFunctionStatement* pointer ) 
   { 
     SgStatementFunctionStatement* source = (SgStatementFunctionStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_function = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_function );
     storageOf_expression = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression );
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgStatementFunctionStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgStatementFunctionStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgStatementFunctionStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgStatementFunctionStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 16981 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgCtorInitializerListStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 16994 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgCtorInitializerListStorageClass::pickOutIRNodeData ( SgCtorInitializerList* pointer ) 
   { 
     SgCtorInitializerList* source = (SgCtorInitializerList*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgInitializedNamePtrList::iterator i_ctors = source->p_ctors.begin() ; 
     unsigned int tempListCountctors = 0; 
     SgInitializedNamePtrList::value_type *  tempListctors = new SgInitializedNamePtrList::value_type[ source->p_ctors.size() ]; 
     for ( ; i_ctors != source->p_ctors.end(); ++i_ctors ) 
        {
          tempListctors[tempListCountctors] = *i_ctors;
          tempListCountctors++; 
          (*i_ctors) = (SgInitializedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_ctors ) );
        }
     storageOf_ctors.storeDataInEasyStorageClass(source->p_ctors);
     tempListCountctors = 0; 
     i_ctors = source->p_ctors.begin() ; 
     for ( ; i_ctors != source->p_ctors.end(); ++i_ctors ) 
        {
          *i_ctors = tempListctors[tempListCountctors] ;
          tempListCountctors++; 
        }
      delete [] tempListctors; 
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgCtorInitializerListStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgInitializedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgCtorInitializerListStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgInitializedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgCtorInitializerListStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgInitializedNamePtrList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgCtorInitializerListStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgInitializedNamePtrList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 17113 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgPragmaDeclarationStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 17126 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgPragmaDeclarationStorageClass::pickOutIRNodeData ( SgPragmaDeclaration* pointer ) 
   { 
     SgPragmaDeclaration* source = (SgPragmaDeclaration*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_pragma = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_pragma );
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgPragmaDeclarationStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgPragmaDeclarationStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgPragmaDeclarationStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgPragmaDeclarationStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 17224 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgUsingDirectiveStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 17237 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgUsingDirectiveStatementStorageClass::pickOutIRNodeData ( SgUsingDirectiveStatement* pointer ) 
   { 
     SgUsingDirectiveStatement* source = (SgUsingDirectiveStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_namespaceDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_namespaceDeclaration );
     storageOf_name_qualification_length =  source->p_name_qualification_length ;
     storageOf_type_elaboration_required =  source->p_type_elaboration_required ;
     storageOf_global_qualification_required =  source->p_global_qualification_required ;
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgUsingDirectiveStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgUsingDirectiveStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgUsingDirectiveStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgUsingDirectiveStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 17338 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgClassDeclarationStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 17351 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgClassDeclarationStorageClass::pickOutIRNodeData ( SgClassDeclaration* pointer ) 
   { 
     SgClassDeclaration* source = (SgClassDeclaration*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_name.pickOutIRNodeData( &(source->p_name) );
     storageOf_class_type =  source->p_class_type ;
     storageOf_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type );
     storageOf_definition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definition );
     storageOf_scope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_scope );
     storageOf_specialization =  source->p_specialization ;
     storageOf_from_template =  source->p_from_template ;
     storageOf_fixupScope =  source->p_fixupScope ;
     storageOf_isUnNamed =  source->p_isUnNamed ;
     storageOf_explicit_interface =  source->p_explicit_interface ;
     storageOf_decoratorList = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_decoratorList );
     storageOf_name_qualification_length =  source->p_name_qualification_length ;
     storageOf_type_elaboration_required =  source->p_type_elaboration_required ;
     storageOf_global_qualification_required =  source->p_global_qualification_required ;
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgClassDeclarationStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgClassDeclarationStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgClassDeclarationStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgClassDeclarationStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 17466 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTemplateInstantiationDeclStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 17479 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgTemplateInstantiationDeclStorageClass::pickOutIRNodeData ( SgTemplateInstantiationDecl* pointer ) 
   { 
     SgTemplateInstantiationDecl* source = (SgTemplateInstantiationDecl*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_templateName.pickOutIRNodeData( &(source->p_templateName) );
     storageOf_templateHeader.pickOutIRNodeData( &(source->p_templateHeader) );
     storageOf_templateDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_templateDeclaration );
     SgTemplateArgumentPtrList::iterator i_templateArguments = source->p_templateArguments.begin() ; 
     unsigned int tempListCounttemplateArguments = 0; 
     SgTemplateArgumentPtrList::value_type *  tempListtemplateArguments = new SgTemplateArgumentPtrList::value_type[ source->p_templateArguments.size() ]; 
     for ( ; i_templateArguments != source->p_templateArguments.end(); ++i_templateArguments ) 
        {
          tempListtemplateArguments[tempListCounttemplateArguments] = *i_templateArguments;
          tempListCounttemplateArguments++; 
          (*i_templateArguments) = (SgTemplateArgumentPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_templateArguments ) );
        }
     storageOf_templateArguments.storeDataInEasyStorageClass(source->p_templateArguments);
     tempListCounttemplateArguments = 0; 
     i_templateArguments = source->p_templateArguments.begin() ; 
     for ( ; i_templateArguments != source->p_templateArguments.end(); ++i_templateArguments ) 
        {
          *i_templateArguments = tempListtemplateArguments[tempListCounttemplateArguments] ;
          tempListCounttemplateArguments++; 
        }
      delete [] tempListtemplateArguments; 
     storageOf_nameResetFromMangledForm =  source->p_nameResetFromMangledForm ;
     storageOf_name.pickOutIRNodeData( &(source->p_name) );
     storageOf_class_type =  source->p_class_type ;
     storageOf_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type );
     storageOf_definition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definition );
     storageOf_scope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_scope );
     storageOf_specialization =  source->p_specialization ;
     storageOf_from_template =  source->p_from_template ;
     storageOf_fixupScope =  source->p_fixupScope ;
     storageOf_isUnNamed =  source->p_isUnNamed ;
     storageOf_explicit_interface =  source->p_explicit_interface ;
     storageOf_decoratorList = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_decoratorList );
     storageOf_name_qualification_length =  source->p_name_qualification_length ;
     storageOf_type_elaboration_required =  source->p_type_elaboration_required ;
     storageOf_global_qualification_required =  source->p_global_qualification_required ;
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgTemplateInstantiationDeclStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgTemplateArgumentPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTemplateInstantiationDeclStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgTemplateArgumentPtrList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTemplateInstantiationDeclStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgTemplateArgumentPtrList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTemplateInstantiationDeclStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgTemplateArgumentPtrList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 17620 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgDerivedTypeStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 17633 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgDerivedTypeStatementStorageClass::pickOutIRNodeData ( SgDerivedTypeStatement* pointer ) 
   { 
     SgDerivedTypeStatement* source = (SgDerivedTypeStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_end_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_end_numeric_label );
     storageOf_name.pickOutIRNodeData( &(source->p_name) );
     storageOf_class_type =  source->p_class_type ;
     storageOf_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type );
     storageOf_definition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definition );
     storageOf_scope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_scope );
     storageOf_specialization =  source->p_specialization ;
     storageOf_from_template =  source->p_from_template ;
     storageOf_fixupScope =  source->p_fixupScope ;
     storageOf_isUnNamed =  source->p_isUnNamed ;
     storageOf_explicit_interface =  source->p_explicit_interface ;
     storageOf_decoratorList = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_decoratorList );
     storageOf_name_qualification_length =  source->p_name_qualification_length ;
     storageOf_type_elaboration_required =  source->p_type_elaboration_required ;
     storageOf_global_qualification_required =  source->p_global_qualification_required ;
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgDerivedTypeStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgDerivedTypeStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgDerivedTypeStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgDerivedTypeStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 17749 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgModuleStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 17762 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgModuleStatementStorageClass::pickOutIRNodeData ( SgModuleStatement* pointer ) 
   { 
     SgModuleStatement* source = (SgModuleStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_end_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_end_numeric_label );
     storageOf_name.pickOutIRNodeData( &(source->p_name) );
     storageOf_class_type =  source->p_class_type ;
     storageOf_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type );
     storageOf_definition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definition );
     storageOf_scope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_scope );
     storageOf_specialization =  source->p_specialization ;
     storageOf_from_template =  source->p_from_template ;
     storageOf_fixupScope =  source->p_fixupScope ;
     storageOf_isUnNamed =  source->p_isUnNamed ;
     storageOf_explicit_interface =  source->p_explicit_interface ;
     storageOf_decoratorList = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_decoratorList );
     storageOf_name_qualification_length =  source->p_name_qualification_length ;
     storageOf_type_elaboration_required =  source->p_type_elaboration_required ;
     storageOf_global_qualification_required =  source->p_global_qualification_required ;
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgModuleStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgModuleStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgModuleStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgModuleStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 17878 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgImplicitStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 17891 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgImplicitStatementStorageClass::pickOutIRNodeData ( SgImplicitStatement* pointer ) 
   { 
     SgImplicitStatement* source = (SgImplicitStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_implicit_none =  source->p_implicit_none ;
     SgInitializedNamePtrList::iterator i_variables = source->p_variables.begin() ; 
     unsigned int tempListCountvariables = 0; 
     SgInitializedNamePtrList::value_type *  tempListvariables = new SgInitializedNamePtrList::value_type[ source->p_variables.size() ]; 
     for ( ; i_variables != source->p_variables.end(); ++i_variables ) 
        {
          tempListvariables[tempListCountvariables] = *i_variables;
          tempListCountvariables++; 
          (*i_variables) = (SgInitializedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_variables ) );
        }
     storageOf_variables.storeDataInEasyStorageClass(source->p_variables);
     tempListCountvariables = 0; 
     i_variables = source->p_variables.begin() ; 
     for ( ; i_variables != source->p_variables.end(); ++i_variables ) 
        {
          *i_variables = tempListvariables[tempListCountvariables] ;
          tempListCountvariables++; 
        }
      delete [] tempListvariables; 
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgImplicitStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgInitializedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgImplicitStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgInitializedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgImplicitStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgInitializedNamePtrList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgImplicitStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgInitializedNamePtrList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 18011 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgUsingDeclarationStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 18024 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgUsingDeclarationStatementStorageClass::pickOutIRNodeData ( SgUsingDeclarationStatement* pointer ) 
   { 
     SgUsingDeclarationStatement* source = (SgUsingDeclarationStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_declaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declaration );
     storageOf_initializedName = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_initializedName );
     storageOf_name_qualification_length =  source->p_name_qualification_length ;
     storageOf_type_elaboration_required =  source->p_type_elaboration_required ;
     storageOf_global_qualification_required =  source->p_global_qualification_required ;
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgUsingDeclarationStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgUsingDeclarationStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgUsingDeclarationStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgUsingDeclarationStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 18126 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgNamelistStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 18139 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgNamelistStatementStorageClass::pickOutIRNodeData ( SgNamelistStatement* pointer ) 
   { 
     SgNamelistStatement* source = (SgNamelistStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgNameGroupPtrList::iterator i_group_list = source->p_group_list.begin() ; 
     unsigned int tempListCountgroup_list = 0; 
     SgNameGroupPtrList::value_type *  tempListgroup_list = new SgNameGroupPtrList::value_type[ source->p_group_list.size() ]; 
     for ( ; i_group_list != source->p_group_list.end(); ++i_group_list ) 
        {
          tempListgroup_list[tempListCountgroup_list] = *i_group_list;
          tempListCountgroup_list++; 
          (*i_group_list) = (SgNameGroupPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_group_list ) );
        }
     storageOf_group_list.storeDataInEasyStorageClass(source->p_group_list);
     tempListCountgroup_list = 0; 
     i_group_list = source->p_group_list.begin() ; 
     for ( ; i_group_list != source->p_group_list.end(); ++i_group_list ) 
        {
          *i_group_list = tempListgroup_list[tempListCountgroup_list] ;
          tempListCountgroup_list++; 
        }
      delete [] tempListgroup_list; 
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgNamelistStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgNameGroupPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgNamelistStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgNameGroupPtrList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgNamelistStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgNameGroupPtrList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgNamelistStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgNameGroupPtrList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 18258 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgImportStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 18271 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgImportStatementStorageClass::pickOutIRNodeData ( SgImportStatement* pointer ) 
   { 
     SgImportStatement* source = (SgImportStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgExpressionPtrList::iterator i_import_list = source->p_import_list.begin() ; 
     unsigned int tempListCountimport_list = 0; 
     SgExpressionPtrList::value_type *  tempListimport_list = new SgExpressionPtrList::value_type[ source->p_import_list.size() ]; 
     for ( ; i_import_list != source->p_import_list.end(); ++i_import_list ) 
        {
          tempListimport_list[tempListCountimport_list] = *i_import_list;
          tempListCountimport_list++; 
          (*i_import_list) = (SgExpressionPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_import_list ) );
        }
     storageOf_import_list.storeDataInEasyStorageClass(source->p_import_list);
     tempListCountimport_list = 0; 
     i_import_list = source->p_import_list.begin() ; 
     for ( ; i_import_list != source->p_import_list.end(); ++i_import_list ) 
        {
          *i_import_list = tempListimport_list[tempListCountimport_list] ;
          tempListCountimport_list++; 
        }
      delete [] tempListimport_list; 
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgImportStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgExpressionPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgImportStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgExpressionPtrList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgImportStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgExpressionPtrList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgImportStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgExpressionPtrList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 18390 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgFunctionDeclarationStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 18403 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgFunctionDeclarationStorageClass::pickOutIRNodeData ( SgFunctionDeclaration* pointer ) 
   { 
     SgFunctionDeclaration* source = (SgFunctionDeclaration*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_name.pickOutIRNodeData( &(source->p_name) );
     storageOf_parameterList = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parameterList );
     storageOf_functionModifier.pickOutIRNodeData( &(source->p_functionModifier) );
     storageOf_specialFunctionModifier.pickOutIRNodeData( &(source->p_specialFunctionModifier) );
     SgTypePtrList::iterator i_exceptionSpecification = source->p_exceptionSpecification.begin() ; 
     unsigned int tempListCountexceptionSpecification = 0; 
     SgTypePtrList::value_type *  tempListexceptionSpecification = new SgTypePtrList::value_type[ source->p_exceptionSpecification.size() ]; 
     for ( ; i_exceptionSpecification != source->p_exceptionSpecification.end(); ++i_exceptionSpecification ) 
        {
          tempListexceptionSpecification[tempListCountexceptionSpecification] = *i_exceptionSpecification;
          tempListCountexceptionSpecification++; 
          (*i_exceptionSpecification) = (SgTypePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_exceptionSpecification ) );
        }
     storageOf_exceptionSpecification.storeDataInEasyStorageClass(source->p_exceptionSpecification);
     tempListCountexceptionSpecification = 0; 
     i_exceptionSpecification = source->p_exceptionSpecification.begin() ; 
     for ( ; i_exceptionSpecification != source->p_exceptionSpecification.end(); ++i_exceptionSpecification ) 
        {
          *i_exceptionSpecification = tempListexceptionSpecification[tempListCountexceptionSpecification] ;
          tempListCountexceptionSpecification++; 
        }
      delete [] tempListexceptionSpecification; 
     storageOf_named_in_end_statement =  source->p_named_in_end_statement ;
     storageOf_asm_name.storeDataInEasyStorageClass(source->p_asm_name);
     storageOf_decoratorList = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_decoratorList );
     storageOf_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type );
     storageOf_definition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definition );
     storageOf_oldStyleDefinition =  source->p_oldStyleDefinition ;
     storageOf_scope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_scope );
     storageOf_specialization =  source->p_specialization ;
     storageOf_requiresNameQualificationOnReturnType =  source->p_requiresNameQualificationOnReturnType ;
     storageOf_gnu_extension_section.storeDataInEasyStorageClass(source->p_gnu_extension_section);
     storageOf_gnu_extension_alias.storeDataInEasyStorageClass(source->p_gnu_extension_alias);
     storageOf_gnu_extension_visability =  source->p_gnu_extension_visability ;
     storageOf_name_qualification_length =  source->p_name_qualification_length ;
     storageOf_type_elaboration_required =  source->p_type_elaboration_required ;
     storageOf_global_qualification_required =  source->p_global_qualification_required ;
     storageOf_name_qualification_length_for_return_type =  source->p_name_qualification_length_for_return_type ;
     storageOf_type_elaboration_required_for_return_type =  source->p_type_elaboration_required_for_return_type ;
     storageOf_global_qualification_required_for_return_type =  source->p_global_qualification_required_for_return_type ;
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgFunctionDeclarationStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     SgFunctionModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     SgSpecialFunctionModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgTypePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgFunctionDeclarationStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     SgFunctionModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     SgSpecialFunctionModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgTypePtrList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgFunctionDeclarationStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     SgFunctionModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     SgSpecialFunctionModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgTypePtrList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgFunctionDeclarationStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     SgFunctionModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     SgSpecialFunctionModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgTypePtrList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 18556 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgMemberFunctionDeclarationStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 18569 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgMemberFunctionDeclarationStorageClass::pickOutIRNodeData ( SgMemberFunctionDeclaration* pointer ) 
   { 
     SgMemberFunctionDeclaration* source = (SgMemberFunctionDeclaration*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_CtorInitializerList = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_CtorInitializerList );
     storageOf_associatedClassDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_associatedClassDeclaration );
     storageOf_name.pickOutIRNodeData( &(source->p_name) );
     storageOf_parameterList = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parameterList );
     storageOf_functionModifier.pickOutIRNodeData( &(source->p_functionModifier) );
     storageOf_specialFunctionModifier.pickOutIRNodeData( &(source->p_specialFunctionModifier) );
     SgTypePtrList::iterator i_exceptionSpecification = source->p_exceptionSpecification.begin() ; 
     unsigned int tempListCountexceptionSpecification = 0; 
     SgTypePtrList::value_type *  tempListexceptionSpecification = new SgTypePtrList::value_type[ source->p_exceptionSpecification.size() ]; 
     for ( ; i_exceptionSpecification != source->p_exceptionSpecification.end(); ++i_exceptionSpecification ) 
        {
          tempListexceptionSpecification[tempListCountexceptionSpecification] = *i_exceptionSpecification;
          tempListCountexceptionSpecification++; 
          (*i_exceptionSpecification) = (SgTypePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_exceptionSpecification ) );
        }
     storageOf_exceptionSpecification.storeDataInEasyStorageClass(source->p_exceptionSpecification);
     tempListCountexceptionSpecification = 0; 
     i_exceptionSpecification = source->p_exceptionSpecification.begin() ; 
     for ( ; i_exceptionSpecification != source->p_exceptionSpecification.end(); ++i_exceptionSpecification ) 
        {
          *i_exceptionSpecification = tempListexceptionSpecification[tempListCountexceptionSpecification] ;
          tempListCountexceptionSpecification++; 
        }
      delete [] tempListexceptionSpecification; 
     storageOf_named_in_end_statement =  source->p_named_in_end_statement ;
     storageOf_asm_name.storeDataInEasyStorageClass(source->p_asm_name);
     storageOf_decoratorList = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_decoratorList );
     storageOf_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type );
     storageOf_definition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definition );
     storageOf_oldStyleDefinition =  source->p_oldStyleDefinition ;
     storageOf_scope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_scope );
     storageOf_specialization =  source->p_specialization ;
     storageOf_requiresNameQualificationOnReturnType =  source->p_requiresNameQualificationOnReturnType ;
     storageOf_gnu_extension_section.storeDataInEasyStorageClass(source->p_gnu_extension_section);
     storageOf_gnu_extension_alias.storeDataInEasyStorageClass(source->p_gnu_extension_alias);
     storageOf_gnu_extension_visability =  source->p_gnu_extension_visability ;
     storageOf_name_qualification_length =  source->p_name_qualification_length ;
     storageOf_type_elaboration_required =  source->p_type_elaboration_required ;
     storageOf_global_qualification_required =  source->p_global_qualification_required ;
     storageOf_name_qualification_length_for_return_type =  source->p_name_qualification_length_for_return_type ;
     storageOf_type_elaboration_required_for_return_type =  source->p_type_elaboration_required_for_return_type ;
     storageOf_global_qualification_required_for_return_type =  source->p_global_qualification_required_for_return_type ;
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgMemberFunctionDeclarationStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     SgFunctionModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     SgSpecialFunctionModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgTypePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgMemberFunctionDeclarationStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     SgFunctionModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     SgSpecialFunctionModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgTypePtrList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgMemberFunctionDeclarationStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     SgFunctionModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     SgSpecialFunctionModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgTypePtrList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgMemberFunctionDeclarationStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     SgFunctionModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     SgSpecialFunctionModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgTypePtrList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 18724 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTemplateInstantiationMemberFunctionDeclStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 18737 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgTemplateInstantiationMemberFunctionDeclStorageClass::pickOutIRNodeData ( SgTemplateInstantiationMemberFunctionDecl* pointer ) 
   { 
     SgTemplateInstantiationMemberFunctionDecl* source = (SgTemplateInstantiationMemberFunctionDecl*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_templateName.pickOutIRNodeData( &(source->p_templateName) );
     storageOf_templateDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_templateDeclaration );
     SgTemplateArgumentPtrList::iterator i_templateArguments = source->p_templateArguments.begin() ; 
     unsigned int tempListCounttemplateArguments = 0; 
     SgTemplateArgumentPtrList::value_type *  tempListtemplateArguments = new SgTemplateArgumentPtrList::value_type[ source->p_templateArguments.size() ]; 
     for ( ; i_templateArguments != source->p_templateArguments.end(); ++i_templateArguments ) 
        {
          tempListtemplateArguments[tempListCounttemplateArguments] = *i_templateArguments;
          tempListCounttemplateArguments++; 
          (*i_templateArguments) = (SgTemplateArgumentPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_templateArguments ) );
        }
     storageOf_templateArguments.storeDataInEasyStorageClass(source->p_templateArguments);
     tempListCounttemplateArguments = 0; 
     i_templateArguments = source->p_templateArguments.begin() ; 
     for ( ; i_templateArguments != source->p_templateArguments.end(); ++i_templateArguments ) 
        {
          *i_templateArguments = tempListtemplateArguments[tempListCounttemplateArguments] ;
          tempListCounttemplateArguments++; 
        }
      delete [] tempListtemplateArguments; 
     storageOf_nameResetFromMangledForm =  source->p_nameResetFromMangledForm ;
     storageOf_CtorInitializerList = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_CtorInitializerList );
     storageOf_associatedClassDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_associatedClassDeclaration );
     storageOf_name.pickOutIRNodeData( &(source->p_name) );
     storageOf_parameterList = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parameterList );
     storageOf_functionModifier.pickOutIRNodeData( &(source->p_functionModifier) );
     storageOf_specialFunctionModifier.pickOutIRNodeData( &(source->p_specialFunctionModifier) );
     SgTypePtrList::iterator i_exceptionSpecification = source->p_exceptionSpecification.begin() ; 
     unsigned int tempListCountexceptionSpecification = 0; 
     SgTypePtrList::value_type *  tempListexceptionSpecification = new SgTypePtrList::value_type[ source->p_exceptionSpecification.size() ]; 
     for ( ; i_exceptionSpecification != source->p_exceptionSpecification.end(); ++i_exceptionSpecification ) 
        {
          tempListexceptionSpecification[tempListCountexceptionSpecification] = *i_exceptionSpecification;
          tempListCountexceptionSpecification++; 
          (*i_exceptionSpecification) = (SgTypePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_exceptionSpecification ) );
        }
     storageOf_exceptionSpecification.storeDataInEasyStorageClass(source->p_exceptionSpecification);
     tempListCountexceptionSpecification = 0; 
     i_exceptionSpecification = source->p_exceptionSpecification.begin() ; 
     for ( ; i_exceptionSpecification != source->p_exceptionSpecification.end(); ++i_exceptionSpecification ) 
        {
          *i_exceptionSpecification = tempListexceptionSpecification[tempListCountexceptionSpecification] ;
          tempListCountexceptionSpecification++; 
        }
      delete [] tempListexceptionSpecification; 
     storageOf_named_in_end_statement =  source->p_named_in_end_statement ;
     storageOf_asm_name.storeDataInEasyStorageClass(source->p_asm_name);
     storageOf_decoratorList = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_decoratorList );
     storageOf_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type );
     storageOf_definition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definition );
     storageOf_oldStyleDefinition =  source->p_oldStyleDefinition ;
     storageOf_scope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_scope );
     storageOf_specialization =  source->p_specialization ;
     storageOf_requiresNameQualificationOnReturnType =  source->p_requiresNameQualificationOnReturnType ;
     storageOf_gnu_extension_section.storeDataInEasyStorageClass(source->p_gnu_extension_section);
     storageOf_gnu_extension_alias.storeDataInEasyStorageClass(source->p_gnu_extension_alias);
     storageOf_gnu_extension_visability =  source->p_gnu_extension_visability ;
     storageOf_name_qualification_length =  source->p_name_qualification_length ;
     storageOf_type_elaboration_required =  source->p_type_elaboration_required ;
     storageOf_global_qualification_required =  source->p_global_qualification_required ;
     storageOf_name_qualification_length_for_return_type =  source->p_name_qualification_length_for_return_type ;
     storageOf_type_elaboration_required_for_return_type =  source->p_type_elaboration_required_for_return_type ;
     storageOf_global_qualification_required_for_return_type =  source->p_global_qualification_required_for_return_type ;
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgTemplateInstantiationMemberFunctionDeclStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgTemplateArgumentPtrList > :: arrangeMemoryPoolInOneBlock() ;
     SgFunctionModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     SgSpecialFunctionModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgTypePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTemplateInstantiationMemberFunctionDeclStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgTemplateArgumentPtrList > :: deleteMemoryPool() ;
     SgFunctionModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     SgSpecialFunctionModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgTypePtrList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTemplateInstantiationMemberFunctionDeclStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgTemplateArgumentPtrList > :: writeToFile(out) ;
     SgFunctionModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     SgSpecialFunctionModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgTypePtrList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTemplateInstantiationMemberFunctionDeclStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgTemplateArgumentPtrList > :: readFromFile(in) ;
     SgFunctionModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     SgSpecialFunctionModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgTypePtrList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 18917 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTemplateInstantiationFunctionDeclStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 18930 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgTemplateInstantiationFunctionDeclStorageClass::pickOutIRNodeData ( SgTemplateInstantiationFunctionDecl* pointer ) 
   { 
     SgTemplateInstantiationFunctionDecl* source = (SgTemplateInstantiationFunctionDecl*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_templateName.pickOutIRNodeData( &(source->p_templateName) );
     storageOf_templateDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_templateDeclaration );
     SgTemplateArgumentPtrList::iterator i_templateArguments = source->p_templateArguments.begin() ; 
     unsigned int tempListCounttemplateArguments = 0; 
     SgTemplateArgumentPtrList::value_type *  tempListtemplateArguments = new SgTemplateArgumentPtrList::value_type[ source->p_templateArguments.size() ]; 
     for ( ; i_templateArguments != source->p_templateArguments.end(); ++i_templateArguments ) 
        {
          tempListtemplateArguments[tempListCounttemplateArguments] = *i_templateArguments;
          tempListCounttemplateArguments++; 
          (*i_templateArguments) = (SgTemplateArgumentPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_templateArguments ) );
        }
     storageOf_templateArguments.storeDataInEasyStorageClass(source->p_templateArguments);
     tempListCounttemplateArguments = 0; 
     i_templateArguments = source->p_templateArguments.begin() ; 
     for ( ; i_templateArguments != source->p_templateArguments.end(); ++i_templateArguments ) 
        {
          *i_templateArguments = tempListtemplateArguments[tempListCounttemplateArguments] ;
          tempListCounttemplateArguments++; 
        }
      delete [] tempListtemplateArguments; 
     storageOf_nameResetFromMangledForm =  source->p_nameResetFromMangledForm ;
     storageOf_name.pickOutIRNodeData( &(source->p_name) );
     storageOf_parameterList = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parameterList );
     storageOf_functionModifier.pickOutIRNodeData( &(source->p_functionModifier) );
     storageOf_specialFunctionModifier.pickOutIRNodeData( &(source->p_specialFunctionModifier) );
     SgTypePtrList::iterator i_exceptionSpecification = source->p_exceptionSpecification.begin() ; 
     unsigned int tempListCountexceptionSpecification = 0; 
     SgTypePtrList::value_type *  tempListexceptionSpecification = new SgTypePtrList::value_type[ source->p_exceptionSpecification.size() ]; 
     for ( ; i_exceptionSpecification != source->p_exceptionSpecification.end(); ++i_exceptionSpecification ) 
        {
          tempListexceptionSpecification[tempListCountexceptionSpecification] = *i_exceptionSpecification;
          tempListCountexceptionSpecification++; 
          (*i_exceptionSpecification) = (SgTypePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_exceptionSpecification ) );
        }
     storageOf_exceptionSpecification.storeDataInEasyStorageClass(source->p_exceptionSpecification);
     tempListCountexceptionSpecification = 0; 
     i_exceptionSpecification = source->p_exceptionSpecification.begin() ; 
     for ( ; i_exceptionSpecification != source->p_exceptionSpecification.end(); ++i_exceptionSpecification ) 
        {
          *i_exceptionSpecification = tempListexceptionSpecification[tempListCountexceptionSpecification] ;
          tempListCountexceptionSpecification++; 
        }
      delete [] tempListexceptionSpecification; 
     storageOf_named_in_end_statement =  source->p_named_in_end_statement ;
     storageOf_asm_name.storeDataInEasyStorageClass(source->p_asm_name);
     storageOf_decoratorList = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_decoratorList );
     storageOf_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type );
     storageOf_definition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definition );
     storageOf_oldStyleDefinition =  source->p_oldStyleDefinition ;
     storageOf_scope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_scope );
     storageOf_specialization =  source->p_specialization ;
     storageOf_requiresNameQualificationOnReturnType =  source->p_requiresNameQualificationOnReturnType ;
     storageOf_gnu_extension_section.storeDataInEasyStorageClass(source->p_gnu_extension_section);
     storageOf_gnu_extension_alias.storeDataInEasyStorageClass(source->p_gnu_extension_alias);
     storageOf_gnu_extension_visability =  source->p_gnu_extension_visability ;
     storageOf_name_qualification_length =  source->p_name_qualification_length ;
     storageOf_type_elaboration_required =  source->p_type_elaboration_required ;
     storageOf_global_qualification_required =  source->p_global_qualification_required ;
     storageOf_name_qualification_length_for_return_type =  source->p_name_qualification_length_for_return_type ;
     storageOf_type_elaboration_required_for_return_type =  source->p_type_elaboration_required_for_return_type ;
     storageOf_global_qualification_required_for_return_type =  source->p_global_qualification_required_for_return_type ;
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgTemplateInstantiationFunctionDeclStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgTemplateArgumentPtrList > :: arrangeMemoryPoolInOneBlock() ;
     SgFunctionModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     SgSpecialFunctionModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgTypePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTemplateInstantiationFunctionDeclStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgTemplateArgumentPtrList > :: deleteMemoryPool() ;
     SgFunctionModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     SgSpecialFunctionModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgTypePtrList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTemplateInstantiationFunctionDeclStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgTemplateArgumentPtrList > :: writeToFile(out) ;
     SgFunctionModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     SgSpecialFunctionModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgTypePtrList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTemplateInstantiationFunctionDeclStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgTemplateArgumentPtrList > :: readFromFile(in) ;
     SgFunctionModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     SgSpecialFunctionModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgTypePtrList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 19108 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgProgramHeaderStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 19121 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgProgramHeaderStatementStorageClass::pickOutIRNodeData ( SgProgramHeaderStatement* pointer ) 
   { 
     SgProgramHeaderStatement* source = (SgProgramHeaderStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_program_statement_explicit =  source->p_program_statement_explicit ;
     storageOf_end_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_end_numeric_label );
     storageOf_name.pickOutIRNodeData( &(source->p_name) );
     storageOf_parameterList = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parameterList );
     storageOf_functionModifier.pickOutIRNodeData( &(source->p_functionModifier) );
     storageOf_specialFunctionModifier.pickOutIRNodeData( &(source->p_specialFunctionModifier) );
     SgTypePtrList::iterator i_exceptionSpecification = source->p_exceptionSpecification.begin() ; 
     unsigned int tempListCountexceptionSpecification = 0; 
     SgTypePtrList::value_type *  tempListexceptionSpecification = new SgTypePtrList::value_type[ source->p_exceptionSpecification.size() ]; 
     for ( ; i_exceptionSpecification != source->p_exceptionSpecification.end(); ++i_exceptionSpecification ) 
        {
          tempListexceptionSpecification[tempListCountexceptionSpecification] = *i_exceptionSpecification;
          tempListCountexceptionSpecification++; 
          (*i_exceptionSpecification) = (SgTypePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_exceptionSpecification ) );
        }
     storageOf_exceptionSpecification.storeDataInEasyStorageClass(source->p_exceptionSpecification);
     tempListCountexceptionSpecification = 0; 
     i_exceptionSpecification = source->p_exceptionSpecification.begin() ; 
     for ( ; i_exceptionSpecification != source->p_exceptionSpecification.end(); ++i_exceptionSpecification ) 
        {
          *i_exceptionSpecification = tempListexceptionSpecification[tempListCountexceptionSpecification] ;
          tempListCountexceptionSpecification++; 
        }
      delete [] tempListexceptionSpecification; 
     storageOf_named_in_end_statement =  source->p_named_in_end_statement ;
     storageOf_asm_name.storeDataInEasyStorageClass(source->p_asm_name);
     storageOf_decoratorList = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_decoratorList );
     storageOf_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type );
     storageOf_definition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definition );
     storageOf_oldStyleDefinition =  source->p_oldStyleDefinition ;
     storageOf_scope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_scope );
     storageOf_specialization =  source->p_specialization ;
     storageOf_requiresNameQualificationOnReturnType =  source->p_requiresNameQualificationOnReturnType ;
     storageOf_gnu_extension_section.storeDataInEasyStorageClass(source->p_gnu_extension_section);
     storageOf_gnu_extension_alias.storeDataInEasyStorageClass(source->p_gnu_extension_alias);
     storageOf_gnu_extension_visability =  source->p_gnu_extension_visability ;
     storageOf_name_qualification_length =  source->p_name_qualification_length ;
     storageOf_type_elaboration_required =  source->p_type_elaboration_required ;
     storageOf_global_qualification_required =  source->p_global_qualification_required ;
     storageOf_name_qualification_length_for_return_type =  source->p_name_qualification_length_for_return_type ;
     storageOf_type_elaboration_required_for_return_type =  source->p_type_elaboration_required_for_return_type ;
     storageOf_global_qualification_required_for_return_type =  source->p_global_qualification_required_for_return_type ;
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgProgramHeaderStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     SgFunctionModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     SgSpecialFunctionModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgTypePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgProgramHeaderStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     SgFunctionModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     SgSpecialFunctionModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgTypePtrList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgProgramHeaderStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     SgFunctionModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     SgSpecialFunctionModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgTypePtrList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgProgramHeaderStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     SgFunctionModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     SgSpecialFunctionModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgTypePtrList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 19276 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgProcedureHeaderStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 19289 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgProcedureHeaderStatementStorageClass::pickOutIRNodeData ( SgProcedureHeaderStatement* pointer ) 
   { 
     SgProcedureHeaderStatement* source = (SgProcedureHeaderStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_subprogram_kind =  source->p_subprogram_kind ;
     storageOf_end_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_end_numeric_label );
     storageOf_result_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_result_name );
     storageOf_name.pickOutIRNodeData( &(source->p_name) );
     storageOf_parameterList = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parameterList );
     storageOf_functionModifier.pickOutIRNodeData( &(source->p_functionModifier) );
     storageOf_specialFunctionModifier.pickOutIRNodeData( &(source->p_specialFunctionModifier) );
     SgTypePtrList::iterator i_exceptionSpecification = source->p_exceptionSpecification.begin() ; 
     unsigned int tempListCountexceptionSpecification = 0; 
     SgTypePtrList::value_type *  tempListexceptionSpecification = new SgTypePtrList::value_type[ source->p_exceptionSpecification.size() ]; 
     for ( ; i_exceptionSpecification != source->p_exceptionSpecification.end(); ++i_exceptionSpecification ) 
        {
          tempListexceptionSpecification[tempListCountexceptionSpecification] = *i_exceptionSpecification;
          tempListCountexceptionSpecification++; 
          (*i_exceptionSpecification) = (SgTypePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_exceptionSpecification ) );
        }
     storageOf_exceptionSpecification.storeDataInEasyStorageClass(source->p_exceptionSpecification);
     tempListCountexceptionSpecification = 0; 
     i_exceptionSpecification = source->p_exceptionSpecification.begin() ; 
     for ( ; i_exceptionSpecification != source->p_exceptionSpecification.end(); ++i_exceptionSpecification ) 
        {
          *i_exceptionSpecification = tempListexceptionSpecification[tempListCountexceptionSpecification] ;
          tempListCountexceptionSpecification++; 
        }
      delete [] tempListexceptionSpecification; 
     storageOf_named_in_end_statement =  source->p_named_in_end_statement ;
     storageOf_asm_name.storeDataInEasyStorageClass(source->p_asm_name);
     storageOf_decoratorList = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_decoratorList );
     storageOf_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type );
     storageOf_definition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definition );
     storageOf_oldStyleDefinition =  source->p_oldStyleDefinition ;
     storageOf_scope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_scope );
     storageOf_specialization =  source->p_specialization ;
     storageOf_requiresNameQualificationOnReturnType =  source->p_requiresNameQualificationOnReturnType ;
     storageOf_gnu_extension_section.storeDataInEasyStorageClass(source->p_gnu_extension_section);
     storageOf_gnu_extension_alias.storeDataInEasyStorageClass(source->p_gnu_extension_alias);
     storageOf_gnu_extension_visability =  source->p_gnu_extension_visability ;
     storageOf_name_qualification_length =  source->p_name_qualification_length ;
     storageOf_type_elaboration_required =  source->p_type_elaboration_required ;
     storageOf_global_qualification_required =  source->p_global_qualification_required ;
     storageOf_name_qualification_length_for_return_type =  source->p_name_qualification_length_for_return_type ;
     storageOf_type_elaboration_required_for_return_type =  source->p_type_elaboration_required_for_return_type ;
     storageOf_global_qualification_required_for_return_type =  source->p_global_qualification_required_for_return_type ;
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgProcedureHeaderStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     SgFunctionModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     SgSpecialFunctionModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgTypePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgProcedureHeaderStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     SgFunctionModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     SgSpecialFunctionModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgTypePtrList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgProcedureHeaderStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     SgFunctionModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     SgSpecialFunctionModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgTypePtrList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgProcedureHeaderStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     SgFunctionModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     SgSpecialFunctionModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgTypePtrList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 19445 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgEntryStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 19458 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgEntryStatementStorageClass::pickOutIRNodeData ( SgEntryStatement* pointer ) 
   { 
     SgEntryStatement* source = (SgEntryStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_result_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_result_name );
     storageOf_name.pickOutIRNodeData( &(source->p_name) );
     storageOf_parameterList = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parameterList );
     storageOf_functionModifier.pickOutIRNodeData( &(source->p_functionModifier) );
     storageOf_specialFunctionModifier.pickOutIRNodeData( &(source->p_specialFunctionModifier) );
     SgTypePtrList::iterator i_exceptionSpecification = source->p_exceptionSpecification.begin() ; 
     unsigned int tempListCountexceptionSpecification = 0; 
     SgTypePtrList::value_type *  tempListexceptionSpecification = new SgTypePtrList::value_type[ source->p_exceptionSpecification.size() ]; 
     for ( ; i_exceptionSpecification != source->p_exceptionSpecification.end(); ++i_exceptionSpecification ) 
        {
          tempListexceptionSpecification[tempListCountexceptionSpecification] = *i_exceptionSpecification;
          tempListCountexceptionSpecification++; 
          (*i_exceptionSpecification) = (SgTypePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_exceptionSpecification ) );
        }
     storageOf_exceptionSpecification.storeDataInEasyStorageClass(source->p_exceptionSpecification);
     tempListCountexceptionSpecification = 0; 
     i_exceptionSpecification = source->p_exceptionSpecification.begin() ; 
     for ( ; i_exceptionSpecification != source->p_exceptionSpecification.end(); ++i_exceptionSpecification ) 
        {
          *i_exceptionSpecification = tempListexceptionSpecification[tempListCountexceptionSpecification] ;
          tempListCountexceptionSpecification++; 
        }
      delete [] tempListexceptionSpecification; 
     storageOf_named_in_end_statement =  source->p_named_in_end_statement ;
     storageOf_asm_name.storeDataInEasyStorageClass(source->p_asm_name);
     storageOf_decoratorList = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_decoratorList );
     storageOf_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type );
     storageOf_definition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definition );
     storageOf_oldStyleDefinition =  source->p_oldStyleDefinition ;
     storageOf_scope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_scope );
     storageOf_specialization =  source->p_specialization ;
     storageOf_requiresNameQualificationOnReturnType =  source->p_requiresNameQualificationOnReturnType ;
     storageOf_gnu_extension_section.storeDataInEasyStorageClass(source->p_gnu_extension_section);
     storageOf_gnu_extension_alias.storeDataInEasyStorageClass(source->p_gnu_extension_alias);
     storageOf_gnu_extension_visability =  source->p_gnu_extension_visability ;
     storageOf_name_qualification_length =  source->p_name_qualification_length ;
     storageOf_type_elaboration_required =  source->p_type_elaboration_required ;
     storageOf_global_qualification_required =  source->p_global_qualification_required ;
     storageOf_name_qualification_length_for_return_type =  source->p_name_qualification_length_for_return_type ;
     storageOf_type_elaboration_required_for_return_type =  source->p_type_elaboration_required_for_return_type ;
     storageOf_global_qualification_required_for_return_type =  source->p_global_qualification_required_for_return_type ;
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgEntryStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     SgFunctionModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     SgSpecialFunctionModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgTypePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgEntryStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     SgFunctionModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     SgSpecialFunctionModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgTypePtrList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgEntryStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     SgFunctionModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     SgSpecialFunctionModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgTypePtrList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgEntryStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     SgFunctionModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     SgSpecialFunctionModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgTypePtrList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 19612 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgContainsStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 19625 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgContainsStatementStorageClass::pickOutIRNodeData ( SgContainsStatement* pointer ) 
   { 
     SgContainsStatement* source = (SgContainsStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgContainsStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgContainsStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgContainsStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgContainsStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 19722 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgC_PreprocessorDirectiveStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 19735 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgC_PreprocessorDirectiveStatementStorageClass::pickOutIRNodeData ( SgC_PreprocessorDirectiveStatement* pointer ) 
   { 
     SgC_PreprocessorDirectiveStatement* source = (SgC_PreprocessorDirectiveStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_directiveString.storeDataInEasyStorageClass(source->p_directiveString);
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgC_PreprocessorDirectiveStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgC_PreprocessorDirectiveStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgC_PreprocessorDirectiveStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgC_PreprocessorDirectiveStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 19833 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgIncludeDirectiveStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 19846 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgIncludeDirectiveStatementStorageClass::pickOutIRNodeData ( SgIncludeDirectiveStatement* pointer ) 
   { 
     SgIncludeDirectiveStatement* source = (SgIncludeDirectiveStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_headerFileBody = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_headerFileBody );
     storageOf_directiveString.storeDataInEasyStorageClass(source->p_directiveString);
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgIncludeDirectiveStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgIncludeDirectiveStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgIncludeDirectiveStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgIncludeDirectiveStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 19945 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgDefineDirectiveStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 19958 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgDefineDirectiveStatementStorageClass::pickOutIRNodeData ( SgDefineDirectiveStatement* pointer ) 
   { 
     SgDefineDirectiveStatement* source = (SgDefineDirectiveStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_directiveString.storeDataInEasyStorageClass(source->p_directiveString);
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgDefineDirectiveStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgDefineDirectiveStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgDefineDirectiveStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgDefineDirectiveStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 20056 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgUndefDirectiveStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 20069 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgUndefDirectiveStatementStorageClass::pickOutIRNodeData ( SgUndefDirectiveStatement* pointer ) 
   { 
     SgUndefDirectiveStatement* source = (SgUndefDirectiveStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_directiveString.storeDataInEasyStorageClass(source->p_directiveString);
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgUndefDirectiveStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgUndefDirectiveStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgUndefDirectiveStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgUndefDirectiveStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 20167 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgIfdefDirectiveStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 20180 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgIfdefDirectiveStatementStorageClass::pickOutIRNodeData ( SgIfdefDirectiveStatement* pointer ) 
   { 
     SgIfdefDirectiveStatement* source = (SgIfdefDirectiveStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_directiveString.storeDataInEasyStorageClass(source->p_directiveString);
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgIfdefDirectiveStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgIfdefDirectiveStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgIfdefDirectiveStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgIfdefDirectiveStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 20278 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgIfndefDirectiveStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 20291 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgIfndefDirectiveStatementStorageClass::pickOutIRNodeData ( SgIfndefDirectiveStatement* pointer ) 
   { 
     SgIfndefDirectiveStatement* source = (SgIfndefDirectiveStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_directiveString.storeDataInEasyStorageClass(source->p_directiveString);
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgIfndefDirectiveStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgIfndefDirectiveStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgIfndefDirectiveStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgIfndefDirectiveStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 20389 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgIfDirectiveStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 20402 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgIfDirectiveStatementStorageClass::pickOutIRNodeData ( SgIfDirectiveStatement* pointer ) 
   { 
     SgIfDirectiveStatement* source = (SgIfDirectiveStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_directiveString.storeDataInEasyStorageClass(source->p_directiveString);
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgIfDirectiveStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgIfDirectiveStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgIfDirectiveStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgIfDirectiveStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 20500 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgDeadIfDirectiveStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 20513 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgDeadIfDirectiveStatementStorageClass::pickOutIRNodeData ( SgDeadIfDirectiveStatement* pointer ) 
   { 
     SgDeadIfDirectiveStatement* source = (SgDeadIfDirectiveStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_directiveString.storeDataInEasyStorageClass(source->p_directiveString);
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgDeadIfDirectiveStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgDeadIfDirectiveStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgDeadIfDirectiveStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgDeadIfDirectiveStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 20611 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgElseDirectiveStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 20624 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgElseDirectiveStatementStorageClass::pickOutIRNodeData ( SgElseDirectiveStatement* pointer ) 
   { 
     SgElseDirectiveStatement* source = (SgElseDirectiveStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_directiveString.storeDataInEasyStorageClass(source->p_directiveString);
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgElseDirectiveStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgElseDirectiveStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgElseDirectiveStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgElseDirectiveStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 20722 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgElseifDirectiveStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 20735 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgElseifDirectiveStatementStorageClass::pickOutIRNodeData ( SgElseifDirectiveStatement* pointer ) 
   { 
     SgElseifDirectiveStatement* source = (SgElseifDirectiveStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_directiveString.storeDataInEasyStorageClass(source->p_directiveString);
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgElseifDirectiveStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgElseifDirectiveStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgElseifDirectiveStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgElseifDirectiveStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 20833 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgEndifDirectiveStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 20846 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgEndifDirectiveStatementStorageClass::pickOutIRNodeData ( SgEndifDirectiveStatement* pointer ) 
   { 
     SgEndifDirectiveStatement* source = (SgEndifDirectiveStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_directiveString.storeDataInEasyStorageClass(source->p_directiveString);
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgEndifDirectiveStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgEndifDirectiveStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgEndifDirectiveStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgEndifDirectiveStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 20944 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgLineDirectiveStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 20957 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgLineDirectiveStatementStorageClass::pickOutIRNodeData ( SgLineDirectiveStatement* pointer ) 
   { 
     SgLineDirectiveStatement* source = (SgLineDirectiveStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_directiveString.storeDataInEasyStorageClass(source->p_directiveString);
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgLineDirectiveStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgLineDirectiveStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgLineDirectiveStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgLineDirectiveStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 21055 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgWarningDirectiveStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 21068 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgWarningDirectiveStatementStorageClass::pickOutIRNodeData ( SgWarningDirectiveStatement* pointer ) 
   { 
     SgWarningDirectiveStatement* source = (SgWarningDirectiveStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_directiveString.storeDataInEasyStorageClass(source->p_directiveString);
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgWarningDirectiveStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgWarningDirectiveStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgWarningDirectiveStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgWarningDirectiveStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 21166 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgErrorDirectiveStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 21179 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgErrorDirectiveStatementStorageClass::pickOutIRNodeData ( SgErrorDirectiveStatement* pointer ) 
   { 
     SgErrorDirectiveStatement* source = (SgErrorDirectiveStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_directiveString.storeDataInEasyStorageClass(source->p_directiveString);
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgErrorDirectiveStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgErrorDirectiveStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgErrorDirectiveStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgErrorDirectiveStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 21277 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgEmptyDirectiveStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 21290 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgEmptyDirectiveStatementStorageClass::pickOutIRNodeData ( SgEmptyDirectiveStatement* pointer ) 
   { 
     SgEmptyDirectiveStatement* source = (SgEmptyDirectiveStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_directiveString.storeDataInEasyStorageClass(source->p_directiveString);
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgEmptyDirectiveStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgEmptyDirectiveStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgEmptyDirectiveStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgEmptyDirectiveStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 21388 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgIncludeNextDirectiveStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 21401 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgIncludeNextDirectiveStatementStorageClass::pickOutIRNodeData ( SgIncludeNextDirectiveStatement* pointer ) 
   { 
     SgIncludeNextDirectiveStatement* source = (SgIncludeNextDirectiveStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_directiveString.storeDataInEasyStorageClass(source->p_directiveString);
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgIncludeNextDirectiveStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgIncludeNextDirectiveStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgIncludeNextDirectiveStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgIncludeNextDirectiveStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 21499 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgIdentDirectiveStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 21512 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgIdentDirectiveStatementStorageClass::pickOutIRNodeData ( SgIdentDirectiveStatement* pointer ) 
   { 
     SgIdentDirectiveStatement* source = (SgIdentDirectiveStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_directiveString.storeDataInEasyStorageClass(source->p_directiveString);
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgIdentDirectiveStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgIdentDirectiveStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgIdentDirectiveStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgIdentDirectiveStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 21610 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgLinemarkerDirectiveStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 21623 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgLinemarkerDirectiveStatementStorageClass::pickOutIRNodeData ( SgLinemarkerDirectiveStatement* pointer ) 
   { 
     SgLinemarkerDirectiveStatement* source = (SgLinemarkerDirectiveStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_linenumber =  source->p_linenumber ;
     storageOf_filename.storeDataInEasyStorageClass(source->p_filename);
     storageOf_flaglist.storeDataInEasyStorageClass(source->p_flaglist);
     storageOf_directiveString.storeDataInEasyStorageClass(source->p_directiveString);
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgLinemarkerDirectiveStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgUnsignedCharList > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgLinemarkerDirectiveStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < SgUnsignedCharList > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgLinemarkerDirectiveStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < SgUnsignedCharList > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgLinemarkerDirectiveStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < SgUnsignedCharList > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 21728 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgOmpThreadprivateStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 21741 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgOmpThreadprivateStatementStorageClass::pickOutIRNodeData ( SgOmpThreadprivateStatement* pointer ) 
   { 
     SgOmpThreadprivateStatement* source = (SgOmpThreadprivateStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgVarRefExpPtrList::iterator i_variables = source->p_variables.begin() ; 
     unsigned int tempListCountvariables = 0; 
     SgVarRefExpPtrList::value_type *  tempListvariables = new SgVarRefExpPtrList::value_type[ source->p_variables.size() ]; 
     for ( ; i_variables != source->p_variables.end(); ++i_variables ) 
        {
          tempListvariables[tempListCountvariables] = *i_variables;
          tempListCountvariables++; 
          (*i_variables) = (SgVarRefExpPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_variables ) );
        }
     storageOf_variables.storeDataInEasyStorageClass(source->p_variables);
     tempListCountvariables = 0; 
     i_variables = source->p_variables.begin() ; 
     for ( ; i_variables != source->p_variables.end(); ++i_variables ) 
        {
          *i_variables = tempListvariables[tempListCountvariables] ;
          tempListCountvariables++; 
        }
      delete [] tempListvariables; 
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgOmpThreadprivateStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgVarRefExpPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgOmpThreadprivateStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgVarRefExpPtrList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgOmpThreadprivateStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgVarRefExpPtrList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgOmpThreadprivateStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgVarRefExpPtrList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 21860 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgFortranIncludeLineStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 21873 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgFortranIncludeLineStorageClass::pickOutIRNodeData ( SgFortranIncludeLine* pointer ) 
   { 
     SgFortranIncludeLine* source = (SgFortranIncludeLine*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_filename.storeDataInEasyStorageClass(source->p_filename);
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgFortranIncludeLineStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgFortranIncludeLineStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgFortranIncludeLineStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgFortranIncludeLineStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 21971 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgJavaImportStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 21984 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgJavaImportStatementStorageClass::pickOutIRNodeData ( SgJavaImportStatement* pointer ) 
   { 
     SgJavaImportStatement* source = (SgJavaImportStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_path.pickOutIRNodeData( &(source->p_path) );
     storageOf_containsWildCard =  source->p_containsWildCard ;
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgJavaImportStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgJavaImportStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgJavaImportStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgJavaImportStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 22087 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgStmtDeclarationStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 22100 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgStmtDeclarationStatementStorageClass::pickOutIRNodeData ( SgStmtDeclarationStatement* pointer ) 
   { 
     SgStmtDeclarationStatement* source = (SgStmtDeclarationStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_statement = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_statement );
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgStmtDeclarationStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgStmtDeclarationStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgStmtDeclarationStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgStmtDeclarationStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 22198 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgExprStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 22211 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgExprStatementStorageClass::pickOutIRNodeData ( SgExprStatement* pointer ) 
   { 
     SgExprStatement* source = (SgExprStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_expression = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgExprStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgExprStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgExprStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgExprStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 22269 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgLabelStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 22282 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgLabelStatementStorageClass::pickOutIRNodeData ( SgLabelStatement* pointer ) 
   { 
     SgLabelStatement* source = (SgLabelStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_label.pickOutIRNodeData( &(source->p_label) );
     storageOf_scope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_scope );
     storageOf_statement = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_statement );
     storageOf_gnu_extension_unused =  source->p_gnu_extension_unused ;
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgLabelStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgLabelStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgLabelStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgLabelStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 22347 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgCaseOptionStmtStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 22360 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgCaseOptionStmtStorageClass::pickOutIRNodeData ( SgCaseOptionStmt* pointer ) 
   { 
     SgCaseOptionStmt* source = (SgCaseOptionStmt*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_key = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_key );
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     storageOf_key_range_end = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_key_range_end );
     storageOf_case_construct_name.storeDataInEasyStorageClass(source->p_case_construct_name);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgCaseOptionStmtStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgCaseOptionStmtStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgCaseOptionStmtStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgCaseOptionStmtStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 22425 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTryStmtStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 22438 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgTryStmtStorageClass::pickOutIRNodeData ( SgTryStmt* pointer ) 
   { 
     SgTryStmt* source = (SgTryStmt*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     storageOf_catch_statement_seq_root = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_catch_statement_seq_root );
     storageOf_else_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_else_body );
     storageOf_finally_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_finally_body );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgTryStmtStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTryStmtStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTryStmtStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTryStmtStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 22499 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgDefaultOptionStmtStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 22512 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgDefaultOptionStmtStorageClass::pickOutIRNodeData ( SgDefaultOptionStmt* pointer ) 
   { 
     SgDefaultOptionStmt* source = (SgDefaultOptionStmt*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     storageOf_default_construct_name.storeDataInEasyStorageClass(source->p_default_construct_name);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgDefaultOptionStmtStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgDefaultOptionStmtStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgDefaultOptionStmtStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgDefaultOptionStmtStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 22575 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgBreakStmtStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 22588 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgBreakStmtStorageClass::pickOutIRNodeData ( SgBreakStmt* pointer ) 
   { 
     SgBreakStmt* source = (SgBreakStmt*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_do_string_label.storeDataInEasyStorageClass(source->p_do_string_label);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgBreakStmtStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgBreakStmtStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgBreakStmtStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgBreakStmtStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 22650 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgContinueStmtStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 22663 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgContinueStmtStorageClass::pickOutIRNodeData ( SgContinueStmt* pointer ) 
   { 
     SgContinueStmt* source = (SgContinueStmt*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_do_string_label.storeDataInEasyStorageClass(source->p_do_string_label);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgContinueStmtStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgContinueStmtStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgContinueStmtStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgContinueStmtStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 22725 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgReturnStmtStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 22738 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgReturnStmtStorageClass::pickOutIRNodeData ( SgReturnStmt* pointer ) 
   { 
     SgReturnStmt* source = (SgReturnStmt*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_expression = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgReturnStmtStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgReturnStmtStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgReturnStmtStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgReturnStmtStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 22796 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgGotoStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 22809 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgGotoStatementStorageClass::pickOutIRNodeData ( SgGotoStatement* pointer ) 
   { 
     SgGotoStatement* source = (SgGotoStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_label );
     storageOf_label_expression = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_label_expression );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgGotoStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgGotoStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgGotoStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgGotoStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 22868 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgSpawnStmtStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 22881 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgSpawnStmtStorageClass::pickOutIRNodeData ( SgSpawnStmt* pointer ) 
   { 
     SgSpawnStmt* source = (SgSpawnStmt*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_the_func = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_the_func );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgSpawnStmtStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgSpawnStmtStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgSpawnStmtStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgSpawnStmtStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 22939 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgNullStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 22952 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgNullStatementStorageClass::pickOutIRNodeData ( SgNullStatement* pointer ) 
   { 
     SgNullStatement* source = (SgNullStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgNullStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgNullStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgNullStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgNullStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 23009 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgVariantStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 23022 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgVariantStatementStorageClass::pickOutIRNodeData ( SgVariantStatement* pointer ) 
   { 
     SgVariantStatement* source = (SgVariantStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgVariantStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgVariantStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgVariantStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgVariantStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 23079 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgForInitStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 23092 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgForInitStatementStorageClass::pickOutIRNodeData ( SgForInitStatement* pointer ) 
   { 
     SgForInitStatement* source = (SgForInitStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgStatementPtrList::iterator i_init_stmt = source->p_init_stmt.begin() ; 
     unsigned int tempListCountinit_stmt = 0; 
     SgStatementPtrList::value_type *  tempListinit_stmt = new SgStatementPtrList::value_type[ source->p_init_stmt.size() ]; 
     for ( ; i_init_stmt != source->p_init_stmt.end(); ++i_init_stmt ) 
        {
          tempListinit_stmt[tempListCountinit_stmt] = *i_init_stmt;
          tempListCountinit_stmt++; 
          (*i_init_stmt) = (SgStatementPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_init_stmt ) );
        }
     storageOf_init_stmt.storeDataInEasyStorageClass(source->p_init_stmt);
     tempListCountinit_stmt = 0; 
     i_init_stmt = source->p_init_stmt.begin() ; 
     for ( ; i_init_stmt != source->p_init_stmt.end(); ++i_init_stmt ) 
        {
          *i_init_stmt = tempListinit_stmt[tempListCountinit_stmt] ;
          tempListCountinit_stmt++; 
        }
      delete [] tempListinit_stmt; 
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgForInitStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgStatementPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgForInitStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgStatementPtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgForInitStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgStatementPtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgForInitStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgStatementPtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 23171 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgCatchStatementSeqStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 23184 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgCatchStatementSeqStorageClass::pickOutIRNodeData ( SgCatchStatementSeq* pointer ) 
   { 
     SgCatchStatementSeq* source = (SgCatchStatementSeq*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgStatementPtrList::iterator i_catch_statement_seq = source->p_catch_statement_seq.begin() ; 
     unsigned int tempListCountcatch_statement_seq = 0; 
     SgStatementPtrList::value_type *  tempListcatch_statement_seq = new SgStatementPtrList::value_type[ source->p_catch_statement_seq.size() ]; 
     for ( ; i_catch_statement_seq != source->p_catch_statement_seq.end(); ++i_catch_statement_seq ) 
        {
          tempListcatch_statement_seq[tempListCountcatch_statement_seq] = *i_catch_statement_seq;
          tempListCountcatch_statement_seq++; 
          (*i_catch_statement_seq) = (SgStatementPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_catch_statement_seq ) );
        }
     storageOf_catch_statement_seq.storeDataInEasyStorageClass(source->p_catch_statement_seq);
     tempListCountcatch_statement_seq = 0; 
     i_catch_statement_seq = source->p_catch_statement_seq.begin() ; 
     for ( ; i_catch_statement_seq != source->p_catch_statement_seq.end(); ++i_catch_statement_seq ) 
        {
          *i_catch_statement_seq = tempListcatch_statement_seq[tempListCountcatch_statement_seq] ;
          tempListCountcatch_statement_seq++; 
        }
      delete [] tempListcatch_statement_seq; 
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgCatchStatementSeqStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgStatementPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgCatchStatementSeqStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgStatementPtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgCatchStatementSeqStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgStatementPtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgCatchStatementSeqStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgStatementPtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 23263 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgStopOrPauseStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 23276 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgStopOrPauseStatementStorageClass::pickOutIRNodeData ( SgStopOrPauseStatement* pointer ) 
   { 
     SgStopOrPauseStatement* source = (SgStopOrPauseStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_stop_or_pause =  source->p_stop_or_pause ;
     storageOf_code = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_code );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgStopOrPauseStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgStopOrPauseStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgStopOrPauseStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgStopOrPauseStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 23335 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgIOStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 23348 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgIOStatementStorageClass::pickOutIRNodeData ( SgIOStatement* pointer ) 
   { 
     SgIOStatement* source = (SgIOStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_io_statement =  source->p_io_statement ;
     storageOf_io_stmt_list = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_io_stmt_list );
     storageOf_unit = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_unit );
     storageOf_iostat = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_iostat );
     storageOf_err = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_err );
     storageOf_iomsg = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_iomsg );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgIOStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgIOStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgIOStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgIOStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 23411 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgPrintStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 23424 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgPrintStatementStorageClass::pickOutIRNodeData ( SgPrintStatement* pointer ) 
   { 
     SgPrintStatement* source = (SgPrintStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_format = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_format );
     storageOf_io_statement =  source->p_io_statement ;
     storageOf_io_stmt_list = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_io_stmt_list );
     storageOf_unit = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_unit );
     storageOf_iostat = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_iostat );
     storageOf_err = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_err );
     storageOf_iomsg = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_iomsg );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgPrintStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgPrintStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgPrintStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgPrintStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 23488 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgReadStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 23501 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgReadStatementStorageClass::pickOutIRNodeData ( SgReadStatement* pointer ) 
   { 
     SgReadStatement* source = (SgReadStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_format = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_format );
     storageOf_rec = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rec );
     storageOf_end = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_end );
     storageOf_namelist = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_namelist );
     storageOf_advance = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_advance );
     storageOf_size = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_size );
     storageOf_eor = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_eor );
     storageOf_asynchronous = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_asynchronous );
     storageOf_io_statement =  source->p_io_statement ;
     storageOf_io_stmt_list = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_io_stmt_list );
     storageOf_unit = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_unit );
     storageOf_iostat = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_iostat );
     storageOf_err = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_err );
     storageOf_iomsg = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_iomsg );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgReadStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgReadStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgReadStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgReadStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 23572 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgWriteStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 23585 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgWriteStatementStorageClass::pickOutIRNodeData ( SgWriteStatement* pointer ) 
   { 
     SgWriteStatement* source = (SgWriteStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_format = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_format );
     storageOf_rec = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rec );
     storageOf_namelist = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_namelist );
     storageOf_advance = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_advance );
     storageOf_asynchronous = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_asynchronous );
     storageOf_io_statement =  source->p_io_statement ;
     storageOf_io_stmt_list = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_io_stmt_list );
     storageOf_unit = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_unit );
     storageOf_iostat = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_iostat );
     storageOf_err = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_err );
     storageOf_iomsg = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_iomsg );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgWriteStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgWriteStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgWriteStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgWriteStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 23653 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgOpenStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 23666 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgOpenStatementStorageClass::pickOutIRNodeData ( SgOpenStatement* pointer ) 
   { 
     SgOpenStatement* source = (SgOpenStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_file = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_file );
     storageOf_status = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_status );
     storageOf_access = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_access );
     storageOf_form = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_form );
     storageOf_recl = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_recl );
     storageOf_blank = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_blank );
     storageOf_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_position );
     storageOf_action = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_action );
     storageOf_delim = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_delim );
     storageOf_pad = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_pad );
     storageOf_round = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_round );
     storageOf_sign = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_sign );
     storageOf_asynchronous = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_asynchronous );
     storageOf_io_statement =  source->p_io_statement ;
     storageOf_io_stmt_list = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_io_stmt_list );
     storageOf_unit = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_unit );
     storageOf_iostat = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_iostat );
     storageOf_err = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_err );
     storageOf_iomsg = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_iomsg );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgOpenStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgOpenStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgOpenStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgOpenStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 23742 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgCloseStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 23755 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgCloseStatementStorageClass::pickOutIRNodeData ( SgCloseStatement* pointer ) 
   { 
     SgCloseStatement* source = (SgCloseStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_status = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_status );
     storageOf_io_statement =  source->p_io_statement ;
     storageOf_io_stmt_list = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_io_stmt_list );
     storageOf_unit = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_unit );
     storageOf_iostat = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_iostat );
     storageOf_err = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_err );
     storageOf_iomsg = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_iomsg );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgCloseStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgCloseStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgCloseStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgCloseStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 23819 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgInquireStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 23832 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgInquireStatementStorageClass::pickOutIRNodeData ( SgInquireStatement* pointer ) 
   { 
     SgInquireStatement* source = (SgInquireStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_file = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_file );
     storageOf_access = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_access );
     storageOf_form = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_form );
     storageOf_recl = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_recl );
     storageOf_blank = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_blank );
     storageOf_exist = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_exist );
     storageOf_opened = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_opened );
     storageOf_number = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_number );
     storageOf_named = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_named );
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_sequential = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_sequential );
     storageOf_direct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_direct );
     storageOf_formatted = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_formatted );
     storageOf_unformatted = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_unformatted );
     storageOf_nextrec = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_nextrec );
     storageOf_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_position );
     storageOf_action = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_action );
     storageOf_read = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_read );
     storageOf_write = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_write );
     storageOf_readwrite = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_readwrite );
     storageOf_delim = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_delim );
     storageOf_pad = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_pad );
     storageOf_asynchronous = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_asynchronous );
     storageOf_decimal = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_decimal );
     storageOf_stream = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_stream );
     storageOf_size = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_size );
     storageOf_pending = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_pending );
     storageOf_iolengthExp = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_iolengthExp );
     storageOf_io_statement =  source->p_io_statement ;
     storageOf_io_stmt_list = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_io_stmt_list );
     storageOf_unit = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_unit );
     storageOf_iostat = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_iostat );
     storageOf_err = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_err );
     storageOf_iomsg = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_iomsg );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgInquireStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgInquireStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgInquireStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgInquireStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 23923 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgFlushStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 23936 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgFlushStatementStorageClass::pickOutIRNodeData ( SgFlushStatement* pointer ) 
   { 
     SgFlushStatement* source = (SgFlushStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_io_statement =  source->p_io_statement ;
     storageOf_io_stmt_list = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_io_stmt_list );
     storageOf_unit = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_unit );
     storageOf_iostat = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_iostat );
     storageOf_err = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_err );
     storageOf_iomsg = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_iomsg );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgFlushStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgFlushStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgFlushStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgFlushStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 23999 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgBackspaceStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 24012 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgBackspaceStatementStorageClass::pickOutIRNodeData ( SgBackspaceStatement* pointer ) 
   { 
     SgBackspaceStatement* source = (SgBackspaceStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_io_statement =  source->p_io_statement ;
     storageOf_io_stmt_list = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_io_stmt_list );
     storageOf_unit = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_unit );
     storageOf_iostat = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_iostat );
     storageOf_err = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_err );
     storageOf_iomsg = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_iomsg );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgBackspaceStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgBackspaceStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgBackspaceStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgBackspaceStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 24075 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgRewindStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 24088 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgRewindStatementStorageClass::pickOutIRNodeData ( SgRewindStatement* pointer ) 
   { 
     SgRewindStatement* source = (SgRewindStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_io_statement =  source->p_io_statement ;
     storageOf_io_stmt_list = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_io_stmt_list );
     storageOf_unit = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_unit );
     storageOf_iostat = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_iostat );
     storageOf_err = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_err );
     storageOf_iomsg = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_iomsg );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgRewindStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgRewindStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgRewindStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgRewindStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 24151 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgEndfileStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 24164 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgEndfileStatementStorageClass::pickOutIRNodeData ( SgEndfileStatement* pointer ) 
   { 
     SgEndfileStatement* source = (SgEndfileStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_io_statement =  source->p_io_statement ;
     storageOf_io_stmt_list = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_io_stmt_list );
     storageOf_unit = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_unit );
     storageOf_iostat = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_iostat );
     storageOf_err = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_err );
     storageOf_iomsg = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_iomsg );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgEndfileStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgEndfileStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgEndfileStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgEndfileStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 24227 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgWaitStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 24240 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgWaitStatementStorageClass::pickOutIRNodeData ( SgWaitStatement* pointer ) 
   { 
     SgWaitStatement* source = (SgWaitStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_io_statement =  source->p_io_statement ;
     storageOf_io_stmt_list = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_io_stmt_list );
     storageOf_unit = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_unit );
     storageOf_iostat = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_iostat );
     storageOf_err = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_err );
     storageOf_iomsg = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_iomsg );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgWaitStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgWaitStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgWaitStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgWaitStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 24303 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgWhereStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 24316 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgWhereStatementStorageClass::pickOutIRNodeData ( SgWhereStatement* pointer ) 
   { 
     SgWhereStatement* source = (SgWhereStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_condition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_condition );
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     storageOf_elsewhere = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_elsewhere );
     storageOf_end_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_end_numeric_label );
     storageOf_string_label.storeDataInEasyStorageClass(source->p_string_label);
     storageOf_has_end_statement =  source->p_has_end_statement ;
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgWhereStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgWhereStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgWhereStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgWhereStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 24383 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgElseWhereStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 24396 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgElseWhereStatementStorageClass::pickOutIRNodeData ( SgElseWhereStatement* pointer ) 
   { 
     SgElseWhereStatement* source = (SgElseWhereStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_condition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_condition );
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     storageOf_elsewhere = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_elsewhere );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgElseWhereStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgElseWhereStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgElseWhereStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgElseWhereStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 24456 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgNullifyStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 24469 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgNullifyStatementStorageClass::pickOutIRNodeData ( SgNullifyStatement* pointer ) 
   { 
     SgNullifyStatement* source = (SgNullifyStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_pointer_list = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_pointer_list );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgNullifyStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgNullifyStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgNullifyStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgNullifyStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 24527 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgArithmeticIfStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 24540 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgArithmeticIfStatementStorageClass::pickOutIRNodeData ( SgArithmeticIfStatement* pointer ) 
   { 
     SgArithmeticIfStatement* source = (SgArithmeticIfStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_conditional = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_conditional );
     storageOf_less_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_less_label );
     storageOf_equal_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_equal_label );
     storageOf_greater_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_greater_label );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgArithmeticIfStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgArithmeticIfStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgArithmeticIfStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgArithmeticIfStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 24601 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAssignStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 24614 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAssignStatementStorageClass::pickOutIRNodeData ( SgAssignStatement* pointer ) 
   { 
     SgAssignStatement* source = (SgAssignStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_label );
     storageOf_value = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_value );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAssignStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAssignStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAssignStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAssignStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 24673 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgComputedGotoStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 24686 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgComputedGotoStatementStorageClass::pickOutIRNodeData ( SgComputedGotoStatement* pointer ) 
   { 
     SgComputedGotoStatement* source = (SgComputedGotoStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_labelList = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_labelList );
     storageOf_label_index = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_label_index );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgComputedGotoStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgComputedGotoStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgComputedGotoStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgComputedGotoStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 24745 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAssignedGotoStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 24758 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAssignedGotoStatementStorageClass::pickOutIRNodeData ( SgAssignedGotoStatement* pointer ) 
   { 
     SgAssignedGotoStatement* source = (SgAssignedGotoStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_targets = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_targets );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAssignedGotoStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAssignedGotoStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAssignedGotoStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAssignedGotoStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 24816 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAllocateStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 24829 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAllocateStatementStorageClass::pickOutIRNodeData ( SgAllocateStatement* pointer ) 
   { 
     SgAllocateStatement* source = (SgAllocateStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_expr_list = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expr_list );
     storageOf_stat_expression = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_stat_expression );
     storageOf_errmsg_expression = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_errmsg_expression );
     storageOf_source_expression = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_expression );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAllocateStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAllocateStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAllocateStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAllocateStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 24890 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgDeallocateStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 24903 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgDeallocateStatementStorageClass::pickOutIRNodeData ( SgDeallocateStatement* pointer ) 
   { 
     SgDeallocateStatement* source = (SgDeallocateStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_expr_list = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expr_list );
     storageOf_stat_expression = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_stat_expression );
     storageOf_errmsg_expression = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_errmsg_expression );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgDeallocateStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgDeallocateStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgDeallocateStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgDeallocateStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 24963 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgUpcNotifyStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 24976 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgUpcNotifyStatementStorageClass::pickOutIRNodeData ( SgUpcNotifyStatement* pointer ) 
   { 
     SgUpcNotifyStatement* source = (SgUpcNotifyStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_notify_expression = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_notify_expression );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgUpcNotifyStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgUpcNotifyStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgUpcNotifyStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgUpcNotifyStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 25034 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgUpcWaitStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 25047 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgUpcWaitStatementStorageClass::pickOutIRNodeData ( SgUpcWaitStatement* pointer ) 
   { 
     SgUpcWaitStatement* source = (SgUpcWaitStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_wait_expression = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_wait_expression );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgUpcWaitStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgUpcWaitStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgUpcWaitStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgUpcWaitStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 25105 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgUpcBarrierStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 25118 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgUpcBarrierStatementStorageClass::pickOutIRNodeData ( SgUpcBarrierStatement* pointer ) 
   { 
     SgUpcBarrierStatement* source = (SgUpcBarrierStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_barrier_expression = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_barrier_expression );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgUpcBarrierStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgUpcBarrierStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgUpcBarrierStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgUpcBarrierStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 25176 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgUpcFenceStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 25189 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgUpcFenceStatementStorageClass::pickOutIRNodeData ( SgUpcFenceStatement* pointer ) 
   { 
     SgUpcFenceStatement* source = (SgUpcFenceStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgUpcFenceStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgUpcFenceStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgUpcFenceStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgUpcFenceStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 25246 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgOmpBarrierStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 25259 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgOmpBarrierStatementStorageClass::pickOutIRNodeData ( SgOmpBarrierStatement* pointer ) 
   { 
     SgOmpBarrierStatement* source = (SgOmpBarrierStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgOmpBarrierStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgOmpBarrierStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgOmpBarrierStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgOmpBarrierStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 25316 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgOmpTaskwaitStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 25329 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgOmpTaskwaitStatementStorageClass::pickOutIRNodeData ( SgOmpTaskwaitStatement* pointer ) 
   { 
     SgOmpTaskwaitStatement* source = (SgOmpTaskwaitStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgOmpTaskwaitStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgOmpTaskwaitStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgOmpTaskwaitStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgOmpTaskwaitStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 25386 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgOmpFlushStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 25399 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgOmpFlushStatementStorageClass::pickOutIRNodeData ( SgOmpFlushStatement* pointer ) 
   { 
     SgOmpFlushStatement* source = (SgOmpFlushStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgVarRefExpPtrList::iterator i_variables = source->p_variables.begin() ; 
     unsigned int tempListCountvariables = 0; 
     SgVarRefExpPtrList::value_type *  tempListvariables = new SgVarRefExpPtrList::value_type[ source->p_variables.size() ]; 
     for ( ; i_variables != source->p_variables.end(); ++i_variables ) 
        {
          tempListvariables[tempListCountvariables] = *i_variables;
          tempListCountvariables++; 
          (*i_variables) = (SgVarRefExpPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_variables ) );
        }
     storageOf_variables.storeDataInEasyStorageClass(source->p_variables);
     tempListCountvariables = 0; 
     i_variables = source->p_variables.begin() ; 
     for ( ; i_variables != source->p_variables.end(); ++i_variables ) 
        {
          *i_variables = tempListvariables[tempListCountvariables] ;
          tempListCountvariables++; 
        }
      delete [] tempListvariables; 
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgOmpFlushStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgVarRefExpPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgOmpFlushStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgVarRefExpPtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgOmpFlushStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgVarRefExpPtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgOmpFlushStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgVarRefExpPtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 25478 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgOmpBodyStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 25491 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgOmpBodyStatementStorageClass::pickOutIRNodeData ( SgOmpBodyStatement* pointer ) 
   { 
     SgOmpBodyStatement* source = (SgOmpBodyStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgOmpBodyStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgOmpBodyStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgOmpBodyStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgOmpBodyStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 25549 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgOmpAtomicStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 25562 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgOmpAtomicStatementStorageClass::pickOutIRNodeData ( SgOmpAtomicStatement* pointer ) 
   { 
     SgOmpAtomicStatement* source = (SgOmpAtomicStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgOmpAtomicStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgOmpAtomicStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgOmpAtomicStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgOmpAtomicStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 25620 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgOmpMasterStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 25633 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgOmpMasterStatementStorageClass::pickOutIRNodeData ( SgOmpMasterStatement* pointer ) 
   { 
     SgOmpMasterStatement* source = (SgOmpMasterStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgOmpMasterStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgOmpMasterStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgOmpMasterStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgOmpMasterStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 25691 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgOmpOrderedStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 25704 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgOmpOrderedStatementStorageClass::pickOutIRNodeData ( SgOmpOrderedStatement* pointer ) 
   { 
     SgOmpOrderedStatement* source = (SgOmpOrderedStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgOmpOrderedStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgOmpOrderedStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgOmpOrderedStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgOmpOrderedStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 25762 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgOmpCriticalStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 25775 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgOmpCriticalStatementStorageClass::pickOutIRNodeData ( SgOmpCriticalStatement* pointer ) 
   { 
     SgOmpCriticalStatement* source = (SgOmpCriticalStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_name.pickOutIRNodeData( &(source->p_name) );
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgOmpCriticalStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgOmpCriticalStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgOmpCriticalStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgOmpCriticalStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 25838 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgOmpSectionStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 25851 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgOmpSectionStatementStorageClass::pickOutIRNodeData ( SgOmpSectionStatement* pointer ) 
   { 
     SgOmpSectionStatement* source = (SgOmpSectionStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgOmpSectionStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgOmpSectionStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgOmpSectionStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgOmpSectionStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 25909 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgOmpWorkshareStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 25922 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgOmpWorkshareStatementStorageClass::pickOutIRNodeData ( SgOmpWorkshareStatement* pointer ) 
   { 
     SgOmpWorkshareStatement* source = (SgOmpWorkshareStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgOmpWorkshareStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgOmpWorkshareStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgOmpWorkshareStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgOmpWorkshareStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 25980 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgOmpClauseBodyStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 25993 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgOmpClauseBodyStatementStorageClass::pickOutIRNodeData ( SgOmpClauseBodyStatement* pointer ) 
   { 
     SgOmpClauseBodyStatement* source = (SgOmpClauseBodyStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgOmpClausePtrList::iterator i_clauses = source->p_clauses.begin() ; 
     unsigned int tempListCountclauses = 0; 
     SgOmpClausePtrList::value_type *  tempListclauses = new SgOmpClausePtrList::value_type[ source->p_clauses.size() ]; 
     for ( ; i_clauses != source->p_clauses.end(); ++i_clauses ) 
        {
          tempListclauses[tempListCountclauses] = *i_clauses;
          tempListCountclauses++; 
          (*i_clauses) = (SgOmpClausePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_clauses ) );
        }
     storageOf_clauses.storeDataInEasyStorageClass(source->p_clauses);
     tempListCountclauses = 0; 
     i_clauses = source->p_clauses.begin() ; 
     for ( ; i_clauses != source->p_clauses.end(); ++i_clauses ) 
        {
          *i_clauses = tempListclauses[tempListCountclauses] ;
          tempListCountclauses++; 
        }
      delete [] tempListclauses; 
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgOmpClauseBodyStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgOmpClausePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgOmpClauseBodyStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgOmpClausePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgOmpClauseBodyStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgOmpClausePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgOmpClauseBodyStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgOmpClausePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 26073 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgOmpParallelStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 26086 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgOmpParallelStatementStorageClass::pickOutIRNodeData ( SgOmpParallelStatement* pointer ) 
   { 
     SgOmpParallelStatement* source = (SgOmpParallelStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgOmpClausePtrList::iterator i_clauses = source->p_clauses.begin() ; 
     unsigned int tempListCountclauses = 0; 
     SgOmpClausePtrList::value_type *  tempListclauses = new SgOmpClausePtrList::value_type[ source->p_clauses.size() ]; 
     for ( ; i_clauses != source->p_clauses.end(); ++i_clauses ) 
        {
          tempListclauses[tempListCountclauses] = *i_clauses;
          tempListCountclauses++; 
          (*i_clauses) = (SgOmpClausePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_clauses ) );
        }
     storageOf_clauses.storeDataInEasyStorageClass(source->p_clauses);
     tempListCountclauses = 0; 
     i_clauses = source->p_clauses.begin() ; 
     for ( ; i_clauses != source->p_clauses.end(); ++i_clauses ) 
        {
          *i_clauses = tempListclauses[tempListCountclauses] ;
          tempListCountclauses++; 
        }
      delete [] tempListclauses; 
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgOmpParallelStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgOmpClausePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgOmpParallelStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgOmpClausePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgOmpParallelStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgOmpClausePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgOmpParallelStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgOmpClausePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 26166 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgOmpSingleStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 26179 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgOmpSingleStatementStorageClass::pickOutIRNodeData ( SgOmpSingleStatement* pointer ) 
   { 
     SgOmpSingleStatement* source = (SgOmpSingleStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgOmpClausePtrList::iterator i_clauses = source->p_clauses.begin() ; 
     unsigned int tempListCountclauses = 0; 
     SgOmpClausePtrList::value_type *  tempListclauses = new SgOmpClausePtrList::value_type[ source->p_clauses.size() ]; 
     for ( ; i_clauses != source->p_clauses.end(); ++i_clauses ) 
        {
          tempListclauses[tempListCountclauses] = *i_clauses;
          tempListCountclauses++; 
          (*i_clauses) = (SgOmpClausePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_clauses ) );
        }
     storageOf_clauses.storeDataInEasyStorageClass(source->p_clauses);
     tempListCountclauses = 0; 
     i_clauses = source->p_clauses.begin() ; 
     for ( ; i_clauses != source->p_clauses.end(); ++i_clauses ) 
        {
          *i_clauses = tempListclauses[tempListCountclauses] ;
          tempListCountclauses++; 
        }
      delete [] tempListclauses; 
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgOmpSingleStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgOmpClausePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgOmpSingleStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgOmpClausePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgOmpSingleStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgOmpClausePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgOmpSingleStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgOmpClausePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 26259 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgOmpTaskStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 26272 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgOmpTaskStatementStorageClass::pickOutIRNodeData ( SgOmpTaskStatement* pointer ) 
   { 
     SgOmpTaskStatement* source = (SgOmpTaskStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgOmpClausePtrList::iterator i_clauses = source->p_clauses.begin() ; 
     unsigned int tempListCountclauses = 0; 
     SgOmpClausePtrList::value_type *  tempListclauses = new SgOmpClausePtrList::value_type[ source->p_clauses.size() ]; 
     for ( ; i_clauses != source->p_clauses.end(); ++i_clauses ) 
        {
          tempListclauses[tempListCountclauses] = *i_clauses;
          tempListCountclauses++; 
          (*i_clauses) = (SgOmpClausePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_clauses ) );
        }
     storageOf_clauses.storeDataInEasyStorageClass(source->p_clauses);
     tempListCountclauses = 0; 
     i_clauses = source->p_clauses.begin() ; 
     for ( ; i_clauses != source->p_clauses.end(); ++i_clauses ) 
        {
          *i_clauses = tempListclauses[tempListCountclauses] ;
          tempListCountclauses++; 
        }
      delete [] tempListclauses; 
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgOmpTaskStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgOmpClausePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgOmpTaskStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgOmpClausePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgOmpTaskStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgOmpClausePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgOmpTaskStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgOmpClausePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 26352 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgOmpForStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 26365 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgOmpForStatementStorageClass::pickOutIRNodeData ( SgOmpForStatement* pointer ) 
   { 
     SgOmpForStatement* source = (SgOmpForStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgOmpClausePtrList::iterator i_clauses = source->p_clauses.begin() ; 
     unsigned int tempListCountclauses = 0; 
     SgOmpClausePtrList::value_type *  tempListclauses = new SgOmpClausePtrList::value_type[ source->p_clauses.size() ]; 
     for ( ; i_clauses != source->p_clauses.end(); ++i_clauses ) 
        {
          tempListclauses[tempListCountclauses] = *i_clauses;
          tempListCountclauses++; 
          (*i_clauses) = (SgOmpClausePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_clauses ) );
        }
     storageOf_clauses.storeDataInEasyStorageClass(source->p_clauses);
     tempListCountclauses = 0; 
     i_clauses = source->p_clauses.begin() ; 
     for ( ; i_clauses != source->p_clauses.end(); ++i_clauses ) 
        {
          *i_clauses = tempListclauses[tempListCountclauses] ;
          tempListCountclauses++; 
        }
      delete [] tempListclauses; 
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgOmpForStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgOmpClausePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgOmpForStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgOmpClausePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgOmpForStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgOmpClausePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgOmpForStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgOmpClausePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 26445 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgOmpDoStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 26458 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgOmpDoStatementStorageClass::pickOutIRNodeData ( SgOmpDoStatement* pointer ) 
   { 
     SgOmpDoStatement* source = (SgOmpDoStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgOmpClausePtrList::iterator i_clauses = source->p_clauses.begin() ; 
     unsigned int tempListCountclauses = 0; 
     SgOmpClausePtrList::value_type *  tempListclauses = new SgOmpClausePtrList::value_type[ source->p_clauses.size() ]; 
     for ( ; i_clauses != source->p_clauses.end(); ++i_clauses ) 
        {
          tempListclauses[tempListCountclauses] = *i_clauses;
          tempListCountclauses++; 
          (*i_clauses) = (SgOmpClausePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_clauses ) );
        }
     storageOf_clauses.storeDataInEasyStorageClass(source->p_clauses);
     tempListCountclauses = 0; 
     i_clauses = source->p_clauses.begin() ; 
     for ( ; i_clauses != source->p_clauses.end(); ++i_clauses ) 
        {
          *i_clauses = tempListclauses[tempListCountclauses] ;
          tempListCountclauses++; 
        }
      delete [] tempListclauses; 
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgOmpDoStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgOmpClausePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgOmpDoStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgOmpClausePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgOmpDoStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgOmpClausePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgOmpDoStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgOmpClausePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 26538 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgOmpSectionsStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 26551 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgOmpSectionsStatementStorageClass::pickOutIRNodeData ( SgOmpSectionsStatement* pointer ) 
   { 
     SgOmpSectionsStatement* source = (SgOmpSectionsStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgOmpClausePtrList::iterator i_clauses = source->p_clauses.begin() ; 
     unsigned int tempListCountclauses = 0; 
     SgOmpClausePtrList::value_type *  tempListclauses = new SgOmpClausePtrList::value_type[ source->p_clauses.size() ]; 
     for ( ; i_clauses != source->p_clauses.end(); ++i_clauses ) 
        {
          tempListclauses[tempListCountclauses] = *i_clauses;
          tempListCountclauses++; 
          (*i_clauses) = (SgOmpClausePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_clauses ) );
        }
     storageOf_clauses.storeDataInEasyStorageClass(source->p_clauses);
     tempListCountclauses = 0; 
     i_clauses = source->p_clauses.begin() ; 
     for ( ; i_clauses != source->p_clauses.end(); ++i_clauses ) 
        {
          *i_clauses = tempListclauses[tempListCountclauses] ;
          tempListCountclauses++; 
        }
      delete [] tempListclauses; 
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgOmpSectionsStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgOmpClausePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgOmpSectionsStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgOmpClausePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgOmpSectionsStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgOmpClausePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgOmpSectionsStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgOmpClausePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 26631 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgSequenceStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 26644 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgSequenceStatementStorageClass::pickOutIRNodeData ( SgSequenceStatement* pointer ) 
   { 
     SgSequenceStatement* source = (SgSequenceStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgSequenceStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgSequenceStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgSequenceStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgSequenceStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 26701 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgWithStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 26714 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgWithStatementStorageClass::pickOutIRNodeData ( SgWithStatement* pointer ) 
   { 
     SgWithStatement* source = (SgWithStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_expression = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression );
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgWithStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgWithStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgWithStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgWithStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 26773 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgPythonPrintStmtStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 26786 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgPythonPrintStmtStorageClass::pickOutIRNodeData ( SgPythonPrintStmt* pointer ) 
   { 
     SgPythonPrintStmt* source = (SgPythonPrintStmt*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_destination = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_destination );
     storageOf_values = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_values );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgPythonPrintStmtStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgPythonPrintStmtStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgPythonPrintStmtStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgPythonPrintStmtStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 26845 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgPassStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 26858 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgPassStatementStorageClass::pickOutIRNodeData ( SgPassStatement* pointer ) 
   { 
     SgPassStatement* source = (SgPassStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgPassStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgPassStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgPassStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgPassStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 26915 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAssertStmtStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 26928 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAssertStmtStorageClass::pickOutIRNodeData ( SgAssertStmt* pointer ) 
   { 
     SgAssertStmt* source = (SgAssertStmt*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_test = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_test );
     storageOf_exception_argument = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_exception_argument );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAssertStmtStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAssertStmtStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAssertStmtStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAssertStmtStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 26987 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgExecStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 27000 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgExecStatementStorageClass::pickOutIRNodeData ( SgExecStatement* pointer ) 
   { 
     SgExecStatement* source = (SgExecStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_executable = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_executable );
     storageOf_globals = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_globals );
     storageOf_locals = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_locals );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgExecStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgExecStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgExecStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgExecStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 27060 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgPythonGlobalStmtStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 27073 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgPythonGlobalStmtStorageClass::pickOutIRNodeData ( SgPythonGlobalStmt* pointer ) 
   { 
     SgPythonGlobalStmt* source = (SgPythonGlobalStmt*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgInitializedNamePtrList::iterator i_names = source->p_names.begin() ; 
     unsigned int tempListCountnames = 0; 
     SgInitializedNamePtrList::value_type *  tempListnames = new SgInitializedNamePtrList::value_type[ source->p_names.size() ]; 
     for ( ; i_names != source->p_names.end(); ++i_names ) 
        {
          tempListnames[tempListCountnames] = *i_names;
          tempListCountnames++; 
          (*i_names) = (SgInitializedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_names ) );
        }
     storageOf_names.storeDataInEasyStorageClass(source->p_names);
     tempListCountnames = 0; 
     i_names = source->p_names.begin() ; 
     for ( ; i_names != source->p_names.end(); ++i_names ) 
        {
          *i_names = tempListnames[tempListCountnames] ;
          tempListCountnames++; 
        }
      delete [] tempListnames; 
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgPythonGlobalStmtStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgInitializedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgPythonGlobalStmtStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgInitializedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgPythonGlobalStmtStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgInitializedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgPythonGlobalStmtStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgInitializedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 27152 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgJavaThrowStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 27165 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgJavaThrowStatementStorageClass::pickOutIRNodeData ( SgJavaThrowStatement* pointer ) 
   { 
     SgJavaThrowStatement* source = (SgJavaThrowStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_throwOp = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_throwOp );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgJavaThrowStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgJavaThrowStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgJavaThrowStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgJavaThrowStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 27223 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgJavaSynchronizedStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 27236 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgJavaSynchronizedStatementStorageClass::pickOutIRNodeData ( SgJavaSynchronizedStatement* pointer ) 
   { 
     SgJavaSynchronizedStatement* source = (SgJavaSynchronizedStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_expression = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression );
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgJavaSynchronizedStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgJavaSynchronizedStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgJavaSynchronizedStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgJavaSynchronizedStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 27295 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgExpressionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 27308 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgExpressionStorageClass::pickOutIRNodeData ( SgExpression* pointer ) 
   { 
     SgExpression* source = (SgExpression*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgExpressionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgExpressionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgExpressionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgExpressionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 27367 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgUnaryOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 27380 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgUnaryOpStorageClass::pickOutIRNodeData ( SgUnaryOp* pointer ) 
   { 
     SgUnaryOp* source = (SgUnaryOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_mode =  source->p_mode ;
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgUnaryOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgUnaryOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgUnaryOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgUnaryOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 27442 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgExpressionRootStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 27455 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgExpressionRootStorageClass::pickOutIRNodeData ( SgExpressionRoot* pointer ) 
   { 
     SgExpressionRoot* source = (SgExpressionRoot*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_mode =  source->p_mode ;
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgExpressionRootStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgExpressionRootStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgExpressionRootStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgExpressionRootStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 27517 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgMinusOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 27530 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgMinusOpStorageClass::pickOutIRNodeData ( SgMinusOp* pointer ) 
   { 
     SgMinusOp* source = (SgMinusOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_mode =  source->p_mode ;
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgMinusOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgMinusOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgMinusOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgMinusOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 27592 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgUnaryAddOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 27605 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgUnaryAddOpStorageClass::pickOutIRNodeData ( SgUnaryAddOp* pointer ) 
   { 
     SgUnaryAddOp* source = (SgUnaryAddOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_mode =  source->p_mode ;
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgUnaryAddOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgUnaryAddOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgUnaryAddOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgUnaryAddOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 27667 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgNotOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 27680 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgNotOpStorageClass::pickOutIRNodeData ( SgNotOp* pointer ) 
   { 
     SgNotOp* source = (SgNotOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_mode =  source->p_mode ;
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgNotOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgNotOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgNotOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgNotOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 27742 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgPointerDerefExpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 27755 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgPointerDerefExpStorageClass::pickOutIRNodeData ( SgPointerDerefExp* pointer ) 
   { 
     SgPointerDerefExp* source = (SgPointerDerefExp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_mode =  source->p_mode ;
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgPointerDerefExpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgPointerDerefExpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgPointerDerefExpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgPointerDerefExpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 27817 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAddressOfOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 27830 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAddressOfOpStorageClass::pickOutIRNodeData ( SgAddressOfOp* pointer ) 
   { 
     SgAddressOfOp* source = (SgAddressOfOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_mode =  source->p_mode ;
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAddressOfOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAddressOfOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAddressOfOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAddressOfOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 27892 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgMinusMinusOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 27905 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgMinusMinusOpStorageClass::pickOutIRNodeData ( SgMinusMinusOp* pointer ) 
   { 
     SgMinusMinusOp* source = (SgMinusMinusOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_mode =  source->p_mode ;
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgMinusMinusOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgMinusMinusOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgMinusMinusOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgMinusMinusOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 27967 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgPlusPlusOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 27980 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgPlusPlusOpStorageClass::pickOutIRNodeData ( SgPlusPlusOp* pointer ) 
   { 
     SgPlusPlusOp* source = (SgPlusPlusOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_mode =  source->p_mode ;
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgPlusPlusOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgPlusPlusOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgPlusPlusOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgPlusPlusOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 28042 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgBitComplementOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 28055 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgBitComplementOpStorageClass::pickOutIRNodeData ( SgBitComplementOp* pointer ) 
   { 
     SgBitComplementOp* source = (SgBitComplementOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_mode =  source->p_mode ;
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgBitComplementOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgBitComplementOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgBitComplementOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgBitComplementOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 28117 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgCastExpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 28130 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgCastExpStorageClass::pickOutIRNodeData ( SgCastExp* pointer ) 
   { 
     SgCastExp* source = (SgCastExp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_cast_type =  source->p_cast_type ;
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_name_qualification_length =  source->p_name_qualification_length ;
     storageOf_type_elaboration_required =  source->p_type_elaboration_required ;
     storageOf_global_qualification_required =  source->p_global_qualification_required ;
     storageOf_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_mode =  source->p_mode ;
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgCastExpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgCastExpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgCastExpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgCastExpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 28197 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgThrowOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 28210 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgThrowOpStorageClass::pickOutIRNodeData ( SgThrowOp* pointer ) 
   { 
     SgThrowOp* source = (SgThrowOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_throwKind =  source->p_throwKind ;
     storageOf_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_mode =  source->p_mode ;
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgThrowOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgThrowOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgThrowOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgThrowOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 28273 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgRealPartOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 28286 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgRealPartOpStorageClass::pickOutIRNodeData ( SgRealPartOp* pointer ) 
   { 
     SgRealPartOp* source = (SgRealPartOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_mode =  source->p_mode ;
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgRealPartOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgRealPartOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgRealPartOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgRealPartOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 28348 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgImagPartOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 28361 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgImagPartOpStorageClass::pickOutIRNodeData ( SgImagPartOp* pointer ) 
   { 
     SgImagPartOp* source = (SgImagPartOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_mode =  source->p_mode ;
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgImagPartOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgImagPartOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgImagPartOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgImagPartOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 28423 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgConjugateOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 28436 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgConjugateOpStorageClass::pickOutIRNodeData ( SgConjugateOp* pointer ) 
   { 
     SgConjugateOp* source = (SgConjugateOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_mode =  source->p_mode ;
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgConjugateOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgConjugateOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgConjugateOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgConjugateOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 28498 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgUserDefinedUnaryOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 28511 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgUserDefinedUnaryOpStorageClass::pickOutIRNodeData ( SgUserDefinedUnaryOp* pointer ) 
   { 
     SgUserDefinedUnaryOp* source = (SgUserDefinedUnaryOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_operator_name.pickOutIRNodeData( &(source->p_operator_name) );
     storageOf_symbol = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_symbol );
     storageOf_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_mode =  source->p_mode ;
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgUserDefinedUnaryOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgUserDefinedUnaryOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgUserDefinedUnaryOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgUserDefinedUnaryOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 28579 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgBinaryOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 28592 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgBinaryOpStorageClass::pickOutIRNodeData ( SgBinaryOp* pointer ) 
   { 
     SgBinaryOp* source = (SgBinaryOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgBinaryOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgBinaryOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgBinaryOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgBinaryOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 28655 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgArrowExpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 28668 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgArrowExpStorageClass::pickOutIRNodeData ( SgArrowExp* pointer ) 
   { 
     SgArrowExp* source = (SgArrowExp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgArrowExpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgArrowExpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgArrowExpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgArrowExpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 28731 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgDotExpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 28744 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgDotExpStorageClass::pickOutIRNodeData ( SgDotExp* pointer ) 
   { 
     SgDotExp* source = (SgDotExp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgDotExpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgDotExpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgDotExpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgDotExpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 28807 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgDotStarOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 28820 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgDotStarOpStorageClass::pickOutIRNodeData ( SgDotStarOp* pointer ) 
   { 
     SgDotStarOp* source = (SgDotStarOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgDotStarOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgDotStarOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgDotStarOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgDotStarOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 28883 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgArrowStarOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 28896 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgArrowStarOpStorageClass::pickOutIRNodeData ( SgArrowStarOp* pointer ) 
   { 
     SgArrowStarOp* source = (SgArrowStarOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgArrowStarOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgArrowStarOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgArrowStarOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgArrowStarOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 28959 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgEqualityOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 28972 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgEqualityOpStorageClass::pickOutIRNodeData ( SgEqualityOp* pointer ) 
   { 
     SgEqualityOp* source = (SgEqualityOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgEqualityOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgEqualityOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgEqualityOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgEqualityOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 29035 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgLessThanOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 29048 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgLessThanOpStorageClass::pickOutIRNodeData ( SgLessThanOp* pointer ) 
   { 
     SgLessThanOp* source = (SgLessThanOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgLessThanOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgLessThanOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgLessThanOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgLessThanOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 29111 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgGreaterThanOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 29124 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgGreaterThanOpStorageClass::pickOutIRNodeData ( SgGreaterThanOp* pointer ) 
   { 
     SgGreaterThanOp* source = (SgGreaterThanOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgGreaterThanOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgGreaterThanOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgGreaterThanOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgGreaterThanOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 29187 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgNotEqualOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 29200 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgNotEqualOpStorageClass::pickOutIRNodeData ( SgNotEqualOp* pointer ) 
   { 
     SgNotEqualOp* source = (SgNotEqualOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgNotEqualOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgNotEqualOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgNotEqualOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgNotEqualOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 29263 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgLessOrEqualOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 29276 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgLessOrEqualOpStorageClass::pickOutIRNodeData ( SgLessOrEqualOp* pointer ) 
   { 
     SgLessOrEqualOp* source = (SgLessOrEqualOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgLessOrEqualOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgLessOrEqualOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgLessOrEqualOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgLessOrEqualOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 29339 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgGreaterOrEqualOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 29352 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgGreaterOrEqualOpStorageClass::pickOutIRNodeData ( SgGreaterOrEqualOp* pointer ) 
   { 
     SgGreaterOrEqualOp* source = (SgGreaterOrEqualOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgGreaterOrEqualOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgGreaterOrEqualOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgGreaterOrEqualOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgGreaterOrEqualOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 29415 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAddOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 29428 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAddOpStorageClass::pickOutIRNodeData ( SgAddOp* pointer ) 
   { 
     SgAddOp* source = (SgAddOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAddOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAddOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAddOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAddOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 29491 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgSubtractOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 29504 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgSubtractOpStorageClass::pickOutIRNodeData ( SgSubtractOp* pointer ) 
   { 
     SgSubtractOp* source = (SgSubtractOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgSubtractOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgSubtractOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgSubtractOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgSubtractOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 29567 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgMultiplyOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 29580 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgMultiplyOpStorageClass::pickOutIRNodeData ( SgMultiplyOp* pointer ) 
   { 
     SgMultiplyOp* source = (SgMultiplyOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgMultiplyOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgMultiplyOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgMultiplyOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgMultiplyOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 29643 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgDivideOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 29656 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgDivideOpStorageClass::pickOutIRNodeData ( SgDivideOp* pointer ) 
   { 
     SgDivideOp* source = (SgDivideOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgDivideOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgDivideOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgDivideOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgDivideOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 29719 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgIntegerDivideOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 29732 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgIntegerDivideOpStorageClass::pickOutIRNodeData ( SgIntegerDivideOp* pointer ) 
   { 
     SgIntegerDivideOp* source = (SgIntegerDivideOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgIntegerDivideOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgIntegerDivideOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgIntegerDivideOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgIntegerDivideOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 29795 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgModOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 29808 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgModOpStorageClass::pickOutIRNodeData ( SgModOp* pointer ) 
   { 
     SgModOp* source = (SgModOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgModOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgModOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgModOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgModOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 29871 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAndOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 29884 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAndOpStorageClass::pickOutIRNodeData ( SgAndOp* pointer ) 
   { 
     SgAndOp* source = (SgAndOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAndOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAndOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAndOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAndOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 29947 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgOrOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 29960 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgOrOpStorageClass::pickOutIRNodeData ( SgOrOp* pointer ) 
   { 
     SgOrOp* source = (SgOrOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgOrOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgOrOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgOrOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgOrOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 30023 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgBitXorOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 30036 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgBitXorOpStorageClass::pickOutIRNodeData ( SgBitXorOp* pointer ) 
   { 
     SgBitXorOp* source = (SgBitXorOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgBitXorOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgBitXorOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgBitXorOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgBitXorOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 30099 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgBitAndOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 30112 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgBitAndOpStorageClass::pickOutIRNodeData ( SgBitAndOp* pointer ) 
   { 
     SgBitAndOp* source = (SgBitAndOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgBitAndOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgBitAndOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgBitAndOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgBitAndOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 30175 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgBitOrOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 30188 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgBitOrOpStorageClass::pickOutIRNodeData ( SgBitOrOp* pointer ) 
   { 
     SgBitOrOp* source = (SgBitOrOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgBitOrOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgBitOrOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgBitOrOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgBitOrOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 30251 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgCommaOpExpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 30264 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgCommaOpExpStorageClass::pickOutIRNodeData ( SgCommaOpExp* pointer ) 
   { 
     SgCommaOpExp* source = (SgCommaOpExp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgCommaOpExpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgCommaOpExpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgCommaOpExpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgCommaOpExpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 30327 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgLshiftOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 30340 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgLshiftOpStorageClass::pickOutIRNodeData ( SgLshiftOp* pointer ) 
   { 
     SgLshiftOp* source = (SgLshiftOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgLshiftOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgLshiftOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgLshiftOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgLshiftOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 30403 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgRshiftOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 30416 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgRshiftOpStorageClass::pickOutIRNodeData ( SgRshiftOp* pointer ) 
   { 
     SgRshiftOp* source = (SgRshiftOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgRshiftOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgRshiftOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgRshiftOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgRshiftOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 30479 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgPntrArrRefExpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 30492 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgPntrArrRefExpStorageClass::pickOutIRNodeData ( SgPntrArrRefExp* pointer ) 
   { 
     SgPntrArrRefExp* source = (SgPntrArrRefExp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgPntrArrRefExpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgPntrArrRefExpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgPntrArrRefExpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgPntrArrRefExpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 30555 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgScopeOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 30568 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgScopeOpStorageClass::pickOutIRNodeData ( SgScopeOp* pointer ) 
   { 
     SgScopeOp* source = (SgScopeOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgScopeOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgScopeOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgScopeOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgScopeOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 30631 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAssignOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 30644 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAssignOpStorageClass::pickOutIRNodeData ( SgAssignOp* pointer ) 
   { 
     SgAssignOp* source = (SgAssignOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAssignOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAssignOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAssignOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAssignOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 30707 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgExponentiationOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 30720 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgExponentiationOpStorageClass::pickOutIRNodeData ( SgExponentiationOp* pointer ) 
   { 
     SgExponentiationOp* source = (SgExponentiationOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgExponentiationOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgExponentiationOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgExponentiationOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgExponentiationOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 30783 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgJavaUnsignedRshiftOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 30796 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgJavaUnsignedRshiftOpStorageClass::pickOutIRNodeData ( SgJavaUnsignedRshiftOp* pointer ) 
   { 
     SgJavaUnsignedRshiftOp* source = (SgJavaUnsignedRshiftOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgJavaUnsignedRshiftOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgJavaUnsignedRshiftOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgJavaUnsignedRshiftOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgJavaUnsignedRshiftOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 30859 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgConcatenationOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 30872 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgConcatenationOpStorageClass::pickOutIRNodeData ( SgConcatenationOp* pointer ) 
   { 
     SgConcatenationOp* source = (SgConcatenationOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgConcatenationOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgConcatenationOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgConcatenationOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgConcatenationOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 30935 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgPointerAssignOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 30948 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgPointerAssignOpStorageClass::pickOutIRNodeData ( SgPointerAssignOp* pointer ) 
   { 
     SgPointerAssignOp* source = (SgPointerAssignOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgPointerAssignOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgPointerAssignOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgPointerAssignOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgPointerAssignOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 31011 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgUserDefinedBinaryOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 31024 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgUserDefinedBinaryOpStorageClass::pickOutIRNodeData ( SgUserDefinedBinaryOp* pointer ) 
   { 
     SgUserDefinedBinaryOp* source = (SgUserDefinedBinaryOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_operator_name.pickOutIRNodeData( &(source->p_operator_name) );
     storageOf_symbol = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_symbol );
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgUserDefinedBinaryOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgUserDefinedBinaryOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgUserDefinedBinaryOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgUserDefinedBinaryOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 31093 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgCompoundAssignOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 31106 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgCompoundAssignOpStorageClass::pickOutIRNodeData ( SgCompoundAssignOp* pointer ) 
   { 
     SgCompoundAssignOp* source = (SgCompoundAssignOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgCompoundAssignOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgCompoundAssignOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgCompoundAssignOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgCompoundAssignOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 31169 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgPlusAssignOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 31182 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgPlusAssignOpStorageClass::pickOutIRNodeData ( SgPlusAssignOp* pointer ) 
   { 
     SgPlusAssignOp* source = (SgPlusAssignOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgPlusAssignOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgPlusAssignOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgPlusAssignOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgPlusAssignOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 31245 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgMinusAssignOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 31258 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgMinusAssignOpStorageClass::pickOutIRNodeData ( SgMinusAssignOp* pointer ) 
   { 
     SgMinusAssignOp* source = (SgMinusAssignOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgMinusAssignOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgMinusAssignOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgMinusAssignOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgMinusAssignOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 31321 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAndAssignOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 31334 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAndAssignOpStorageClass::pickOutIRNodeData ( SgAndAssignOp* pointer ) 
   { 
     SgAndAssignOp* source = (SgAndAssignOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAndAssignOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAndAssignOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAndAssignOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAndAssignOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 31397 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgIorAssignOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 31410 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgIorAssignOpStorageClass::pickOutIRNodeData ( SgIorAssignOp* pointer ) 
   { 
     SgIorAssignOp* source = (SgIorAssignOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgIorAssignOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgIorAssignOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgIorAssignOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgIorAssignOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 31473 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgMultAssignOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 31486 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgMultAssignOpStorageClass::pickOutIRNodeData ( SgMultAssignOp* pointer ) 
   { 
     SgMultAssignOp* source = (SgMultAssignOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgMultAssignOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgMultAssignOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgMultAssignOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgMultAssignOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 31549 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgDivAssignOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 31562 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgDivAssignOpStorageClass::pickOutIRNodeData ( SgDivAssignOp* pointer ) 
   { 
     SgDivAssignOp* source = (SgDivAssignOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgDivAssignOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgDivAssignOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgDivAssignOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgDivAssignOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 31625 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgModAssignOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 31638 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgModAssignOpStorageClass::pickOutIRNodeData ( SgModAssignOp* pointer ) 
   { 
     SgModAssignOp* source = (SgModAssignOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgModAssignOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgModAssignOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgModAssignOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgModAssignOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 31701 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgXorAssignOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 31714 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgXorAssignOpStorageClass::pickOutIRNodeData ( SgXorAssignOp* pointer ) 
   { 
     SgXorAssignOp* source = (SgXorAssignOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgXorAssignOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgXorAssignOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgXorAssignOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgXorAssignOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 31777 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgLshiftAssignOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 31790 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgLshiftAssignOpStorageClass::pickOutIRNodeData ( SgLshiftAssignOp* pointer ) 
   { 
     SgLshiftAssignOp* source = (SgLshiftAssignOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgLshiftAssignOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgLshiftAssignOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgLshiftAssignOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgLshiftAssignOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 31853 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgRshiftAssignOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 31866 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgRshiftAssignOpStorageClass::pickOutIRNodeData ( SgRshiftAssignOp* pointer ) 
   { 
     SgRshiftAssignOp* source = (SgRshiftAssignOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgRshiftAssignOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgRshiftAssignOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgRshiftAssignOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgRshiftAssignOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 31929 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgJavaUnsignedRshiftAssignOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 31942 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgJavaUnsignedRshiftAssignOpStorageClass::pickOutIRNodeData ( SgJavaUnsignedRshiftAssignOp* pointer ) 
   { 
     SgJavaUnsignedRshiftAssignOp* source = (SgJavaUnsignedRshiftAssignOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgJavaUnsignedRshiftAssignOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgJavaUnsignedRshiftAssignOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgJavaUnsignedRshiftAssignOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgJavaUnsignedRshiftAssignOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 32005 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgIntegerDivideAssignOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 32018 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgIntegerDivideAssignOpStorageClass::pickOutIRNodeData ( SgIntegerDivideAssignOp* pointer ) 
   { 
     SgIntegerDivideAssignOp* source = (SgIntegerDivideAssignOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgIntegerDivideAssignOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgIntegerDivideAssignOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgIntegerDivideAssignOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgIntegerDivideAssignOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 32081 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgExponentiationAssignOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 32094 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgExponentiationAssignOpStorageClass::pickOutIRNodeData ( SgExponentiationAssignOp* pointer ) 
   { 
     SgExponentiationAssignOp* source = (SgExponentiationAssignOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgExponentiationAssignOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgExponentiationAssignOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgExponentiationAssignOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgExponentiationAssignOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 32157 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgMembershipOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 32170 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgMembershipOpStorageClass::pickOutIRNodeData ( SgMembershipOp* pointer ) 
   { 
     SgMembershipOp* source = (SgMembershipOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgMembershipOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgMembershipOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgMembershipOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgMembershipOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 32233 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgNonMembershipOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 32246 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgNonMembershipOpStorageClass::pickOutIRNodeData ( SgNonMembershipOp* pointer ) 
   { 
     SgNonMembershipOp* source = (SgNonMembershipOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgNonMembershipOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgNonMembershipOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgNonMembershipOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgNonMembershipOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 32309 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgIsOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 32322 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgIsOpStorageClass::pickOutIRNodeData ( SgIsOp* pointer ) 
   { 
     SgIsOp* source = (SgIsOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgIsOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgIsOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgIsOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgIsOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 32385 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgIsNotOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 32398 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgIsNotOpStorageClass::pickOutIRNodeData ( SgIsNotOp* pointer ) 
   { 
     SgIsNotOp* source = (SgIsNotOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgIsNotOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgIsNotOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgIsNotOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgIsNotOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 32461 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgExprListExpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 32474 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgExprListExpStorageClass::pickOutIRNodeData ( SgExprListExp* pointer ) 
   { 
     SgExprListExp* source = (SgExprListExp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgExpressionPtrList::iterator i_expressions = source->p_expressions.begin() ; 
     unsigned int tempListCountexpressions = 0; 
     SgExpressionPtrList::value_type *  tempListexpressions = new SgExpressionPtrList::value_type[ source->p_expressions.size() ]; 
     for ( ; i_expressions != source->p_expressions.end(); ++i_expressions ) 
        {
          tempListexpressions[tempListCountexpressions] = *i_expressions;
          tempListCountexpressions++; 
          (*i_expressions) = (SgExpressionPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_expressions ) );
        }
     storageOf_expressions.storeDataInEasyStorageClass(source->p_expressions);
     tempListCountexpressions = 0; 
     i_expressions = source->p_expressions.begin() ; 
     for ( ; i_expressions != source->p_expressions.end(); ++i_expressions ) 
        {
          *i_expressions = tempListexpressions[tempListCountexpressions] ;
          tempListCountexpressions++; 
        }
      delete [] tempListexpressions; 
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgExprListExpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgExpressionPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgExprListExpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgExpressionPtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgExprListExpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgExpressionPtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgExprListExpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgExpressionPtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 32555 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgListExpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 32568 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgListExpStorageClass::pickOutIRNodeData ( SgListExp* pointer ) 
   { 
     SgListExp* source = (SgListExp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgExpressionPtrList::iterator i_expressions = source->p_expressions.begin() ; 
     unsigned int tempListCountexpressions = 0; 
     SgExpressionPtrList::value_type *  tempListexpressions = new SgExpressionPtrList::value_type[ source->p_expressions.size() ]; 
     for ( ; i_expressions != source->p_expressions.end(); ++i_expressions ) 
        {
          tempListexpressions[tempListCountexpressions] = *i_expressions;
          tempListCountexpressions++; 
          (*i_expressions) = (SgExpressionPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_expressions ) );
        }
     storageOf_expressions.storeDataInEasyStorageClass(source->p_expressions);
     tempListCountexpressions = 0; 
     i_expressions = source->p_expressions.begin() ; 
     for ( ; i_expressions != source->p_expressions.end(); ++i_expressions ) 
        {
          *i_expressions = tempListexpressions[tempListCountexpressions] ;
          tempListCountexpressions++; 
        }
      delete [] tempListexpressions; 
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgListExpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgExpressionPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgListExpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgExpressionPtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgListExpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgExpressionPtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgListExpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgExpressionPtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 32649 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTupleExpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 32662 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgTupleExpStorageClass::pickOutIRNodeData ( SgTupleExp* pointer ) 
   { 
     SgTupleExp* source = (SgTupleExp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgExpressionPtrList::iterator i_expressions = source->p_expressions.begin() ; 
     unsigned int tempListCountexpressions = 0; 
     SgExpressionPtrList::value_type *  tempListexpressions = new SgExpressionPtrList::value_type[ source->p_expressions.size() ]; 
     for ( ; i_expressions != source->p_expressions.end(); ++i_expressions ) 
        {
          tempListexpressions[tempListCountexpressions] = *i_expressions;
          tempListCountexpressions++; 
          (*i_expressions) = (SgExpressionPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_expressions ) );
        }
     storageOf_expressions.storeDataInEasyStorageClass(source->p_expressions);
     tempListCountexpressions = 0; 
     i_expressions = source->p_expressions.begin() ; 
     for ( ; i_expressions != source->p_expressions.end(); ++i_expressions ) 
        {
          *i_expressions = tempListexpressions[tempListCountexpressions] ;
          tempListCountexpressions++; 
        }
      delete [] tempListexpressions; 
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgTupleExpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgExpressionPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTupleExpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgExpressionPtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTupleExpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgExpressionPtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTupleExpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgExpressionPtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 32743 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgVarRefExpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 32756 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgVarRefExpStorageClass::pickOutIRNodeData ( SgVarRefExp* pointer ) 
   { 
     SgVarRefExp* source = (SgVarRefExp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_symbol = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_symbol );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_name_qualification_length =  source->p_name_qualification_length ;
     storageOf_type_elaboration_required =  source->p_type_elaboration_required ;
     storageOf_global_qualification_required =  source->p_global_qualification_required ;
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgVarRefExpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgVarRefExpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgVarRefExpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgVarRefExpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 32820 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgClassNameRefExpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 32833 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgClassNameRefExpStorageClass::pickOutIRNodeData ( SgClassNameRefExp* pointer ) 
   { 
     SgClassNameRefExp* source = (SgClassNameRefExp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_symbol = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_symbol );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgClassNameRefExpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgClassNameRefExpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgClassNameRefExpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgClassNameRefExpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 32893 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgFunctionRefExpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 32906 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgFunctionRefExpStorageClass::pickOutIRNodeData ( SgFunctionRefExp* pointer ) 
   { 
     SgFunctionRefExp* source = (SgFunctionRefExp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_symbol_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_symbol_i );
     storageOf_function_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_function_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_name_qualification_length =  source->p_name_qualification_length ;
     storageOf_type_elaboration_required =  source->p_type_elaboration_required ;
     storageOf_global_qualification_required =  source->p_global_qualification_required ;
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgFunctionRefExpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgFunctionRefExpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgFunctionRefExpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgFunctionRefExpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 32971 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgMemberFunctionRefExpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 32984 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgMemberFunctionRefExpStorageClass::pickOutIRNodeData ( SgMemberFunctionRefExp* pointer ) 
   { 
     SgMemberFunctionRefExp* source = (SgMemberFunctionRefExp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_symbol_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_symbol_i );
     storageOf_virtual_call =  source->p_virtual_call ;
     storageOf_function_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_function_type );
     storageOf_need_qualifier =  source->p_need_qualifier ;
     storageOf_name_qualification_length =  source->p_name_qualification_length ;
     storageOf_type_elaboration_required =  source->p_type_elaboration_required ;
     storageOf_global_qualification_required =  source->p_global_qualification_required ;
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgMemberFunctionRefExpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgMemberFunctionRefExpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgMemberFunctionRefExpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgMemberFunctionRefExpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 33050 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgValueExpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 33063 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgValueExpStorageClass::pickOutIRNodeData ( SgValueExp* pointer ) 
   { 
     SgValueExp* source = (SgValueExp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgValueExpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgValueExpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgValueExpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgValueExpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 33123 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgBoolValExpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 33136 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgBoolValExpStorageClass::pickOutIRNodeData ( SgBoolValExp* pointer ) 
   { 
     SgBoolValExp* source = (SgBoolValExp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_value =  source->p_value ;
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgBoolValExpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgBoolValExpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgBoolValExpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgBoolValExpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 33197 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgStringValStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 33210 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgStringValStorageClass::pickOutIRNodeData ( SgStringVal* pointer ) 
   { 
     SgStringVal* source = (SgStringVal*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_value.storeDataInEasyStorageClass(source->p_value);
     storageOf_wcharString =  source->p_wcharString ;
     storageOf_usesSingleQuotes =  source->p_usesSingleQuotes ;
     storageOf_usesDoubleQuotes =  source->p_usesDoubleQuotes ;
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgStringValStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgStringValStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgStringValStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgStringValStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 33278 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgShortValStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 33291 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgShortValStorageClass::pickOutIRNodeData ( SgShortVal* pointer ) 
   { 
     SgShortVal* source = (SgShortVal*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_value =  source->p_value ;
     storageOf_valueString.storeDataInEasyStorageClass(source->p_valueString);
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgShortValStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgShortValStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgShortValStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgShortValStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 33357 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgCharValStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 33370 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgCharValStorageClass::pickOutIRNodeData ( SgCharVal* pointer ) 
   { 
     SgCharVal* source = (SgCharVal*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_value =  source->p_value ;
     storageOf_valueString.storeDataInEasyStorageClass(source->p_valueString);
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgCharValStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgCharValStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgCharValStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgCharValStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 33436 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgUnsignedCharValStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 33449 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgUnsignedCharValStorageClass::pickOutIRNodeData ( SgUnsignedCharVal* pointer ) 
   { 
     SgUnsignedCharVal* source = (SgUnsignedCharVal*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_value =  source->p_value ;
     storageOf_valueString.storeDataInEasyStorageClass(source->p_valueString);
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgUnsignedCharValStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgUnsignedCharValStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgUnsignedCharValStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgUnsignedCharValStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 33515 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgWcharValStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 33528 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgWcharValStorageClass::pickOutIRNodeData ( SgWcharVal* pointer ) 
   { 
     SgWcharVal* source = (SgWcharVal*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_valueUL =  source->p_valueUL ;
     storageOf_valueString.storeDataInEasyStorageClass(source->p_valueString);
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgWcharValStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgWcharValStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgWcharValStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgWcharValStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 33594 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgUnsignedShortValStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 33607 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgUnsignedShortValStorageClass::pickOutIRNodeData ( SgUnsignedShortVal* pointer ) 
   { 
     SgUnsignedShortVal* source = (SgUnsignedShortVal*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_value =  source->p_value ;
     storageOf_valueString.storeDataInEasyStorageClass(source->p_valueString);
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgUnsignedShortValStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgUnsignedShortValStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgUnsignedShortValStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgUnsignedShortValStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 33673 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgIntValStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 33686 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgIntValStorageClass::pickOutIRNodeData ( SgIntVal* pointer ) 
   { 
     SgIntVal* source = (SgIntVal*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_value =  source->p_value ;
     storageOf_valueString.storeDataInEasyStorageClass(source->p_valueString);
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgIntValStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgIntValStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgIntValStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgIntValStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 33752 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgEnumValStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 33765 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgEnumValStorageClass::pickOutIRNodeData ( SgEnumVal* pointer ) 
   { 
     SgEnumVal* source = (SgEnumVal*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_value =  source->p_value ;
     storageOf_declaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declaration );
     storageOf_name.pickOutIRNodeData( &(source->p_name) );
     storageOf_requiresNameQualification =  source->p_requiresNameQualification ;
     storageOf_name_qualification_length =  source->p_name_qualification_length ;
     storageOf_type_elaboration_required =  source->p_type_elaboration_required ;
     storageOf_global_qualification_required =  source->p_global_qualification_required ;
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgEnumValStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgEnumValStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgEnumValStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgEnumValStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 33836 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgUnsignedIntValStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 33849 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgUnsignedIntValStorageClass::pickOutIRNodeData ( SgUnsignedIntVal* pointer ) 
   { 
     SgUnsignedIntVal* source = (SgUnsignedIntVal*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_value =  source->p_value ;
     storageOf_valueString.storeDataInEasyStorageClass(source->p_valueString);
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgUnsignedIntValStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgUnsignedIntValStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgUnsignedIntValStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgUnsignedIntValStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 33915 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgLongIntValStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 33928 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgLongIntValStorageClass::pickOutIRNodeData ( SgLongIntVal* pointer ) 
   { 
     SgLongIntVal* source = (SgLongIntVal*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_value =  source->p_value ;
     storageOf_valueString.storeDataInEasyStorageClass(source->p_valueString);
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgLongIntValStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgLongIntValStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgLongIntValStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgLongIntValStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 33994 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgLongLongIntValStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 34007 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgLongLongIntValStorageClass::pickOutIRNodeData ( SgLongLongIntVal* pointer ) 
   { 
     SgLongLongIntVal* source = (SgLongLongIntVal*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_value =  source->p_value ;
     storageOf_valueString.storeDataInEasyStorageClass(source->p_valueString);
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgLongLongIntValStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgLongLongIntValStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgLongLongIntValStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgLongLongIntValStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 34073 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgUnsignedLongLongIntValStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 34086 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgUnsignedLongLongIntValStorageClass::pickOutIRNodeData ( SgUnsignedLongLongIntVal* pointer ) 
   { 
     SgUnsignedLongLongIntVal* source = (SgUnsignedLongLongIntVal*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_value =  source->p_value ;
     storageOf_valueString.storeDataInEasyStorageClass(source->p_valueString);
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgUnsignedLongLongIntValStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgUnsignedLongLongIntValStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgUnsignedLongLongIntValStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgUnsignedLongLongIntValStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 34152 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgUnsignedLongValStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 34165 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgUnsignedLongValStorageClass::pickOutIRNodeData ( SgUnsignedLongVal* pointer ) 
   { 
     SgUnsignedLongVal* source = (SgUnsignedLongVal*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_value =  source->p_value ;
     storageOf_valueString.storeDataInEasyStorageClass(source->p_valueString);
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgUnsignedLongValStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgUnsignedLongValStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgUnsignedLongValStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgUnsignedLongValStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 34231 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgFloatValStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 34244 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgFloatValStorageClass::pickOutIRNodeData ( SgFloatVal* pointer ) 
   { 
     SgFloatVal* source = (SgFloatVal*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_value =  source->p_value ;
     storageOf_valueString.storeDataInEasyStorageClass(source->p_valueString);
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgFloatValStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgFloatValStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgFloatValStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgFloatValStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 34310 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgDoubleValStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 34323 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgDoubleValStorageClass::pickOutIRNodeData ( SgDoubleVal* pointer ) 
   { 
     SgDoubleVal* source = (SgDoubleVal*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_value =  source->p_value ;
     storageOf_valueString.storeDataInEasyStorageClass(source->p_valueString);
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgDoubleValStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgDoubleValStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgDoubleValStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgDoubleValStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 34389 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgLongDoubleValStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 34402 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgLongDoubleValStorageClass::pickOutIRNodeData ( SgLongDoubleVal* pointer ) 
   { 
     SgLongDoubleVal* source = (SgLongDoubleVal*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_value =  source->p_value ;
     storageOf_valueString.storeDataInEasyStorageClass(source->p_valueString);
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgLongDoubleValStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgLongDoubleValStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgLongDoubleValStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgLongDoubleValStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 34468 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgComplexValStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 34481 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgComplexValStorageClass::pickOutIRNodeData ( SgComplexVal* pointer ) 
   { 
     SgComplexVal* source = (SgComplexVal*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_real_value = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_real_value );
     storageOf_imaginary_value = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_imaginary_value );
     storageOf_precisionType = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_precisionType );
     storageOf_valueString.storeDataInEasyStorageClass(source->p_valueString);
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgComplexValStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgComplexValStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgComplexValStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgComplexValStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 34549 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgUpcThreadsStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 34562 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgUpcThreadsStorageClass::pickOutIRNodeData ( SgUpcThreads* pointer ) 
   { 
     SgUpcThreads* source = (SgUpcThreads*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_value =  source->p_value ;
     storageOf_valueString.storeDataInEasyStorageClass(source->p_valueString);
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgUpcThreadsStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgUpcThreadsStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgUpcThreadsStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgUpcThreadsStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 34628 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgUpcMythreadStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 34641 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgUpcMythreadStorageClass::pickOutIRNodeData ( SgUpcMythread* pointer ) 
   { 
     SgUpcMythread* source = (SgUpcMythread*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_value =  source->p_value ;
     storageOf_valueString.storeDataInEasyStorageClass(source->p_valueString);
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgUpcMythreadStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgUpcMythreadStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgUpcMythreadStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgUpcMythreadStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 34707 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgCallExpressionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 34720 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgCallExpressionStorageClass::pickOutIRNodeData ( SgCallExpression* pointer ) 
   { 
     SgCallExpression* source = (SgCallExpression*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_function = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_function );
     storageOf_args = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_args );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgCallExpressionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgCallExpressionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgCallExpressionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgCallExpressionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 34782 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgFunctionCallExpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 34795 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgFunctionCallExpStorageClass::pickOutIRNodeData ( SgFunctionCallExp* pointer ) 
   { 
     SgFunctionCallExp* source = (SgFunctionCallExp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_function = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_function );
     storageOf_args = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_args );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgFunctionCallExpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgFunctionCallExpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgFunctionCallExpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgFunctionCallExpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 34857 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgSizeOfOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 34870 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgSizeOfOpStorageClass::pickOutIRNodeData ( SgSizeOfOp* pointer ) 
   { 
     SgSizeOfOp* source = (SgSizeOfOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_operand_expr = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operand_expr );
     storageOf_operand_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operand_type );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_name_qualification_length =  source->p_name_qualification_length ;
     storageOf_type_elaboration_required =  source->p_type_elaboration_required ;
     storageOf_global_qualification_required =  source->p_global_qualification_required ;
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgSizeOfOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgSizeOfOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgSizeOfOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgSizeOfOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 34935 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgUpcLocalsizeofExpressionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 34948 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgUpcLocalsizeofExpressionStorageClass::pickOutIRNodeData ( SgUpcLocalsizeofExpression* pointer ) 
   { 
     SgUpcLocalsizeofExpression* source = (SgUpcLocalsizeofExpression*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_expression = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression );
     storageOf_operand_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operand_type );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgUpcLocalsizeofExpressionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgUpcLocalsizeofExpressionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgUpcLocalsizeofExpressionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgUpcLocalsizeofExpressionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 35010 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgUpcBlocksizeofExpressionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 35023 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgUpcBlocksizeofExpressionStorageClass::pickOutIRNodeData ( SgUpcBlocksizeofExpression* pointer ) 
   { 
     SgUpcBlocksizeofExpression* source = (SgUpcBlocksizeofExpression*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_expression = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression );
     storageOf_operand_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operand_type );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgUpcBlocksizeofExpressionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgUpcBlocksizeofExpressionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgUpcBlocksizeofExpressionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgUpcBlocksizeofExpressionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 35085 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgUpcElemsizeofExpressionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 35098 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgUpcElemsizeofExpressionStorageClass::pickOutIRNodeData ( SgUpcElemsizeofExpression* pointer ) 
   { 
     SgUpcElemsizeofExpression* source = (SgUpcElemsizeofExpression*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_expression = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression );
     storageOf_operand_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operand_type );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgUpcElemsizeofExpressionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgUpcElemsizeofExpressionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgUpcElemsizeofExpressionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgUpcElemsizeofExpressionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 35160 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgJavaInstanceOfOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 35173 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgJavaInstanceOfOpStorageClass::pickOutIRNodeData ( SgJavaInstanceOfOp* pointer ) 
   { 
     SgJavaInstanceOfOp* source = (SgJavaInstanceOfOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_operand_expr = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operand_expr );
     storageOf_operand_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operand_type );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgJavaInstanceOfOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgJavaInstanceOfOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgJavaInstanceOfOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgJavaInstanceOfOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 35235 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgSuperExpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 35248 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgSuperExpStorageClass::pickOutIRNodeData ( SgSuperExp* pointer ) 
   { 
     SgSuperExp* source = (SgSuperExp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_class_symbol = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_class_symbol );
     storageOf_pobj_super =  source->p_pobj_super ;
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgSuperExpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgSuperExpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgSuperExpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgSuperExpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 35309 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTypeIdOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 35322 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgTypeIdOpStorageClass::pickOutIRNodeData ( SgTypeIdOp* pointer ) 
   { 
     SgTypeIdOp* source = (SgTypeIdOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_operand_expr = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operand_expr );
     storageOf_operand_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operand_type );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_name_qualification_length =  source->p_name_qualification_length ;
     storageOf_type_elaboration_required =  source->p_type_elaboration_required ;
     storageOf_global_qualification_required =  source->p_global_qualification_required ;
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgTypeIdOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTypeIdOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTypeIdOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTypeIdOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 35387 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgConditionalExpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 35400 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgConditionalExpStorageClass::pickOutIRNodeData ( SgConditionalExp* pointer ) 
   { 
     SgConditionalExp* source = (SgConditionalExp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_conditional_exp = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_conditional_exp );
     storageOf_true_exp = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_true_exp );
     storageOf_false_exp = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_false_exp );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgConditionalExpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgConditionalExpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgConditionalExpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgConditionalExpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 35463 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgNewExpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 35476 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgNewExpStorageClass::pickOutIRNodeData ( SgNewExp* pointer ) 
   { 
     SgNewExp* source = (SgNewExp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_specified_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_specified_type );
     storageOf_placement_args = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_placement_args );
     storageOf_constructor_args = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_constructor_args );
     storageOf_builtin_args = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_builtin_args );
     storageOf_need_global_specifier =  source->p_need_global_specifier ;
     storageOf_newOperatorDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_newOperatorDeclaration );
     storageOf_name_qualification_length =  source->p_name_qualification_length ;
     storageOf_type_elaboration_required =  source->p_type_elaboration_required ;
     storageOf_global_qualification_required =  source->p_global_qualification_required ;
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgNewExpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgNewExpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgNewExpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgNewExpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 35544 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgDeleteExpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 35557 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgDeleteExpStorageClass::pickOutIRNodeData ( SgDeleteExp* pointer ) 
   { 
     SgDeleteExp* source = (SgDeleteExp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_variable = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_variable );
     storageOf_is_array =  source->p_is_array ;
     storageOf_need_global_specifier =  source->p_need_global_specifier ;
     storageOf_deleteOperatorDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_deleteOperatorDeclaration );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgDeleteExpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgDeleteExpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgDeleteExpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgDeleteExpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 35620 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgThisExpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 35633 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgThisExpStorageClass::pickOutIRNodeData ( SgThisExp* pointer ) 
   { 
     SgThisExp* source = (SgThisExp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_class_symbol = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_class_symbol );
     storageOf_pobj_this =  source->p_pobj_this ;
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgThisExpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgThisExpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgThisExpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgThisExpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 35694 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgRefExpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 35707 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgRefExpStorageClass::pickOutIRNodeData ( SgRefExp* pointer ) 
   { 
     SgRefExp* source = (SgRefExp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_type_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_name );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgRefExpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgRefExpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgRefExpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgRefExpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 35767 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgInitializerStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 35780 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgInitializerStorageClass::pickOutIRNodeData ( SgInitializer* pointer ) 
   { 
     SgInitializer* source = (SgInitializer*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_is_explicit_cast =  source->p_is_explicit_cast ;
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgInitializerStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgInitializerStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgInitializerStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgInitializerStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 35840 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAggregateInitializerStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 35853 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAggregateInitializerStorageClass::pickOutIRNodeData ( SgAggregateInitializer* pointer ) 
   { 
     SgAggregateInitializer* source = (SgAggregateInitializer*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_initializers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_initializers );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_need_explicit_braces =  source->p_need_explicit_braces ;
     storageOf_is_explicit_cast =  source->p_is_explicit_cast ;
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAggregateInitializerStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAggregateInitializerStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAggregateInitializerStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAggregateInitializerStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 35916 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgCompoundInitializerStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 35929 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgCompoundInitializerStorageClass::pickOutIRNodeData ( SgCompoundInitializer* pointer ) 
   { 
     SgCompoundInitializer* source = (SgCompoundInitializer*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_initializers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_initializers );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_is_explicit_cast =  source->p_is_explicit_cast ;
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgCompoundInitializerStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgCompoundInitializerStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgCompoundInitializerStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgCompoundInitializerStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 35991 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgConstructorInitializerStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 36004 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgConstructorInitializerStorageClass::pickOutIRNodeData ( SgConstructorInitializer* pointer ) 
   { 
     SgConstructorInitializer* source = (SgConstructorInitializer*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_declaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declaration );
     storageOf_args = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_args );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_need_name =  source->p_need_name ;
     storageOf_need_qualifier =  source->p_need_qualifier ;
     storageOf_need_parenthesis_after_name =  source->p_need_parenthesis_after_name ;
     storageOf_associated_class_unknown =  source->p_associated_class_unknown ;
     storageOf_name_qualification_length =  source->p_name_qualification_length ;
     storageOf_type_elaboration_required =  source->p_type_elaboration_required ;
     storageOf_global_qualification_required =  source->p_global_qualification_required ;
     storageOf_is_explicit_cast =  source->p_is_explicit_cast ;
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgConstructorInitializerStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgConstructorInitializerStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgConstructorInitializerStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgConstructorInitializerStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 36074 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAssignInitializerStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 36087 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAssignInitializerStorageClass::pickOutIRNodeData ( SgAssignInitializer* pointer ) 
   { 
     SgAssignInitializer* source = (SgAssignInitializer*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_is_explicit_cast =  source->p_is_explicit_cast ;
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAssignInitializerStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAssignInitializerStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAssignInitializerStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAssignInitializerStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 36149 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgDesignatedInitializerStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 36162 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgDesignatedInitializerStorageClass::pickOutIRNodeData ( SgDesignatedInitializer* pointer ) 
   { 
     SgDesignatedInitializer* source = (SgDesignatedInitializer*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_designatorList = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_designatorList );
     storageOf_memberInit = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_memberInit );
     storageOf_is_explicit_cast =  source->p_is_explicit_cast ;
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgDesignatedInitializerStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgDesignatedInitializerStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgDesignatedInitializerStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgDesignatedInitializerStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 36224 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgVarArgStartOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 36237 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgVarArgStartOpStorageClass::pickOutIRNodeData ( SgVarArgStartOp* pointer ) 
   { 
     SgVarArgStartOp* source = (SgVarArgStartOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_lhs_operand = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand );
     storageOf_rhs_operand = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgVarArgStartOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgVarArgStartOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgVarArgStartOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgVarArgStartOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 36299 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgVarArgOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 36312 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgVarArgOpStorageClass::pickOutIRNodeData ( SgVarArgOp* pointer ) 
   { 
     SgVarArgOp* source = (SgVarArgOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_operand_expr = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operand_expr );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgVarArgOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgVarArgOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgVarArgOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgVarArgOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 36373 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgVarArgEndOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 36386 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgVarArgEndOpStorageClass::pickOutIRNodeData ( SgVarArgEndOp* pointer ) 
   { 
     SgVarArgEndOp* source = (SgVarArgEndOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_operand_expr = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operand_expr );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgVarArgEndOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgVarArgEndOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgVarArgEndOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgVarArgEndOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 36447 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgVarArgCopyOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 36460 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgVarArgCopyOpStorageClass::pickOutIRNodeData ( SgVarArgCopyOp* pointer ) 
   { 
     SgVarArgCopyOp* source = (SgVarArgCopyOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_lhs_operand = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand );
     storageOf_rhs_operand = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgVarArgCopyOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgVarArgCopyOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgVarArgCopyOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgVarArgCopyOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 36522 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgVarArgStartOneOperandOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 36535 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgVarArgStartOneOperandOpStorageClass::pickOutIRNodeData ( SgVarArgStartOneOperandOp* pointer ) 
   { 
     SgVarArgStartOneOperandOp* source = (SgVarArgStartOneOperandOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_operand_expr = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operand_expr );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgVarArgStartOneOperandOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgVarArgStartOneOperandOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgVarArgStartOneOperandOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgVarArgStartOneOperandOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 36596 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgNullExpressionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 36609 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgNullExpressionStorageClass::pickOutIRNodeData ( SgNullExpression* pointer ) 
   { 
     SgNullExpression* source = (SgNullExpression*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgNullExpressionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgNullExpressionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgNullExpressionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgNullExpressionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 36668 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgVariantExpressionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 36681 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgVariantExpressionStorageClass::pickOutIRNodeData ( SgVariantExpression* pointer ) 
   { 
     SgVariantExpression* source = (SgVariantExpression*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgVariantExpressionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgVariantExpressionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgVariantExpressionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgVariantExpressionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 36740 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgSubscriptExpressionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 36753 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgSubscriptExpressionStorageClass::pickOutIRNodeData ( SgSubscriptExpression* pointer ) 
   { 
     SgSubscriptExpression* source = (SgSubscriptExpression*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_lowerBound = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lowerBound );
     storageOf_upperBound = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_upperBound );
     storageOf_stride = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_stride );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgSubscriptExpressionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgSubscriptExpressionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgSubscriptExpressionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgSubscriptExpressionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 36815 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgColonShapeExpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 36828 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgColonShapeExpStorageClass::pickOutIRNodeData ( SgColonShapeExp* pointer ) 
   { 
     SgColonShapeExp* source = (SgColonShapeExp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgColonShapeExpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgColonShapeExpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgColonShapeExpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgColonShapeExpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 36887 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsteriskShapeExpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 36900 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsteriskShapeExpStorageClass::pickOutIRNodeData ( SgAsteriskShapeExp* pointer ) 
   { 
     SgAsteriskShapeExp* source = (SgAsteriskShapeExp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsteriskShapeExpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsteriskShapeExpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsteriskShapeExpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsteriskShapeExpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 36959 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgImpliedDoStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 36972 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgImpliedDoStorageClass::pickOutIRNodeData ( SgImpliedDo* pointer ) 
   { 
     SgImpliedDo* source = (SgImpliedDo*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_do_var_initialization = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_do_var_initialization );
     storageOf_last_val = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_last_val );
     storageOf_increment = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_increment );
     storageOf_object_list = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_object_list );
     storageOf_implied_do_scope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_implied_do_scope );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgImpliedDoStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgImpliedDoStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgImpliedDoStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgImpliedDoStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 37036 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgIOItemExpressionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 37049 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgIOItemExpressionStorageClass::pickOutIRNodeData ( SgIOItemExpression* pointer ) 
   { 
     SgIOItemExpression* source = (SgIOItemExpression*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_name.pickOutIRNodeData( &(source->p_name) );
     storageOf_io_item = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_io_item );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgIOItemExpressionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgIOItemExpressionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgIOItemExpressionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgIOItemExpressionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 37114 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgStatementExpressionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 37127 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgStatementExpressionStorageClass::pickOutIRNodeData ( SgStatementExpression* pointer ) 
   { 
     SgStatementExpression* source = (SgStatementExpression*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_statement = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_statement );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgStatementExpressionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgStatementExpressionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgStatementExpressionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgStatementExpressionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 37187 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 37200 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmOpStorageClass::pickOutIRNodeData ( SgAsmOp* pointer ) 
   { 
     SgAsmOp* source = (SgAsmOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_constraint =  source->p_constraint ;
     storageOf_modifiers =  source->p_modifiers ;
     storageOf_expression = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression );
     storageOf_recordRawAsmOperandDescriptions =  source->p_recordRawAsmOperandDescriptions ;
     storageOf_isOutputOperand =  source->p_isOutputOperand ;
     storageOf_constraintString.storeDataInEasyStorageClass(source->p_constraintString);
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 37270 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgLabelRefExpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 37283 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgLabelRefExpStorageClass::pickOutIRNodeData ( SgLabelRefExp* pointer ) 
   { 
     SgLabelRefExp* source = (SgLabelRefExp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_symbol = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_symbol );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgLabelRefExpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgLabelRefExpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgLabelRefExpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgLabelRefExpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 37343 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgActualArgumentExpressionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 37356 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgActualArgumentExpressionStorageClass::pickOutIRNodeData ( SgActualArgumentExpression* pointer ) 
   { 
     SgActualArgumentExpression* source = (SgActualArgumentExpression*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_argument_name.pickOutIRNodeData( &(source->p_argument_name) );
     storageOf_expression = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgActualArgumentExpressionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgActualArgumentExpressionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgActualArgumentExpressionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgActualArgumentExpressionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 37421 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgUnknownArrayOrFunctionReferenceStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 37434 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgUnknownArrayOrFunctionReferenceStorageClass::pickOutIRNodeData ( SgUnknownArrayOrFunctionReference* pointer ) 
   { 
     SgUnknownArrayOrFunctionReference* source = (SgUnknownArrayOrFunctionReference*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_named_reference = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_named_reference );
     storageOf_expression_list = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_list );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgUnknownArrayOrFunctionReferenceStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgUnknownArrayOrFunctionReferenceStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgUnknownArrayOrFunctionReferenceStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgUnknownArrayOrFunctionReferenceStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 37500 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgPseudoDestructorRefExpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 37513 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgPseudoDestructorRefExpStorageClass::pickOutIRNodeData ( SgPseudoDestructorRefExp* pointer ) 
   { 
     SgPseudoDestructorRefExp* source = (SgPseudoDestructorRefExp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_object_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_object_type );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgPseudoDestructorRefExpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgPseudoDestructorRefExpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgPseudoDestructorRefExpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgPseudoDestructorRefExpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 37574 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgCAFCoExpressionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 37587 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgCAFCoExpressionStorageClass::pickOutIRNodeData ( SgCAFCoExpression* pointer ) 
   { 
     SgCAFCoExpression* source = (SgCAFCoExpression*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_teamId = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_teamId );
     storageOf_teamRank = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_teamRank );
     storageOf_referData = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_referData );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgCAFCoExpressionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgCAFCoExpressionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgCAFCoExpressionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgCAFCoExpressionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 37649 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgCudaKernelCallExpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 37662 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgCudaKernelCallExpStorageClass::pickOutIRNodeData ( SgCudaKernelCallExp* pointer ) 
   { 
     SgCudaKernelCallExp* source = (SgCudaKernelCallExp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_function = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_function );
     storageOf_args = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_args );
     storageOf_exec_config = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_exec_config );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgCudaKernelCallExpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgCudaKernelCallExpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgCudaKernelCallExpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgCudaKernelCallExpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 37724 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgCudaKernelExecConfigStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 37737 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgCudaKernelExecConfigStorageClass::pickOutIRNodeData ( SgCudaKernelExecConfig* pointer ) 
   { 
     SgCudaKernelExecConfig* source = (SgCudaKernelExecConfig*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_grid = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_grid );
     storageOf_blocks = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_blocks );
     storageOf_shared = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_shared );
     storageOf_stream = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_stream );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgCudaKernelExecConfigStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgCudaKernelExecConfigStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgCudaKernelExecConfigStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgCudaKernelExecConfigStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 37800 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgLambdaRefExpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 37813 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgLambdaRefExpStorageClass::pickOutIRNodeData ( SgLambdaRefExp* pointer ) 
   { 
     SgLambdaRefExp* source = (SgLambdaRefExp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_functionDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_functionDeclaration );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgLambdaRefExpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgLambdaRefExpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgLambdaRefExpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgLambdaRefExpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 37873 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgDictionaryExpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 37886 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgDictionaryExpStorageClass::pickOutIRNodeData ( SgDictionaryExp* pointer ) 
   { 
     SgDictionaryExp* source = (SgDictionaryExp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgKeyDatumPairPtrList::iterator i_key_datum_pairs = source->p_key_datum_pairs.begin() ; 
     unsigned int tempListCountkey_datum_pairs = 0; 
     SgKeyDatumPairPtrList::value_type *  tempListkey_datum_pairs = new SgKeyDatumPairPtrList::value_type[ source->p_key_datum_pairs.size() ]; 
     for ( ; i_key_datum_pairs != source->p_key_datum_pairs.end(); ++i_key_datum_pairs ) 
        {
          tempListkey_datum_pairs[tempListCountkey_datum_pairs] = *i_key_datum_pairs;
          tempListCountkey_datum_pairs++; 
          (*i_key_datum_pairs) = (SgKeyDatumPairPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_key_datum_pairs ) );
        }
     storageOf_key_datum_pairs.storeDataInEasyStorageClass(source->p_key_datum_pairs);
     tempListCountkey_datum_pairs = 0; 
     i_key_datum_pairs = source->p_key_datum_pairs.begin() ; 
     for ( ; i_key_datum_pairs != source->p_key_datum_pairs.end(); ++i_key_datum_pairs ) 
        {
          *i_key_datum_pairs = tempListkey_datum_pairs[tempListCountkey_datum_pairs] ;
          tempListCountkey_datum_pairs++; 
        }
      delete [] tempListkey_datum_pairs; 
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgDictionaryExpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgKeyDatumPairPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgDictionaryExpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgKeyDatumPairPtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgDictionaryExpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgKeyDatumPairPtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgDictionaryExpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgKeyDatumPairPtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 37967 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgKeyDatumPairStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 37980 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgKeyDatumPairStorageClass::pickOutIRNodeData ( SgKeyDatumPair* pointer ) 
   { 
     SgKeyDatumPair* source = (SgKeyDatumPair*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_key = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_key );
     storageOf_datum = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_datum );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgKeyDatumPairStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgKeyDatumPairStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgKeyDatumPairStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgKeyDatumPairStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 38041 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgComprehensionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 38054 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgComprehensionStorageClass::pickOutIRNodeData ( SgComprehension* pointer ) 
   { 
     SgComprehension* source = (SgComprehension*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_target = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_target );
     storageOf_iter = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_iter );
     storageOf_filters = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_filters );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgComprehensionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgComprehensionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgComprehensionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgComprehensionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 38116 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgListComprehensionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 38129 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgListComprehensionStorageClass::pickOutIRNodeData ( SgListComprehension* pointer ) 
   { 
     SgListComprehension* source = (SgListComprehension*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_element = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_element );
     storageOf_generators = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_generators );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgListComprehensionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgListComprehensionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgListComprehensionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgListComprehensionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 38190 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgSetComprehensionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 38203 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgSetComprehensionStorageClass::pickOutIRNodeData ( SgSetComprehension* pointer ) 
   { 
     SgSetComprehension* source = (SgSetComprehension*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_element = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_element );
     storageOf_generators = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_generators );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgSetComprehensionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgSetComprehensionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgSetComprehensionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgSetComprehensionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 38264 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgDictionaryComprehensionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 38277 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgDictionaryComprehensionStorageClass::pickOutIRNodeData ( SgDictionaryComprehension* pointer ) 
   { 
     SgDictionaryComprehension* source = (SgDictionaryComprehension*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_element = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_element );
     storageOf_generators = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_generators );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgDictionaryComprehensionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgDictionaryComprehensionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgDictionaryComprehensionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgDictionaryComprehensionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 38338 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgNaryOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 38351 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgNaryOpStorageClass::pickOutIRNodeData ( SgNaryOp* pointer ) 
   { 
     SgNaryOp* source = (SgNaryOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgExpressionPtrList::iterator i_operands = source->p_operands.begin() ; 
     unsigned int tempListCountoperands = 0; 
     SgExpressionPtrList::value_type *  tempListoperands = new SgExpressionPtrList::value_type[ source->p_operands.size() ]; 
     for ( ; i_operands != source->p_operands.end(); ++i_operands ) 
        {
          tempListoperands[tempListCountoperands] = *i_operands;
          tempListCountoperands++; 
          (*i_operands) = (SgExpressionPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_operands ) );
        }
     storageOf_operands.storeDataInEasyStorageClass(source->p_operands);
     tempListCountoperands = 0; 
     i_operands = source->p_operands.begin() ; 
     for ( ; i_operands != source->p_operands.end(); ++i_operands ) 
        {
          *i_operands = tempListoperands[tempListCountoperands] ;
          tempListCountoperands++; 
        }
      delete [] tempListoperands; 
     storageOf_operators.storeDataInEasyStorageClass(source->p_operators);
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgNaryOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgExpressionPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < VariantTList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgNaryOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgExpressionPtrList > :: deleteMemoryPool() ;
     EasyStorage < VariantTList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgNaryOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgExpressionPtrList > :: writeToFile(out) ;
     EasyStorage < VariantTList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgNaryOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgExpressionPtrList > :: readFromFile(in) ;
     EasyStorage < VariantTList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 38437 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgNaryBooleanOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 38450 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgNaryBooleanOpStorageClass::pickOutIRNodeData ( SgNaryBooleanOp* pointer ) 
   { 
     SgNaryBooleanOp* source = (SgNaryBooleanOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgExpressionPtrList::iterator i_operands = source->p_operands.begin() ; 
     unsigned int tempListCountoperands = 0; 
     SgExpressionPtrList::value_type *  tempListoperands = new SgExpressionPtrList::value_type[ source->p_operands.size() ]; 
     for ( ; i_operands != source->p_operands.end(); ++i_operands ) 
        {
          tempListoperands[tempListCountoperands] = *i_operands;
          tempListCountoperands++; 
          (*i_operands) = (SgExpressionPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_operands ) );
        }
     storageOf_operands.storeDataInEasyStorageClass(source->p_operands);
     tempListCountoperands = 0; 
     i_operands = source->p_operands.begin() ; 
     for ( ; i_operands != source->p_operands.end(); ++i_operands ) 
        {
          *i_operands = tempListoperands[tempListCountoperands] ;
          tempListCountoperands++; 
        }
      delete [] tempListoperands; 
     storageOf_operators.storeDataInEasyStorageClass(source->p_operators);
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgNaryBooleanOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgExpressionPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < VariantTList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgNaryBooleanOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgExpressionPtrList > :: deleteMemoryPool() ;
     EasyStorage < VariantTList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgNaryBooleanOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgExpressionPtrList > :: writeToFile(out) ;
     EasyStorage < VariantTList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgNaryBooleanOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgExpressionPtrList > :: readFromFile(in) ;
     EasyStorage < VariantTList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 38536 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgNaryComparisonOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 38549 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgNaryComparisonOpStorageClass::pickOutIRNodeData ( SgNaryComparisonOp* pointer ) 
   { 
     SgNaryComparisonOp* source = (SgNaryComparisonOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgExpressionPtrList::iterator i_operands = source->p_operands.begin() ; 
     unsigned int tempListCountoperands = 0; 
     SgExpressionPtrList::value_type *  tempListoperands = new SgExpressionPtrList::value_type[ source->p_operands.size() ]; 
     for ( ; i_operands != source->p_operands.end(); ++i_operands ) 
        {
          tempListoperands[tempListCountoperands] = *i_operands;
          tempListCountoperands++; 
          (*i_operands) = (SgExpressionPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_operands ) );
        }
     storageOf_operands.storeDataInEasyStorageClass(source->p_operands);
     tempListCountoperands = 0; 
     i_operands = source->p_operands.begin() ; 
     for ( ; i_operands != source->p_operands.end(); ++i_operands ) 
        {
          *i_operands = tempListoperands[tempListCountoperands] ;
          tempListCountoperands++; 
        }
      delete [] tempListoperands; 
     storageOf_operators.storeDataInEasyStorageClass(source->p_operators);
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgNaryComparisonOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgExpressionPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < VariantTList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgNaryComparisonOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgExpressionPtrList > :: deleteMemoryPool() ;
     EasyStorage < VariantTList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgNaryComparisonOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgExpressionPtrList > :: writeToFile(out) ;
     EasyStorage < VariantTList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgNaryComparisonOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgExpressionPtrList > :: readFromFile(in) ;
     EasyStorage < VariantTList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 38635 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgStringConversionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 38648 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgStringConversionStorageClass::pickOutIRNodeData ( SgStringConversion* pointer ) 
   { 
     SgStringConversion* source = (SgStringConversion*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_expression = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgStringConversionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgStringConversionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgStringConversionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgStringConversionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 38708 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgYieldExpressionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 38721 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgYieldExpressionStorageClass::pickOutIRNodeData ( SgYieldExpression* pointer ) 
   { 
     SgYieldExpression* source = (SgYieldExpression*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_value = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_value );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgYieldExpressionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgYieldExpressionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgYieldExpressionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgYieldExpressionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 38781 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTokenStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 38794 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgTokenStorageClass::pickOutIRNodeData ( SgToken* pointer ) 
   { 
     SgToken* source = (SgToken*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_lexeme_string.storeDataInEasyStorageClass(source->p_lexeme_string);
     storageOf_classification_code =  source->p_classification_code ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgTokenStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTokenStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTokenStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTokenStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 38855 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgSymbolStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 38868 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgSymbolStorageClass::pickOutIRNodeData ( SgSymbol* pointer ) 
   { 
     SgSymbol* source = (SgSymbol*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgSymbolStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgSymbolStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgSymbolStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgSymbolStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 38916 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgVariableSymbolStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 38929 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgVariableSymbolStorageClass::pickOutIRNodeData ( SgVariableSymbol* pointer ) 
   { 
     SgVariableSymbol* source = (SgVariableSymbol*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_declaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declaration );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgVariableSymbolStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgVariableSymbolStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgVariableSymbolStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgVariableSymbolStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 38978 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgFunctionSymbolStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 38991 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgFunctionSymbolStorageClass::pickOutIRNodeData ( SgFunctionSymbol* pointer ) 
   { 
     SgFunctionSymbol* source = (SgFunctionSymbol*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_declaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declaration );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgFunctionSymbolStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgFunctionSymbolStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgFunctionSymbolStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgFunctionSymbolStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 39040 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgMemberFunctionSymbolStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 39053 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgMemberFunctionSymbolStorageClass::pickOutIRNodeData ( SgMemberFunctionSymbol* pointer ) 
   { 
     SgMemberFunctionSymbol* source = (SgMemberFunctionSymbol*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_declaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declaration );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgMemberFunctionSymbolStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgMemberFunctionSymbolStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgMemberFunctionSymbolStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgMemberFunctionSymbolStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 39102 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgRenameSymbolStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 39115 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgRenameSymbolStorageClass::pickOutIRNodeData ( SgRenameSymbol* pointer ) 
   { 
     SgRenameSymbol* source = (SgRenameSymbol*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_original_symbol = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_original_symbol );
     storageOf_new_name.pickOutIRNodeData( &(source->p_new_name) );
     storageOf_declaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declaration );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgRenameSymbolStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgRenameSymbolStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgRenameSymbolStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgRenameSymbolStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 39170 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgFunctionTypeSymbolStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 39183 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgFunctionTypeSymbolStorageClass::pickOutIRNodeData ( SgFunctionTypeSymbol* pointer ) 
   { 
     SgFunctionTypeSymbol* source = (SgFunctionTypeSymbol*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_name.pickOutIRNodeData( &(source->p_name) );
     storageOf_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgFunctionTypeSymbolStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgFunctionTypeSymbolStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgFunctionTypeSymbolStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgFunctionTypeSymbolStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 39237 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgClassSymbolStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 39250 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgClassSymbolStorageClass::pickOutIRNodeData ( SgClassSymbol* pointer ) 
   { 
     SgClassSymbol* source = (SgClassSymbol*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_declaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declaration );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgClassSymbolStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgClassSymbolStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgClassSymbolStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgClassSymbolStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 39299 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTemplateSymbolStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 39312 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgTemplateSymbolStorageClass::pickOutIRNodeData ( SgTemplateSymbol* pointer ) 
   { 
     SgTemplateSymbol* source = (SgTemplateSymbol*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_declaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declaration );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgTemplateSymbolStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTemplateSymbolStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTemplateSymbolStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTemplateSymbolStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 39361 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgEnumSymbolStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 39374 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgEnumSymbolStorageClass::pickOutIRNodeData ( SgEnumSymbol* pointer ) 
   { 
     SgEnumSymbol* source = (SgEnumSymbol*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_declaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declaration );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgEnumSymbolStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgEnumSymbolStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgEnumSymbolStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgEnumSymbolStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 39423 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgEnumFieldSymbolStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 39436 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgEnumFieldSymbolStorageClass::pickOutIRNodeData ( SgEnumFieldSymbol* pointer ) 
   { 
     SgEnumFieldSymbol* source = (SgEnumFieldSymbol*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_declaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declaration );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgEnumFieldSymbolStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgEnumFieldSymbolStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgEnumFieldSymbolStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgEnumFieldSymbolStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 39485 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTypedefSymbolStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 39498 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgTypedefSymbolStorageClass::pickOutIRNodeData ( SgTypedefSymbol* pointer ) 
   { 
     SgTypedefSymbol* source = (SgTypedefSymbol*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_declaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declaration );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgTypedefSymbolStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTypedefSymbolStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTypedefSymbolStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTypedefSymbolStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 39547 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgLabelSymbolStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 39560 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgLabelSymbolStorageClass::pickOutIRNodeData ( SgLabelSymbol* pointer ) 
   { 
     SgLabelSymbol* source = (SgLabelSymbol*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_declaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declaration );
     storageOf_fortran_statement = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_fortran_statement );
     storageOf_fortran_alternate_return_parameter = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_fortran_alternate_return_parameter );
     storageOf_numeric_label_value =  source->p_numeric_label_value ;
     storageOf_label_type =  source->p_label_type ;
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgLabelSymbolStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgLabelSymbolStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgLabelSymbolStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgLabelSymbolStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 39613 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgDefaultSymbolStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 39626 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgDefaultSymbolStorageClass::pickOutIRNodeData ( SgDefaultSymbol* pointer ) 
   { 
     SgDefaultSymbol* source = (SgDefaultSymbol*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgDefaultSymbolStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgDefaultSymbolStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgDefaultSymbolStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgDefaultSymbolStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 39675 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgNamespaceSymbolStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 39688 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgNamespaceSymbolStorageClass::pickOutIRNodeData ( SgNamespaceSymbol* pointer ) 
   { 
     SgNamespaceSymbol* source = (SgNamespaceSymbol*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_name.pickOutIRNodeData( &(source->p_name) );
     storageOf_declaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declaration );
     storageOf_aliasDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_aliasDeclaration );
     storageOf_isAlias =  source->p_isAlias ;
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgNamespaceSymbolStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgNamespaceSymbolStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgNamespaceSymbolStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgNamespaceSymbolStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 39744 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgIntrinsicSymbolStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 39757 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgIntrinsicSymbolStorageClass::pickOutIRNodeData ( SgIntrinsicSymbol* pointer ) 
   { 
     SgIntrinsicSymbol* source = (SgIntrinsicSymbol*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_declaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declaration );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgIntrinsicSymbolStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgIntrinsicSymbolStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgIntrinsicSymbolStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgIntrinsicSymbolStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 39806 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgModuleSymbolStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 39819 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgModuleSymbolStorageClass::pickOutIRNodeData ( SgModuleSymbol* pointer ) 
   { 
     SgModuleSymbol* source = (SgModuleSymbol*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_declaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declaration );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgModuleSymbolStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgModuleSymbolStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgModuleSymbolStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgModuleSymbolStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 39868 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgInterfaceSymbolStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 39881 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgInterfaceSymbolStorageClass::pickOutIRNodeData ( SgInterfaceSymbol* pointer ) 
   { 
     SgInterfaceSymbol* source = (SgInterfaceSymbol*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_declaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declaration );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgInterfaceSymbolStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgInterfaceSymbolStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgInterfaceSymbolStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgInterfaceSymbolStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 39930 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgCommonSymbolStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 39943 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgCommonSymbolStorageClass::pickOutIRNodeData ( SgCommonSymbol* pointer ) 
   { 
     SgCommonSymbol* source = (SgCommonSymbol*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_declaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declaration );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgCommonSymbolStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgCommonSymbolStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgCommonSymbolStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgCommonSymbolStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 39992 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAliasSymbolStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 40005 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAliasSymbolStorageClass::pickOutIRNodeData ( SgAliasSymbol* pointer ) 
   { 
     SgAliasSymbol* source = (SgAliasSymbol*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_alias = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_alias );
     storageOf_isRenamed =  source->p_isRenamed ;
     storageOf_new_name.pickOutIRNodeData( &(source->p_new_name) );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAliasSymbolStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAliasSymbolStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAliasSymbolStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAliasSymbolStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 40060 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmBinaryAddressSymbolStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 40073 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmBinaryAddressSymbolStorageClass::pickOutIRNodeData ( SgAsmBinaryAddressSymbol* pointer ) 
   { 
     SgAsmBinaryAddressSymbol* source = (SgAsmBinaryAddressSymbol*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_address_name.pickOutIRNodeData( &(source->p_address_name) );
     storageOf_address = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_address );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmBinaryAddressSymbolStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmBinaryAddressSymbolStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmBinaryAddressSymbolStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmBinaryAddressSymbolStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 40127 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmBinaryDataSymbolStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 40140 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmBinaryDataSymbolStorageClass::pickOutIRNodeData ( SgAsmBinaryDataSymbol* pointer ) 
   { 
     SgAsmBinaryDataSymbol* source = (SgAsmBinaryDataSymbol*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_variable_name.pickOutIRNodeData( &(source->p_variable_name) );
     storageOf_address = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_address );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmBinaryDataSymbolStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmBinaryDataSymbolStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmBinaryDataSymbolStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmBinaryDataSymbolStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 40194 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgJavaLabelSymbolStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 40207 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgJavaLabelSymbolStorageClass::pickOutIRNodeData ( SgJavaLabelSymbol* pointer ) 
   { 
     SgJavaLabelSymbol* source = (SgJavaLabelSymbol*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_declaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declaration );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgJavaLabelSymbolStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgJavaLabelSymbolStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgJavaLabelSymbolStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgJavaLabelSymbolStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 40256 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmNodeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 40269 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmNodeStorageClass::pickOutIRNodeData ( SgAsmNode* pointer ) 
   { 
     SgAsmNode* source = (SgAsmNode*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmNodeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmNodeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmNodeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmNodeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 40323 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 40336 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmStatementStorageClass::pickOutIRNodeData ( SgAsmStatement* pointer ) 
   { 
     SgAsmStatement* source = (SgAsmStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_address =  source->p_address ;
     storageOf_comment.storeDataInEasyStorageClass(source->p_comment);
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 40396 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmFunctionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 40409 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmFunctionStorageClass::pickOutIRNodeData ( SgAsmFunction* pointer ) 
   { 
     SgAsmFunction* source = (SgAsmFunction*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_reason =  source->p_reason ;
     storageOf_function_kind =  source->p_function_kind ;
     storageOf_may_return =  source->p_may_return ;
     storageOf_name_md5.storeDataInEasyStorageClass(source->p_name_md5);
     SgAsmStatementPtrList::iterator i_statementList = source->p_statementList.begin() ; 
     unsigned int tempListCountstatementList = 0; 
     SgAsmStatementPtrList::value_type *  tempListstatementList = new SgAsmStatementPtrList::value_type[ source->p_statementList.size() ]; 
     for ( ; i_statementList != source->p_statementList.end(); ++i_statementList ) 
        {
          tempListstatementList[tempListCountstatementList] = *i_statementList;
          tempListCountstatementList++; 
          (*i_statementList) = (SgAsmStatementPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_statementList ) );
        }
     storageOf_statementList.storeDataInEasyStorageClass(source->p_statementList);
     tempListCountstatementList = 0; 
     i_statementList = source->p_statementList.begin() ; 
     for ( ; i_statementList != source->p_statementList.end(); ++i_statementList ) 
        {
          *i_statementList = tempListstatementList[tempListCountstatementList] ;
          tempListCountstatementList++; 
        }
      delete [] tempListstatementList; 
     SgAsmStatementPtrList::iterator i_dest = source->p_dest.begin() ; 
     unsigned int tempListCountdest = 0; 
     SgAsmStatementPtrList::value_type *  tempListdest = new SgAsmStatementPtrList::value_type[ source->p_dest.size() ]; 
     for ( ; i_dest != source->p_dest.end(); ++i_dest ) 
        {
          tempListdest[tempListCountdest] = *i_dest;
          tempListCountdest++; 
          (*i_dest) = (SgAsmStatementPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_dest ) );
        }
     storageOf_dest.storeDataInEasyStorageClass(source->p_dest);
     tempListCountdest = 0; 
     i_dest = source->p_dest.begin() ; 
     for ( ; i_dest != source->p_dest.end(); ++i_dest ) 
        {
          *i_dest = tempListdest[tempListCountdest] ;
          tempListCountdest++; 
        }
      delete [] tempListdest; 
     storageOf_entry_va =  source->p_entry_va ;
     storageOf_symbol_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_symbol_table );
     storageOf_cached_vertex =  source->p_cached_vertex ;
     storageOf_address =  source->p_address ;
     storageOf_comment.storeDataInEasyStorageClass(source->p_comment);
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmFunctionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgAsmStatementPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmFunctionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < SgAsmStatementPtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmFunctionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < SgAsmStatementPtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmFunctionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < SgAsmStatementPtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 40517 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmBlockStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 40530 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmBlockStorageClass::pickOutIRNodeData ( SgAsmBlock* pointer ) 
   { 
     SgAsmBlock* source = (SgAsmBlock*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_next_block_true_address =  source->p_next_block_true_address ;
     storageOf_next_block_false_address =  source->p_next_block_false_address ;
     storageOf_id =  source->p_id ;
     storageOf_reason =  source->p_reason ;
     SgAsmStatementPtrList::iterator i_statementList = source->p_statementList.begin() ; 
     unsigned int tempListCountstatementList = 0; 
     SgAsmStatementPtrList::value_type *  tempListstatementList = new SgAsmStatementPtrList::value_type[ source->p_statementList.size() ]; 
     for ( ; i_statementList != source->p_statementList.end(); ++i_statementList ) 
        {
          tempListstatementList[tempListCountstatementList] = *i_statementList;
          tempListCountstatementList++; 
          (*i_statementList) = (SgAsmStatementPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_statementList ) );
        }
     storageOf_statementList.storeDataInEasyStorageClass(source->p_statementList);
     tempListCountstatementList = 0; 
     i_statementList = source->p_statementList.begin() ; 
     for ( ; i_statementList != source->p_statementList.end(); ++i_statementList ) 
        {
          *i_statementList = tempListstatementList[tempListCountstatementList] ;
          tempListCountstatementList++; 
        }
      delete [] tempListstatementList; 
     SgAsmIntegerValuePtrList::iterator i_successors = source->p_successors.begin() ; 
     unsigned int tempListCountsuccessors = 0; 
     SgAsmIntegerValuePtrList::value_type *  tempListsuccessors = new SgAsmIntegerValuePtrList::value_type[ source->p_successors.size() ]; 
     for ( ; i_successors != source->p_successors.end(); ++i_successors ) 
        {
          tempListsuccessors[tempListCountsuccessors] = *i_successors;
          tempListCountsuccessors++; 
          (*i_successors) = (SgAsmIntegerValuePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_successors ) );
        }
     storageOf_successors.storeDataInEasyStorageClass(source->p_successors);
     tempListCountsuccessors = 0; 
     i_successors = source->p_successors.begin() ; 
     for ( ; i_successors != source->p_successors.end(); ++i_successors ) 
        {
          *i_successors = tempListsuccessors[tempListCountsuccessors] ;
          tempListCountsuccessors++; 
        }
      delete [] tempListsuccessors; 
     storageOf_successors_complete =  source->p_successors_complete ;
     storageOf_immediate_dominator = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_immediate_dominator );
     storageOf_cached_vertex =  source->p_cached_vertex ;
     storageOf_code_likelihood =  source->p_code_likelihood ;
     storageOf_address =  source->p_address ;
     storageOf_comment.storeDataInEasyStorageClass(source->p_comment);
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmBlockStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgAsmStatementPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgAsmIntegerValuePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmBlockStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgAsmStatementPtrList > :: deleteMemoryPool() ;
     EasyStorage < SgAsmIntegerValuePtrList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmBlockStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgAsmStatementPtrList > :: writeToFile(out) ;
     EasyStorage < SgAsmIntegerValuePtrList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmBlockStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgAsmStatementPtrList > :: readFromFile(in) ;
     EasyStorage < SgAsmIntegerValuePtrList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 40642 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmInstructionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 40655 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmInstructionStorageClass::pickOutIRNodeData ( SgAsmInstruction* pointer ) 
   { 
     SgAsmInstruction* source = (SgAsmInstruction*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_mnemonic.storeDataInEasyStorageClass(source->p_mnemonic);
     storageOf_raw_bytes.storeDataInEasyStorageClass(source->p_raw_bytes);
     storageOf_operandList = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operandList );
     SgAsmStatementPtrList::iterator i_sources = source->p_sources.begin() ; 
     unsigned int tempListCountsources = 0; 
     SgAsmStatementPtrList::value_type *  tempListsources = new SgAsmStatementPtrList::value_type[ source->p_sources.size() ]; 
     for ( ; i_sources != source->p_sources.end(); ++i_sources ) 
        {
          tempListsources[tempListCountsources] = *i_sources;
          tempListCountsources++; 
          (*i_sources) = (SgAsmStatementPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_sources ) );
        }
     storageOf_sources.storeDataInEasyStorageClass(source->p_sources);
     tempListCountsources = 0; 
     i_sources = source->p_sources.begin() ; 
     for ( ; i_sources != source->p_sources.end(); ++i_sources ) 
        {
          *i_sources = tempListsources[tempListCountsources] ;
          tempListCountsources++; 
        }
      delete [] tempListsources; 
     storageOf_address =  source->p_address ;
     storageOf_comment.storeDataInEasyStorageClass(source->p_comment);
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmInstructionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgUnsignedCharList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgAsmStatementPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmInstructionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < SgUnsignedCharList > :: deleteMemoryPool() ;
     EasyStorage < SgAsmStatementPtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmInstructionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < SgUnsignedCharList > :: writeToFile(out) ;
     EasyStorage < SgAsmStatementPtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmInstructionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < SgUnsignedCharList > :: readFromFile(in) ;
     EasyStorage < SgAsmStatementPtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 40744 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmx86InstructionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 40757 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmx86InstructionStorageClass::pickOutIRNodeData ( SgAsmx86Instruction* pointer ) 
   { 
     SgAsmx86Instruction* source = (SgAsmx86Instruction*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_kind =  source->p_kind ;
     storageOf_baseSize =  source->p_baseSize ;
     storageOf_operandSize =  source->p_operandSize ;
     storageOf_addressSize =  source->p_addressSize ;
     storageOf_lockPrefix =  source->p_lockPrefix ;
     storageOf_repeatPrefix =  source->p_repeatPrefix ;
     storageOf_branchPrediction =  source->p_branchPrediction ;
     storageOf_segmentOverride =  source->p_segmentOverride ;
     storageOf_mnemonic.storeDataInEasyStorageClass(source->p_mnemonic);
     storageOf_raw_bytes.storeDataInEasyStorageClass(source->p_raw_bytes);
     storageOf_operandList = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operandList );
     SgAsmStatementPtrList::iterator i_sources = source->p_sources.begin() ; 
     unsigned int tempListCountsources = 0; 
     SgAsmStatementPtrList::value_type *  tempListsources = new SgAsmStatementPtrList::value_type[ source->p_sources.size() ]; 
     for ( ; i_sources != source->p_sources.end(); ++i_sources ) 
        {
          tempListsources[tempListCountsources] = *i_sources;
          tempListCountsources++; 
          (*i_sources) = (SgAsmStatementPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_sources ) );
        }
     storageOf_sources.storeDataInEasyStorageClass(source->p_sources);
     tempListCountsources = 0; 
     i_sources = source->p_sources.begin() ; 
     for ( ; i_sources != source->p_sources.end(); ++i_sources ) 
        {
          *i_sources = tempListsources[tempListCountsources] ;
          tempListCountsources++; 
        }
      delete [] tempListsources; 
     storageOf_address =  source->p_address ;
     storageOf_comment.storeDataInEasyStorageClass(source->p_comment);
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmx86InstructionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgUnsignedCharList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgAsmStatementPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmx86InstructionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < SgUnsignedCharList > :: deleteMemoryPool() ;
     EasyStorage < SgAsmStatementPtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmx86InstructionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < SgUnsignedCharList > :: writeToFile(out) ;
     EasyStorage < SgAsmStatementPtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmx86InstructionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < SgUnsignedCharList > :: readFromFile(in) ;
     EasyStorage < SgAsmStatementPtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 40854 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmArmInstructionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 40867 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmArmInstructionStorageClass::pickOutIRNodeData ( SgAsmArmInstruction* pointer ) 
   { 
     SgAsmArmInstruction* source = (SgAsmArmInstruction*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_kind =  source->p_kind ;
     storageOf_condition =  source->p_condition ;
     storageOf_positionOfConditionInMnemonic =  source->p_positionOfConditionInMnemonic ;
     storageOf_mnemonic.storeDataInEasyStorageClass(source->p_mnemonic);
     storageOf_raw_bytes.storeDataInEasyStorageClass(source->p_raw_bytes);
     storageOf_operandList = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operandList );
     SgAsmStatementPtrList::iterator i_sources = source->p_sources.begin() ; 
     unsigned int tempListCountsources = 0; 
     SgAsmStatementPtrList::value_type *  tempListsources = new SgAsmStatementPtrList::value_type[ source->p_sources.size() ]; 
     for ( ; i_sources != source->p_sources.end(); ++i_sources ) 
        {
          tempListsources[tempListCountsources] = *i_sources;
          tempListCountsources++; 
          (*i_sources) = (SgAsmStatementPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_sources ) );
        }
     storageOf_sources.storeDataInEasyStorageClass(source->p_sources);
     tempListCountsources = 0; 
     i_sources = source->p_sources.begin() ; 
     for ( ; i_sources != source->p_sources.end(); ++i_sources ) 
        {
          *i_sources = tempListsources[tempListCountsources] ;
          tempListCountsources++; 
        }
      delete [] tempListsources; 
     storageOf_address =  source->p_address ;
     storageOf_comment.storeDataInEasyStorageClass(source->p_comment);
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmArmInstructionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgUnsignedCharList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgAsmStatementPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmArmInstructionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < SgUnsignedCharList > :: deleteMemoryPool() ;
     EasyStorage < SgAsmStatementPtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmArmInstructionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < SgUnsignedCharList > :: writeToFile(out) ;
     EasyStorage < SgAsmStatementPtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmArmInstructionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < SgUnsignedCharList > :: readFromFile(in) ;
     EasyStorage < SgAsmStatementPtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 40959 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmPowerpcInstructionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 40972 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmPowerpcInstructionStorageClass::pickOutIRNodeData ( SgAsmPowerpcInstruction* pointer ) 
   { 
     SgAsmPowerpcInstruction* source = (SgAsmPowerpcInstruction*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_kind =  source->p_kind ;
     storageOf_mnemonic.storeDataInEasyStorageClass(source->p_mnemonic);
     storageOf_raw_bytes.storeDataInEasyStorageClass(source->p_raw_bytes);
     storageOf_operandList = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operandList );
     SgAsmStatementPtrList::iterator i_sources = source->p_sources.begin() ; 
     unsigned int tempListCountsources = 0; 
     SgAsmStatementPtrList::value_type *  tempListsources = new SgAsmStatementPtrList::value_type[ source->p_sources.size() ]; 
     for ( ; i_sources != source->p_sources.end(); ++i_sources ) 
        {
          tempListsources[tempListCountsources] = *i_sources;
          tempListCountsources++; 
          (*i_sources) = (SgAsmStatementPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_sources ) );
        }
     storageOf_sources.storeDataInEasyStorageClass(source->p_sources);
     tempListCountsources = 0; 
     i_sources = source->p_sources.begin() ; 
     for ( ; i_sources != source->p_sources.end(); ++i_sources ) 
        {
          *i_sources = tempListsources[tempListCountsources] ;
          tempListCountsources++; 
        }
      delete [] tempListsources; 
     storageOf_address =  source->p_address ;
     storageOf_comment.storeDataInEasyStorageClass(source->p_comment);
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmPowerpcInstructionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgUnsignedCharList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgAsmStatementPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmPowerpcInstructionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < SgUnsignedCharList > :: deleteMemoryPool() ;
     EasyStorage < SgAsmStatementPtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmPowerpcInstructionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < SgUnsignedCharList > :: writeToFile(out) ;
     EasyStorage < SgAsmStatementPtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmPowerpcInstructionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < SgUnsignedCharList > :: readFromFile(in) ;
     EasyStorage < SgAsmStatementPtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 41062 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmStaticDataStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 41075 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmStaticDataStorageClass::pickOutIRNodeData ( SgAsmStaticData* pointer ) 
   { 
     SgAsmStaticData* source = (SgAsmStaticData*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_raw_bytes.storeDataInEasyStorageClass(source->p_raw_bytes);
     storageOf_address =  source->p_address ;
     storageOf_comment.storeDataInEasyStorageClass(source->p_comment);
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmStaticDataStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgUnsignedCharList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmStaticDataStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgUnsignedCharList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmStaticDataStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgUnsignedCharList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmStaticDataStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgUnsignedCharList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 41140 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmExpressionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 41153 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmExpressionStorageClass::pickOutIRNodeData ( SgAsmExpression* pointer ) 
   { 
     SgAsmExpression* source = (SgAsmExpression*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_replacement.storeDataInEasyStorageClass(source->p_replacement);
     storageOf_comment.storeDataInEasyStorageClass(source->p_comment);
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmExpressionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmExpressionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmExpressionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmExpressionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 41213 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmValueExpressionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 41226 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmValueExpressionStorageClass::pickOutIRNodeData ( SgAsmValueExpression* pointer ) 
   { 
     SgAsmValueExpression* source = (SgAsmValueExpression*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_unfolded_expression_tree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_unfolded_expression_tree );
     storageOf_bit_offset =  source->p_bit_offset ;
     storageOf_bit_size =  source->p_bit_size ;
     storageOf_symbol = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_symbol );
     storageOf_replacement.storeDataInEasyStorageClass(source->p_replacement);
     storageOf_comment.storeDataInEasyStorageClass(source->p_comment);
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmValueExpressionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmValueExpressionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmValueExpressionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmValueExpressionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 41290 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmIntegerValueExpressionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 41303 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmIntegerValueExpressionStorageClass::pickOutIRNodeData ( SgAsmIntegerValueExpression* pointer ) 
   { 
     SgAsmIntegerValueExpression* source = (SgAsmIntegerValueExpression*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_base_node = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_base_node );
     storageOf_relative_value =  source->p_relative_value ;
     storageOf_significant_bits =  source->p_significant_bits ;
     storageOf_unfolded_expression_tree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_unfolded_expression_tree );
     storageOf_bit_offset =  source->p_bit_offset ;
     storageOf_bit_size =  source->p_bit_size ;
     storageOf_symbol = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_symbol );
     storageOf_replacement.storeDataInEasyStorageClass(source->p_replacement);
     storageOf_comment.storeDataInEasyStorageClass(source->p_comment);
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmIntegerValueExpressionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmIntegerValueExpressionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmIntegerValueExpressionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmIntegerValueExpressionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 41370 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmByteValueExpressionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 41383 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmByteValueExpressionStorageClass::pickOutIRNodeData ( SgAsmByteValueExpression* pointer ) 
   { 
     SgAsmByteValueExpression* source = (SgAsmByteValueExpression*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_base_node = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_base_node );
     storageOf_relative_value =  source->p_relative_value ;
     storageOf_significant_bits =  source->p_significant_bits ;
     storageOf_unfolded_expression_tree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_unfolded_expression_tree );
     storageOf_bit_offset =  source->p_bit_offset ;
     storageOf_bit_size =  source->p_bit_size ;
     storageOf_symbol = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_symbol );
     storageOf_replacement.storeDataInEasyStorageClass(source->p_replacement);
     storageOf_comment.storeDataInEasyStorageClass(source->p_comment);
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmByteValueExpressionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmByteValueExpressionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmByteValueExpressionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmByteValueExpressionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 41450 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmWordValueExpressionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 41463 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmWordValueExpressionStorageClass::pickOutIRNodeData ( SgAsmWordValueExpression* pointer ) 
   { 
     SgAsmWordValueExpression* source = (SgAsmWordValueExpression*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_base_node = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_base_node );
     storageOf_relative_value =  source->p_relative_value ;
     storageOf_significant_bits =  source->p_significant_bits ;
     storageOf_unfolded_expression_tree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_unfolded_expression_tree );
     storageOf_bit_offset =  source->p_bit_offset ;
     storageOf_bit_size =  source->p_bit_size ;
     storageOf_symbol = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_symbol );
     storageOf_replacement.storeDataInEasyStorageClass(source->p_replacement);
     storageOf_comment.storeDataInEasyStorageClass(source->p_comment);
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmWordValueExpressionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmWordValueExpressionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmWordValueExpressionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmWordValueExpressionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 41530 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDoubleWordValueExpressionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 41543 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDoubleWordValueExpressionStorageClass::pickOutIRNodeData ( SgAsmDoubleWordValueExpression* pointer ) 
   { 
     SgAsmDoubleWordValueExpression* source = (SgAsmDoubleWordValueExpression*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_base_node = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_base_node );
     storageOf_relative_value =  source->p_relative_value ;
     storageOf_significant_bits =  source->p_significant_bits ;
     storageOf_unfolded_expression_tree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_unfolded_expression_tree );
     storageOf_bit_offset =  source->p_bit_offset ;
     storageOf_bit_size =  source->p_bit_size ;
     storageOf_symbol = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_symbol );
     storageOf_replacement.storeDataInEasyStorageClass(source->p_replacement);
     storageOf_comment.storeDataInEasyStorageClass(source->p_comment);
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDoubleWordValueExpressionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDoubleWordValueExpressionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDoubleWordValueExpressionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDoubleWordValueExpressionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 41610 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmQuadWordValueExpressionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 41623 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmQuadWordValueExpressionStorageClass::pickOutIRNodeData ( SgAsmQuadWordValueExpression* pointer ) 
   { 
     SgAsmQuadWordValueExpression* source = (SgAsmQuadWordValueExpression*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_base_node = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_base_node );
     storageOf_relative_value =  source->p_relative_value ;
     storageOf_significant_bits =  source->p_significant_bits ;
     storageOf_unfolded_expression_tree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_unfolded_expression_tree );
     storageOf_bit_offset =  source->p_bit_offset ;
     storageOf_bit_size =  source->p_bit_size ;
     storageOf_symbol = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_symbol );
     storageOf_replacement.storeDataInEasyStorageClass(source->p_replacement);
     storageOf_comment.storeDataInEasyStorageClass(source->p_comment);
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmQuadWordValueExpressionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmQuadWordValueExpressionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmQuadWordValueExpressionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmQuadWordValueExpressionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 41690 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmSingleFloatValueExpressionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 41703 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmSingleFloatValueExpressionStorageClass::pickOutIRNodeData ( SgAsmSingleFloatValueExpression* pointer ) 
   { 
     SgAsmSingleFloatValueExpression* source = (SgAsmSingleFloatValueExpression*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_value =  source->p_value ;
     storageOf_unfolded_expression_tree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_unfolded_expression_tree );
     storageOf_bit_offset =  source->p_bit_offset ;
     storageOf_bit_size =  source->p_bit_size ;
     storageOf_symbol = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_symbol );
     storageOf_replacement.storeDataInEasyStorageClass(source->p_replacement);
     storageOf_comment.storeDataInEasyStorageClass(source->p_comment);
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmSingleFloatValueExpressionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmSingleFloatValueExpressionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmSingleFloatValueExpressionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmSingleFloatValueExpressionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 41768 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDoubleFloatValueExpressionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 41781 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDoubleFloatValueExpressionStorageClass::pickOutIRNodeData ( SgAsmDoubleFloatValueExpression* pointer ) 
   { 
     SgAsmDoubleFloatValueExpression* source = (SgAsmDoubleFloatValueExpression*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_value =  source->p_value ;
     storageOf_unfolded_expression_tree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_unfolded_expression_tree );
     storageOf_bit_offset =  source->p_bit_offset ;
     storageOf_bit_size =  source->p_bit_size ;
     storageOf_symbol = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_symbol );
     storageOf_replacement.storeDataInEasyStorageClass(source->p_replacement);
     storageOf_comment.storeDataInEasyStorageClass(source->p_comment);
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDoubleFloatValueExpressionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDoubleFloatValueExpressionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDoubleFloatValueExpressionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDoubleFloatValueExpressionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 41846 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmVectorValueExpressionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 41859 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmVectorValueExpressionStorageClass::pickOutIRNodeData ( SgAsmVectorValueExpression* pointer ) 
   { 
     SgAsmVectorValueExpression* source = (SgAsmVectorValueExpression*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_size =  source->p_size ;
     storageOf_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type );
     storageOf_unfolded_expression_tree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_unfolded_expression_tree );
     storageOf_bit_offset =  source->p_bit_offset ;
     storageOf_bit_size =  source->p_bit_size ;
     storageOf_symbol = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_symbol );
     storageOf_replacement.storeDataInEasyStorageClass(source->p_replacement);
     storageOf_comment.storeDataInEasyStorageClass(source->p_comment);
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmVectorValueExpressionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmVectorValueExpressionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmVectorValueExpressionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmVectorValueExpressionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 41925 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmBinaryExpressionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 41938 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmBinaryExpressionStorageClass::pickOutIRNodeData ( SgAsmBinaryExpression* pointer ) 
   { 
     SgAsmBinaryExpression* source = (SgAsmBinaryExpression*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_lhs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs );
     storageOf_rhs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs );
     storageOf_replacement.storeDataInEasyStorageClass(source->p_replacement);
     storageOf_comment.storeDataInEasyStorageClass(source->p_comment);
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmBinaryExpressionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmBinaryExpressionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmBinaryExpressionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmBinaryExpressionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 42000 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmBinaryAddStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 42013 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmBinaryAddStorageClass::pickOutIRNodeData ( SgAsmBinaryAdd* pointer ) 
   { 
     SgAsmBinaryAdd* source = (SgAsmBinaryAdd*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_lhs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs );
     storageOf_rhs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs );
     storageOf_replacement.storeDataInEasyStorageClass(source->p_replacement);
     storageOf_comment.storeDataInEasyStorageClass(source->p_comment);
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmBinaryAddStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmBinaryAddStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmBinaryAddStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmBinaryAddStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 42075 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmBinarySubtractStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 42088 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmBinarySubtractStorageClass::pickOutIRNodeData ( SgAsmBinarySubtract* pointer ) 
   { 
     SgAsmBinarySubtract* source = (SgAsmBinarySubtract*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_lhs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs );
     storageOf_rhs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs );
     storageOf_replacement.storeDataInEasyStorageClass(source->p_replacement);
     storageOf_comment.storeDataInEasyStorageClass(source->p_comment);
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmBinarySubtractStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmBinarySubtractStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmBinarySubtractStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmBinarySubtractStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 42150 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmBinaryMultiplyStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 42163 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmBinaryMultiplyStorageClass::pickOutIRNodeData ( SgAsmBinaryMultiply* pointer ) 
   { 
     SgAsmBinaryMultiply* source = (SgAsmBinaryMultiply*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_lhs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs );
     storageOf_rhs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs );
     storageOf_replacement.storeDataInEasyStorageClass(source->p_replacement);
     storageOf_comment.storeDataInEasyStorageClass(source->p_comment);
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmBinaryMultiplyStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmBinaryMultiplyStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmBinaryMultiplyStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmBinaryMultiplyStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 42225 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmBinaryDivideStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 42238 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmBinaryDivideStorageClass::pickOutIRNodeData ( SgAsmBinaryDivide* pointer ) 
   { 
     SgAsmBinaryDivide* source = (SgAsmBinaryDivide*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_lhs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs );
     storageOf_rhs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs );
     storageOf_replacement.storeDataInEasyStorageClass(source->p_replacement);
     storageOf_comment.storeDataInEasyStorageClass(source->p_comment);
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmBinaryDivideStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmBinaryDivideStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmBinaryDivideStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmBinaryDivideStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 42300 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmBinaryModStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 42313 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmBinaryModStorageClass::pickOutIRNodeData ( SgAsmBinaryMod* pointer ) 
   { 
     SgAsmBinaryMod* source = (SgAsmBinaryMod*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_lhs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs );
     storageOf_rhs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs );
     storageOf_replacement.storeDataInEasyStorageClass(source->p_replacement);
     storageOf_comment.storeDataInEasyStorageClass(source->p_comment);
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmBinaryModStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmBinaryModStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmBinaryModStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmBinaryModStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 42375 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmBinaryAddPreupdateStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 42388 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmBinaryAddPreupdateStorageClass::pickOutIRNodeData ( SgAsmBinaryAddPreupdate* pointer ) 
   { 
     SgAsmBinaryAddPreupdate* source = (SgAsmBinaryAddPreupdate*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_lhs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs );
     storageOf_rhs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs );
     storageOf_replacement.storeDataInEasyStorageClass(source->p_replacement);
     storageOf_comment.storeDataInEasyStorageClass(source->p_comment);
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmBinaryAddPreupdateStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmBinaryAddPreupdateStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmBinaryAddPreupdateStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmBinaryAddPreupdateStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 42450 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmBinarySubtractPreupdateStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 42463 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmBinarySubtractPreupdateStorageClass::pickOutIRNodeData ( SgAsmBinarySubtractPreupdate* pointer ) 
   { 
     SgAsmBinarySubtractPreupdate* source = (SgAsmBinarySubtractPreupdate*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_lhs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs );
     storageOf_rhs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs );
     storageOf_replacement.storeDataInEasyStorageClass(source->p_replacement);
     storageOf_comment.storeDataInEasyStorageClass(source->p_comment);
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmBinarySubtractPreupdateStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmBinarySubtractPreupdateStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmBinarySubtractPreupdateStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmBinarySubtractPreupdateStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 42525 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmBinaryAddPostupdateStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 42538 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmBinaryAddPostupdateStorageClass::pickOutIRNodeData ( SgAsmBinaryAddPostupdate* pointer ) 
   { 
     SgAsmBinaryAddPostupdate* source = (SgAsmBinaryAddPostupdate*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_lhs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs );
     storageOf_rhs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs );
     storageOf_replacement.storeDataInEasyStorageClass(source->p_replacement);
     storageOf_comment.storeDataInEasyStorageClass(source->p_comment);
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmBinaryAddPostupdateStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmBinaryAddPostupdateStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmBinaryAddPostupdateStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmBinaryAddPostupdateStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 42600 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmBinarySubtractPostupdateStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 42613 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmBinarySubtractPostupdateStorageClass::pickOutIRNodeData ( SgAsmBinarySubtractPostupdate* pointer ) 
   { 
     SgAsmBinarySubtractPostupdate* source = (SgAsmBinarySubtractPostupdate*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_lhs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs );
     storageOf_rhs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs );
     storageOf_replacement.storeDataInEasyStorageClass(source->p_replacement);
     storageOf_comment.storeDataInEasyStorageClass(source->p_comment);
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmBinarySubtractPostupdateStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmBinarySubtractPostupdateStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmBinarySubtractPostupdateStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmBinarySubtractPostupdateStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 42675 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmBinaryLslStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 42688 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmBinaryLslStorageClass::pickOutIRNodeData ( SgAsmBinaryLsl* pointer ) 
   { 
     SgAsmBinaryLsl* source = (SgAsmBinaryLsl*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_lhs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs );
     storageOf_rhs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs );
     storageOf_replacement.storeDataInEasyStorageClass(source->p_replacement);
     storageOf_comment.storeDataInEasyStorageClass(source->p_comment);
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmBinaryLslStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmBinaryLslStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmBinaryLslStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmBinaryLslStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 42750 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmBinaryLsrStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 42763 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmBinaryLsrStorageClass::pickOutIRNodeData ( SgAsmBinaryLsr* pointer ) 
   { 
     SgAsmBinaryLsr* source = (SgAsmBinaryLsr*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_lhs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs );
     storageOf_rhs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs );
     storageOf_replacement.storeDataInEasyStorageClass(source->p_replacement);
     storageOf_comment.storeDataInEasyStorageClass(source->p_comment);
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmBinaryLsrStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmBinaryLsrStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmBinaryLsrStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmBinaryLsrStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 42825 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmBinaryAsrStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 42838 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmBinaryAsrStorageClass::pickOutIRNodeData ( SgAsmBinaryAsr* pointer ) 
   { 
     SgAsmBinaryAsr* source = (SgAsmBinaryAsr*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_lhs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs );
     storageOf_rhs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs );
     storageOf_replacement.storeDataInEasyStorageClass(source->p_replacement);
     storageOf_comment.storeDataInEasyStorageClass(source->p_comment);
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmBinaryAsrStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmBinaryAsrStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmBinaryAsrStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmBinaryAsrStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 42900 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmBinaryRorStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 42913 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmBinaryRorStorageClass::pickOutIRNodeData ( SgAsmBinaryRor* pointer ) 
   { 
     SgAsmBinaryRor* source = (SgAsmBinaryRor*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_lhs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs );
     storageOf_rhs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs );
     storageOf_replacement.storeDataInEasyStorageClass(source->p_replacement);
     storageOf_comment.storeDataInEasyStorageClass(source->p_comment);
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmBinaryRorStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmBinaryRorStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmBinaryRorStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmBinaryRorStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 42975 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmUnaryExpressionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 42988 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmUnaryExpressionStorageClass::pickOutIRNodeData ( SgAsmUnaryExpression* pointer ) 
   { 
     SgAsmUnaryExpression* source = (SgAsmUnaryExpression*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_operand = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operand );
     storageOf_replacement.storeDataInEasyStorageClass(source->p_replacement);
     storageOf_comment.storeDataInEasyStorageClass(source->p_comment);
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmUnaryExpressionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmUnaryExpressionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmUnaryExpressionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmUnaryExpressionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 43049 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmUnaryPlusStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 43062 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmUnaryPlusStorageClass::pickOutIRNodeData ( SgAsmUnaryPlus* pointer ) 
   { 
     SgAsmUnaryPlus* source = (SgAsmUnaryPlus*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_operand = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operand );
     storageOf_replacement.storeDataInEasyStorageClass(source->p_replacement);
     storageOf_comment.storeDataInEasyStorageClass(source->p_comment);
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmUnaryPlusStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmUnaryPlusStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmUnaryPlusStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmUnaryPlusStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 43123 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmUnaryMinusStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 43136 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmUnaryMinusStorageClass::pickOutIRNodeData ( SgAsmUnaryMinus* pointer ) 
   { 
     SgAsmUnaryMinus* source = (SgAsmUnaryMinus*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_operand = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operand );
     storageOf_replacement.storeDataInEasyStorageClass(source->p_replacement);
     storageOf_comment.storeDataInEasyStorageClass(source->p_comment);
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmUnaryMinusStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmUnaryMinusStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmUnaryMinusStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmUnaryMinusStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 43197 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmUnaryRrxStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 43210 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmUnaryRrxStorageClass::pickOutIRNodeData ( SgAsmUnaryRrx* pointer ) 
   { 
     SgAsmUnaryRrx* source = (SgAsmUnaryRrx*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_operand = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operand );
     storageOf_replacement.storeDataInEasyStorageClass(source->p_replacement);
     storageOf_comment.storeDataInEasyStorageClass(source->p_comment);
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmUnaryRrxStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmUnaryRrxStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmUnaryRrxStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmUnaryRrxStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 43271 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmUnaryArmSpecialRegisterListStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 43284 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmUnaryArmSpecialRegisterListStorageClass::pickOutIRNodeData ( SgAsmUnaryArmSpecialRegisterList* pointer ) 
   { 
     SgAsmUnaryArmSpecialRegisterList* source = (SgAsmUnaryArmSpecialRegisterList*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_operand = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operand );
     storageOf_replacement.storeDataInEasyStorageClass(source->p_replacement);
     storageOf_comment.storeDataInEasyStorageClass(source->p_comment);
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmUnaryArmSpecialRegisterListStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmUnaryArmSpecialRegisterListStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmUnaryArmSpecialRegisterListStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmUnaryArmSpecialRegisterListStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 43345 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmMemoryReferenceExpressionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 43358 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmMemoryReferenceExpressionStorageClass::pickOutIRNodeData ( SgAsmMemoryReferenceExpression* pointer ) 
   { 
     SgAsmMemoryReferenceExpression* source = (SgAsmMemoryReferenceExpression*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_address = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_address );
     storageOf_segment = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_segment );
     storageOf_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type );
     storageOf_replacement.storeDataInEasyStorageClass(source->p_replacement);
     storageOf_comment.storeDataInEasyStorageClass(source->p_comment);
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmMemoryReferenceExpressionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmMemoryReferenceExpressionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmMemoryReferenceExpressionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmMemoryReferenceExpressionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 43421 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmRegisterReferenceExpressionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 43434 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmRegisterReferenceExpressionStorageClass::pickOutIRNodeData ( SgAsmRegisterReferenceExpression* pointer ) 
   { 
     SgAsmRegisterReferenceExpression* source = (SgAsmRegisterReferenceExpression*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type );
     storageOf_descriptor =  source->p_descriptor ;
     storageOf_replacement.storeDataInEasyStorageClass(source->p_replacement);
     storageOf_comment.storeDataInEasyStorageClass(source->p_comment);
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmRegisterReferenceExpressionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmRegisterReferenceExpressionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmRegisterReferenceExpressionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmRegisterReferenceExpressionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 43496 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmx86RegisterReferenceExpressionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 43509 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmx86RegisterReferenceExpressionStorageClass::pickOutIRNodeData ( SgAsmx86RegisterReferenceExpression* pointer ) 
   { 
     SgAsmx86RegisterReferenceExpression* source = (SgAsmx86RegisterReferenceExpression*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type );
     storageOf_descriptor =  source->p_descriptor ;
     storageOf_replacement.storeDataInEasyStorageClass(source->p_replacement);
     storageOf_comment.storeDataInEasyStorageClass(source->p_comment);
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmx86RegisterReferenceExpressionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmx86RegisterReferenceExpressionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmx86RegisterReferenceExpressionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmx86RegisterReferenceExpressionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 43571 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmArmRegisterReferenceExpressionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 43584 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmArmRegisterReferenceExpressionStorageClass::pickOutIRNodeData ( SgAsmArmRegisterReferenceExpression* pointer ) 
   { 
     SgAsmArmRegisterReferenceExpression* source = (SgAsmArmRegisterReferenceExpression*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_psr_mask =  source->p_psr_mask ;
     storageOf_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type );
     storageOf_descriptor =  source->p_descriptor ;
     storageOf_replacement.storeDataInEasyStorageClass(source->p_replacement);
     storageOf_comment.storeDataInEasyStorageClass(source->p_comment);
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmArmRegisterReferenceExpressionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmArmRegisterReferenceExpressionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmArmRegisterReferenceExpressionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmArmRegisterReferenceExpressionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 43647 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmPowerpcRegisterReferenceExpressionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 43660 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmPowerpcRegisterReferenceExpressionStorageClass::pickOutIRNodeData ( SgAsmPowerpcRegisterReferenceExpression* pointer ) 
   { 
     SgAsmPowerpcRegisterReferenceExpression* source = (SgAsmPowerpcRegisterReferenceExpression*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type );
     storageOf_descriptor =  source->p_descriptor ;
     storageOf_replacement.storeDataInEasyStorageClass(source->p_replacement);
     storageOf_comment.storeDataInEasyStorageClass(source->p_comment);
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmPowerpcRegisterReferenceExpressionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmPowerpcRegisterReferenceExpressionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmPowerpcRegisterReferenceExpressionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmPowerpcRegisterReferenceExpressionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 43722 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmControlFlagsExpressionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 43735 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmControlFlagsExpressionStorageClass::pickOutIRNodeData ( SgAsmControlFlagsExpression* pointer ) 
   { 
     SgAsmControlFlagsExpression* source = (SgAsmControlFlagsExpression*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_bit_flags =  source->p_bit_flags ;
     storageOf_replacement.storeDataInEasyStorageClass(source->p_replacement);
     storageOf_comment.storeDataInEasyStorageClass(source->p_comment);
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmControlFlagsExpressionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmControlFlagsExpressionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmControlFlagsExpressionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmControlFlagsExpressionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 43796 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmCommonSubExpressionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 43809 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmCommonSubExpressionStorageClass::pickOutIRNodeData ( SgAsmCommonSubExpression* pointer ) 
   { 
     SgAsmCommonSubExpression* source = (SgAsmCommonSubExpression*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_subexpression = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_subexpression );
     storageOf_replacement.storeDataInEasyStorageClass(source->p_replacement);
     storageOf_comment.storeDataInEasyStorageClass(source->p_comment);
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmCommonSubExpressionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmCommonSubExpressionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmCommonSubExpressionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmCommonSubExpressionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 43870 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmExprListExpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 43883 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmExprListExpStorageClass::pickOutIRNodeData ( SgAsmExprListExp* pointer ) 
   { 
     SgAsmExprListExp* source = (SgAsmExprListExp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgAsmExpressionPtrList::iterator i_expressions = source->p_expressions.begin() ; 
     unsigned int tempListCountexpressions = 0; 
     SgAsmExpressionPtrList::value_type *  tempListexpressions = new SgAsmExpressionPtrList::value_type[ source->p_expressions.size() ]; 
     for ( ; i_expressions != source->p_expressions.end(); ++i_expressions ) 
        {
          tempListexpressions[tempListCountexpressions] = *i_expressions;
          tempListCountexpressions++; 
          (*i_expressions) = (SgAsmExpressionPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_expressions ) );
        }
     storageOf_expressions.storeDataInEasyStorageClass(source->p_expressions);
     tempListCountexpressions = 0; 
     i_expressions = source->p_expressions.begin() ; 
     for ( ; i_expressions != source->p_expressions.end(); ++i_expressions ) 
        {
          *i_expressions = tempListexpressions[tempListCountexpressions] ;
          tempListCountexpressions++; 
        }
      delete [] tempListexpressions; 
     storageOf_replacement.storeDataInEasyStorageClass(source->p_replacement);
     storageOf_comment.storeDataInEasyStorageClass(source->p_comment);
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmExprListExpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgAsmExpressionPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmExprListExpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgAsmExpressionPtrList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmExprListExpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgAsmExpressionPtrList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmExprListExpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgAsmExpressionPtrList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 43965 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmInterpretationStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 43978 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmInterpretationStorageClass::pickOutIRNodeData ( SgAsmInterpretation* pointer ) 
   { 
     SgAsmInterpretation* source = (SgAsmInterpretation*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_dwarf_info = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_dwarf_info );
     storageOf_headers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_headers );
     storageOf_global_block = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_global_block );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmInterpretationStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmInterpretationStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmInterpretationStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmInterpretationStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 44035 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmOperandListStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 44048 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmOperandListStorageClass::pickOutIRNodeData ( SgAsmOperandList* pointer ) 
   { 
     SgAsmOperandList* source = (SgAsmOperandList*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgAsmExpressionPtrList::iterator i_operands = source->p_operands.begin() ; 
     unsigned int tempListCountoperands = 0; 
     SgAsmExpressionPtrList::value_type *  tempListoperands = new SgAsmExpressionPtrList::value_type[ source->p_operands.size() ]; 
     for ( ; i_operands != source->p_operands.end(); ++i_operands ) 
        {
          tempListoperands[tempListCountoperands] = *i_operands;
          tempListCountoperands++; 
          (*i_operands) = (SgAsmExpressionPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_operands ) );
        }
     storageOf_operands.storeDataInEasyStorageClass(source->p_operands);
     tempListCountoperands = 0; 
     i_operands = source->p_operands.begin() ; 
     for ( ; i_operands != source->p_operands.end(); ++i_operands ) 
        {
          *i_operands = tempListoperands[tempListCountoperands] ;
          tempListCountoperands++; 
        }
      delete [] tempListoperands; 
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmOperandListStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgAsmExpressionPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmOperandListStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgAsmExpressionPtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmOperandListStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgAsmExpressionPtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmOperandListStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgAsmExpressionPtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 44124 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 44137 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmTypeStorageClass::pickOutIRNodeData ( SgAsmType* pointer ) 
   { 
     SgAsmType* source = (SgAsmType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 44191 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmTypeByteStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 44204 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmTypeByteStorageClass::pickOutIRNodeData ( SgAsmTypeByte* pointer ) 
   { 
     SgAsmTypeByte* source = (SgAsmTypeByte*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmTypeByteStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmTypeByteStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmTypeByteStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmTypeByteStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 44258 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmTypeWordStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 44271 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmTypeWordStorageClass::pickOutIRNodeData ( SgAsmTypeWord* pointer ) 
   { 
     SgAsmTypeWord* source = (SgAsmTypeWord*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmTypeWordStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmTypeWordStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmTypeWordStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmTypeWordStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 44325 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmTypeDoubleWordStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 44338 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmTypeDoubleWordStorageClass::pickOutIRNodeData ( SgAsmTypeDoubleWord* pointer ) 
   { 
     SgAsmTypeDoubleWord* source = (SgAsmTypeDoubleWord*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmTypeDoubleWordStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmTypeDoubleWordStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmTypeDoubleWordStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmTypeDoubleWordStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 44392 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmTypeQuadWordStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 44405 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmTypeQuadWordStorageClass::pickOutIRNodeData ( SgAsmTypeQuadWord* pointer ) 
   { 
     SgAsmTypeQuadWord* source = (SgAsmTypeQuadWord*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmTypeQuadWordStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmTypeQuadWordStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmTypeQuadWordStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmTypeQuadWordStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 44459 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmTypeDoubleQuadWordStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 44472 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmTypeDoubleQuadWordStorageClass::pickOutIRNodeData ( SgAsmTypeDoubleQuadWord* pointer ) 
   { 
     SgAsmTypeDoubleQuadWord* source = (SgAsmTypeDoubleQuadWord*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmTypeDoubleQuadWordStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmTypeDoubleQuadWordStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmTypeDoubleQuadWordStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmTypeDoubleQuadWordStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 44526 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmType80bitFloatStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 44539 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmType80bitFloatStorageClass::pickOutIRNodeData ( SgAsmType80bitFloat* pointer ) 
   { 
     SgAsmType80bitFloat* source = (SgAsmType80bitFloat*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmType80bitFloatStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmType80bitFloatStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmType80bitFloatStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmType80bitFloatStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 44593 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmType128bitFloatStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 44606 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmType128bitFloatStorageClass::pickOutIRNodeData ( SgAsmType128bitFloat* pointer ) 
   { 
     SgAsmType128bitFloat* source = (SgAsmType128bitFloat*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmType128bitFloatStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmType128bitFloatStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmType128bitFloatStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmType128bitFloatStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 44660 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmTypeSingleFloatStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 44673 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmTypeSingleFloatStorageClass::pickOutIRNodeData ( SgAsmTypeSingleFloat* pointer ) 
   { 
     SgAsmTypeSingleFloat* source = (SgAsmTypeSingleFloat*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmTypeSingleFloatStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmTypeSingleFloatStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmTypeSingleFloatStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmTypeSingleFloatStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 44727 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmTypeDoubleFloatStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 44740 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmTypeDoubleFloatStorageClass::pickOutIRNodeData ( SgAsmTypeDoubleFloat* pointer ) 
   { 
     SgAsmTypeDoubleFloat* source = (SgAsmTypeDoubleFloat*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmTypeDoubleFloatStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmTypeDoubleFloatStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmTypeDoubleFloatStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmTypeDoubleFloatStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 44794 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmTypeVectorStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 44807 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmTypeVectorStorageClass::pickOutIRNodeData ( SgAsmTypeVector* pointer ) 
   { 
     SgAsmTypeVector* source = (SgAsmTypeVector*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_elementCount =  source->p_elementCount ;
     storageOf_elementType = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_elementType );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmTypeVectorStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmTypeVectorStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmTypeVectorStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmTypeVectorStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 44863 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmExecutableFileFormatStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 44876 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmExecutableFileFormatStorageClass::pickOutIRNodeData ( SgAsmExecutableFileFormat* pointer ) 
   { 
     SgAsmExecutableFileFormat* source = (SgAsmExecutableFileFormat*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmExecutableFileFormatStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmExecutableFileFormatStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmExecutableFileFormatStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmExecutableFileFormatStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 44930 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmGenericDLLStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 44943 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmGenericDLLStorageClass::pickOutIRNodeData ( SgAsmGenericDLL* pointer ) 
   { 
     SgAsmGenericDLL* source = (SgAsmGenericDLL*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_symbols.storeDataInEasyStorageClass(source->p_symbols);
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmGenericDLLStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgStringList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmGenericDLLStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgStringList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmGenericDLLStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgStringList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmGenericDLLStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgStringList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 45003 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmGenericFormatStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 45016 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmGenericFormatStorageClass::pickOutIRNodeData ( SgAsmGenericFormat* pointer ) 
   { 
     SgAsmGenericFormat* source = (SgAsmGenericFormat*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_family =  source->p_family ;
     storageOf_purpose =  source->p_purpose ;
     storageOf_sex =  source->p_sex ;
     storageOf_version =  source->p_version ;
     storageOf_is_current_version =  source->p_is_current_version ;
     storageOf_abi =  source->p_abi ;
     storageOf_abi_version =  source->p_abi_version ;
     storageOf_word_size =  source->p_word_size ;
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmGenericFormatStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmGenericFormatStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmGenericFormatStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmGenericFormatStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 45078 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmGenericDLLListStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 45091 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmGenericDLLListStorageClass::pickOutIRNodeData ( SgAsmGenericDLLList* pointer ) 
   { 
     SgAsmGenericDLLList* source = (SgAsmGenericDLLList*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgAsmGenericDLLPtrList::iterator i_dlls = source->p_dlls.begin() ; 
     unsigned int tempListCountdlls = 0; 
     SgAsmGenericDLLPtrList::value_type *  tempListdlls = new SgAsmGenericDLLPtrList::value_type[ source->p_dlls.size() ]; 
     for ( ; i_dlls != source->p_dlls.end(); ++i_dlls ) 
        {
          tempListdlls[tempListCountdlls] = *i_dlls;
          tempListCountdlls++; 
          (*i_dlls) = (SgAsmGenericDLLPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_dlls ) );
        }
     storageOf_dlls.storeDataInEasyStorageClass(source->p_dlls);
     tempListCountdlls = 0; 
     i_dlls = source->p_dlls.begin() ; 
     for ( ; i_dlls != source->p_dlls.end(); ++i_dlls ) 
        {
          *i_dlls = tempListdlls[tempListCountdlls] ;
          tempListCountdlls++; 
        }
      delete [] tempListdlls; 
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmGenericDLLListStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgAsmGenericDLLPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmGenericDLLListStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgAsmGenericDLLPtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmGenericDLLListStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgAsmGenericDLLPtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmGenericDLLListStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgAsmGenericDLLPtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 45167 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmElfEHFrameEntryFDStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 45180 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmElfEHFrameEntryFDStorageClass::pickOutIRNodeData ( SgAsmElfEHFrameEntryFD* pointer ) 
   { 
     SgAsmElfEHFrameEntryFD* source = (SgAsmElfEHFrameEntryFD*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_begin_rva =  source->p_begin_rva ;
     storageOf_size =  source->p_size ;
     storageOf_augmentation_data.storeDataInEasyStorageClass(source->p_augmentation_data);
     storageOf_instructions.storeDataInEasyStorageClass(source->p_instructions);
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmElfEHFrameEntryFDStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgUnsignedCharList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmElfEHFrameEntryFDStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgUnsignedCharList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmElfEHFrameEntryFDStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgUnsignedCharList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmElfEHFrameEntryFDStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgUnsignedCharList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 45242 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmGenericFileStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 45255 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmGenericFileStorageClass::pickOutIRNodeData ( SgAsmGenericFile* pointer ) 
   { 
     SgAsmGenericFile* source = (SgAsmGenericFile*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_fd =  source->p_fd ;
     storageOf_sb =  source->p_sb ;
     storageOf_data.storeDataInEasyStorageClass(source->p_data);
     storageOf_headers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_headers );
     storageOf_holes = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_holes );
     storageOf_truncate_zeros =  source->p_truncate_zeros ;
     storageOf_tracking_references =  source->p_tracking_references ;
     storageOf_referenced_extents.storeDataInEasyStorageClass(source->p_referenced_extents);
     storageOf_neuter =  source->p_neuter ;
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmGenericFileStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgFileContentList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < ExtentMap > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmGenericFileStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < SgFileContentList > :: deleteMemoryPool() ;
     EasyStorage < ExtentMap > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmGenericFileStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < SgFileContentList > :: writeToFile(out) ;
     EasyStorage < ExtentMap > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmGenericFileStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < SgFileContentList > :: readFromFile(in) ;
     EasyStorage < ExtentMap > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 45331 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmGenericSectionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 45344 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmGenericSectionStorageClass::pickOutIRNodeData ( SgAsmGenericSection* pointer ) 
   { 
     SgAsmGenericSection* source = (SgAsmGenericSection*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_file = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_file );
     storageOf_header = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_header );
     storageOf_size =  source->p_size ;
     storageOf_offset =  source->p_offset ;
     storageOf_file_alignment =  source->p_file_alignment ;
     storageOf_data.storeDataInEasyStorageClass(source->p_data);
     storageOf_purpose =  source->p_purpose ;
     storageOf_synthesized =  source->p_synthesized ;
     storageOf_id =  source->p_id ;
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_short_name.storeDataInEasyStorageClass(source->p_short_name);
     storageOf_mapped_preferred_rva =  source->p_mapped_preferred_rva ;
     storageOf_mapped_size =  source->p_mapped_size ;
     storageOf_mapped_alignment =  source->p_mapped_alignment ;
     storageOf_mapped_rperm =  source->p_mapped_rperm ;
     storageOf_mapped_wperm =  source->p_mapped_wperm ;
     storageOf_mapped_xperm =  source->p_mapped_xperm ;
     storageOf_contains_code =  source->p_contains_code ;
     storageOf_mapped_actual_va =  source->p_mapped_actual_va ;
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmGenericSectionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgFileContentList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmGenericSectionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgFileContentList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmGenericSectionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgFileContentList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmGenericSectionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgFileContentList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 45425 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmGenericHeaderStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 45438 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmGenericHeaderStorageClass::pickOutIRNodeData ( SgAsmGenericHeader* pointer ) 
   { 
     SgAsmGenericHeader* source = (SgAsmGenericHeader*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_exec_format = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_exec_format );
     storageOf_magic.storeDataInEasyStorageClass(source->p_magic);
     storageOf_isa =  source->p_isa ;
     storageOf_base_va =  source->p_base_va ;
     storageOf_entry_rvas.storeDataInEasyStorageClass(source->p_entry_rvas);
     storageOf_dlls = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_dlls );
     storageOf_sections = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_sections );
     storageOf_file = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_file );
     storageOf_header = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_header );
     storageOf_size =  source->p_size ;
     storageOf_offset =  source->p_offset ;
     storageOf_file_alignment =  source->p_file_alignment ;
     storageOf_data.storeDataInEasyStorageClass(source->p_data);
     storageOf_purpose =  source->p_purpose ;
     storageOf_synthesized =  source->p_synthesized ;
     storageOf_id =  source->p_id ;
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_short_name.storeDataInEasyStorageClass(source->p_short_name);
     storageOf_mapped_preferred_rva =  source->p_mapped_preferred_rva ;
     storageOf_mapped_size =  source->p_mapped_size ;
     storageOf_mapped_alignment =  source->p_mapped_alignment ;
     storageOf_mapped_rperm =  source->p_mapped_rperm ;
     storageOf_mapped_wperm =  source->p_mapped_wperm ;
     storageOf_mapped_xperm =  source->p_mapped_xperm ;
     storageOf_contains_code =  source->p_contains_code ;
     storageOf_mapped_actual_va =  source->p_mapped_actual_va ;
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmGenericHeaderStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgCharList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgRVAList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgFileContentList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmGenericHeaderStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgCharList > :: deleteMemoryPool() ;
     EasyStorage < SgRVAList > :: deleteMemoryPool() ;
     EasyStorage < SgFileContentList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmGenericHeaderStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgCharList > :: writeToFile(out) ;
     EasyStorage < SgRVAList > :: writeToFile(out) ;
     EasyStorage < SgFileContentList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmGenericHeaderStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgCharList > :: readFromFile(in) ;
     EasyStorage < SgRVAList > :: readFromFile(in) ;
     EasyStorage < SgFileContentList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 45534 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmPEFileHeaderStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 45547 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmPEFileHeaderStorageClass::pickOutIRNodeData ( SgAsmPEFileHeader* pointer ) 
   { 
     SgAsmPEFileHeader* source = (SgAsmPEFileHeader*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_e_cpu_type =  source->p_e_cpu_type ;
     storageOf_e_nsections =  source->p_e_nsections ;
     storageOf_e_time =  source->p_e_time ;
     storageOf_e_coff_symtab =  source->p_e_coff_symtab ;
     storageOf_e_nt_hdr_size =  source->p_e_nt_hdr_size ;
     storageOf_e_coff_nsyms =  source->p_e_coff_nsyms ;
     storageOf_e_flags =  source->p_e_flags ;
     storageOf_e_opt_magic =  source->p_e_opt_magic ;
     storageOf_e_lmajor =  source->p_e_lmajor ;
     storageOf_e_lminor =  source->p_e_lminor ;
     storageOf_e_code_size =  source->p_e_code_size ;
     storageOf_e_data_size =  source->p_e_data_size ;
     storageOf_e_bss_size =  source->p_e_bss_size ;
     storageOf_e_code_rva =  source->p_e_code_rva ;
     storageOf_e_data_rva =  source->p_e_data_rva ;
     storageOf_e_section_align =  source->p_e_section_align ;
     storageOf_e_file_align =  source->p_e_file_align ;
     storageOf_e_os_major =  source->p_e_os_major ;
     storageOf_e_os_minor =  source->p_e_os_minor ;
     storageOf_e_user_major =  source->p_e_user_major ;
     storageOf_e_user_minor =  source->p_e_user_minor ;
     storageOf_e_subsys_major =  source->p_e_subsys_major ;
     storageOf_e_subsys_minor =  source->p_e_subsys_minor ;
     storageOf_e_reserved9 =  source->p_e_reserved9 ;
     storageOf_e_image_size =  source->p_e_image_size ;
     storageOf_e_header_size =  source->p_e_header_size ;
     storageOf_e_file_checksum =  source->p_e_file_checksum ;
     storageOf_e_subsystem =  source->p_e_subsystem ;
     storageOf_e_dll_flags =  source->p_e_dll_flags ;
     storageOf_e_stack_reserve_size =  source->p_e_stack_reserve_size ;
     storageOf_e_stack_commit_size =  source->p_e_stack_commit_size ;
     storageOf_e_heap_reserve_size =  source->p_e_heap_reserve_size ;
     storageOf_e_heap_commit_size =  source->p_e_heap_commit_size ;
     storageOf_e_loader_flags =  source->p_e_loader_flags ;
     storageOf_e_num_rvasize_pairs =  source->p_e_num_rvasize_pairs ;
     storageOf_rvasize_pairs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rvasize_pairs );
     storageOf_section_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_section_table );
     storageOf_coff_symtab = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_coff_symtab );
     storageOf_exec_format = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_exec_format );
     storageOf_magic.storeDataInEasyStorageClass(source->p_magic);
     storageOf_isa =  source->p_isa ;
     storageOf_base_va =  source->p_base_va ;
     storageOf_entry_rvas.storeDataInEasyStorageClass(source->p_entry_rvas);
     storageOf_dlls = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_dlls );
     storageOf_sections = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_sections );
     storageOf_file = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_file );
     storageOf_header = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_header );
     storageOf_size =  source->p_size ;
     storageOf_offset =  source->p_offset ;
     storageOf_file_alignment =  source->p_file_alignment ;
     storageOf_data.storeDataInEasyStorageClass(source->p_data);
     storageOf_purpose =  source->p_purpose ;
     storageOf_synthesized =  source->p_synthesized ;
     storageOf_id =  source->p_id ;
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_short_name.storeDataInEasyStorageClass(source->p_short_name);
     storageOf_mapped_preferred_rva =  source->p_mapped_preferred_rva ;
     storageOf_mapped_size =  source->p_mapped_size ;
     storageOf_mapped_alignment =  source->p_mapped_alignment ;
     storageOf_mapped_rperm =  source->p_mapped_rperm ;
     storageOf_mapped_wperm =  source->p_mapped_wperm ;
     storageOf_mapped_xperm =  source->p_mapped_xperm ;
     storageOf_contains_code =  source->p_contains_code ;
     storageOf_mapped_actual_va =  source->p_mapped_actual_va ;
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmPEFileHeaderStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgCharList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgRVAList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgFileContentList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmPEFileHeaderStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgCharList > :: deleteMemoryPool() ;
     EasyStorage < SgRVAList > :: deleteMemoryPool() ;
     EasyStorage < SgFileContentList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmPEFileHeaderStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgCharList > :: writeToFile(out) ;
     EasyStorage < SgRVAList > :: writeToFile(out) ;
     EasyStorage < SgFileContentList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmPEFileHeaderStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgCharList > :: readFromFile(in) ;
     EasyStorage < SgRVAList > :: readFromFile(in) ;
     EasyStorage < SgFileContentList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 45681 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmLEFileHeaderStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 45694 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmLEFileHeaderStorageClass::pickOutIRNodeData ( SgAsmLEFileHeader* pointer ) 
   { 
     SgAsmLEFileHeader* source = (SgAsmLEFileHeader*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_e_byte_order =  source->p_e_byte_order ;
     storageOf_e_word_order =  source->p_e_word_order ;
     storageOf_e_format_level =  source->p_e_format_level ;
     storageOf_e_cpu_type =  source->p_e_cpu_type ;
     storageOf_e_os_type =  source->p_e_os_type ;
     storageOf_e_module_version =  source->p_e_module_version ;
     storageOf_e_flags =  source->p_e_flags ;
     storageOf_e_eip_section =  source->p_e_eip_section ;
     storageOf_e_esp_section =  source->p_e_esp_section ;
     storageOf_e_last_page_size =  source->p_e_last_page_size ;
     storageOf_e_page_offset_shift =  source->p_e_page_offset_shift ;
     storageOf_e_fixup_sect_cksum =  source->p_e_fixup_sect_cksum ;
     storageOf_e_loader_sect_cksum =  source->p_e_loader_sect_cksum ;
     storageOf_e_secttab_nentries =  source->p_e_secttab_nentries ;
     storageOf_e_rsrctab_nentries =  source->p_e_rsrctab_nentries ;
     storageOf_e_fmtdirtab_nentries =  source->p_e_fmtdirtab_nentries ;
     storageOf_e_import_modtab_nentries =  source->p_e_import_modtab_nentries ;
     storageOf_e_preload_npages =  source->p_e_preload_npages ;
     storageOf_e_nonresnametab_size =  source->p_e_nonresnametab_size ;
     storageOf_e_nonresnametab_cksum =  source->p_e_nonresnametab_cksum ;
     storageOf_e_auto_ds_section =  source->p_e_auto_ds_section ;
     storageOf_e_debug_info_size =  source->p_e_debug_info_size ;
     storageOf_e_num_instance_preload =  source->p_e_num_instance_preload ;
     storageOf_e_num_instance_demand =  source->p_e_num_instance_demand ;
     storageOf_e_heap_size =  source->p_e_heap_size ;
     storageOf_e_npages =  source->p_e_npages ;
     storageOf_e_eip =  source->p_e_eip ;
     storageOf_e_esp =  source->p_e_esp ;
     storageOf_e_page_size =  source->p_e_page_size ;
     storageOf_e_fixup_sect_size =  source->p_e_fixup_sect_size ;
     storageOf_e_loader_sect_size =  source->p_e_loader_sect_size ;
     storageOf_e_secttab_rfo =  source->p_e_secttab_rfo ;
     storageOf_e_pagetab_rfo =  source->p_e_pagetab_rfo ;
     storageOf_e_iterpages_offset =  source->p_e_iterpages_offset ;
     storageOf_e_rsrctab_rfo =  source->p_e_rsrctab_rfo ;
     storageOf_e_resnametab_rfo =  source->p_e_resnametab_rfo ;
     storageOf_e_entrytab_rfo =  source->p_e_entrytab_rfo ;
     storageOf_e_fmtdirtab_rfo =  source->p_e_fmtdirtab_rfo ;
     storageOf_e_fixup_pagetab_rfo =  source->p_e_fixup_pagetab_rfo ;
     storageOf_e_fixup_rectab_rfo =  source->p_e_fixup_rectab_rfo ;
     storageOf_e_import_modtab_rfo =  source->p_e_import_modtab_rfo ;
     storageOf_e_import_proctab_rfo =  source->p_e_import_proctab_rfo ;
     storageOf_e_ppcksumtab_rfo =  source->p_e_ppcksumtab_rfo ;
     storageOf_e_data_pages_offset =  source->p_e_data_pages_offset ;
     storageOf_e_nonresnametab_offset =  source->p_e_nonresnametab_offset ;
     storageOf_e_debug_info_rfo =  source->p_e_debug_info_rfo ;
     storageOf_dos2_header = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_dos2_header );
     storageOf_section_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_section_table );
     storageOf_page_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_page_table );
     storageOf_resname_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_resname_table );
     storageOf_nonresname_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_nonresname_table );
     storageOf_entry_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_entry_table );
     storageOf_reloc_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_reloc_table );
     storageOf_exec_format = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_exec_format );
     storageOf_magic.storeDataInEasyStorageClass(source->p_magic);
     storageOf_isa =  source->p_isa ;
     storageOf_base_va =  source->p_base_va ;
     storageOf_entry_rvas.storeDataInEasyStorageClass(source->p_entry_rvas);
     storageOf_dlls = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_dlls );
     storageOf_sections = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_sections );
     storageOf_file = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_file );
     storageOf_header = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_header );
     storageOf_size =  source->p_size ;
     storageOf_offset =  source->p_offset ;
     storageOf_file_alignment =  source->p_file_alignment ;
     storageOf_data.storeDataInEasyStorageClass(source->p_data);
     storageOf_purpose =  source->p_purpose ;
     storageOf_synthesized =  source->p_synthesized ;
     storageOf_id =  source->p_id ;
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_short_name.storeDataInEasyStorageClass(source->p_short_name);
     storageOf_mapped_preferred_rva =  source->p_mapped_preferred_rva ;
     storageOf_mapped_size =  source->p_mapped_size ;
     storageOf_mapped_alignment =  source->p_mapped_alignment ;
     storageOf_mapped_rperm =  source->p_mapped_rperm ;
     storageOf_mapped_wperm =  source->p_mapped_wperm ;
     storageOf_mapped_xperm =  source->p_mapped_xperm ;
     storageOf_contains_code =  source->p_contains_code ;
     storageOf_mapped_actual_va =  source->p_mapped_actual_va ;
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmLEFileHeaderStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgCharList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgRVAList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgFileContentList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmLEFileHeaderStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgCharList > :: deleteMemoryPool() ;
     EasyStorage < SgRVAList > :: deleteMemoryPool() ;
     EasyStorage < SgFileContentList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmLEFileHeaderStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgCharList > :: writeToFile(out) ;
     EasyStorage < SgRVAList > :: writeToFile(out) ;
     EasyStorage < SgFileContentList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmLEFileHeaderStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgCharList > :: readFromFile(in) ;
     EasyStorage < SgRVAList > :: readFromFile(in) ;
     EasyStorage < SgFileContentList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 45843 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmNEFileHeaderStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 45856 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmNEFileHeaderStorageClass::pickOutIRNodeData ( SgAsmNEFileHeader* pointer ) 
   { 
     SgAsmNEFileHeader* source = (SgAsmNEFileHeader*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_e_linker_major =  source->p_e_linker_major ;
     storageOf_e_linker_minor =  source->p_e_linker_minor ;
     storageOf_e_checksum =  source->p_e_checksum ;
     storageOf_e_flags1 =  source->p_e_flags1 ;
     storageOf_e_autodata_sn =  source->p_e_autodata_sn ;
     storageOf_e_bss_size =  source->p_e_bss_size ;
     storageOf_e_stack_size =  source->p_e_stack_size ;
     storageOf_e_csip =  source->p_e_csip ;
     storageOf_e_sssp =  source->p_e_sssp ;
     storageOf_e_nsections =  source->p_e_nsections ;
     storageOf_e_nmodrefs =  source->p_e_nmodrefs ;
     storageOf_e_nnonresnames =  source->p_e_nnonresnames ;
     storageOf_e_nmovable_entries =  source->p_e_nmovable_entries ;
     storageOf_e_sector_align =  source->p_e_sector_align ;
     storageOf_e_nresources =  source->p_e_nresources ;
     storageOf_e_exetype =  source->p_e_exetype ;
     storageOf_e_flags2 =  source->p_e_flags2 ;
     storageOf_e_res1 =  source->p_e_res1 ;
     storageOf_e_winvers =  source->p_e_winvers ;
     storageOf_e_entrytab_rfo =  source->p_e_entrytab_rfo ;
     storageOf_e_entrytab_size =  source->p_e_entrytab_size ;
     storageOf_e_sectab_rfo =  source->p_e_sectab_rfo ;
     storageOf_e_rsrctab_rfo =  source->p_e_rsrctab_rfo ;
     storageOf_e_resnametab_rfo =  source->p_e_resnametab_rfo ;
     storageOf_e_modreftab_rfo =  source->p_e_modreftab_rfo ;
     storageOf_e_importnametab_rfo =  source->p_e_importnametab_rfo ;
     storageOf_e_nonresnametab_offset =  source->p_e_nonresnametab_offset ;
     storageOf_e_fastload_sector =  source->p_e_fastload_sector ;
     storageOf_e_fastload_nsectors =  source->p_e_fastload_nsectors ;
     storageOf_dos2_header = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_dos2_header );
     storageOf_section_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_section_table );
     storageOf_resname_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_resname_table );
     storageOf_nonresname_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_nonresname_table );
     storageOf_module_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_module_table );
     storageOf_entry_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_entry_table );
     storageOf_exec_format = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_exec_format );
     storageOf_magic.storeDataInEasyStorageClass(source->p_magic);
     storageOf_isa =  source->p_isa ;
     storageOf_base_va =  source->p_base_va ;
     storageOf_entry_rvas.storeDataInEasyStorageClass(source->p_entry_rvas);
     storageOf_dlls = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_dlls );
     storageOf_sections = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_sections );
     storageOf_file = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_file );
     storageOf_header = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_header );
     storageOf_size =  source->p_size ;
     storageOf_offset =  source->p_offset ;
     storageOf_file_alignment =  source->p_file_alignment ;
     storageOf_data.storeDataInEasyStorageClass(source->p_data);
     storageOf_purpose =  source->p_purpose ;
     storageOf_synthesized =  source->p_synthesized ;
     storageOf_id =  source->p_id ;
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_short_name.storeDataInEasyStorageClass(source->p_short_name);
     storageOf_mapped_preferred_rva =  source->p_mapped_preferred_rva ;
     storageOf_mapped_size =  source->p_mapped_size ;
     storageOf_mapped_alignment =  source->p_mapped_alignment ;
     storageOf_mapped_rperm =  source->p_mapped_rperm ;
     storageOf_mapped_wperm =  source->p_mapped_wperm ;
     storageOf_mapped_xperm =  source->p_mapped_xperm ;
     storageOf_contains_code =  source->p_contains_code ;
     storageOf_mapped_actual_va =  source->p_mapped_actual_va ;
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmNEFileHeaderStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgCharList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgRVAList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgFileContentList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmNEFileHeaderStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgCharList > :: deleteMemoryPool() ;
     EasyStorage < SgRVAList > :: deleteMemoryPool() ;
     EasyStorage < SgFileContentList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmNEFileHeaderStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgCharList > :: writeToFile(out) ;
     EasyStorage < SgRVAList > :: writeToFile(out) ;
     EasyStorage < SgFileContentList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmNEFileHeaderStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgCharList > :: readFromFile(in) ;
     EasyStorage < SgRVAList > :: readFromFile(in) ;
     EasyStorage < SgFileContentList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 45987 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDOSFileHeaderStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 46000 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDOSFileHeaderStorageClass::pickOutIRNodeData ( SgAsmDOSFileHeader* pointer ) 
   { 
     SgAsmDOSFileHeader* source = (SgAsmDOSFileHeader*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_e_last_page_size =  source->p_e_last_page_size ;
     storageOf_e_total_pages =  source->p_e_total_pages ;
     storageOf_e_nrelocs =  source->p_e_nrelocs ;
     storageOf_e_header_paragraphs =  source->p_e_header_paragraphs ;
     storageOf_e_minalloc =  source->p_e_minalloc ;
     storageOf_e_maxalloc =  source->p_e_maxalloc ;
     storageOf_e_ss =  source->p_e_ss ;
     storageOf_e_sp =  source->p_e_sp ;
     storageOf_e_cksum =  source->p_e_cksum ;
     storageOf_e_ip =  source->p_e_ip ;
     storageOf_e_cs =  source->p_e_cs ;
     storageOf_e_overlay =  source->p_e_overlay ;
     storageOf_e_relocs_offset =  source->p_e_relocs_offset ;
     storageOf_e_res1 =  source->p_e_res1 ;
     storageOf_relocs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_relocs );
     storageOf_rm_section = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rm_section );
     storageOf_exec_format = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_exec_format );
     storageOf_magic.storeDataInEasyStorageClass(source->p_magic);
     storageOf_isa =  source->p_isa ;
     storageOf_base_va =  source->p_base_va ;
     storageOf_entry_rvas.storeDataInEasyStorageClass(source->p_entry_rvas);
     storageOf_dlls = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_dlls );
     storageOf_sections = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_sections );
     storageOf_file = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_file );
     storageOf_header = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_header );
     storageOf_size =  source->p_size ;
     storageOf_offset =  source->p_offset ;
     storageOf_file_alignment =  source->p_file_alignment ;
     storageOf_data.storeDataInEasyStorageClass(source->p_data);
     storageOf_purpose =  source->p_purpose ;
     storageOf_synthesized =  source->p_synthesized ;
     storageOf_id =  source->p_id ;
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_short_name.storeDataInEasyStorageClass(source->p_short_name);
     storageOf_mapped_preferred_rva =  source->p_mapped_preferred_rva ;
     storageOf_mapped_size =  source->p_mapped_size ;
     storageOf_mapped_alignment =  source->p_mapped_alignment ;
     storageOf_mapped_rperm =  source->p_mapped_rperm ;
     storageOf_mapped_wperm =  source->p_mapped_wperm ;
     storageOf_mapped_xperm =  source->p_mapped_xperm ;
     storageOf_contains_code =  source->p_contains_code ;
     storageOf_mapped_actual_va =  source->p_mapped_actual_va ;
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDOSFileHeaderStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgCharList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgRVAList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgFileContentList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDOSFileHeaderStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgCharList > :: deleteMemoryPool() ;
     EasyStorage < SgRVAList > :: deleteMemoryPool() ;
     EasyStorage < SgFileContentList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDOSFileHeaderStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgCharList > :: writeToFile(out) ;
     EasyStorage < SgRVAList > :: writeToFile(out) ;
     EasyStorage < SgFileContentList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDOSFileHeaderStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgCharList > :: readFromFile(in) ;
     EasyStorage < SgRVAList > :: readFromFile(in) ;
     EasyStorage < SgFileContentList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 46112 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmElfFileHeaderStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 46125 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmElfFileHeaderStorageClass::pickOutIRNodeData ( SgAsmElfFileHeader* pointer ) 
   { 
     SgAsmElfFileHeader* source = (SgAsmElfFileHeader*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_e_ident_file_class =  source->p_e_ident_file_class ;
     storageOf_e_ident_data_encoding =  source->p_e_ident_data_encoding ;
     storageOf_e_ident_file_version =  source->p_e_ident_file_version ;
     storageOf_e_ident_padding.storeDataInEasyStorageClass(source->p_e_ident_padding);
     storageOf_e_type =  source->p_e_type ;
     storageOf_e_machine =  source->p_e_machine ;
     storageOf_e_flags =  source->p_e_flags ;
     storageOf_e_ehsize =  source->p_e_ehsize ;
     storageOf_phextrasz =  source->p_phextrasz ;
     storageOf_e_phnum =  source->p_e_phnum ;
     storageOf_shextrasz =  source->p_shextrasz ;
     storageOf_e_shnum =  source->p_e_shnum ;
     storageOf_e_shstrndx =  source->p_e_shstrndx ;
     storageOf_section_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_section_table );
     storageOf_segment_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_segment_table );
     storageOf_exec_format = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_exec_format );
     storageOf_magic.storeDataInEasyStorageClass(source->p_magic);
     storageOf_isa =  source->p_isa ;
     storageOf_base_va =  source->p_base_va ;
     storageOf_entry_rvas.storeDataInEasyStorageClass(source->p_entry_rvas);
     storageOf_dlls = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_dlls );
     storageOf_sections = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_sections );
     storageOf_file = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_file );
     storageOf_header = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_header );
     storageOf_size =  source->p_size ;
     storageOf_offset =  source->p_offset ;
     storageOf_file_alignment =  source->p_file_alignment ;
     storageOf_data.storeDataInEasyStorageClass(source->p_data);
     storageOf_purpose =  source->p_purpose ;
     storageOf_synthesized =  source->p_synthesized ;
     storageOf_id =  source->p_id ;
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_short_name.storeDataInEasyStorageClass(source->p_short_name);
     storageOf_mapped_preferred_rva =  source->p_mapped_preferred_rva ;
     storageOf_mapped_size =  source->p_mapped_size ;
     storageOf_mapped_alignment =  source->p_mapped_alignment ;
     storageOf_mapped_rperm =  source->p_mapped_rperm ;
     storageOf_mapped_wperm =  source->p_mapped_wperm ;
     storageOf_mapped_xperm =  source->p_mapped_xperm ;
     storageOf_contains_code =  source->p_contains_code ;
     storageOf_mapped_actual_va =  source->p_mapped_actual_va ;
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmElfFileHeaderStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgUnsignedCharList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgCharList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgRVAList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgFileContentList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmElfFileHeaderStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgUnsignedCharList > :: deleteMemoryPool() ;
     EasyStorage < SgCharList > :: deleteMemoryPool() ;
     EasyStorage < SgRVAList > :: deleteMemoryPool() ;
     EasyStorage < SgFileContentList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmElfFileHeaderStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgUnsignedCharList > :: writeToFile(out) ;
     EasyStorage < SgCharList > :: writeToFile(out) ;
     EasyStorage < SgRVAList > :: writeToFile(out) ;
     EasyStorage < SgFileContentList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmElfFileHeaderStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgUnsignedCharList > :: readFromFile(in) ;
     EasyStorage < SgCharList > :: readFromFile(in) ;
     EasyStorage < SgRVAList > :: readFromFile(in) ;
     EasyStorage < SgFileContentList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 46240 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmElfSectionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 46253 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmElfSectionStorageClass::pickOutIRNodeData ( SgAsmElfSection* pointer ) 
   { 
     SgAsmElfSection* source = (SgAsmElfSection*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_linked_section = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_linked_section );
     storageOf_section_entry = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_section_entry );
     storageOf_segment_entry = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_segment_entry );
     storageOf_file = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_file );
     storageOf_header = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_header );
     storageOf_size =  source->p_size ;
     storageOf_offset =  source->p_offset ;
     storageOf_file_alignment =  source->p_file_alignment ;
     storageOf_data.storeDataInEasyStorageClass(source->p_data);
     storageOf_purpose =  source->p_purpose ;
     storageOf_synthesized =  source->p_synthesized ;
     storageOf_id =  source->p_id ;
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_short_name.storeDataInEasyStorageClass(source->p_short_name);
     storageOf_mapped_preferred_rva =  source->p_mapped_preferred_rva ;
     storageOf_mapped_size =  source->p_mapped_size ;
     storageOf_mapped_alignment =  source->p_mapped_alignment ;
     storageOf_mapped_rperm =  source->p_mapped_rperm ;
     storageOf_mapped_wperm =  source->p_mapped_wperm ;
     storageOf_mapped_xperm =  source->p_mapped_xperm ;
     storageOf_contains_code =  source->p_contains_code ;
     storageOf_mapped_actual_va =  source->p_mapped_actual_va ;
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmElfSectionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgFileContentList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmElfSectionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgFileContentList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmElfSectionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgFileContentList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmElfSectionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgFileContentList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 46337 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmElfSymbolSectionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 46350 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmElfSymbolSectionStorageClass::pickOutIRNodeData ( SgAsmElfSymbolSection* pointer ) 
   { 
     SgAsmElfSymbolSection* source = (SgAsmElfSymbolSection*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_symbols = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_symbols );
     storageOf_is_dynamic =  source->p_is_dynamic ;
     storageOf_linked_section = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_linked_section );
     storageOf_section_entry = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_section_entry );
     storageOf_segment_entry = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_segment_entry );
     storageOf_file = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_file );
     storageOf_header = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_header );
     storageOf_size =  source->p_size ;
     storageOf_offset =  source->p_offset ;
     storageOf_file_alignment =  source->p_file_alignment ;
     storageOf_data.storeDataInEasyStorageClass(source->p_data);
     storageOf_purpose =  source->p_purpose ;
     storageOf_synthesized =  source->p_synthesized ;
     storageOf_id =  source->p_id ;
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_short_name.storeDataInEasyStorageClass(source->p_short_name);
     storageOf_mapped_preferred_rva =  source->p_mapped_preferred_rva ;
     storageOf_mapped_size =  source->p_mapped_size ;
     storageOf_mapped_alignment =  source->p_mapped_alignment ;
     storageOf_mapped_rperm =  source->p_mapped_rperm ;
     storageOf_mapped_wperm =  source->p_mapped_wperm ;
     storageOf_mapped_xperm =  source->p_mapped_xperm ;
     storageOf_contains_code =  source->p_contains_code ;
     storageOf_mapped_actual_va =  source->p_mapped_actual_va ;
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmElfSymbolSectionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgFileContentList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmElfSymbolSectionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgFileContentList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmElfSymbolSectionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgFileContentList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmElfSymbolSectionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgFileContentList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 46436 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmElfRelocSectionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 46449 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmElfRelocSectionStorageClass::pickOutIRNodeData ( SgAsmElfRelocSection* pointer ) 
   { 
     SgAsmElfRelocSection* source = (SgAsmElfRelocSection*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_uses_addend =  source->p_uses_addend ;
     storageOf_target_section = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_target_section );
     storageOf_entries = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_entries );
     storageOf_linked_section = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_linked_section );
     storageOf_section_entry = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_section_entry );
     storageOf_segment_entry = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_segment_entry );
     storageOf_file = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_file );
     storageOf_header = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_header );
     storageOf_size =  source->p_size ;
     storageOf_offset =  source->p_offset ;
     storageOf_file_alignment =  source->p_file_alignment ;
     storageOf_data.storeDataInEasyStorageClass(source->p_data);
     storageOf_purpose =  source->p_purpose ;
     storageOf_synthesized =  source->p_synthesized ;
     storageOf_id =  source->p_id ;
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_short_name.storeDataInEasyStorageClass(source->p_short_name);
     storageOf_mapped_preferred_rva =  source->p_mapped_preferred_rva ;
     storageOf_mapped_size =  source->p_mapped_size ;
     storageOf_mapped_alignment =  source->p_mapped_alignment ;
     storageOf_mapped_rperm =  source->p_mapped_rperm ;
     storageOf_mapped_wperm =  source->p_mapped_wperm ;
     storageOf_mapped_xperm =  source->p_mapped_xperm ;
     storageOf_contains_code =  source->p_contains_code ;
     storageOf_mapped_actual_va =  source->p_mapped_actual_va ;
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmElfRelocSectionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgFileContentList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmElfRelocSectionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgFileContentList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmElfRelocSectionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgFileContentList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmElfRelocSectionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgFileContentList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 46536 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmElfDynamicSectionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 46549 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmElfDynamicSectionStorageClass::pickOutIRNodeData ( SgAsmElfDynamicSection* pointer ) 
   { 
     SgAsmElfDynamicSection* source = (SgAsmElfDynamicSection*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_entries = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_entries );
     storageOf_linked_section = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_linked_section );
     storageOf_section_entry = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_section_entry );
     storageOf_segment_entry = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_segment_entry );
     storageOf_file = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_file );
     storageOf_header = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_header );
     storageOf_size =  source->p_size ;
     storageOf_offset =  source->p_offset ;
     storageOf_file_alignment =  source->p_file_alignment ;
     storageOf_data.storeDataInEasyStorageClass(source->p_data);
     storageOf_purpose =  source->p_purpose ;
     storageOf_synthesized =  source->p_synthesized ;
     storageOf_id =  source->p_id ;
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_short_name.storeDataInEasyStorageClass(source->p_short_name);
     storageOf_mapped_preferred_rva =  source->p_mapped_preferred_rva ;
     storageOf_mapped_size =  source->p_mapped_size ;
     storageOf_mapped_alignment =  source->p_mapped_alignment ;
     storageOf_mapped_rperm =  source->p_mapped_rperm ;
     storageOf_mapped_wperm =  source->p_mapped_wperm ;
     storageOf_mapped_xperm =  source->p_mapped_xperm ;
     storageOf_contains_code =  source->p_contains_code ;
     storageOf_mapped_actual_va =  source->p_mapped_actual_va ;
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmElfDynamicSectionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgFileContentList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmElfDynamicSectionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgFileContentList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmElfDynamicSectionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgFileContentList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmElfDynamicSectionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgFileContentList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 46634 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmElfStringSectionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 46647 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmElfStringSectionStorageClass::pickOutIRNodeData ( SgAsmElfStringSection* pointer ) 
   { 
     SgAsmElfStringSection* source = (SgAsmElfStringSection*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_strtab = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_strtab );
     storageOf_linked_section = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_linked_section );
     storageOf_section_entry = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_section_entry );
     storageOf_segment_entry = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_segment_entry );
     storageOf_file = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_file );
     storageOf_header = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_header );
     storageOf_size =  source->p_size ;
     storageOf_offset =  source->p_offset ;
     storageOf_file_alignment =  source->p_file_alignment ;
     storageOf_data.storeDataInEasyStorageClass(source->p_data);
     storageOf_purpose =  source->p_purpose ;
     storageOf_synthesized =  source->p_synthesized ;
     storageOf_id =  source->p_id ;
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_short_name.storeDataInEasyStorageClass(source->p_short_name);
     storageOf_mapped_preferred_rva =  source->p_mapped_preferred_rva ;
     storageOf_mapped_size =  source->p_mapped_size ;
     storageOf_mapped_alignment =  source->p_mapped_alignment ;
     storageOf_mapped_rperm =  source->p_mapped_rperm ;
     storageOf_mapped_wperm =  source->p_mapped_wperm ;
     storageOf_mapped_xperm =  source->p_mapped_xperm ;
     storageOf_contains_code =  source->p_contains_code ;
     storageOf_mapped_actual_va =  source->p_mapped_actual_va ;
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmElfStringSectionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgFileContentList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmElfStringSectionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgFileContentList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmElfStringSectionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgFileContentList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmElfStringSectionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgFileContentList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 46732 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmElfNoteSectionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 46745 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmElfNoteSectionStorageClass::pickOutIRNodeData ( SgAsmElfNoteSection* pointer ) 
   { 
     SgAsmElfNoteSection* source = (SgAsmElfNoteSection*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_entries = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_entries );
     storageOf_linked_section = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_linked_section );
     storageOf_section_entry = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_section_entry );
     storageOf_segment_entry = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_segment_entry );
     storageOf_file = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_file );
     storageOf_header = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_header );
     storageOf_size =  source->p_size ;
     storageOf_offset =  source->p_offset ;
     storageOf_file_alignment =  source->p_file_alignment ;
     storageOf_data.storeDataInEasyStorageClass(source->p_data);
     storageOf_purpose =  source->p_purpose ;
     storageOf_synthesized =  source->p_synthesized ;
     storageOf_id =  source->p_id ;
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_short_name.storeDataInEasyStorageClass(source->p_short_name);
     storageOf_mapped_preferred_rva =  source->p_mapped_preferred_rva ;
     storageOf_mapped_size =  source->p_mapped_size ;
     storageOf_mapped_alignment =  source->p_mapped_alignment ;
     storageOf_mapped_rperm =  source->p_mapped_rperm ;
     storageOf_mapped_wperm =  source->p_mapped_wperm ;
     storageOf_mapped_xperm =  source->p_mapped_xperm ;
     storageOf_contains_code =  source->p_contains_code ;
     storageOf_mapped_actual_va =  source->p_mapped_actual_va ;
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmElfNoteSectionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgFileContentList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmElfNoteSectionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgFileContentList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmElfNoteSectionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgFileContentList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmElfNoteSectionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgFileContentList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 46830 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmElfEHFrameSectionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 46843 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmElfEHFrameSectionStorageClass::pickOutIRNodeData ( SgAsmElfEHFrameSection* pointer ) 
   { 
     SgAsmElfEHFrameSection* source = (SgAsmElfEHFrameSection*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_ci_entries = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ci_entries );
     storageOf_linked_section = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_linked_section );
     storageOf_section_entry = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_section_entry );
     storageOf_segment_entry = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_segment_entry );
     storageOf_file = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_file );
     storageOf_header = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_header );
     storageOf_size =  source->p_size ;
     storageOf_offset =  source->p_offset ;
     storageOf_file_alignment =  source->p_file_alignment ;
     storageOf_data.storeDataInEasyStorageClass(source->p_data);
     storageOf_purpose =  source->p_purpose ;
     storageOf_synthesized =  source->p_synthesized ;
     storageOf_id =  source->p_id ;
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_short_name.storeDataInEasyStorageClass(source->p_short_name);
     storageOf_mapped_preferred_rva =  source->p_mapped_preferred_rva ;
     storageOf_mapped_size =  source->p_mapped_size ;
     storageOf_mapped_alignment =  source->p_mapped_alignment ;
     storageOf_mapped_rperm =  source->p_mapped_rperm ;
     storageOf_mapped_wperm =  source->p_mapped_wperm ;
     storageOf_mapped_xperm =  source->p_mapped_xperm ;
     storageOf_contains_code =  source->p_contains_code ;
     storageOf_mapped_actual_va =  source->p_mapped_actual_va ;
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmElfEHFrameSectionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgFileContentList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmElfEHFrameSectionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgFileContentList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmElfEHFrameSectionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgFileContentList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmElfEHFrameSectionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgFileContentList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 46928 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmElfSymverSectionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 46941 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmElfSymverSectionStorageClass::pickOutIRNodeData ( SgAsmElfSymverSection* pointer ) 
   { 
     SgAsmElfSymverSection* source = (SgAsmElfSymverSection*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_entries = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_entries );
     storageOf_linked_section = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_linked_section );
     storageOf_section_entry = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_section_entry );
     storageOf_segment_entry = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_segment_entry );
     storageOf_file = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_file );
     storageOf_header = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_header );
     storageOf_size =  source->p_size ;
     storageOf_offset =  source->p_offset ;
     storageOf_file_alignment =  source->p_file_alignment ;
     storageOf_data.storeDataInEasyStorageClass(source->p_data);
     storageOf_purpose =  source->p_purpose ;
     storageOf_synthesized =  source->p_synthesized ;
     storageOf_id =  source->p_id ;
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_short_name.storeDataInEasyStorageClass(source->p_short_name);
     storageOf_mapped_preferred_rva =  source->p_mapped_preferred_rva ;
     storageOf_mapped_size =  source->p_mapped_size ;
     storageOf_mapped_alignment =  source->p_mapped_alignment ;
     storageOf_mapped_rperm =  source->p_mapped_rperm ;
     storageOf_mapped_wperm =  source->p_mapped_wperm ;
     storageOf_mapped_xperm =  source->p_mapped_xperm ;
     storageOf_contains_code =  source->p_contains_code ;
     storageOf_mapped_actual_va =  source->p_mapped_actual_va ;
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmElfSymverSectionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgFileContentList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmElfSymverSectionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgFileContentList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmElfSymverSectionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgFileContentList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmElfSymverSectionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgFileContentList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 47026 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmElfSymverDefinedSectionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 47039 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmElfSymverDefinedSectionStorageClass::pickOutIRNodeData ( SgAsmElfSymverDefinedSection* pointer ) 
   { 
     SgAsmElfSymverDefinedSection* source = (SgAsmElfSymverDefinedSection*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_entries = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_entries );
     storageOf_linked_section = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_linked_section );
     storageOf_section_entry = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_section_entry );
     storageOf_segment_entry = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_segment_entry );
     storageOf_file = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_file );
     storageOf_header = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_header );
     storageOf_size =  source->p_size ;
     storageOf_offset =  source->p_offset ;
     storageOf_file_alignment =  source->p_file_alignment ;
     storageOf_data.storeDataInEasyStorageClass(source->p_data);
     storageOf_purpose =  source->p_purpose ;
     storageOf_synthesized =  source->p_synthesized ;
     storageOf_id =  source->p_id ;
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_short_name.storeDataInEasyStorageClass(source->p_short_name);
     storageOf_mapped_preferred_rva =  source->p_mapped_preferred_rva ;
     storageOf_mapped_size =  source->p_mapped_size ;
     storageOf_mapped_alignment =  source->p_mapped_alignment ;
     storageOf_mapped_rperm =  source->p_mapped_rperm ;
     storageOf_mapped_wperm =  source->p_mapped_wperm ;
     storageOf_mapped_xperm =  source->p_mapped_xperm ;
     storageOf_contains_code =  source->p_contains_code ;
     storageOf_mapped_actual_va =  source->p_mapped_actual_va ;
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmElfSymverDefinedSectionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgFileContentList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmElfSymverDefinedSectionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgFileContentList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmElfSymverDefinedSectionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgFileContentList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmElfSymverDefinedSectionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgFileContentList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 47124 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmElfSymverNeededSectionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 47137 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmElfSymverNeededSectionStorageClass::pickOutIRNodeData ( SgAsmElfSymverNeededSection* pointer ) 
   { 
     SgAsmElfSymverNeededSection* source = (SgAsmElfSymverNeededSection*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_entries = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_entries );
     storageOf_linked_section = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_linked_section );
     storageOf_section_entry = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_section_entry );
     storageOf_segment_entry = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_segment_entry );
     storageOf_file = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_file );
     storageOf_header = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_header );
     storageOf_size =  source->p_size ;
     storageOf_offset =  source->p_offset ;
     storageOf_file_alignment =  source->p_file_alignment ;
     storageOf_data.storeDataInEasyStorageClass(source->p_data);
     storageOf_purpose =  source->p_purpose ;
     storageOf_synthesized =  source->p_synthesized ;
     storageOf_id =  source->p_id ;
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_short_name.storeDataInEasyStorageClass(source->p_short_name);
     storageOf_mapped_preferred_rva =  source->p_mapped_preferred_rva ;
     storageOf_mapped_size =  source->p_mapped_size ;
     storageOf_mapped_alignment =  source->p_mapped_alignment ;
     storageOf_mapped_rperm =  source->p_mapped_rperm ;
     storageOf_mapped_wperm =  source->p_mapped_wperm ;
     storageOf_mapped_xperm =  source->p_mapped_xperm ;
     storageOf_contains_code =  source->p_contains_code ;
     storageOf_mapped_actual_va =  source->p_mapped_actual_va ;
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmElfSymverNeededSectionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgFileContentList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmElfSymverNeededSectionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgFileContentList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmElfSymverNeededSectionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgFileContentList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmElfSymverNeededSectionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgFileContentList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 47222 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmElfSectionTableStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 47235 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmElfSectionTableStorageClass::pickOutIRNodeData ( SgAsmElfSectionTable* pointer ) 
   { 
     SgAsmElfSectionTable* source = (SgAsmElfSectionTable*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_file = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_file );
     storageOf_header = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_header );
     storageOf_size =  source->p_size ;
     storageOf_offset =  source->p_offset ;
     storageOf_file_alignment =  source->p_file_alignment ;
     storageOf_data.storeDataInEasyStorageClass(source->p_data);
     storageOf_purpose =  source->p_purpose ;
     storageOf_synthesized =  source->p_synthesized ;
     storageOf_id =  source->p_id ;
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_short_name.storeDataInEasyStorageClass(source->p_short_name);
     storageOf_mapped_preferred_rva =  source->p_mapped_preferred_rva ;
     storageOf_mapped_size =  source->p_mapped_size ;
     storageOf_mapped_alignment =  source->p_mapped_alignment ;
     storageOf_mapped_rperm =  source->p_mapped_rperm ;
     storageOf_mapped_wperm =  source->p_mapped_wperm ;
     storageOf_mapped_xperm =  source->p_mapped_xperm ;
     storageOf_contains_code =  source->p_contains_code ;
     storageOf_mapped_actual_va =  source->p_mapped_actual_va ;
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmElfSectionTableStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgFileContentList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmElfSectionTableStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgFileContentList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmElfSectionTableStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgFileContentList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmElfSectionTableStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgFileContentList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 47316 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmElfSegmentTableStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 47329 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmElfSegmentTableStorageClass::pickOutIRNodeData ( SgAsmElfSegmentTable* pointer ) 
   { 
     SgAsmElfSegmentTable* source = (SgAsmElfSegmentTable*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_file = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_file );
     storageOf_header = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_header );
     storageOf_size =  source->p_size ;
     storageOf_offset =  source->p_offset ;
     storageOf_file_alignment =  source->p_file_alignment ;
     storageOf_data.storeDataInEasyStorageClass(source->p_data);
     storageOf_purpose =  source->p_purpose ;
     storageOf_synthesized =  source->p_synthesized ;
     storageOf_id =  source->p_id ;
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_short_name.storeDataInEasyStorageClass(source->p_short_name);
     storageOf_mapped_preferred_rva =  source->p_mapped_preferred_rva ;
     storageOf_mapped_size =  source->p_mapped_size ;
     storageOf_mapped_alignment =  source->p_mapped_alignment ;
     storageOf_mapped_rperm =  source->p_mapped_rperm ;
     storageOf_mapped_wperm =  source->p_mapped_wperm ;
     storageOf_mapped_xperm =  source->p_mapped_xperm ;
     storageOf_contains_code =  source->p_contains_code ;
     storageOf_mapped_actual_va =  source->p_mapped_actual_va ;
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmElfSegmentTableStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgFileContentList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmElfSegmentTableStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgFileContentList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmElfSegmentTableStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgFileContentList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmElfSegmentTableStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgFileContentList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 47410 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmPESectionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 47423 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmPESectionStorageClass::pickOutIRNodeData ( SgAsmPESection* pointer ) 
   { 
     SgAsmPESection* source = (SgAsmPESection*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_section_entry = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_section_entry );
     storageOf_file = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_file );
     storageOf_header = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_header );
     storageOf_size =  source->p_size ;
     storageOf_offset =  source->p_offset ;
     storageOf_file_alignment =  source->p_file_alignment ;
     storageOf_data.storeDataInEasyStorageClass(source->p_data);
     storageOf_purpose =  source->p_purpose ;
     storageOf_synthesized =  source->p_synthesized ;
     storageOf_id =  source->p_id ;
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_short_name.storeDataInEasyStorageClass(source->p_short_name);
     storageOf_mapped_preferred_rva =  source->p_mapped_preferred_rva ;
     storageOf_mapped_size =  source->p_mapped_size ;
     storageOf_mapped_alignment =  source->p_mapped_alignment ;
     storageOf_mapped_rperm =  source->p_mapped_rperm ;
     storageOf_mapped_wperm =  source->p_mapped_wperm ;
     storageOf_mapped_xperm =  source->p_mapped_xperm ;
     storageOf_contains_code =  source->p_contains_code ;
     storageOf_mapped_actual_va =  source->p_mapped_actual_va ;
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmPESectionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgFileContentList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmPESectionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgFileContentList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmPESectionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgFileContentList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmPESectionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgFileContentList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 47505 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmPEImportSectionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 47518 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmPEImportSectionStorageClass::pickOutIRNodeData ( SgAsmPEImportSection* pointer ) 
   { 
     SgAsmPEImportSection* source = (SgAsmPEImportSection*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_import_directories = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_import_directories );
     storageOf_section_entry = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_section_entry );
     storageOf_file = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_file );
     storageOf_header = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_header );
     storageOf_size =  source->p_size ;
     storageOf_offset =  source->p_offset ;
     storageOf_file_alignment =  source->p_file_alignment ;
     storageOf_data.storeDataInEasyStorageClass(source->p_data);
     storageOf_purpose =  source->p_purpose ;
     storageOf_synthesized =  source->p_synthesized ;
     storageOf_id =  source->p_id ;
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_short_name.storeDataInEasyStorageClass(source->p_short_name);
     storageOf_mapped_preferred_rva =  source->p_mapped_preferred_rva ;
     storageOf_mapped_size =  source->p_mapped_size ;
     storageOf_mapped_alignment =  source->p_mapped_alignment ;
     storageOf_mapped_rperm =  source->p_mapped_rperm ;
     storageOf_mapped_wperm =  source->p_mapped_wperm ;
     storageOf_mapped_xperm =  source->p_mapped_xperm ;
     storageOf_contains_code =  source->p_contains_code ;
     storageOf_mapped_actual_va =  source->p_mapped_actual_va ;
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmPEImportSectionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgFileContentList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmPEImportSectionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgFileContentList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmPEImportSectionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgFileContentList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmPEImportSectionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgFileContentList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 47601 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmPEExportSectionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 47614 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmPEExportSectionStorageClass::pickOutIRNodeData ( SgAsmPEExportSection* pointer ) 
   { 
     SgAsmPEExportSection* source = (SgAsmPEExportSection*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_export_dir = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_export_dir );
     storageOf_exports = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_exports );
     storageOf_section_entry = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_section_entry );
     storageOf_file = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_file );
     storageOf_header = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_header );
     storageOf_size =  source->p_size ;
     storageOf_offset =  source->p_offset ;
     storageOf_file_alignment =  source->p_file_alignment ;
     storageOf_data.storeDataInEasyStorageClass(source->p_data);
     storageOf_purpose =  source->p_purpose ;
     storageOf_synthesized =  source->p_synthesized ;
     storageOf_id =  source->p_id ;
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_short_name.storeDataInEasyStorageClass(source->p_short_name);
     storageOf_mapped_preferred_rva =  source->p_mapped_preferred_rva ;
     storageOf_mapped_size =  source->p_mapped_size ;
     storageOf_mapped_alignment =  source->p_mapped_alignment ;
     storageOf_mapped_rperm =  source->p_mapped_rperm ;
     storageOf_mapped_wperm =  source->p_mapped_wperm ;
     storageOf_mapped_xperm =  source->p_mapped_xperm ;
     storageOf_contains_code =  source->p_contains_code ;
     storageOf_mapped_actual_va =  source->p_mapped_actual_va ;
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmPEExportSectionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgFileContentList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmPEExportSectionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgFileContentList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmPEExportSectionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgFileContentList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmPEExportSectionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgFileContentList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 47698 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmPEStringSectionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 47711 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmPEStringSectionStorageClass::pickOutIRNodeData ( SgAsmPEStringSection* pointer ) 
   { 
     SgAsmPEStringSection* source = (SgAsmPEStringSection*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_strtab = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_strtab );
     storageOf_section_entry = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_section_entry );
     storageOf_file = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_file );
     storageOf_header = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_header );
     storageOf_size =  source->p_size ;
     storageOf_offset =  source->p_offset ;
     storageOf_file_alignment =  source->p_file_alignment ;
     storageOf_data.storeDataInEasyStorageClass(source->p_data);
     storageOf_purpose =  source->p_purpose ;
     storageOf_synthesized =  source->p_synthesized ;
     storageOf_id =  source->p_id ;
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_short_name.storeDataInEasyStorageClass(source->p_short_name);
     storageOf_mapped_preferred_rva =  source->p_mapped_preferred_rva ;
     storageOf_mapped_size =  source->p_mapped_size ;
     storageOf_mapped_alignment =  source->p_mapped_alignment ;
     storageOf_mapped_rperm =  source->p_mapped_rperm ;
     storageOf_mapped_wperm =  source->p_mapped_wperm ;
     storageOf_mapped_xperm =  source->p_mapped_xperm ;
     storageOf_contains_code =  source->p_contains_code ;
     storageOf_mapped_actual_va =  source->p_mapped_actual_va ;
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmPEStringSectionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgFileContentList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmPEStringSectionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgFileContentList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmPEStringSectionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgFileContentList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmPEStringSectionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgFileContentList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 47794 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmPESectionTableStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 47807 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmPESectionTableStorageClass::pickOutIRNodeData ( SgAsmPESectionTable* pointer ) 
   { 
     SgAsmPESectionTable* source = (SgAsmPESectionTable*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_file = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_file );
     storageOf_header = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_header );
     storageOf_size =  source->p_size ;
     storageOf_offset =  source->p_offset ;
     storageOf_file_alignment =  source->p_file_alignment ;
     storageOf_data.storeDataInEasyStorageClass(source->p_data);
     storageOf_purpose =  source->p_purpose ;
     storageOf_synthesized =  source->p_synthesized ;
     storageOf_id =  source->p_id ;
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_short_name.storeDataInEasyStorageClass(source->p_short_name);
     storageOf_mapped_preferred_rva =  source->p_mapped_preferred_rva ;
     storageOf_mapped_size =  source->p_mapped_size ;
     storageOf_mapped_alignment =  source->p_mapped_alignment ;
     storageOf_mapped_rperm =  source->p_mapped_rperm ;
     storageOf_mapped_wperm =  source->p_mapped_wperm ;
     storageOf_mapped_xperm =  source->p_mapped_xperm ;
     storageOf_contains_code =  source->p_contains_code ;
     storageOf_mapped_actual_va =  source->p_mapped_actual_va ;
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmPESectionTableStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgFileContentList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmPESectionTableStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgFileContentList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmPESectionTableStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgFileContentList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmPESectionTableStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgFileContentList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 47888 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDOSExtendedHeaderStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 47901 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDOSExtendedHeaderStorageClass::pickOutIRNodeData ( SgAsmDOSExtendedHeader* pointer ) 
   { 
     SgAsmDOSExtendedHeader* source = (SgAsmDOSExtendedHeader*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_e_res1 =  source->p_e_res1 ;
     storageOf_e_oemid =  source->p_e_oemid ;
     storageOf_e_oeminfo =  source->p_e_oeminfo ;
     storageOf_e_res2 =  source->p_e_res2 ;
     storageOf_e_res3 =  source->p_e_res3 ;
     storageOf_e_res4 =  source->p_e_res4 ;
     storageOf_e_res5 =  source->p_e_res5 ;
     storageOf_e_res6 =  source->p_e_res6 ;
     storageOf_e_lfanew =  source->p_e_lfanew ;
     storageOf_file = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_file );
     storageOf_header = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_header );
     storageOf_size =  source->p_size ;
     storageOf_offset =  source->p_offset ;
     storageOf_file_alignment =  source->p_file_alignment ;
     storageOf_data.storeDataInEasyStorageClass(source->p_data);
     storageOf_purpose =  source->p_purpose ;
     storageOf_synthesized =  source->p_synthesized ;
     storageOf_id =  source->p_id ;
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_short_name.storeDataInEasyStorageClass(source->p_short_name);
     storageOf_mapped_preferred_rva =  source->p_mapped_preferred_rva ;
     storageOf_mapped_size =  source->p_mapped_size ;
     storageOf_mapped_alignment =  source->p_mapped_alignment ;
     storageOf_mapped_rperm =  source->p_mapped_rperm ;
     storageOf_mapped_wperm =  source->p_mapped_wperm ;
     storageOf_mapped_xperm =  source->p_mapped_xperm ;
     storageOf_contains_code =  source->p_contains_code ;
     storageOf_mapped_actual_va =  source->p_mapped_actual_va ;
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDOSExtendedHeaderStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgFileContentList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDOSExtendedHeaderStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgFileContentList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDOSExtendedHeaderStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgFileContentList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDOSExtendedHeaderStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgFileContentList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 47991 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmCoffSymbolTableStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 48004 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmCoffSymbolTableStorageClass::pickOutIRNodeData ( SgAsmCoffSymbolTable* pointer ) 
   { 
     SgAsmCoffSymbolTable* source = (SgAsmCoffSymbolTable*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_strtab = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_strtab );
     storageOf_symbols = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_symbols );
     storageOf_file = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_file );
     storageOf_header = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_header );
     storageOf_size =  source->p_size ;
     storageOf_offset =  source->p_offset ;
     storageOf_file_alignment =  source->p_file_alignment ;
     storageOf_data.storeDataInEasyStorageClass(source->p_data);
     storageOf_purpose =  source->p_purpose ;
     storageOf_synthesized =  source->p_synthesized ;
     storageOf_id =  source->p_id ;
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_short_name.storeDataInEasyStorageClass(source->p_short_name);
     storageOf_mapped_preferred_rva =  source->p_mapped_preferred_rva ;
     storageOf_mapped_size =  source->p_mapped_size ;
     storageOf_mapped_alignment =  source->p_mapped_alignment ;
     storageOf_mapped_rperm =  source->p_mapped_rperm ;
     storageOf_mapped_wperm =  source->p_mapped_wperm ;
     storageOf_mapped_xperm =  source->p_mapped_xperm ;
     storageOf_contains_code =  source->p_contains_code ;
     storageOf_mapped_actual_va =  source->p_mapped_actual_va ;
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmCoffSymbolTableStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgFileContentList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmCoffSymbolTableStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgFileContentList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmCoffSymbolTableStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgFileContentList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmCoffSymbolTableStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgFileContentList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 48087 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmNESectionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 48100 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmNESectionStorageClass::pickOutIRNodeData ( SgAsmNESection* pointer ) 
   { 
     SgAsmNESection* source = (SgAsmNESection*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_st_entry = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_st_entry );
     storageOf_reloc_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_reloc_table );
     storageOf_file = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_file );
     storageOf_header = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_header );
     storageOf_size =  source->p_size ;
     storageOf_offset =  source->p_offset ;
     storageOf_file_alignment =  source->p_file_alignment ;
     storageOf_data.storeDataInEasyStorageClass(source->p_data);
     storageOf_purpose =  source->p_purpose ;
     storageOf_synthesized =  source->p_synthesized ;
     storageOf_id =  source->p_id ;
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_short_name.storeDataInEasyStorageClass(source->p_short_name);
     storageOf_mapped_preferred_rva =  source->p_mapped_preferred_rva ;
     storageOf_mapped_size =  source->p_mapped_size ;
     storageOf_mapped_alignment =  source->p_mapped_alignment ;
     storageOf_mapped_rperm =  source->p_mapped_rperm ;
     storageOf_mapped_wperm =  source->p_mapped_wperm ;
     storageOf_mapped_xperm =  source->p_mapped_xperm ;
     storageOf_contains_code =  source->p_contains_code ;
     storageOf_mapped_actual_va =  source->p_mapped_actual_va ;
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmNESectionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgFileContentList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmNESectionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgFileContentList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmNESectionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgFileContentList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmNESectionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgFileContentList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 48183 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmNESectionTableStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 48196 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmNESectionTableStorageClass::pickOutIRNodeData ( SgAsmNESectionTable* pointer ) 
   { 
     SgAsmNESectionTable* source = (SgAsmNESectionTable*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_flags =  source->p_flags ;
     storageOf_sector =  source->p_sector ;
     storageOf_physical_size =  source->p_physical_size ;
     storageOf_virtual_size =  source->p_virtual_size ;
     storageOf_file = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_file );
     storageOf_header = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_header );
     storageOf_size =  source->p_size ;
     storageOf_offset =  source->p_offset ;
     storageOf_file_alignment =  source->p_file_alignment ;
     storageOf_data.storeDataInEasyStorageClass(source->p_data);
     storageOf_purpose =  source->p_purpose ;
     storageOf_synthesized =  source->p_synthesized ;
     storageOf_id =  source->p_id ;
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_short_name.storeDataInEasyStorageClass(source->p_short_name);
     storageOf_mapped_preferred_rva =  source->p_mapped_preferred_rva ;
     storageOf_mapped_size =  source->p_mapped_size ;
     storageOf_mapped_alignment =  source->p_mapped_alignment ;
     storageOf_mapped_rperm =  source->p_mapped_rperm ;
     storageOf_mapped_wperm =  source->p_mapped_wperm ;
     storageOf_mapped_xperm =  source->p_mapped_xperm ;
     storageOf_contains_code =  source->p_contains_code ;
     storageOf_mapped_actual_va =  source->p_mapped_actual_va ;
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmNESectionTableStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgFileContentList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmNESectionTableStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgFileContentList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmNESectionTableStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgFileContentList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmNESectionTableStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgFileContentList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 48281 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmNENameTableStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 48294 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmNENameTableStorageClass::pickOutIRNodeData ( SgAsmNENameTable* pointer ) 
   { 
     SgAsmNENameTable* source = (SgAsmNENameTable*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_names.storeDataInEasyStorageClass(source->p_names);
     storageOf_ordinals.storeDataInEasyStorageClass(source->p_ordinals);
     storageOf_file = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_file );
     storageOf_header = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_header );
     storageOf_size =  source->p_size ;
     storageOf_offset =  source->p_offset ;
     storageOf_file_alignment =  source->p_file_alignment ;
     storageOf_data.storeDataInEasyStorageClass(source->p_data);
     storageOf_purpose =  source->p_purpose ;
     storageOf_synthesized =  source->p_synthesized ;
     storageOf_id =  source->p_id ;
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_short_name.storeDataInEasyStorageClass(source->p_short_name);
     storageOf_mapped_preferred_rva =  source->p_mapped_preferred_rva ;
     storageOf_mapped_size =  source->p_mapped_size ;
     storageOf_mapped_alignment =  source->p_mapped_alignment ;
     storageOf_mapped_rperm =  source->p_mapped_rperm ;
     storageOf_mapped_wperm =  source->p_mapped_wperm ;
     storageOf_mapped_xperm =  source->p_mapped_xperm ;
     storageOf_contains_code =  source->p_contains_code ;
     storageOf_mapped_actual_va =  source->p_mapped_actual_va ;
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmNENameTableStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgStringList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgUnsignedList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgFileContentList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmNENameTableStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgStringList > :: deleteMemoryPool() ;
     EasyStorage < SgUnsignedList > :: deleteMemoryPool() ;
     EasyStorage < SgFileContentList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmNENameTableStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgStringList > :: writeToFile(out) ;
     EasyStorage < SgUnsignedList > :: writeToFile(out) ;
     EasyStorage < SgFileContentList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmNENameTableStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgStringList > :: readFromFile(in) ;
     EasyStorage < SgUnsignedList > :: readFromFile(in) ;
     EasyStorage < SgFileContentList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 48385 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmNEModuleTableStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 48398 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmNEModuleTableStorageClass::pickOutIRNodeData ( SgAsmNEModuleTable* pointer ) 
   { 
     SgAsmNEModuleTable* source = (SgAsmNEModuleTable*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_strtab = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_strtab );
     storageOf_name_offsets.storeDataInEasyStorageClass(source->p_name_offsets);
     storageOf_names.storeDataInEasyStorageClass(source->p_names);
     storageOf_file = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_file );
     storageOf_header = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_header );
     storageOf_size =  source->p_size ;
     storageOf_offset =  source->p_offset ;
     storageOf_file_alignment =  source->p_file_alignment ;
     storageOf_data.storeDataInEasyStorageClass(source->p_data);
     storageOf_purpose =  source->p_purpose ;
     storageOf_synthesized =  source->p_synthesized ;
     storageOf_id =  source->p_id ;
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_short_name.storeDataInEasyStorageClass(source->p_short_name);
     storageOf_mapped_preferred_rva =  source->p_mapped_preferred_rva ;
     storageOf_mapped_size =  source->p_mapped_size ;
     storageOf_mapped_alignment =  source->p_mapped_alignment ;
     storageOf_mapped_rperm =  source->p_mapped_rperm ;
     storageOf_mapped_wperm =  source->p_mapped_wperm ;
     storageOf_mapped_xperm =  source->p_mapped_xperm ;
     storageOf_contains_code =  source->p_contains_code ;
     storageOf_mapped_actual_va =  source->p_mapped_actual_va ;
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmNEModuleTableStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgAddressList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgStringList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgFileContentList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmNEModuleTableStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgAddressList > :: deleteMemoryPool() ;
     EasyStorage < SgStringList > :: deleteMemoryPool() ;
     EasyStorage < SgFileContentList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmNEModuleTableStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgAddressList > :: writeToFile(out) ;
     EasyStorage < SgStringList > :: writeToFile(out) ;
     EasyStorage < SgFileContentList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmNEModuleTableStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgAddressList > :: readFromFile(in) ;
     EasyStorage < SgStringList > :: readFromFile(in) ;
     EasyStorage < SgFileContentList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 48490 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmNEStringTableStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 48503 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmNEStringTableStorageClass::pickOutIRNodeData ( SgAsmNEStringTable* pointer ) 
   { 
     SgAsmNEStringTable* source = (SgAsmNEStringTable*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_file = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_file );
     storageOf_header = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_header );
     storageOf_size =  source->p_size ;
     storageOf_offset =  source->p_offset ;
     storageOf_file_alignment =  source->p_file_alignment ;
     storageOf_data.storeDataInEasyStorageClass(source->p_data);
     storageOf_purpose =  source->p_purpose ;
     storageOf_synthesized =  source->p_synthesized ;
     storageOf_id =  source->p_id ;
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_short_name.storeDataInEasyStorageClass(source->p_short_name);
     storageOf_mapped_preferred_rva =  source->p_mapped_preferred_rva ;
     storageOf_mapped_size =  source->p_mapped_size ;
     storageOf_mapped_alignment =  source->p_mapped_alignment ;
     storageOf_mapped_rperm =  source->p_mapped_rperm ;
     storageOf_mapped_wperm =  source->p_mapped_wperm ;
     storageOf_mapped_xperm =  source->p_mapped_xperm ;
     storageOf_contains_code =  source->p_contains_code ;
     storageOf_mapped_actual_va =  source->p_mapped_actual_va ;
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmNEStringTableStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgFileContentList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmNEStringTableStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgFileContentList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmNEStringTableStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgFileContentList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmNEStringTableStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgFileContentList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 48584 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmNEEntryTableStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 48597 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmNEEntryTableStorageClass::pickOutIRNodeData ( SgAsmNEEntryTable* pointer ) 
   { 
     SgAsmNEEntryTable* source = (SgAsmNEEntryTable*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_bundle_sizes.storeDataInEasyStorageClass(source->p_bundle_sizes);
     SgAsmNEEntryPointPtrList::iterator i_entries = source->p_entries.begin() ; 
     unsigned int tempListCountentries = 0; 
     SgAsmNEEntryPointPtrList::value_type *  tempListentries = new SgAsmNEEntryPointPtrList::value_type[ source->p_entries.size() ]; 
     for ( ; i_entries != source->p_entries.end(); ++i_entries ) 
        {
          tempListentries[tempListCountentries] = *i_entries;
          tempListCountentries++; 
          (*i_entries) = (SgAsmNEEntryPointPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_entries ) );
        }
     storageOf_entries.storeDataInEasyStorageClass(source->p_entries);
     tempListCountentries = 0; 
     i_entries = source->p_entries.begin() ; 
     for ( ; i_entries != source->p_entries.end(); ++i_entries ) 
        {
          *i_entries = tempListentries[tempListCountentries] ;
          tempListCountentries++; 
        }
      delete [] tempListentries; 
     storageOf_file = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_file );
     storageOf_header = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_header );
     storageOf_size =  source->p_size ;
     storageOf_offset =  source->p_offset ;
     storageOf_file_alignment =  source->p_file_alignment ;
     storageOf_data.storeDataInEasyStorageClass(source->p_data);
     storageOf_purpose =  source->p_purpose ;
     storageOf_synthesized =  source->p_synthesized ;
     storageOf_id =  source->p_id ;
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_short_name.storeDataInEasyStorageClass(source->p_short_name);
     storageOf_mapped_preferred_rva =  source->p_mapped_preferred_rva ;
     storageOf_mapped_size =  source->p_mapped_size ;
     storageOf_mapped_alignment =  source->p_mapped_alignment ;
     storageOf_mapped_rperm =  source->p_mapped_rperm ;
     storageOf_mapped_wperm =  source->p_mapped_wperm ;
     storageOf_mapped_xperm =  source->p_mapped_xperm ;
     storageOf_contains_code =  source->p_contains_code ;
     storageOf_mapped_actual_va =  source->p_mapped_actual_va ;
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmNEEntryTableStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgSizeTList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgAsmNEEntryPointPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgFileContentList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmNEEntryTableStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgSizeTList > :: deleteMemoryPool() ;
     EasyStorage < SgAsmNEEntryPointPtrList > :: deleteMemoryPool() ;
     EasyStorage < SgFileContentList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmNEEntryTableStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgSizeTList > :: writeToFile(out) ;
     EasyStorage < SgAsmNEEntryPointPtrList > :: writeToFile(out) ;
     EasyStorage < SgFileContentList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmNEEntryTableStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgSizeTList > :: readFromFile(in) ;
     EasyStorage < SgAsmNEEntryPointPtrList > :: readFromFile(in) ;
     EasyStorage < SgFileContentList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 48705 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmNERelocTableStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 48718 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmNERelocTableStorageClass::pickOutIRNodeData ( SgAsmNERelocTable* pointer ) 
   { 
     SgAsmNERelocTable* source = (SgAsmNERelocTable*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgAsmNERelocEntryPtrList::iterator i_entries = source->p_entries.begin() ; 
     unsigned int tempListCountentries = 0; 
     SgAsmNERelocEntryPtrList::value_type *  tempListentries = new SgAsmNERelocEntryPtrList::value_type[ source->p_entries.size() ]; 
     for ( ; i_entries != source->p_entries.end(); ++i_entries ) 
        {
          tempListentries[tempListCountentries] = *i_entries;
          tempListCountentries++; 
          (*i_entries) = (SgAsmNERelocEntryPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_entries ) );
        }
     storageOf_entries.storeDataInEasyStorageClass(source->p_entries);
     tempListCountentries = 0; 
     i_entries = source->p_entries.begin() ; 
     for ( ; i_entries != source->p_entries.end(); ++i_entries ) 
        {
          *i_entries = tempListentries[tempListCountentries] ;
          tempListCountentries++; 
        }
      delete [] tempListentries; 
     storageOf_file = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_file );
     storageOf_header = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_header );
     storageOf_size =  source->p_size ;
     storageOf_offset =  source->p_offset ;
     storageOf_file_alignment =  source->p_file_alignment ;
     storageOf_data.storeDataInEasyStorageClass(source->p_data);
     storageOf_purpose =  source->p_purpose ;
     storageOf_synthesized =  source->p_synthesized ;
     storageOf_id =  source->p_id ;
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_short_name.storeDataInEasyStorageClass(source->p_short_name);
     storageOf_mapped_preferred_rva =  source->p_mapped_preferred_rva ;
     storageOf_mapped_size =  source->p_mapped_size ;
     storageOf_mapped_alignment =  source->p_mapped_alignment ;
     storageOf_mapped_rperm =  source->p_mapped_rperm ;
     storageOf_mapped_wperm =  source->p_mapped_wperm ;
     storageOf_mapped_xperm =  source->p_mapped_xperm ;
     storageOf_contains_code =  source->p_contains_code ;
     storageOf_mapped_actual_va =  source->p_mapped_actual_va ;
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmNERelocTableStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgAsmNERelocEntryPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgFileContentList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmNERelocTableStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgAsmNERelocEntryPtrList > :: deleteMemoryPool() ;
     EasyStorage < SgFileContentList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmNERelocTableStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgAsmNERelocEntryPtrList > :: writeToFile(out) ;
     EasyStorage < SgFileContentList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmNERelocTableStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgAsmNERelocEntryPtrList > :: readFromFile(in) ;
     EasyStorage < SgFileContentList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 48821 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmLESectionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 48834 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmLESectionStorageClass::pickOutIRNodeData ( SgAsmLESection* pointer ) 
   { 
     SgAsmLESection* source = (SgAsmLESection*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_st_entry = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_st_entry );
     storageOf_file = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_file );
     storageOf_header = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_header );
     storageOf_size =  source->p_size ;
     storageOf_offset =  source->p_offset ;
     storageOf_file_alignment =  source->p_file_alignment ;
     storageOf_data.storeDataInEasyStorageClass(source->p_data);
     storageOf_purpose =  source->p_purpose ;
     storageOf_synthesized =  source->p_synthesized ;
     storageOf_id =  source->p_id ;
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_short_name.storeDataInEasyStorageClass(source->p_short_name);
     storageOf_mapped_preferred_rva =  source->p_mapped_preferred_rva ;
     storageOf_mapped_size =  source->p_mapped_size ;
     storageOf_mapped_alignment =  source->p_mapped_alignment ;
     storageOf_mapped_rperm =  source->p_mapped_rperm ;
     storageOf_mapped_wperm =  source->p_mapped_wperm ;
     storageOf_mapped_xperm =  source->p_mapped_xperm ;
     storageOf_contains_code =  source->p_contains_code ;
     storageOf_mapped_actual_va =  source->p_mapped_actual_va ;
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmLESectionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgFileContentList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmLESectionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgFileContentList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmLESectionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgFileContentList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmLESectionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgFileContentList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 48916 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmLESectionTableStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 48929 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmLESectionTableStorageClass::pickOutIRNodeData ( SgAsmLESectionTable* pointer ) 
   { 
     SgAsmLESectionTable* source = (SgAsmLESectionTable*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_file = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_file );
     storageOf_header = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_header );
     storageOf_size =  source->p_size ;
     storageOf_offset =  source->p_offset ;
     storageOf_file_alignment =  source->p_file_alignment ;
     storageOf_data.storeDataInEasyStorageClass(source->p_data);
     storageOf_purpose =  source->p_purpose ;
     storageOf_synthesized =  source->p_synthesized ;
     storageOf_id =  source->p_id ;
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_short_name.storeDataInEasyStorageClass(source->p_short_name);
     storageOf_mapped_preferred_rva =  source->p_mapped_preferred_rva ;
     storageOf_mapped_size =  source->p_mapped_size ;
     storageOf_mapped_alignment =  source->p_mapped_alignment ;
     storageOf_mapped_rperm =  source->p_mapped_rperm ;
     storageOf_mapped_wperm =  source->p_mapped_wperm ;
     storageOf_mapped_xperm =  source->p_mapped_xperm ;
     storageOf_contains_code =  source->p_contains_code ;
     storageOf_mapped_actual_va =  source->p_mapped_actual_va ;
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmLESectionTableStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgFileContentList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmLESectionTableStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgFileContentList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmLESectionTableStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgFileContentList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmLESectionTableStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgFileContentList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 49010 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmLENameTableStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 49023 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmLENameTableStorageClass::pickOutIRNodeData ( SgAsmLENameTable* pointer ) 
   { 
     SgAsmLENameTable* source = (SgAsmLENameTable*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_names.storeDataInEasyStorageClass(source->p_names);
     storageOf_ordinals.storeDataInEasyStorageClass(source->p_ordinals);
     storageOf_file = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_file );
     storageOf_header = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_header );
     storageOf_size =  source->p_size ;
     storageOf_offset =  source->p_offset ;
     storageOf_file_alignment =  source->p_file_alignment ;
     storageOf_data.storeDataInEasyStorageClass(source->p_data);
     storageOf_purpose =  source->p_purpose ;
     storageOf_synthesized =  source->p_synthesized ;
     storageOf_id =  source->p_id ;
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_short_name.storeDataInEasyStorageClass(source->p_short_name);
     storageOf_mapped_preferred_rva =  source->p_mapped_preferred_rva ;
     storageOf_mapped_size =  source->p_mapped_size ;
     storageOf_mapped_alignment =  source->p_mapped_alignment ;
     storageOf_mapped_rperm =  source->p_mapped_rperm ;
     storageOf_mapped_wperm =  source->p_mapped_wperm ;
     storageOf_mapped_xperm =  source->p_mapped_xperm ;
     storageOf_contains_code =  source->p_contains_code ;
     storageOf_mapped_actual_va =  source->p_mapped_actual_va ;
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmLENameTableStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgStringList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgUnsignedList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgFileContentList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmLENameTableStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgStringList > :: deleteMemoryPool() ;
     EasyStorage < SgUnsignedList > :: deleteMemoryPool() ;
     EasyStorage < SgFileContentList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmLENameTableStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgStringList > :: writeToFile(out) ;
     EasyStorage < SgUnsignedList > :: writeToFile(out) ;
     EasyStorage < SgFileContentList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmLENameTableStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgStringList > :: readFromFile(in) ;
     EasyStorage < SgUnsignedList > :: readFromFile(in) ;
     EasyStorage < SgFileContentList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 49114 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmLEPageTableStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 49127 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmLEPageTableStorageClass::pickOutIRNodeData ( SgAsmLEPageTable* pointer ) 
   { 
     SgAsmLEPageTable* source = (SgAsmLEPageTable*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgAsmLEPageTableEntryPtrList::iterator i_entries = source->p_entries.begin() ; 
     unsigned int tempListCountentries = 0; 
     SgAsmLEPageTableEntryPtrList::value_type *  tempListentries = new SgAsmLEPageTableEntryPtrList::value_type[ source->p_entries.size() ]; 
     for ( ; i_entries != source->p_entries.end(); ++i_entries ) 
        {
          tempListentries[tempListCountentries] = *i_entries;
          tempListCountentries++; 
          (*i_entries) = (SgAsmLEPageTableEntryPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_entries ) );
        }
     storageOf_entries.storeDataInEasyStorageClass(source->p_entries);
     tempListCountentries = 0; 
     i_entries = source->p_entries.begin() ; 
     for ( ; i_entries != source->p_entries.end(); ++i_entries ) 
        {
          *i_entries = tempListentries[tempListCountentries] ;
          tempListCountentries++; 
        }
      delete [] tempListentries; 
     storageOf_file = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_file );
     storageOf_header = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_header );
     storageOf_size =  source->p_size ;
     storageOf_offset =  source->p_offset ;
     storageOf_file_alignment =  source->p_file_alignment ;
     storageOf_data.storeDataInEasyStorageClass(source->p_data);
     storageOf_purpose =  source->p_purpose ;
     storageOf_synthesized =  source->p_synthesized ;
     storageOf_id =  source->p_id ;
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_short_name.storeDataInEasyStorageClass(source->p_short_name);
     storageOf_mapped_preferred_rva =  source->p_mapped_preferred_rva ;
     storageOf_mapped_size =  source->p_mapped_size ;
     storageOf_mapped_alignment =  source->p_mapped_alignment ;
     storageOf_mapped_rperm =  source->p_mapped_rperm ;
     storageOf_mapped_wperm =  source->p_mapped_wperm ;
     storageOf_mapped_xperm =  source->p_mapped_xperm ;
     storageOf_contains_code =  source->p_contains_code ;
     storageOf_mapped_actual_va =  source->p_mapped_actual_va ;
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmLEPageTableStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgAsmLEPageTableEntryPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgFileContentList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmLEPageTableStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgAsmLEPageTableEntryPtrList > :: deleteMemoryPool() ;
     EasyStorage < SgFileContentList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmLEPageTableStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgAsmLEPageTableEntryPtrList > :: writeToFile(out) ;
     EasyStorage < SgFileContentList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmLEPageTableStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgAsmLEPageTableEntryPtrList > :: readFromFile(in) ;
     EasyStorage < SgFileContentList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 49230 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmLEEntryTableStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 49243 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmLEEntryTableStorageClass::pickOutIRNodeData ( SgAsmLEEntryTable* pointer ) 
   { 
     SgAsmLEEntryTable* source = (SgAsmLEEntryTable*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_bundle_sizes.storeDataInEasyStorageClass(source->p_bundle_sizes);
     SgAsmLEEntryPointPtrList::iterator i_entries = source->p_entries.begin() ; 
     unsigned int tempListCountentries = 0; 
     SgAsmLEEntryPointPtrList::value_type *  tempListentries = new SgAsmLEEntryPointPtrList::value_type[ source->p_entries.size() ]; 
     for ( ; i_entries != source->p_entries.end(); ++i_entries ) 
        {
          tempListentries[tempListCountentries] = *i_entries;
          tempListCountentries++; 
          (*i_entries) = (SgAsmLEEntryPointPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_entries ) );
        }
     storageOf_entries.storeDataInEasyStorageClass(source->p_entries);
     tempListCountentries = 0; 
     i_entries = source->p_entries.begin() ; 
     for ( ; i_entries != source->p_entries.end(); ++i_entries ) 
        {
          *i_entries = tempListentries[tempListCountentries] ;
          tempListCountentries++; 
        }
      delete [] tempListentries; 
     storageOf_file = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_file );
     storageOf_header = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_header );
     storageOf_size =  source->p_size ;
     storageOf_offset =  source->p_offset ;
     storageOf_file_alignment =  source->p_file_alignment ;
     storageOf_data.storeDataInEasyStorageClass(source->p_data);
     storageOf_purpose =  source->p_purpose ;
     storageOf_synthesized =  source->p_synthesized ;
     storageOf_id =  source->p_id ;
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_short_name.storeDataInEasyStorageClass(source->p_short_name);
     storageOf_mapped_preferred_rva =  source->p_mapped_preferred_rva ;
     storageOf_mapped_size =  source->p_mapped_size ;
     storageOf_mapped_alignment =  source->p_mapped_alignment ;
     storageOf_mapped_rperm =  source->p_mapped_rperm ;
     storageOf_mapped_wperm =  source->p_mapped_wperm ;
     storageOf_mapped_xperm =  source->p_mapped_xperm ;
     storageOf_contains_code =  source->p_contains_code ;
     storageOf_mapped_actual_va =  source->p_mapped_actual_va ;
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmLEEntryTableStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgSizeTList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgAsmLEEntryPointPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgFileContentList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmLEEntryTableStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgSizeTList > :: deleteMemoryPool() ;
     EasyStorage < SgAsmLEEntryPointPtrList > :: deleteMemoryPool() ;
     EasyStorage < SgFileContentList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmLEEntryTableStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgSizeTList > :: writeToFile(out) ;
     EasyStorage < SgAsmLEEntryPointPtrList > :: writeToFile(out) ;
     EasyStorage < SgFileContentList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmLEEntryTableStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgSizeTList > :: readFromFile(in) ;
     EasyStorage < SgAsmLEEntryPointPtrList > :: readFromFile(in) ;
     EasyStorage < SgFileContentList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 49351 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmLERelocTableStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 49364 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmLERelocTableStorageClass::pickOutIRNodeData ( SgAsmLERelocTable* pointer ) 
   { 
     SgAsmLERelocTable* source = (SgAsmLERelocTable*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgAsmLERelocEntryPtrList::iterator i_entries = source->p_entries.begin() ; 
     unsigned int tempListCountentries = 0; 
     SgAsmLERelocEntryPtrList::value_type *  tempListentries = new SgAsmLERelocEntryPtrList::value_type[ source->p_entries.size() ]; 
     for ( ; i_entries != source->p_entries.end(); ++i_entries ) 
        {
          tempListentries[tempListCountentries] = *i_entries;
          tempListCountentries++; 
          (*i_entries) = (SgAsmLERelocEntryPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_entries ) );
        }
     storageOf_entries.storeDataInEasyStorageClass(source->p_entries);
     tempListCountentries = 0; 
     i_entries = source->p_entries.begin() ; 
     for ( ; i_entries != source->p_entries.end(); ++i_entries ) 
        {
          *i_entries = tempListentries[tempListCountentries] ;
          tempListCountentries++; 
        }
      delete [] tempListentries; 
     storageOf_file = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_file );
     storageOf_header = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_header );
     storageOf_size =  source->p_size ;
     storageOf_offset =  source->p_offset ;
     storageOf_file_alignment =  source->p_file_alignment ;
     storageOf_data.storeDataInEasyStorageClass(source->p_data);
     storageOf_purpose =  source->p_purpose ;
     storageOf_synthesized =  source->p_synthesized ;
     storageOf_id =  source->p_id ;
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_short_name.storeDataInEasyStorageClass(source->p_short_name);
     storageOf_mapped_preferred_rva =  source->p_mapped_preferred_rva ;
     storageOf_mapped_size =  source->p_mapped_size ;
     storageOf_mapped_alignment =  source->p_mapped_alignment ;
     storageOf_mapped_rperm =  source->p_mapped_rperm ;
     storageOf_mapped_wperm =  source->p_mapped_wperm ;
     storageOf_mapped_xperm =  source->p_mapped_xperm ;
     storageOf_contains_code =  source->p_contains_code ;
     storageOf_mapped_actual_va =  source->p_mapped_actual_va ;
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmLERelocTableStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgAsmLERelocEntryPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgFileContentList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmLERelocTableStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgAsmLERelocEntryPtrList > :: deleteMemoryPool() ;
     EasyStorage < SgFileContentList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmLERelocTableStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgAsmLERelocEntryPtrList > :: writeToFile(out) ;
     EasyStorage < SgFileContentList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmLERelocTableStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgAsmLERelocEntryPtrList > :: readFromFile(in) ;
     EasyStorage < SgFileContentList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 49467 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmGenericSymbolStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 49480 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmGenericSymbolStorageClass::pickOutIRNodeData ( SgAsmGenericSymbol* pointer ) 
   { 
     SgAsmGenericSymbol* source = (SgAsmGenericSymbol*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_def_state =  source->p_def_state ;
     storageOf_binding =  source->p_binding ;
     storageOf_type =  source->p_type ;
     storageOf_value =  source->p_value ;
     storageOf_size =  source->p_size ;
     storageOf_bound = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_bound );
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmGenericSymbolStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmGenericSymbolStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmGenericSymbolStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmGenericSymbolStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 49541 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmCoffSymbolStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 49554 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmCoffSymbolStorageClass::pickOutIRNodeData ( SgAsmCoffSymbol* pointer ) 
   { 
     SgAsmCoffSymbol* source = (SgAsmCoffSymbol*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_st_name.storeDataInEasyStorageClass(source->p_st_name);
     storageOf_st_name_offset =  source->p_st_name_offset ;
     storageOf_st_section_num =  source->p_st_section_num ;
     storageOf_st_type =  source->p_st_type ;
     storageOf_st_storage_class =  source->p_st_storage_class ;
     storageOf_st_num_aux_entries =  source->p_st_num_aux_entries ;
     storageOf_aux_data.storeDataInEasyStorageClass(source->p_aux_data);
     storageOf_def_state =  source->p_def_state ;
     storageOf_binding =  source->p_binding ;
     storageOf_type =  source->p_type ;
     storageOf_value =  source->p_value ;
     storageOf_size =  source->p_size ;
     storageOf_bound = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_bound );
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmCoffSymbolStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgUnsignedCharList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmCoffSymbolStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < SgUnsignedCharList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmCoffSymbolStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < SgUnsignedCharList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmCoffSymbolStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < SgUnsignedCharList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 49630 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmElfSymbolStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 49643 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmElfSymbolStorageClass::pickOutIRNodeData ( SgAsmElfSymbol* pointer ) 
   { 
     SgAsmElfSymbol* source = (SgAsmElfSymbol*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_st_info =  source->p_st_info ;
     storageOf_st_res1 =  source->p_st_res1 ;
     storageOf_st_shndx =  source->p_st_shndx ;
     storageOf_st_size =  source->p_st_size ;
     storageOf_extra.storeDataInEasyStorageClass(source->p_extra);
     storageOf_def_state =  source->p_def_state ;
     storageOf_binding =  source->p_binding ;
     storageOf_type =  source->p_type ;
     storageOf_value =  source->p_value ;
     storageOf_size =  source->p_size ;
     storageOf_bound = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_bound );
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmElfSymbolStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgUnsignedCharList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmElfSymbolStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgUnsignedCharList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmElfSymbolStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgUnsignedCharList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmElfSymbolStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgUnsignedCharList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 49713 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmGenericStrtabStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 49726 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmGenericStrtabStorageClass::pickOutIRNodeData ( SgAsmGenericStrtab* pointer ) 
   { 
     SgAsmGenericStrtab* source = (SgAsmGenericStrtab*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_container = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_container );
     SgAsmGenericStrtab::referenced_t::iterator i_storage_list = source->p_storage_list.begin() ; 
     unsigned int tempListCountstorage_list = 0; 
     SgAsmGenericStrtab::referenced_t::value_type *  tempListstorage_list = new SgAsmGenericStrtab::referenced_t::value_type[ source->p_storage_list.size() ]; 
     for ( ; i_storage_list != source->p_storage_list.end(); ++i_storage_list ) 
        {
          tempListstorage_list[tempListCountstorage_list] = *i_storage_list;
          tempListCountstorage_list++; 
          (*i_storage_list) = (SgAsmGenericStrtab::referenced_t::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_storage_list ) );
        }
     storageOf_storage_list.storeDataInEasyStorageClass(source->p_storage_list);
     tempListCountstorage_list = 0; 
     i_storage_list = source->p_storage_list.begin() ; 
     for ( ; i_storage_list != source->p_storage_list.end(); ++i_storage_list ) 
        {
          *i_storage_list = tempListstorage_list[tempListCountstorage_list] ;
          tempListCountstorage_list++; 
        }
      delete [] tempListstorage_list; 
     storageOf_freelist.storeDataInEasyStorageClass(source->p_freelist);
     storageOf_dont_free = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_dont_free );
     storageOf_num_freed =  source->p_num_freed ;
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmGenericStrtabStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgAsmGenericStrtab::referenced_t > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < ExtentMap > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmGenericStrtabStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgAsmGenericStrtab::referenced_t > :: deleteMemoryPool() ;
     EasyStorage < ExtentMap > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmGenericStrtabStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgAsmGenericStrtab::referenced_t > :: writeToFile(out) ;
     EasyStorage < ExtentMap > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmGenericStrtabStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgAsmGenericStrtab::referenced_t > :: readFromFile(in) ;
     EasyStorage < ExtentMap > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 49810 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmElfStrtabStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 49823 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmElfStrtabStorageClass::pickOutIRNodeData ( SgAsmElfStrtab* pointer ) 
   { 
     SgAsmElfStrtab* source = (SgAsmElfStrtab*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_container = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_container );
     SgAsmGenericStrtab::referenced_t::iterator i_storage_list = source->p_storage_list.begin() ; 
     unsigned int tempListCountstorage_list = 0; 
     SgAsmGenericStrtab::referenced_t::value_type *  tempListstorage_list = new SgAsmGenericStrtab::referenced_t::value_type[ source->p_storage_list.size() ]; 
     for ( ; i_storage_list != source->p_storage_list.end(); ++i_storage_list ) 
        {
          tempListstorage_list[tempListCountstorage_list] = *i_storage_list;
          tempListCountstorage_list++; 
          (*i_storage_list) = (SgAsmGenericStrtab::referenced_t::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_storage_list ) );
        }
     storageOf_storage_list.storeDataInEasyStorageClass(source->p_storage_list);
     tempListCountstorage_list = 0; 
     i_storage_list = source->p_storage_list.begin() ; 
     for ( ; i_storage_list != source->p_storage_list.end(); ++i_storage_list ) 
        {
          *i_storage_list = tempListstorage_list[tempListCountstorage_list] ;
          tempListCountstorage_list++; 
        }
      delete [] tempListstorage_list; 
     storageOf_freelist.storeDataInEasyStorageClass(source->p_freelist);
     storageOf_dont_free = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_dont_free );
     storageOf_num_freed =  source->p_num_freed ;
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmElfStrtabStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgAsmGenericStrtab::referenced_t > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < ExtentMap > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmElfStrtabStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgAsmGenericStrtab::referenced_t > :: deleteMemoryPool() ;
     EasyStorage < ExtentMap > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmElfStrtabStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgAsmGenericStrtab::referenced_t > :: writeToFile(out) ;
     EasyStorage < ExtentMap > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmElfStrtabStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgAsmGenericStrtab::referenced_t > :: readFromFile(in) ;
     EasyStorage < ExtentMap > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 49907 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmCoffStrtabStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 49920 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmCoffStrtabStorageClass::pickOutIRNodeData ( SgAsmCoffStrtab* pointer ) 
   { 
     SgAsmCoffStrtab* source = (SgAsmCoffStrtab*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_container = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_container );
     SgAsmGenericStrtab::referenced_t::iterator i_storage_list = source->p_storage_list.begin() ; 
     unsigned int tempListCountstorage_list = 0; 
     SgAsmGenericStrtab::referenced_t::value_type *  tempListstorage_list = new SgAsmGenericStrtab::referenced_t::value_type[ source->p_storage_list.size() ]; 
     for ( ; i_storage_list != source->p_storage_list.end(); ++i_storage_list ) 
        {
          tempListstorage_list[tempListCountstorage_list] = *i_storage_list;
          tempListCountstorage_list++; 
          (*i_storage_list) = (SgAsmGenericStrtab::referenced_t::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_storage_list ) );
        }
     storageOf_storage_list.storeDataInEasyStorageClass(source->p_storage_list);
     tempListCountstorage_list = 0; 
     i_storage_list = source->p_storage_list.begin() ; 
     for ( ; i_storage_list != source->p_storage_list.end(); ++i_storage_list ) 
        {
          *i_storage_list = tempListstorage_list[tempListCountstorage_list] ;
          tempListCountstorage_list++; 
        }
      delete [] tempListstorage_list; 
     storageOf_freelist.storeDataInEasyStorageClass(source->p_freelist);
     storageOf_dont_free = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_dont_free );
     storageOf_num_freed =  source->p_num_freed ;
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmCoffStrtabStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgAsmGenericStrtab::referenced_t > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < ExtentMap > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmCoffStrtabStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgAsmGenericStrtab::referenced_t > :: deleteMemoryPool() ;
     EasyStorage < ExtentMap > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmCoffStrtabStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgAsmGenericStrtab::referenced_t > :: writeToFile(out) ;
     EasyStorage < ExtentMap > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmCoffStrtabStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgAsmGenericStrtab::referenced_t > :: readFromFile(in) ;
     EasyStorage < ExtentMap > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 50004 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmGenericSymbolListStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 50017 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmGenericSymbolListStorageClass::pickOutIRNodeData ( SgAsmGenericSymbolList* pointer ) 
   { 
     SgAsmGenericSymbolList* source = (SgAsmGenericSymbolList*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgAsmGenericSymbolPtrList::iterator i_symbols = source->p_symbols.begin() ; 
     unsigned int tempListCountsymbols = 0; 
     SgAsmGenericSymbolPtrList::value_type *  tempListsymbols = new SgAsmGenericSymbolPtrList::value_type[ source->p_symbols.size() ]; 
     for ( ; i_symbols != source->p_symbols.end(); ++i_symbols ) 
        {
          tempListsymbols[tempListCountsymbols] = *i_symbols;
          tempListCountsymbols++; 
          (*i_symbols) = (SgAsmGenericSymbolPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_symbols ) );
        }
     storageOf_symbols.storeDataInEasyStorageClass(source->p_symbols);
     tempListCountsymbols = 0; 
     i_symbols = source->p_symbols.begin() ; 
     for ( ; i_symbols != source->p_symbols.end(); ++i_symbols ) 
        {
          *i_symbols = tempListsymbols[tempListCountsymbols] ;
          tempListCountsymbols++; 
        }
      delete [] tempListsymbols; 
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmGenericSymbolListStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgAsmGenericSymbolPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmGenericSymbolListStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgAsmGenericSymbolPtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmGenericSymbolListStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgAsmGenericSymbolPtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmGenericSymbolListStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgAsmGenericSymbolPtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 50093 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmGenericSectionListStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 50106 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmGenericSectionListStorageClass::pickOutIRNodeData ( SgAsmGenericSectionList* pointer ) 
   { 
     SgAsmGenericSectionList* source = (SgAsmGenericSectionList*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgAsmGenericSectionPtrList::iterator i_sections = source->p_sections.begin() ; 
     unsigned int tempListCountsections = 0; 
     SgAsmGenericSectionPtrList::value_type *  tempListsections = new SgAsmGenericSectionPtrList::value_type[ source->p_sections.size() ]; 
     for ( ; i_sections != source->p_sections.end(); ++i_sections ) 
        {
          tempListsections[tempListCountsections] = *i_sections;
          tempListCountsections++; 
          (*i_sections) = (SgAsmGenericSectionPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_sections ) );
        }
     storageOf_sections.storeDataInEasyStorageClass(source->p_sections);
     tempListCountsections = 0; 
     i_sections = source->p_sections.begin() ; 
     for ( ; i_sections != source->p_sections.end(); ++i_sections ) 
        {
          *i_sections = tempListsections[tempListCountsections] ;
          tempListCountsections++; 
        }
      delete [] tempListsections; 
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmGenericSectionListStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgAsmGenericSectionPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmGenericSectionListStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgAsmGenericSectionPtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmGenericSectionListStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgAsmGenericSectionPtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmGenericSectionListStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgAsmGenericSectionPtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 50182 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmGenericHeaderListStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 50195 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmGenericHeaderListStorageClass::pickOutIRNodeData ( SgAsmGenericHeaderList* pointer ) 
   { 
     SgAsmGenericHeaderList* source = (SgAsmGenericHeaderList*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgAsmGenericHeaderPtrList::iterator i_headers = source->p_headers.begin() ; 
     unsigned int tempListCountheaders = 0; 
     SgAsmGenericHeaderPtrList::value_type *  tempListheaders = new SgAsmGenericHeaderPtrList::value_type[ source->p_headers.size() ]; 
     for ( ; i_headers != source->p_headers.end(); ++i_headers ) 
        {
          tempListheaders[tempListCountheaders] = *i_headers;
          tempListCountheaders++; 
          (*i_headers) = (SgAsmGenericHeaderPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_headers ) );
        }
     storageOf_headers.storeDataInEasyStorageClass(source->p_headers);
     tempListCountheaders = 0; 
     i_headers = source->p_headers.begin() ; 
     for ( ; i_headers != source->p_headers.end(); ++i_headers ) 
        {
          *i_headers = tempListheaders[tempListCountheaders] ;
          tempListCountheaders++; 
        }
      delete [] tempListheaders; 
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmGenericHeaderListStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgAsmGenericHeaderPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmGenericHeaderListStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgAsmGenericHeaderPtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmGenericHeaderListStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgAsmGenericHeaderPtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmGenericHeaderListStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgAsmGenericHeaderPtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 50271 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmGenericStringStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 50284 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmGenericStringStorageClass::pickOutIRNodeData ( SgAsmGenericString* pointer ) 
   { 
     SgAsmGenericString* source = (SgAsmGenericString*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmGenericStringStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmGenericStringStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmGenericStringStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmGenericStringStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 50338 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmBasicStringStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 50351 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmBasicStringStorageClass::pickOutIRNodeData ( SgAsmBasicString* pointer ) 
   { 
     SgAsmBasicString* source = (SgAsmBasicString*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_string.storeDataInEasyStorageClass(source->p_string);
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmBasicStringStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmBasicStringStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmBasicStringStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmBasicStringStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 50410 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmStoredStringStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 50423 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmStoredStringStorageClass::pickOutIRNodeData ( SgAsmStoredString* pointer ) 
   { 
     SgAsmStoredString* source = (SgAsmStoredString*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_storage = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_storage );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmStoredStringStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmStoredStringStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmStoredStringStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmStoredStringStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 50478 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmElfSectionTableEntryStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 50491 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmElfSectionTableEntryStorageClass::pickOutIRNodeData ( SgAsmElfSectionTableEntry* pointer ) 
   { 
     SgAsmElfSectionTableEntry* source = (SgAsmElfSectionTableEntry*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_sh_name =  source->p_sh_name ;
     storageOf_sh_type =  source->p_sh_type ;
     storageOf_sh_link =  source->p_sh_link ;
     storageOf_sh_info =  source->p_sh_info ;
     storageOf_sh_flags =  source->p_sh_flags ;
     storageOf_sh_addr =  source->p_sh_addr ;
     storageOf_sh_offset =  source->p_sh_offset ;
     storageOf_sh_size =  source->p_sh_size ;
     storageOf_sh_addralign =  source->p_sh_addralign ;
     storageOf_sh_entsize =  source->p_sh_entsize ;
     storageOf_extra.storeDataInEasyStorageClass(source->p_extra);
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmElfSectionTableEntryStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgUnsignedCharList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmElfSectionTableEntryStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgUnsignedCharList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmElfSectionTableEntryStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgUnsignedCharList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmElfSectionTableEntryStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgUnsignedCharList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 50560 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmElfSegmentTableEntryStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 50573 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmElfSegmentTableEntryStorageClass::pickOutIRNodeData ( SgAsmElfSegmentTableEntry* pointer ) 
   { 
     SgAsmElfSegmentTableEntry* source = (SgAsmElfSegmentTableEntry*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_index =  source->p_index ;
     storageOf_type =  source->p_type ;
     storageOf_flags =  source->p_flags ;
     storageOf_offset =  source->p_offset ;
     storageOf_vaddr =  source->p_vaddr ;
     storageOf_paddr =  source->p_paddr ;
     storageOf_filesz =  source->p_filesz ;
     storageOf_memsz =  source->p_memsz ;
     storageOf_align =  source->p_align ;
     storageOf_extra.storeDataInEasyStorageClass(source->p_extra);
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmElfSegmentTableEntryStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgUnsignedCharList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmElfSegmentTableEntryStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgUnsignedCharList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmElfSegmentTableEntryStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgUnsignedCharList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmElfSegmentTableEntryStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgUnsignedCharList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 50641 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmElfSymbolListStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 50654 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmElfSymbolListStorageClass::pickOutIRNodeData ( SgAsmElfSymbolList* pointer ) 
   { 
     SgAsmElfSymbolList* source = (SgAsmElfSymbolList*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgAsmElfSymbolPtrList::iterator i_symbols = source->p_symbols.begin() ; 
     unsigned int tempListCountsymbols = 0; 
     SgAsmElfSymbolPtrList::value_type *  tempListsymbols = new SgAsmElfSymbolPtrList::value_type[ source->p_symbols.size() ]; 
     for ( ; i_symbols != source->p_symbols.end(); ++i_symbols ) 
        {
          tempListsymbols[tempListCountsymbols] = *i_symbols;
          tempListCountsymbols++; 
          (*i_symbols) = (SgAsmElfSymbolPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_symbols ) );
        }
     storageOf_symbols.storeDataInEasyStorageClass(source->p_symbols);
     tempListCountsymbols = 0; 
     i_symbols = source->p_symbols.begin() ; 
     for ( ; i_symbols != source->p_symbols.end(); ++i_symbols ) 
        {
          *i_symbols = tempListsymbols[tempListCountsymbols] ;
          tempListCountsymbols++; 
        }
      delete [] tempListsymbols; 
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmElfSymbolListStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgAsmElfSymbolPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmElfSymbolListStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgAsmElfSymbolPtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmElfSymbolListStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgAsmElfSymbolPtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmElfSymbolListStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgAsmElfSymbolPtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 50730 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmElfRelocEntryStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 50743 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmElfRelocEntryStorageClass::pickOutIRNodeData ( SgAsmElfRelocEntry* pointer ) 
   { 
     SgAsmElfRelocEntry* source = (SgAsmElfRelocEntry*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_r_offset =  source->p_r_offset ;
     storageOf_r_addend =  source->p_r_addend ;
     storageOf_sym =  source->p_sym ;
     storageOf_type =  source->p_type ;
     storageOf_extra.storeDataInEasyStorageClass(source->p_extra);
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmElfRelocEntryStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgUnsignedCharList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmElfRelocEntryStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgUnsignedCharList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmElfRelocEntryStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgUnsignedCharList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmElfRelocEntryStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgUnsignedCharList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 50806 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmElfRelocEntryListStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 50819 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmElfRelocEntryListStorageClass::pickOutIRNodeData ( SgAsmElfRelocEntryList* pointer ) 
   { 
     SgAsmElfRelocEntryList* source = (SgAsmElfRelocEntryList*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgAsmElfRelocEntryPtrList::iterator i_entries = source->p_entries.begin() ; 
     unsigned int tempListCountentries = 0; 
     SgAsmElfRelocEntryPtrList::value_type *  tempListentries = new SgAsmElfRelocEntryPtrList::value_type[ source->p_entries.size() ]; 
     for ( ; i_entries != source->p_entries.end(); ++i_entries ) 
        {
          tempListentries[tempListCountentries] = *i_entries;
          tempListCountentries++; 
          (*i_entries) = (SgAsmElfRelocEntryPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_entries ) );
        }
     storageOf_entries.storeDataInEasyStorageClass(source->p_entries);
     tempListCountentries = 0; 
     i_entries = source->p_entries.begin() ; 
     for ( ; i_entries != source->p_entries.end(); ++i_entries ) 
        {
          *i_entries = tempListentries[tempListCountentries] ;
          tempListCountentries++; 
        }
      delete [] tempListentries; 
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmElfRelocEntryListStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgAsmElfRelocEntryPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmElfRelocEntryListStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgAsmElfRelocEntryPtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmElfRelocEntryListStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgAsmElfRelocEntryPtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmElfRelocEntryListStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgAsmElfRelocEntryPtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 50895 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmPEExportEntryStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 50908 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmPEExportEntryStorageClass::pickOutIRNodeData ( SgAsmPEExportEntry* pointer ) 
   { 
     SgAsmPEExportEntry* source = (SgAsmPEExportEntry*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_ordinal =  source->p_ordinal ;
     storageOf_export_rva =  source->p_export_rva ;
     storageOf_forwarder = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_forwarder );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmPEExportEntryStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmPEExportEntryStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmPEExportEntryStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmPEExportEntryStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 50966 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmPEExportEntryListStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 50979 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmPEExportEntryListStorageClass::pickOutIRNodeData ( SgAsmPEExportEntryList* pointer ) 
   { 
     SgAsmPEExportEntryList* source = (SgAsmPEExportEntryList*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgAsmPEExportEntryPtrList::iterator i_exports = source->p_exports.begin() ; 
     unsigned int tempListCountexports = 0; 
     SgAsmPEExportEntryPtrList::value_type *  tempListexports = new SgAsmPEExportEntryPtrList::value_type[ source->p_exports.size() ]; 
     for ( ; i_exports != source->p_exports.end(); ++i_exports ) 
        {
          tempListexports[tempListCountexports] = *i_exports;
          tempListCountexports++; 
          (*i_exports) = (SgAsmPEExportEntryPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_exports ) );
        }
     storageOf_exports.storeDataInEasyStorageClass(source->p_exports);
     tempListCountexports = 0; 
     i_exports = source->p_exports.begin() ; 
     for ( ; i_exports != source->p_exports.end(); ++i_exports ) 
        {
          *i_exports = tempListexports[tempListCountexports] ;
          tempListCountexports++; 
        }
      delete [] tempListexports; 
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmPEExportEntryListStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgAsmPEExportEntryPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmPEExportEntryListStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgAsmPEExportEntryPtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmPEExportEntryListStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgAsmPEExportEntryPtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmPEExportEntryListStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgAsmPEExportEntryPtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 51055 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmElfDynamicEntryStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 51068 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmElfDynamicEntryStorageClass::pickOutIRNodeData ( SgAsmElfDynamicEntry* pointer ) 
   { 
     SgAsmElfDynamicEntry* source = (SgAsmElfDynamicEntry*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_d_tag =  source->p_d_tag ;
     storageOf_d_val =  source->p_d_val ;
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_extra.storeDataInEasyStorageClass(source->p_extra);
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmElfDynamicEntryStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgUnsignedCharList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmElfDynamicEntryStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgUnsignedCharList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmElfDynamicEntryStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgUnsignedCharList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmElfDynamicEntryStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgUnsignedCharList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 51130 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmElfDynamicEntryListStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 51143 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmElfDynamicEntryListStorageClass::pickOutIRNodeData ( SgAsmElfDynamicEntryList* pointer ) 
   { 
     SgAsmElfDynamicEntryList* source = (SgAsmElfDynamicEntryList*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgAsmElfDynamicEntryPtrList::iterator i_entries = source->p_entries.begin() ; 
     unsigned int tempListCountentries = 0; 
     SgAsmElfDynamicEntryPtrList::value_type *  tempListentries = new SgAsmElfDynamicEntryPtrList::value_type[ source->p_entries.size() ]; 
     for ( ; i_entries != source->p_entries.end(); ++i_entries ) 
        {
          tempListentries[tempListCountentries] = *i_entries;
          tempListCountentries++; 
          (*i_entries) = (SgAsmElfDynamicEntryPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_entries ) );
        }
     storageOf_entries.storeDataInEasyStorageClass(source->p_entries);
     tempListCountentries = 0; 
     i_entries = source->p_entries.begin() ; 
     for ( ; i_entries != source->p_entries.end(); ++i_entries ) 
        {
          *i_entries = tempListentries[tempListCountentries] ;
          tempListCountentries++; 
        }
      delete [] tempListentries; 
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmElfDynamicEntryListStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgAsmElfDynamicEntryPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmElfDynamicEntryListStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgAsmElfDynamicEntryPtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmElfDynamicEntryListStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgAsmElfDynamicEntryPtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmElfDynamicEntryListStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgAsmElfDynamicEntryPtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 51219 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmElfSegmentTableEntryListStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 51232 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmElfSegmentTableEntryListStorageClass::pickOutIRNodeData ( SgAsmElfSegmentTableEntryList* pointer ) 
   { 
     SgAsmElfSegmentTableEntryList* source = (SgAsmElfSegmentTableEntryList*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgAsmElfSegmentTableEntryPtrList::iterator i_entries = source->p_entries.begin() ; 
     unsigned int tempListCountentries = 0; 
     SgAsmElfSegmentTableEntryPtrList::value_type *  tempListentries = new SgAsmElfSegmentTableEntryPtrList::value_type[ source->p_entries.size() ]; 
     for ( ; i_entries != source->p_entries.end(); ++i_entries ) 
        {
          tempListentries[tempListCountentries] = *i_entries;
          tempListCountentries++; 
          (*i_entries) = (SgAsmElfSegmentTableEntryPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_entries ) );
        }
     storageOf_entries.storeDataInEasyStorageClass(source->p_entries);
     tempListCountentries = 0; 
     i_entries = source->p_entries.begin() ; 
     for ( ; i_entries != source->p_entries.end(); ++i_entries ) 
        {
          *i_entries = tempListentries[tempListCountentries] ;
          tempListCountentries++; 
        }
      delete [] tempListentries; 
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmElfSegmentTableEntryListStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgAsmElfSegmentTableEntryPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmElfSegmentTableEntryListStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgAsmElfSegmentTableEntryPtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmElfSegmentTableEntryListStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgAsmElfSegmentTableEntryPtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmElfSegmentTableEntryListStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgAsmElfSegmentTableEntryPtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 51308 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmStringStorageStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 51321 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmStringStorageStorageClass::pickOutIRNodeData ( SgAsmStringStorage* pointer ) 
   { 
     SgAsmStringStorage* source = (SgAsmStringStorage*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_strtab = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_strtab );
     storageOf_string.storeDataInEasyStorageClass(source->p_string);
     storageOf_offset =  source->p_offset ;
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmStringStorageStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmStringStorageStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmStringStorageStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmStringStorageStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 51382 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmElfNoteEntryStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 51395 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmElfNoteEntryStorageClass::pickOutIRNodeData ( SgAsmElfNoteEntry* pointer ) 
   { 
     SgAsmElfNoteEntry* source = (SgAsmElfNoteEntry*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_type =  source->p_type ;
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_payload.storeDataInEasyStorageClass(source->p_payload);
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmElfNoteEntryStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgUnsignedCharList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmElfNoteEntryStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgUnsignedCharList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmElfNoteEntryStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgUnsignedCharList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmElfNoteEntryStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgUnsignedCharList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 51456 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmElfNoteEntryListStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 51469 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmElfNoteEntryListStorageClass::pickOutIRNodeData ( SgAsmElfNoteEntryList* pointer ) 
   { 
     SgAsmElfNoteEntryList* source = (SgAsmElfNoteEntryList*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgAsmElfNoteEntryPtrList::iterator i_entries = source->p_entries.begin() ; 
     unsigned int tempListCountentries = 0; 
     SgAsmElfNoteEntryPtrList::value_type *  tempListentries = new SgAsmElfNoteEntryPtrList::value_type[ source->p_entries.size() ]; 
     for ( ; i_entries != source->p_entries.end(); ++i_entries ) 
        {
          tempListentries[tempListCountentries] = *i_entries;
          tempListCountentries++; 
          (*i_entries) = (SgAsmElfNoteEntryPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_entries ) );
        }
     storageOf_entries.storeDataInEasyStorageClass(source->p_entries);
     tempListCountentries = 0; 
     i_entries = source->p_entries.begin() ; 
     for ( ; i_entries != source->p_entries.end(); ++i_entries ) 
        {
          *i_entries = tempListentries[tempListCountentries] ;
          tempListCountentries++; 
        }
      delete [] tempListentries; 
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmElfNoteEntryListStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgAsmElfNoteEntryPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmElfNoteEntryListStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgAsmElfNoteEntryPtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmElfNoteEntryListStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgAsmElfNoteEntryPtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmElfNoteEntryListStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgAsmElfNoteEntryPtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 51545 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmElfSymverEntryStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 51558 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmElfSymverEntryStorageClass::pickOutIRNodeData ( SgAsmElfSymverEntry* pointer ) 
   { 
     SgAsmElfSymverEntry* source = (SgAsmElfSymverEntry*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_value =  source->p_value ;
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmElfSymverEntryStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmElfSymverEntryStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmElfSymverEntryStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmElfSymverEntryStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 51613 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmElfSymverEntryListStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 51626 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmElfSymverEntryListStorageClass::pickOutIRNodeData ( SgAsmElfSymverEntryList* pointer ) 
   { 
     SgAsmElfSymverEntryList* source = (SgAsmElfSymverEntryList*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgAsmElfSymverEntryPtrList::iterator i_entries = source->p_entries.begin() ; 
     unsigned int tempListCountentries = 0; 
     SgAsmElfSymverEntryPtrList::value_type *  tempListentries = new SgAsmElfSymverEntryPtrList::value_type[ source->p_entries.size() ]; 
     for ( ; i_entries != source->p_entries.end(); ++i_entries ) 
        {
          tempListentries[tempListCountentries] = *i_entries;
          tempListCountentries++; 
          (*i_entries) = (SgAsmElfSymverEntryPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_entries ) );
        }
     storageOf_entries.storeDataInEasyStorageClass(source->p_entries);
     tempListCountentries = 0; 
     i_entries = source->p_entries.begin() ; 
     for ( ; i_entries != source->p_entries.end(); ++i_entries ) 
        {
          *i_entries = tempListentries[tempListCountentries] ;
          tempListCountentries++; 
        }
      delete [] tempListentries; 
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmElfSymverEntryListStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgAsmElfSymverEntryPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmElfSymverEntryListStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgAsmElfSymverEntryPtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmElfSymverEntryListStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgAsmElfSymverEntryPtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmElfSymverEntryListStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgAsmElfSymverEntryPtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 51702 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmElfSymverDefinedEntryStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 51715 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmElfSymverDefinedEntryStorageClass::pickOutIRNodeData ( SgAsmElfSymverDefinedEntry* pointer ) 
   { 
     SgAsmElfSymverDefinedEntry* source = (SgAsmElfSymverDefinedEntry*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_version =  source->p_version ;
     storageOf_flags =  source->p_flags ;
     storageOf_index =  source->p_index ;
     storageOf_hash =  source->p_hash ;
     storageOf_entries = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_entries );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmElfSymverDefinedEntryStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmElfSymverDefinedEntryStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmElfSymverDefinedEntryStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmElfSymverDefinedEntryStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 51774 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmElfSymverDefinedEntryListStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 51787 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmElfSymverDefinedEntryListStorageClass::pickOutIRNodeData ( SgAsmElfSymverDefinedEntryList* pointer ) 
   { 
     SgAsmElfSymverDefinedEntryList* source = (SgAsmElfSymverDefinedEntryList*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgAsmElfSymverDefinedEntryPtrList::iterator i_entries = source->p_entries.begin() ; 
     unsigned int tempListCountentries = 0; 
     SgAsmElfSymverDefinedEntryPtrList::value_type *  tempListentries = new SgAsmElfSymverDefinedEntryPtrList::value_type[ source->p_entries.size() ]; 
     for ( ; i_entries != source->p_entries.end(); ++i_entries ) 
        {
          tempListentries[tempListCountentries] = *i_entries;
          tempListCountentries++; 
          (*i_entries) = (SgAsmElfSymverDefinedEntryPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_entries ) );
        }
     storageOf_entries.storeDataInEasyStorageClass(source->p_entries);
     tempListCountentries = 0; 
     i_entries = source->p_entries.begin() ; 
     for ( ; i_entries != source->p_entries.end(); ++i_entries ) 
        {
          *i_entries = tempListentries[tempListCountentries] ;
          tempListCountentries++; 
        }
      delete [] tempListentries; 
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmElfSymverDefinedEntryListStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgAsmElfSymverDefinedEntryPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmElfSymverDefinedEntryListStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgAsmElfSymverDefinedEntryPtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmElfSymverDefinedEntryListStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgAsmElfSymverDefinedEntryPtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmElfSymverDefinedEntryListStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgAsmElfSymverDefinedEntryPtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 51863 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmElfSymverDefinedAuxStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 51876 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmElfSymverDefinedAuxStorageClass::pickOutIRNodeData ( SgAsmElfSymverDefinedAux* pointer ) 
   { 
     SgAsmElfSymverDefinedAux* source = (SgAsmElfSymverDefinedAux*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmElfSymverDefinedAuxStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmElfSymverDefinedAuxStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmElfSymverDefinedAuxStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmElfSymverDefinedAuxStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 51931 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmElfSymverDefinedAuxListStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 51944 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmElfSymverDefinedAuxListStorageClass::pickOutIRNodeData ( SgAsmElfSymverDefinedAuxList* pointer ) 
   { 
     SgAsmElfSymverDefinedAuxList* source = (SgAsmElfSymverDefinedAuxList*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgAsmElfSymverDefinedAuxPtrList::iterator i_entries = source->p_entries.begin() ; 
     unsigned int tempListCountentries = 0; 
     SgAsmElfSymverDefinedAuxPtrList::value_type *  tempListentries = new SgAsmElfSymverDefinedAuxPtrList::value_type[ source->p_entries.size() ]; 
     for ( ; i_entries != source->p_entries.end(); ++i_entries ) 
        {
          tempListentries[tempListCountentries] = *i_entries;
          tempListCountentries++; 
          (*i_entries) = (SgAsmElfSymverDefinedAuxPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_entries ) );
        }
     storageOf_entries.storeDataInEasyStorageClass(source->p_entries);
     tempListCountentries = 0; 
     i_entries = source->p_entries.begin() ; 
     for ( ; i_entries != source->p_entries.end(); ++i_entries ) 
        {
          *i_entries = tempListentries[tempListCountentries] ;
          tempListCountentries++; 
        }
      delete [] tempListentries; 
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmElfSymverDefinedAuxListStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgAsmElfSymverDefinedAuxPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmElfSymverDefinedAuxListStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgAsmElfSymverDefinedAuxPtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmElfSymverDefinedAuxListStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgAsmElfSymverDefinedAuxPtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmElfSymverDefinedAuxListStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgAsmElfSymverDefinedAuxPtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 52020 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmElfSymverNeededEntryStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 52033 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmElfSymverNeededEntryStorageClass::pickOutIRNodeData ( SgAsmElfSymverNeededEntry* pointer ) 
   { 
     SgAsmElfSymverNeededEntry* source = (SgAsmElfSymverNeededEntry*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_version =  source->p_version ;
     storageOf_file_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_file_name );
     storageOf_entries = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_entries );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmElfSymverNeededEntryStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmElfSymverNeededEntryStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmElfSymverNeededEntryStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmElfSymverNeededEntryStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 52090 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmElfSymverNeededEntryListStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 52103 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmElfSymverNeededEntryListStorageClass::pickOutIRNodeData ( SgAsmElfSymverNeededEntryList* pointer ) 
   { 
     SgAsmElfSymverNeededEntryList* source = (SgAsmElfSymverNeededEntryList*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgAsmElfSymverNeededEntryPtrList::iterator i_entries = source->p_entries.begin() ; 
     unsigned int tempListCountentries = 0; 
     SgAsmElfSymverNeededEntryPtrList::value_type *  tempListentries = new SgAsmElfSymverNeededEntryPtrList::value_type[ source->p_entries.size() ]; 
     for ( ; i_entries != source->p_entries.end(); ++i_entries ) 
        {
          tempListentries[tempListCountentries] = *i_entries;
          tempListCountentries++; 
          (*i_entries) = (SgAsmElfSymverNeededEntryPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_entries ) );
        }
     storageOf_entries.storeDataInEasyStorageClass(source->p_entries);
     tempListCountentries = 0; 
     i_entries = source->p_entries.begin() ; 
     for ( ; i_entries != source->p_entries.end(); ++i_entries ) 
        {
          *i_entries = tempListentries[tempListCountentries] ;
          tempListCountentries++; 
        }
      delete [] tempListentries; 
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmElfSymverNeededEntryListStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgAsmElfSymverNeededEntryPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmElfSymverNeededEntryListStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgAsmElfSymverNeededEntryPtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmElfSymverNeededEntryListStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgAsmElfSymverNeededEntryPtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmElfSymverNeededEntryListStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgAsmElfSymverNeededEntryPtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 52179 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmElfSymverNeededAuxStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 52192 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmElfSymverNeededAuxStorageClass::pickOutIRNodeData ( SgAsmElfSymverNeededAux* pointer ) 
   { 
     SgAsmElfSymverNeededAux* source = (SgAsmElfSymverNeededAux*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_hash =  source->p_hash ;
     storageOf_flags =  source->p_flags ;
     storageOf_other =  source->p_other ;
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmElfSymverNeededAuxStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmElfSymverNeededAuxStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmElfSymverNeededAuxStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmElfSymverNeededAuxStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 52250 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmElfSymverNeededAuxListStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 52263 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmElfSymverNeededAuxListStorageClass::pickOutIRNodeData ( SgAsmElfSymverNeededAuxList* pointer ) 
   { 
     SgAsmElfSymverNeededAuxList* source = (SgAsmElfSymverNeededAuxList*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgAsmElfSymverNeededAuxPtrList::iterator i_entries = source->p_entries.begin() ; 
     unsigned int tempListCountentries = 0; 
     SgAsmElfSymverNeededAuxPtrList::value_type *  tempListentries = new SgAsmElfSymverNeededAuxPtrList::value_type[ source->p_entries.size() ]; 
     for ( ; i_entries != source->p_entries.end(); ++i_entries ) 
        {
          tempListentries[tempListCountentries] = *i_entries;
          tempListCountentries++; 
          (*i_entries) = (SgAsmElfSymverNeededAuxPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_entries ) );
        }
     storageOf_entries.storeDataInEasyStorageClass(source->p_entries);
     tempListCountentries = 0; 
     i_entries = source->p_entries.begin() ; 
     for ( ; i_entries != source->p_entries.end(); ++i_entries ) 
        {
          *i_entries = tempListentries[tempListCountentries] ;
          tempListCountentries++; 
        }
      delete [] tempListentries; 
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmElfSymverNeededAuxListStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgAsmElfSymverNeededAuxPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmElfSymverNeededAuxListStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgAsmElfSymverNeededAuxPtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmElfSymverNeededAuxListStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgAsmElfSymverNeededAuxPtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmElfSymverNeededAuxListStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgAsmElfSymverNeededAuxPtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 52339 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmPEImportDirectoryStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 52352 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmPEImportDirectoryStorageClass::pickOutIRNodeData ( SgAsmPEImportDirectory* pointer ) 
   { 
     SgAsmPEImportDirectory* source = (SgAsmPEImportDirectory*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_dll_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_dll_name );
     storageOf_dll_name_rva =  source->p_dll_name_rva ;
     storageOf_dll_name_nalloc =  source->p_dll_name_nalloc ;
     storageOf_time =  source->p_time ;
     storageOf_forwarder_chain =  source->p_forwarder_chain ;
     storageOf_ilt_rva =  source->p_ilt_rva ;
     storageOf_ilt_nalloc =  source->p_ilt_nalloc ;
     storageOf_iat_rva =  source->p_iat_rva ;
     storageOf_iat_nalloc =  source->p_iat_nalloc ;
     storageOf_imports = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_imports );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmPEImportDirectoryStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmPEImportDirectoryStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmPEImportDirectoryStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmPEImportDirectoryStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 52416 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmPESectionTableEntryStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 52429 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmPESectionTableEntryStorageClass::pickOutIRNodeData ( SgAsmPESectionTableEntry* pointer ) 
   { 
     SgAsmPESectionTableEntry* source = (SgAsmPESectionTableEntry*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_virtual_size =  source->p_virtual_size ;
     storageOf_rva =  source->p_rva ;
     storageOf_physical_size =  source->p_physical_size ;
     storageOf_physical_offset =  source->p_physical_offset ;
     storageOf_coff_line_nums =  source->p_coff_line_nums ;
     storageOf_n_relocs =  source->p_n_relocs ;
     storageOf_n_coff_line_nums =  source->p_n_coff_line_nums ;
     storageOf_flags =  source->p_flags ;
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmPESectionTableEntryStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmPESectionTableEntryStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmPESectionTableEntryStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmPESectionTableEntryStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 52496 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmPEExportDirectoryStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 52509 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmPEExportDirectoryStorageClass::pickOutIRNodeData ( SgAsmPEExportDirectory* pointer ) 
   { 
     SgAsmPEExportDirectory* source = (SgAsmPEExportDirectory*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_res1 =  source->p_res1 ;
     storageOf_timestamp =  source->p_timestamp ;
     storageOf_vmajor =  source->p_vmajor ;
     storageOf_vminor =  source->p_vminor ;
     storageOf_name_rva =  source->p_name_rva ;
     storageOf_ord_base =  source->p_ord_base ;
     storageOf_expaddr_n =  source->p_expaddr_n ;
     storageOf_nameptr_n =  source->p_nameptr_n ;
     storageOf_expaddr_rva =  source->p_expaddr_rva ;
     storageOf_nameptr_rva =  source->p_nameptr_rva ;
     storageOf_ordinals_rva =  source->p_ordinals_rva ;
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmPEExportDirectoryStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmPEExportDirectoryStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmPEExportDirectoryStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmPEExportDirectoryStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 52575 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmPERVASizePairStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 52588 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmPERVASizePairStorageClass::pickOutIRNodeData ( SgAsmPERVASizePair* pointer ) 
   { 
     SgAsmPERVASizePair* source = (SgAsmPERVASizePair*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_e_rva =  source->p_e_rva ;
     storageOf_e_size =  source->p_e_size ;
     storageOf_section = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_section );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmPERVASizePairStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmPERVASizePairStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmPERVASizePairStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmPERVASizePairStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 52645 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmCoffSymbolListStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 52658 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmCoffSymbolListStorageClass::pickOutIRNodeData ( SgAsmCoffSymbolList* pointer ) 
   { 
     SgAsmCoffSymbolList* source = (SgAsmCoffSymbolList*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgAsmCoffSymbolPtrList::iterator i_symbols = source->p_symbols.begin() ; 
     unsigned int tempListCountsymbols = 0; 
     SgAsmCoffSymbolPtrList::value_type *  tempListsymbols = new SgAsmCoffSymbolPtrList::value_type[ source->p_symbols.size() ]; 
     for ( ; i_symbols != source->p_symbols.end(); ++i_symbols ) 
        {
          tempListsymbols[tempListCountsymbols] = *i_symbols;
          tempListCountsymbols++; 
          (*i_symbols) = (SgAsmCoffSymbolPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_symbols ) );
        }
     storageOf_symbols.storeDataInEasyStorageClass(source->p_symbols);
     tempListCountsymbols = 0; 
     i_symbols = source->p_symbols.begin() ; 
     for ( ; i_symbols != source->p_symbols.end(); ++i_symbols ) 
        {
          *i_symbols = tempListsymbols[tempListCountsymbols] ;
          tempListCountsymbols++; 
        }
      delete [] tempListsymbols; 
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmCoffSymbolListStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgAsmCoffSymbolPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmCoffSymbolListStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgAsmCoffSymbolPtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmCoffSymbolListStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgAsmCoffSymbolPtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmCoffSymbolListStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgAsmCoffSymbolPtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 52734 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmPERVASizePairListStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 52747 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmPERVASizePairListStorageClass::pickOutIRNodeData ( SgAsmPERVASizePairList* pointer ) 
   { 
     SgAsmPERVASizePairList* source = (SgAsmPERVASizePairList*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgAsmPERVASizePairPtrList::iterator i_pairs = source->p_pairs.begin() ; 
     unsigned int tempListCountpairs = 0; 
     SgAsmPERVASizePairPtrList::value_type *  tempListpairs = new SgAsmPERVASizePairPtrList::value_type[ source->p_pairs.size() ]; 
     for ( ; i_pairs != source->p_pairs.end(); ++i_pairs ) 
        {
          tempListpairs[tempListCountpairs] = *i_pairs;
          tempListCountpairs++; 
          (*i_pairs) = (SgAsmPERVASizePairPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_pairs ) );
        }
     storageOf_pairs.storeDataInEasyStorageClass(source->p_pairs);
     tempListCountpairs = 0; 
     i_pairs = source->p_pairs.begin() ; 
     for ( ; i_pairs != source->p_pairs.end(); ++i_pairs ) 
        {
          *i_pairs = tempListpairs[tempListCountpairs] ;
          tempListCountpairs++; 
        }
      delete [] tempListpairs; 
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmPERVASizePairListStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgAsmPERVASizePairPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmPERVASizePairListStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgAsmPERVASizePairPtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmPERVASizePairListStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgAsmPERVASizePairPtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmPERVASizePairListStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgAsmPERVASizePairPtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 52823 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmElfEHFrameEntryCIStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 52836 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmElfEHFrameEntryCIStorageClass::pickOutIRNodeData ( SgAsmElfEHFrameEntryCI* pointer ) 
   { 
     SgAsmElfEHFrameEntryCI* source = (SgAsmElfEHFrameEntryCI*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_version =  source->p_version ;
     storageOf_augmentation_string.storeDataInEasyStorageClass(source->p_augmentation_string);
     storageOf_code_alignment_factor =  source->p_code_alignment_factor ;
     storageOf_data_alignment_factor =  source->p_data_alignment_factor ;
     storageOf_augmentation_data_length =  source->p_augmentation_data_length ;
     storageOf_lsda_encoding =  source->p_lsda_encoding ;
     storageOf_prh_encoding =  source->p_prh_encoding ;
     storageOf_prh_arg =  source->p_prh_arg ;
     storageOf_prh_addr =  source->p_prh_addr ;
     storageOf_addr_encoding =  source->p_addr_encoding ;
     storageOf_sig_frame =  source->p_sig_frame ;
     storageOf_instructions.storeDataInEasyStorageClass(source->p_instructions);
     storageOf_fd_entries = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_fd_entries );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmElfEHFrameEntryCIStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgUnsignedCharList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmElfEHFrameEntryCIStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < SgUnsignedCharList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmElfEHFrameEntryCIStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < SgUnsignedCharList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmElfEHFrameEntryCIStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < SgUnsignedCharList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 52911 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmPEImportDirectoryListStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 52924 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmPEImportDirectoryListStorageClass::pickOutIRNodeData ( SgAsmPEImportDirectoryList* pointer ) 
   { 
     SgAsmPEImportDirectoryList* source = (SgAsmPEImportDirectoryList*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgAsmPEImportDirectoryPtrList::iterator i_vector = source->p_vector.begin() ; 
     unsigned int tempListCountvector = 0; 
     SgAsmPEImportDirectoryPtrList::value_type *  tempListvector = new SgAsmPEImportDirectoryPtrList::value_type[ source->p_vector.size() ]; 
     for ( ; i_vector != source->p_vector.end(); ++i_vector ) 
        {
          tempListvector[tempListCountvector] = *i_vector;
          tempListCountvector++; 
          (*i_vector) = (SgAsmPEImportDirectoryPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_vector ) );
        }
     storageOf_vector.storeDataInEasyStorageClass(source->p_vector);
     tempListCountvector = 0; 
     i_vector = source->p_vector.begin() ; 
     for ( ; i_vector != source->p_vector.end(); ++i_vector ) 
        {
          *i_vector = tempListvector[tempListCountvector] ;
          tempListCountvector++; 
        }
      delete [] tempListvector; 
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmPEImportDirectoryListStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgAsmPEImportDirectoryPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmPEImportDirectoryListStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgAsmPEImportDirectoryPtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmPEImportDirectoryListStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgAsmPEImportDirectoryPtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmPEImportDirectoryListStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgAsmPEImportDirectoryPtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 53000 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmNEEntryPointStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 53013 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmNEEntryPointStorageClass::pickOutIRNodeData ( SgAsmNEEntryPoint* pointer ) 
   { 
     SgAsmNEEntryPoint* source = (SgAsmNEEntryPoint*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_flags =  source->p_flags ;
     storageOf_int3f =  source->p_int3f ;
     storageOf_section_idx =  source->p_section_idx ;
     storageOf_section_offset =  source->p_section_offset ;
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmNEEntryPointStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmNEEntryPointStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmNEEntryPointStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmNEEntryPointStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 53071 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmNERelocEntryStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 53084 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmNERelocEntryStorageClass::pickOutIRNodeData ( SgAsmNERelocEntry* pointer ) 
   { 
     SgAsmNERelocEntry* source = (SgAsmNERelocEntry*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_src_type =  source->p_src_type ;
     storageOf_modifier =  source->p_modifier ;
     storageOf_tgt_type =  source->p_tgt_type ;
     storageOf_flags =  source->p_flags ;
     storageOf_src_offset =  source->p_src_offset ;
     storageOf_iref =  source->p_iref ;
     storageOf_iord =  source->p_iord ;
     storageOf_iname =  source->p_iname ;
     storageOf_osfixup =  source->p_osfixup ;
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmNERelocEntryStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmNERelocEntryStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmNERelocEntryStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmNERelocEntryStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 53147 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmNESectionTableEntryStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 53160 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmNESectionTableEntryStorageClass::pickOutIRNodeData ( SgAsmNESectionTableEntry* pointer ) 
   { 
     SgAsmNESectionTableEntry* source = (SgAsmNESectionTableEntry*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_flags =  source->p_flags ;
     storageOf_sector =  source->p_sector ;
     storageOf_physical_size =  source->p_physical_size ;
     storageOf_virtual_size =  source->p_virtual_size ;
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmNESectionTableEntryStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmNESectionTableEntryStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmNESectionTableEntryStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmNESectionTableEntryStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 53218 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmElfEHFrameEntryCIListStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 53231 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmElfEHFrameEntryCIListStorageClass::pickOutIRNodeData ( SgAsmElfEHFrameEntryCIList* pointer ) 
   { 
     SgAsmElfEHFrameEntryCIList* source = (SgAsmElfEHFrameEntryCIList*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgAsmElfEHFrameEntryCIPtrList::iterator i_entries = source->p_entries.begin() ; 
     unsigned int tempListCountentries = 0; 
     SgAsmElfEHFrameEntryCIPtrList::value_type *  tempListentries = new SgAsmElfEHFrameEntryCIPtrList::value_type[ source->p_entries.size() ]; 
     for ( ; i_entries != source->p_entries.end(); ++i_entries ) 
        {
          tempListentries[tempListCountentries] = *i_entries;
          tempListCountentries++; 
          (*i_entries) = (SgAsmElfEHFrameEntryCIPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_entries ) );
        }
     storageOf_entries.storeDataInEasyStorageClass(source->p_entries);
     tempListCountentries = 0; 
     i_entries = source->p_entries.begin() ; 
     for ( ; i_entries != source->p_entries.end(); ++i_entries ) 
        {
          *i_entries = tempListentries[tempListCountentries] ;
          tempListCountentries++; 
        }
      delete [] tempListentries; 
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmElfEHFrameEntryCIListStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgAsmElfEHFrameEntryCIPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmElfEHFrameEntryCIListStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgAsmElfEHFrameEntryCIPtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmElfEHFrameEntryCIListStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgAsmElfEHFrameEntryCIPtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmElfEHFrameEntryCIListStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgAsmElfEHFrameEntryCIPtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 53307 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmLEPageTableEntryStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 53320 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmLEPageTableEntryStorageClass::pickOutIRNodeData ( SgAsmLEPageTableEntry* pointer ) 
   { 
     SgAsmLEPageTableEntry* source = (SgAsmLEPageTableEntry*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_pageno =  source->p_pageno ;
     storageOf_flags =  source->p_flags ;
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmLEPageTableEntryStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmLEPageTableEntryStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmLEPageTableEntryStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmLEPageTableEntryStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 53376 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmLEEntryPointStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 53389 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmLEEntryPointStorageClass::pickOutIRNodeData ( SgAsmLEEntryPoint* pointer ) 
   { 
     SgAsmLEEntryPoint* source = (SgAsmLEEntryPoint*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgAsmLEEntryPointPtrList::iterator i_entries = source->p_entries.begin() ; 
     unsigned int tempListCountentries = 0; 
     SgAsmLEEntryPointPtrList::value_type *  tempListentries = new SgAsmLEEntryPointPtrList::value_type[ source->p_entries.size() ]; 
     for ( ; i_entries != source->p_entries.end(); ++i_entries ) 
        {
          tempListentries[tempListCountentries] = *i_entries;
          tempListCountentries++; 
          (*i_entries) = (SgAsmLEEntryPointPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_entries ) );
        }
     storageOf_entries.storeDataInEasyStorageClass(source->p_entries);
     tempListCountentries = 0; 
     i_entries = source->p_entries.begin() ; 
     for ( ; i_entries != source->p_entries.end(); ++i_entries ) 
        {
          *i_entries = tempListentries[tempListCountentries] ;
          tempListCountentries++; 
        }
      delete [] tempListentries; 
     storageOf_flags =  source->p_flags ;
     storageOf_objnum =  source->p_objnum ;
     storageOf_entry_type =  source->p_entry_type ;
     storageOf_res1 =  source->p_res1 ;
     storageOf_entry_offset =  source->p_entry_offset ;
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmLEEntryPointStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgAsmLEEntryPointPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmLEEntryPointStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgAsmLEEntryPointPtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmLEEntryPointStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgAsmLEEntryPointPtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmLEEntryPointStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgAsmLEEntryPointPtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 53470 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmLESectionTableEntryStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 53483 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmLESectionTableEntryStorageClass::pickOutIRNodeData ( SgAsmLESectionTableEntry* pointer ) 
   { 
     SgAsmLESectionTableEntry* source = (SgAsmLESectionTableEntry*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_flags =  source->p_flags ;
     storageOf_pagemap_index =  source->p_pagemap_index ;
     storageOf_pagemap_nentries =  source->p_pagemap_nentries ;
     storageOf_res1 =  source->p_res1 ;
     storageOf_mapped_size =  source->p_mapped_size ;
     storageOf_base_addr =  source->p_base_addr ;
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmLESectionTableEntryStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmLESectionTableEntryStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmLESectionTableEntryStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmLESectionTableEntryStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 53543 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmElfEHFrameEntryFDListStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 53556 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmElfEHFrameEntryFDListStorageClass::pickOutIRNodeData ( SgAsmElfEHFrameEntryFDList* pointer ) 
   { 
     SgAsmElfEHFrameEntryFDList* source = (SgAsmElfEHFrameEntryFDList*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgAsmElfEHFrameEntryFDPtrList::iterator i_entries = source->p_entries.begin() ; 
     unsigned int tempListCountentries = 0; 
     SgAsmElfEHFrameEntryFDPtrList::value_type *  tempListentries = new SgAsmElfEHFrameEntryFDPtrList::value_type[ source->p_entries.size() ]; 
     for ( ; i_entries != source->p_entries.end(); ++i_entries ) 
        {
          tempListentries[tempListCountentries] = *i_entries;
          tempListCountentries++; 
          (*i_entries) = (SgAsmElfEHFrameEntryFDPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_entries ) );
        }
     storageOf_entries.storeDataInEasyStorageClass(source->p_entries);
     tempListCountentries = 0; 
     i_entries = source->p_entries.begin() ; 
     for ( ; i_entries != source->p_entries.end(); ++i_entries ) 
        {
          *i_entries = tempListentries[tempListCountentries] ;
          tempListCountentries++; 
        }
      delete [] tempListentries; 
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmElfEHFrameEntryFDListStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgAsmElfEHFrameEntryFDPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmElfEHFrameEntryFDListStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgAsmElfEHFrameEntryFDPtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmElfEHFrameEntryFDListStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgAsmElfEHFrameEntryFDPtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmElfEHFrameEntryFDListStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgAsmElfEHFrameEntryFDPtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 53632 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfInformationStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 53645 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfInformationStorageClass::pickOutIRNodeData ( SgAsmDwarfInformation* pointer ) 
   { 
     SgAsmDwarfInformation* source = (SgAsmDwarfInformation*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDwarfInformationStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfInformationStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfInformationStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDwarfInformationStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 53699 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfMacroStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 53712 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfMacroStorageClass::pickOutIRNodeData ( SgAsmDwarfMacro* pointer ) 
   { 
     SgAsmDwarfMacro* source = (SgAsmDwarfMacro*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_macro_string.storeDataInEasyStorageClass(source->p_macro_string);
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDwarfMacroStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfMacroStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfMacroStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDwarfMacroStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 53771 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfMacroListStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 53784 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfMacroListStorageClass::pickOutIRNodeData ( SgAsmDwarfMacroList* pointer ) 
   { 
     SgAsmDwarfMacroList* source = (SgAsmDwarfMacroList*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgAsmDwarfMacroPtrList::iterator i_macro_list = source->p_macro_list.begin() ; 
     unsigned int tempListCountmacro_list = 0; 
     SgAsmDwarfMacroPtrList::value_type *  tempListmacro_list = new SgAsmDwarfMacroPtrList::value_type[ source->p_macro_list.size() ]; 
     for ( ; i_macro_list != source->p_macro_list.end(); ++i_macro_list ) 
        {
          tempListmacro_list[tempListCountmacro_list] = *i_macro_list;
          tempListCountmacro_list++; 
          (*i_macro_list) = (SgAsmDwarfMacroPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_macro_list ) );
        }
     storageOf_macro_list.storeDataInEasyStorageClass(source->p_macro_list);
     tempListCountmacro_list = 0; 
     i_macro_list = source->p_macro_list.begin() ; 
     for ( ; i_macro_list != source->p_macro_list.end(); ++i_macro_list ) 
        {
          *i_macro_list = tempListmacro_list[tempListCountmacro_list] ;
          tempListCountmacro_list++; 
        }
      delete [] tempListmacro_list; 
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDwarfMacroListStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgAsmDwarfMacroPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfMacroListStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgAsmDwarfMacroPtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfMacroListStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgAsmDwarfMacroPtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDwarfMacroListStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgAsmDwarfMacroPtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 53860 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfLineStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 53873 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfLineStorageClass::pickOutIRNodeData ( SgAsmDwarfLine* pointer ) 
   { 
     SgAsmDwarfLine* source = (SgAsmDwarfLine*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_address =  source->p_address ;
     storageOf_file_id =  source->p_file_id ;
     storageOf_line =  source->p_line ;
     storageOf_column =  source->p_column ;
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDwarfLineStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfLineStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfLineStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDwarfLineStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 53931 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfLineListStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 53944 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfLineListStorageClass::pickOutIRNodeData ( SgAsmDwarfLineList* pointer ) 
   { 
     SgAsmDwarfLineList* source = (SgAsmDwarfLineList*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgAsmDwarfLinePtrList::iterator i_line_list = source->p_line_list.begin() ; 
     unsigned int tempListCountline_list = 0; 
     SgAsmDwarfLinePtrList::value_type *  tempListline_list = new SgAsmDwarfLinePtrList::value_type[ source->p_line_list.size() ]; 
     for ( ; i_line_list != source->p_line_list.end(); ++i_line_list ) 
        {
          tempListline_list[tempListCountline_list] = *i_line_list;
          tempListCountline_list++; 
          (*i_line_list) = (SgAsmDwarfLinePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_line_list ) );
        }
     storageOf_line_list.storeDataInEasyStorageClass(source->p_line_list);
     tempListCountline_list = 0; 
     i_line_list = source->p_line_list.begin() ; 
     for ( ; i_line_list != source->p_line_list.end(); ++i_line_list ) 
        {
          *i_line_list = tempListline_list[tempListCountline_list] ;
          tempListCountline_list++; 
        }
      delete [] tempListline_list; 
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDwarfLineListStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgAsmDwarfLinePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfLineListStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgAsmDwarfLinePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfLineListStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgAsmDwarfLinePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDwarfLineListStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgAsmDwarfLinePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 54020 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfCompilationUnitListStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 54033 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfCompilationUnitListStorageClass::pickOutIRNodeData ( SgAsmDwarfCompilationUnitList* pointer ) 
   { 
     SgAsmDwarfCompilationUnitList* source = (SgAsmDwarfCompilationUnitList*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgAsmDwarfCompilationUnitPtrList::iterator i_cu_list = source->p_cu_list.begin() ; 
     unsigned int tempListCountcu_list = 0; 
     SgAsmDwarfCompilationUnitPtrList::value_type *  tempListcu_list = new SgAsmDwarfCompilationUnitPtrList::value_type[ source->p_cu_list.size() ]; 
     for ( ; i_cu_list != source->p_cu_list.end(); ++i_cu_list ) 
        {
          tempListcu_list[tempListCountcu_list] = *i_cu_list;
          tempListCountcu_list++; 
          (*i_cu_list) = (SgAsmDwarfCompilationUnitPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_cu_list ) );
        }
     storageOf_cu_list.storeDataInEasyStorageClass(source->p_cu_list);
     tempListCountcu_list = 0; 
     i_cu_list = source->p_cu_list.begin() ; 
     for ( ; i_cu_list != source->p_cu_list.end(); ++i_cu_list ) 
        {
          *i_cu_list = tempListcu_list[tempListCountcu_list] ;
          tempListCountcu_list++; 
        }
      delete [] tempListcu_list; 
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDwarfCompilationUnitListStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgAsmDwarfCompilationUnitPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfCompilationUnitListStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgAsmDwarfCompilationUnitPtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfCompilationUnitListStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgAsmDwarfCompilationUnitPtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDwarfCompilationUnitListStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgAsmDwarfCompilationUnitPtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 54109 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfConstructStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 54122 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfConstructStorageClass::pickOutIRNodeData ( SgAsmDwarfConstruct* pointer ) 
   { 
     SgAsmDwarfConstruct* source = (SgAsmDwarfConstruct*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDwarfConstructStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfConstructStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfConstructStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDwarfConstructStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 54185 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfArrayTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 54198 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfArrayTypeStorageClass::pickOutIRNodeData ( SgAsmDwarfArrayType* pointer ) 
   { 
     SgAsmDwarfArrayType* source = (SgAsmDwarfArrayType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDwarfArrayTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfArrayTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfArrayTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDwarfArrayTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 54262 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfClassTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 54275 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfClassTypeStorageClass::pickOutIRNodeData ( SgAsmDwarfClassType* pointer ) 
   { 
     SgAsmDwarfClassType* source = (SgAsmDwarfClassType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDwarfClassTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfClassTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfClassTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDwarfClassTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 54339 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfEntryPointStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 54352 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfEntryPointStorageClass::pickOutIRNodeData ( SgAsmDwarfEntryPoint* pointer ) 
   { 
     SgAsmDwarfEntryPoint* source = (SgAsmDwarfEntryPoint*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDwarfEntryPointStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfEntryPointStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfEntryPointStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDwarfEntryPointStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 54415 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfEnumerationTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 54428 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfEnumerationTypeStorageClass::pickOutIRNodeData ( SgAsmDwarfEnumerationType* pointer ) 
   { 
     SgAsmDwarfEnumerationType* source = (SgAsmDwarfEnumerationType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDwarfEnumerationTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfEnumerationTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfEnumerationTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDwarfEnumerationTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 54492 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfFormalParameterStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 54505 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfFormalParameterStorageClass::pickOutIRNodeData ( SgAsmDwarfFormalParameter* pointer ) 
   { 
     SgAsmDwarfFormalParameter* source = (SgAsmDwarfFormalParameter*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDwarfFormalParameterStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfFormalParameterStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfFormalParameterStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDwarfFormalParameterStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 54568 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfImportedDeclarationStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 54581 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfImportedDeclarationStorageClass::pickOutIRNodeData ( SgAsmDwarfImportedDeclaration* pointer ) 
   { 
     SgAsmDwarfImportedDeclaration* source = (SgAsmDwarfImportedDeclaration*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDwarfImportedDeclarationStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfImportedDeclarationStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfImportedDeclarationStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDwarfImportedDeclarationStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 54644 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfLabelStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 54657 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfLabelStorageClass::pickOutIRNodeData ( SgAsmDwarfLabel* pointer ) 
   { 
     SgAsmDwarfLabel* source = (SgAsmDwarfLabel*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDwarfLabelStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfLabelStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfLabelStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDwarfLabelStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 54720 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfLexicalBlockStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 54733 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfLexicalBlockStorageClass::pickOutIRNodeData ( SgAsmDwarfLexicalBlock* pointer ) 
   { 
     SgAsmDwarfLexicalBlock* source = (SgAsmDwarfLexicalBlock*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDwarfLexicalBlockStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfLexicalBlockStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfLexicalBlockStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDwarfLexicalBlockStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 54797 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfMemberStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 54810 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfMemberStorageClass::pickOutIRNodeData ( SgAsmDwarfMember* pointer ) 
   { 
     SgAsmDwarfMember* source = (SgAsmDwarfMember*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDwarfMemberStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfMemberStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfMemberStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDwarfMemberStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 54873 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfPointerTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 54886 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfPointerTypeStorageClass::pickOutIRNodeData ( SgAsmDwarfPointerType* pointer ) 
   { 
     SgAsmDwarfPointerType* source = (SgAsmDwarfPointerType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDwarfPointerTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfPointerTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfPointerTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDwarfPointerTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 54949 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfReferenceTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 54962 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfReferenceTypeStorageClass::pickOutIRNodeData ( SgAsmDwarfReferenceType* pointer ) 
   { 
     SgAsmDwarfReferenceType* source = (SgAsmDwarfReferenceType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDwarfReferenceTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfReferenceTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfReferenceTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDwarfReferenceTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 55025 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfCompilationUnitStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 55038 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfCompilationUnitStorageClass::pickOutIRNodeData ( SgAsmDwarfCompilationUnit* pointer ) 
   { 
     SgAsmDwarfCompilationUnit* source = (SgAsmDwarfCompilationUnit*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_producer.storeDataInEasyStorageClass(source->p_producer);
     storageOf_language.storeDataInEasyStorageClass(source->p_language);
     storageOf_low_pc =  source->p_low_pc ;
     storageOf_hi_pc =  source->p_hi_pc ;
     storageOf_version_stamp =  source->p_version_stamp ;
     storageOf_abbrev_offset =  source->p_abbrev_offset ;
     storageOf_address_size =  source->p_address_size ;
     storageOf_offset_length =  source->p_offset_length ;
     storageOf_line_info = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_line_info );
     storageOf_language_constructs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_language_constructs );
     storageOf_macro_info = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_macro_info );
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDwarfCompilationUnitStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfCompilationUnitStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfCompilationUnitStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDwarfCompilationUnitStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 55112 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfStringTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 55125 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfStringTypeStorageClass::pickOutIRNodeData ( SgAsmDwarfStringType* pointer ) 
   { 
     SgAsmDwarfStringType* source = (SgAsmDwarfStringType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDwarfStringTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfStringTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfStringTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDwarfStringTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 55188 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfStructureTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 55201 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfStructureTypeStorageClass::pickOutIRNodeData ( SgAsmDwarfStructureType* pointer ) 
   { 
     SgAsmDwarfStructureType* source = (SgAsmDwarfStructureType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDwarfStructureTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfStructureTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfStructureTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDwarfStructureTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 55265 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfSubroutineTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 55278 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfSubroutineTypeStorageClass::pickOutIRNodeData ( SgAsmDwarfSubroutineType* pointer ) 
   { 
     SgAsmDwarfSubroutineType* source = (SgAsmDwarfSubroutineType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDwarfSubroutineTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfSubroutineTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfSubroutineTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDwarfSubroutineTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 55342 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfTypedefStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 55355 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfTypedefStorageClass::pickOutIRNodeData ( SgAsmDwarfTypedef* pointer ) 
   { 
     SgAsmDwarfTypedef* source = (SgAsmDwarfTypedef*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDwarfTypedefStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfTypedefStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfTypedefStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDwarfTypedefStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 55418 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfUnionTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 55431 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfUnionTypeStorageClass::pickOutIRNodeData ( SgAsmDwarfUnionType* pointer ) 
   { 
     SgAsmDwarfUnionType* source = (SgAsmDwarfUnionType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDwarfUnionTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfUnionTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfUnionTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDwarfUnionTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 55495 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfUnspecifiedParametersStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 55508 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfUnspecifiedParametersStorageClass::pickOutIRNodeData ( SgAsmDwarfUnspecifiedParameters* pointer ) 
   { 
     SgAsmDwarfUnspecifiedParameters* source = (SgAsmDwarfUnspecifiedParameters*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDwarfUnspecifiedParametersStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfUnspecifiedParametersStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfUnspecifiedParametersStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDwarfUnspecifiedParametersStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 55571 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfVariantStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 55584 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfVariantStorageClass::pickOutIRNodeData ( SgAsmDwarfVariant* pointer ) 
   { 
     SgAsmDwarfVariant* source = (SgAsmDwarfVariant*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDwarfVariantStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfVariantStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfVariantStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDwarfVariantStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 55647 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfCommonBlockStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 55660 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfCommonBlockStorageClass::pickOutIRNodeData ( SgAsmDwarfCommonBlock* pointer ) 
   { 
     SgAsmDwarfCommonBlock* source = (SgAsmDwarfCommonBlock*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDwarfCommonBlockStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfCommonBlockStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfCommonBlockStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDwarfCommonBlockStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 55724 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfCommonInclusionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 55737 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfCommonInclusionStorageClass::pickOutIRNodeData ( SgAsmDwarfCommonInclusion* pointer ) 
   { 
     SgAsmDwarfCommonInclusion* source = (SgAsmDwarfCommonInclusion*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDwarfCommonInclusionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfCommonInclusionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfCommonInclusionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDwarfCommonInclusionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 55800 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfInheritanceStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 55813 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfInheritanceStorageClass::pickOutIRNodeData ( SgAsmDwarfInheritance* pointer ) 
   { 
     SgAsmDwarfInheritance* source = (SgAsmDwarfInheritance*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDwarfInheritanceStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfInheritanceStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfInheritanceStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDwarfInheritanceStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 55876 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfInlinedSubroutineStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 55889 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfInlinedSubroutineStorageClass::pickOutIRNodeData ( SgAsmDwarfInlinedSubroutine* pointer ) 
   { 
     SgAsmDwarfInlinedSubroutine* source = (SgAsmDwarfInlinedSubroutine*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDwarfInlinedSubroutineStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfInlinedSubroutineStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfInlinedSubroutineStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDwarfInlinedSubroutineStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 55953 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfModuleStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 55966 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfModuleStorageClass::pickOutIRNodeData ( SgAsmDwarfModule* pointer ) 
   { 
     SgAsmDwarfModule* source = (SgAsmDwarfModule*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDwarfModuleStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfModuleStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfModuleStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDwarfModuleStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 56029 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfPtrToMemberTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 56042 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfPtrToMemberTypeStorageClass::pickOutIRNodeData ( SgAsmDwarfPtrToMemberType* pointer ) 
   { 
     SgAsmDwarfPtrToMemberType* source = (SgAsmDwarfPtrToMemberType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDwarfPtrToMemberTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfPtrToMemberTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfPtrToMemberTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDwarfPtrToMemberTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 56105 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfSetTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 56118 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfSetTypeStorageClass::pickOutIRNodeData ( SgAsmDwarfSetType* pointer ) 
   { 
     SgAsmDwarfSetType* source = (SgAsmDwarfSetType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDwarfSetTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfSetTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfSetTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDwarfSetTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 56181 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfSubrangeTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 56194 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfSubrangeTypeStorageClass::pickOutIRNodeData ( SgAsmDwarfSubrangeType* pointer ) 
   { 
     SgAsmDwarfSubrangeType* source = (SgAsmDwarfSubrangeType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDwarfSubrangeTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfSubrangeTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfSubrangeTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDwarfSubrangeTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 56257 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfWithStmtStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 56270 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfWithStmtStorageClass::pickOutIRNodeData ( SgAsmDwarfWithStmt* pointer ) 
   { 
     SgAsmDwarfWithStmt* source = (SgAsmDwarfWithStmt*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDwarfWithStmtStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfWithStmtStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfWithStmtStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDwarfWithStmtStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 56333 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfAccessDeclarationStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 56346 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfAccessDeclarationStorageClass::pickOutIRNodeData ( SgAsmDwarfAccessDeclaration* pointer ) 
   { 
     SgAsmDwarfAccessDeclaration* source = (SgAsmDwarfAccessDeclaration*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDwarfAccessDeclarationStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfAccessDeclarationStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfAccessDeclarationStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDwarfAccessDeclarationStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 56409 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfBaseTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 56422 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfBaseTypeStorageClass::pickOutIRNodeData ( SgAsmDwarfBaseType* pointer ) 
   { 
     SgAsmDwarfBaseType* source = (SgAsmDwarfBaseType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDwarfBaseTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfBaseTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfBaseTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDwarfBaseTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 56485 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfCatchBlockStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 56498 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfCatchBlockStorageClass::pickOutIRNodeData ( SgAsmDwarfCatchBlock* pointer ) 
   { 
     SgAsmDwarfCatchBlock* source = (SgAsmDwarfCatchBlock*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDwarfCatchBlockStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfCatchBlockStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfCatchBlockStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDwarfCatchBlockStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 56561 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfConstTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 56574 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfConstTypeStorageClass::pickOutIRNodeData ( SgAsmDwarfConstType* pointer ) 
   { 
     SgAsmDwarfConstType* source = (SgAsmDwarfConstType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDwarfConstTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfConstTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfConstTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDwarfConstTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 56637 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfConstantStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 56650 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfConstantStorageClass::pickOutIRNodeData ( SgAsmDwarfConstant* pointer ) 
   { 
     SgAsmDwarfConstant* source = (SgAsmDwarfConstant*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDwarfConstantStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfConstantStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfConstantStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDwarfConstantStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 56713 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfEnumeratorStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 56726 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfEnumeratorStorageClass::pickOutIRNodeData ( SgAsmDwarfEnumerator* pointer ) 
   { 
     SgAsmDwarfEnumerator* source = (SgAsmDwarfEnumerator*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDwarfEnumeratorStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfEnumeratorStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfEnumeratorStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDwarfEnumeratorStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 56789 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfFileTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 56802 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfFileTypeStorageClass::pickOutIRNodeData ( SgAsmDwarfFileType* pointer ) 
   { 
     SgAsmDwarfFileType* source = (SgAsmDwarfFileType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDwarfFileTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfFileTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfFileTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDwarfFileTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 56865 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfFriendStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 56878 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfFriendStorageClass::pickOutIRNodeData ( SgAsmDwarfFriend* pointer ) 
   { 
     SgAsmDwarfFriend* source = (SgAsmDwarfFriend*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDwarfFriendStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfFriendStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfFriendStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDwarfFriendStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 56941 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfNamelistStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 56954 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfNamelistStorageClass::pickOutIRNodeData ( SgAsmDwarfNamelist* pointer ) 
   { 
     SgAsmDwarfNamelist* source = (SgAsmDwarfNamelist*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDwarfNamelistStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfNamelistStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfNamelistStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDwarfNamelistStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 57017 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfNamelistItemStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 57030 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfNamelistItemStorageClass::pickOutIRNodeData ( SgAsmDwarfNamelistItem* pointer ) 
   { 
     SgAsmDwarfNamelistItem* source = (SgAsmDwarfNamelistItem*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDwarfNamelistItemStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfNamelistItemStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfNamelistItemStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDwarfNamelistItemStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 57093 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfPackedTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 57106 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfPackedTypeStorageClass::pickOutIRNodeData ( SgAsmDwarfPackedType* pointer ) 
   { 
     SgAsmDwarfPackedType* source = (SgAsmDwarfPackedType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDwarfPackedTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfPackedTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfPackedTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDwarfPackedTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 57169 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfSubprogramStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 57182 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfSubprogramStorageClass::pickOutIRNodeData ( SgAsmDwarfSubprogram* pointer ) 
   { 
     SgAsmDwarfSubprogram* source = (SgAsmDwarfSubprogram*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDwarfSubprogramStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfSubprogramStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfSubprogramStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDwarfSubprogramStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 57246 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfTemplateTypeParameterStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 57259 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfTemplateTypeParameterStorageClass::pickOutIRNodeData ( SgAsmDwarfTemplateTypeParameter* pointer ) 
   { 
     SgAsmDwarfTemplateTypeParameter* source = (SgAsmDwarfTemplateTypeParameter*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDwarfTemplateTypeParameterStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfTemplateTypeParameterStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfTemplateTypeParameterStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDwarfTemplateTypeParameterStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 57322 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfTemplateValueParameterStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 57335 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfTemplateValueParameterStorageClass::pickOutIRNodeData ( SgAsmDwarfTemplateValueParameter* pointer ) 
   { 
     SgAsmDwarfTemplateValueParameter* source = (SgAsmDwarfTemplateValueParameter*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDwarfTemplateValueParameterStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfTemplateValueParameterStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfTemplateValueParameterStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDwarfTemplateValueParameterStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 57398 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfThrownTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 57411 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfThrownTypeStorageClass::pickOutIRNodeData ( SgAsmDwarfThrownType* pointer ) 
   { 
     SgAsmDwarfThrownType* source = (SgAsmDwarfThrownType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDwarfThrownTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfThrownTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfThrownTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDwarfThrownTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 57474 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfTryBlockStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 57487 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfTryBlockStorageClass::pickOutIRNodeData ( SgAsmDwarfTryBlock* pointer ) 
   { 
     SgAsmDwarfTryBlock* source = (SgAsmDwarfTryBlock*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDwarfTryBlockStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfTryBlockStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfTryBlockStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDwarfTryBlockStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 57550 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfVariantPartStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 57563 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfVariantPartStorageClass::pickOutIRNodeData ( SgAsmDwarfVariantPart* pointer ) 
   { 
     SgAsmDwarfVariantPart* source = (SgAsmDwarfVariantPart*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDwarfVariantPartStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfVariantPartStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfVariantPartStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDwarfVariantPartStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 57626 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfVariableStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 57639 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfVariableStorageClass::pickOutIRNodeData ( SgAsmDwarfVariable* pointer ) 
   { 
     SgAsmDwarfVariable* source = (SgAsmDwarfVariable*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDwarfVariableStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfVariableStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfVariableStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDwarfVariableStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 57702 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfVolatileTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 57715 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfVolatileTypeStorageClass::pickOutIRNodeData ( SgAsmDwarfVolatileType* pointer ) 
   { 
     SgAsmDwarfVolatileType* source = (SgAsmDwarfVolatileType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDwarfVolatileTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfVolatileTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfVolatileTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDwarfVolatileTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 57778 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfDwarfProcedureStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 57791 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfDwarfProcedureStorageClass::pickOutIRNodeData ( SgAsmDwarfDwarfProcedure* pointer ) 
   { 
     SgAsmDwarfDwarfProcedure* source = (SgAsmDwarfDwarfProcedure*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDwarfDwarfProcedureStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfDwarfProcedureStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfDwarfProcedureStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDwarfDwarfProcedureStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 57854 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfRestrictTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 57867 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfRestrictTypeStorageClass::pickOutIRNodeData ( SgAsmDwarfRestrictType* pointer ) 
   { 
     SgAsmDwarfRestrictType* source = (SgAsmDwarfRestrictType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDwarfRestrictTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfRestrictTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfRestrictTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDwarfRestrictTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 57930 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfInterfaceTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 57943 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfInterfaceTypeStorageClass::pickOutIRNodeData ( SgAsmDwarfInterfaceType* pointer ) 
   { 
     SgAsmDwarfInterfaceType* source = (SgAsmDwarfInterfaceType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDwarfInterfaceTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfInterfaceTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfInterfaceTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDwarfInterfaceTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 58006 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfNamespaceStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 58019 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfNamespaceStorageClass::pickOutIRNodeData ( SgAsmDwarfNamespace* pointer ) 
   { 
     SgAsmDwarfNamespace* source = (SgAsmDwarfNamespace*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDwarfNamespaceStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfNamespaceStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfNamespaceStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDwarfNamespaceStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 58083 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfImportedModuleStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 58096 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfImportedModuleStorageClass::pickOutIRNodeData ( SgAsmDwarfImportedModule* pointer ) 
   { 
     SgAsmDwarfImportedModule* source = (SgAsmDwarfImportedModule*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDwarfImportedModuleStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfImportedModuleStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfImportedModuleStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDwarfImportedModuleStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 58159 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfUnspecifiedTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 58172 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfUnspecifiedTypeStorageClass::pickOutIRNodeData ( SgAsmDwarfUnspecifiedType* pointer ) 
   { 
     SgAsmDwarfUnspecifiedType* source = (SgAsmDwarfUnspecifiedType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDwarfUnspecifiedTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfUnspecifiedTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfUnspecifiedTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDwarfUnspecifiedTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 58235 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfPartialUnitStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 58248 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfPartialUnitStorageClass::pickOutIRNodeData ( SgAsmDwarfPartialUnit* pointer ) 
   { 
     SgAsmDwarfPartialUnit* source = (SgAsmDwarfPartialUnit*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDwarfPartialUnitStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfPartialUnitStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfPartialUnitStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDwarfPartialUnitStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 58311 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfImportedUnitStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 58324 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfImportedUnitStorageClass::pickOutIRNodeData ( SgAsmDwarfImportedUnit* pointer ) 
   { 
     SgAsmDwarfImportedUnit* source = (SgAsmDwarfImportedUnit*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDwarfImportedUnitStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfImportedUnitStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfImportedUnitStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDwarfImportedUnitStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 58387 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfMutableTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 58400 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfMutableTypeStorageClass::pickOutIRNodeData ( SgAsmDwarfMutableType* pointer ) 
   { 
     SgAsmDwarfMutableType* source = (SgAsmDwarfMutableType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDwarfMutableTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfMutableTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfMutableTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDwarfMutableTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 58463 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfConditionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 58476 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfConditionStorageClass::pickOutIRNodeData ( SgAsmDwarfCondition* pointer ) 
   { 
     SgAsmDwarfCondition* source = (SgAsmDwarfCondition*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDwarfConditionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfConditionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfConditionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDwarfConditionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 58539 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfSharedTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 58552 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfSharedTypeStorageClass::pickOutIRNodeData ( SgAsmDwarfSharedType* pointer ) 
   { 
     SgAsmDwarfSharedType* source = (SgAsmDwarfSharedType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDwarfSharedTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfSharedTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfSharedTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDwarfSharedTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 58615 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfFormatLabelStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 58628 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfFormatLabelStorageClass::pickOutIRNodeData ( SgAsmDwarfFormatLabel* pointer ) 
   { 
     SgAsmDwarfFormatLabel* source = (SgAsmDwarfFormatLabel*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDwarfFormatLabelStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfFormatLabelStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfFormatLabelStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDwarfFormatLabelStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 58691 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfFunctionTemplateStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 58704 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfFunctionTemplateStorageClass::pickOutIRNodeData ( SgAsmDwarfFunctionTemplate* pointer ) 
   { 
     SgAsmDwarfFunctionTemplate* source = (SgAsmDwarfFunctionTemplate*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDwarfFunctionTemplateStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfFunctionTemplateStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfFunctionTemplateStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDwarfFunctionTemplateStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 58767 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfClassTemplateStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 58780 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfClassTemplateStorageClass::pickOutIRNodeData ( SgAsmDwarfClassTemplate* pointer ) 
   { 
     SgAsmDwarfClassTemplate* source = (SgAsmDwarfClassTemplate*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDwarfClassTemplateStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfClassTemplateStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfClassTemplateStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDwarfClassTemplateStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 58843 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfUpcSharedTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 58856 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfUpcSharedTypeStorageClass::pickOutIRNodeData ( SgAsmDwarfUpcSharedType* pointer ) 
   { 
     SgAsmDwarfUpcSharedType* source = (SgAsmDwarfUpcSharedType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDwarfUpcSharedTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfUpcSharedTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfUpcSharedTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDwarfUpcSharedTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 58919 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfUpcStrictTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 58932 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfUpcStrictTypeStorageClass::pickOutIRNodeData ( SgAsmDwarfUpcStrictType* pointer ) 
   { 
     SgAsmDwarfUpcStrictType* source = (SgAsmDwarfUpcStrictType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDwarfUpcStrictTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfUpcStrictTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfUpcStrictTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDwarfUpcStrictTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 58995 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfUpcRelaxedTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 59008 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfUpcRelaxedTypeStorageClass::pickOutIRNodeData ( SgAsmDwarfUpcRelaxedType* pointer ) 
   { 
     SgAsmDwarfUpcRelaxedType* source = (SgAsmDwarfUpcRelaxedType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDwarfUpcRelaxedTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfUpcRelaxedTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfUpcRelaxedTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDwarfUpcRelaxedTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 59071 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfUnknownConstructStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 59084 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfUnknownConstructStorageClass::pickOutIRNodeData ( SgAsmDwarfUnknownConstruct* pointer ) 
   { 
     SgAsmDwarfUnknownConstruct* source = (SgAsmDwarfUnknownConstruct*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDwarfUnknownConstructStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfUnknownConstructStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfUnknownConstructStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDwarfUnknownConstructStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 59147 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfConstructListStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 59160 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfConstructListStorageClass::pickOutIRNodeData ( SgAsmDwarfConstructList* pointer ) 
   { 
     SgAsmDwarfConstructList* source = (SgAsmDwarfConstructList*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgAsmDwarfConstructPtrList::iterator i_list = source->p_list.begin() ; 
     unsigned int tempListCountlist = 0; 
     SgAsmDwarfConstructPtrList::value_type *  tempListlist = new SgAsmDwarfConstructPtrList::value_type[ source->p_list.size() ]; 
     for ( ; i_list != source->p_list.end(); ++i_list ) 
        {
          tempListlist[tempListCountlist] = *i_list;
          tempListCountlist++; 
          (*i_list) = (SgAsmDwarfConstructPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_list ) );
        }
     storageOf_list.storeDataInEasyStorageClass(source->p_list);
     tempListCountlist = 0; 
     i_list = source->p_list.begin() ; 
     for ( ; i_list != source->p_list.end(); ++i_list ) 
        {
          *i_list = tempListlist[tempListCountlist] ;
          tempListCountlist++; 
        }
      delete [] tempListlist; 
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmDwarfConstructListStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgAsmDwarfConstructPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfConstructListStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgAsmDwarfConstructPtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfConstructListStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgAsmDwarfConstructPtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmDwarfConstructListStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgAsmDwarfConstructPtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 59236 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmPEImportItemStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 59249 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmPEImportItemStorageClass::pickOutIRNodeData ( SgAsmPEImportItem* pointer ) 
   { 
     SgAsmPEImportItem* source = (SgAsmPEImportItem*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     storageOf_by_ordinal =  source->p_by_ordinal ;
     storageOf_ordinal =  source->p_ordinal ;
     storageOf_hint =  source->p_hint ;
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_hintname_rva =  source->p_hintname_rva ;
     storageOf_hintname_nalloc =  source->p_hintname_nalloc ;
     storageOf_bound_rva =  source->p_bound_rva ;
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmPEImportItemStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmPEImportItemStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmPEImportItemStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmPEImportItemStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 59310 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmPEImportItemListStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 59323 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmPEImportItemListStorageClass::pickOutIRNodeData ( SgAsmPEImportItemList* pointer ) 
   { 
     SgAsmPEImportItemList* source = (SgAsmPEImportItemList*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgAsmPEImportItemPtrList::iterator i_vector = source->p_vector.begin() ; 
     unsigned int tempListCountvector = 0; 
     SgAsmPEImportItemPtrList::value_type *  tempListvector = new SgAsmPEImportItemPtrList::value_type[ source->p_vector.size() ]; 
     for ( ; i_vector != source->p_vector.end(); ++i_vector ) 
        {
          tempListvector[tempListCountvector] = *i_vector;
          tempListCountvector++; 
          (*i_vector) = (SgAsmPEImportItemPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_vector ) );
        }
     storageOf_vector.storeDataInEasyStorageClass(source->p_vector);
     tempListCountvector = 0; 
     i_vector = source->p_vector.begin() ; 
     for ( ; i_vector != source->p_vector.end(); ++i_vector ) 
        {
          *i_vector = tempListvector[tempListCountvector] ;
          tempListCountvector++; 
        }
      delete [] tempListvector; 
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmPEImportItemListStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgAsmPEImportItemPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmPEImportItemListStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgAsmPEImportItemPtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmPEImportItemListStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgAsmPEImportItemPtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmPEImportItemListStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgAsmPEImportItemPtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 59399 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmInterpretationListStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 59412 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmInterpretationListStorageClass::pickOutIRNodeData ( SgAsmInterpretationList* pointer ) 
   { 
     SgAsmInterpretationList* source = (SgAsmInterpretationList*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgAsmInterpretationPtrList::iterator i_interpretations = source->p_interpretations.begin() ; 
     unsigned int tempListCountinterpretations = 0; 
     SgAsmInterpretationPtrList::value_type *  tempListinterpretations = new SgAsmInterpretationPtrList::value_type[ source->p_interpretations.size() ]; 
     for ( ; i_interpretations != source->p_interpretations.end(); ++i_interpretations ) 
        {
          tempListinterpretations[tempListCountinterpretations] = *i_interpretations;
          tempListCountinterpretations++; 
          (*i_interpretations) = (SgAsmInterpretationPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_interpretations ) );
        }
     storageOf_interpretations.storeDataInEasyStorageClass(source->p_interpretations);
     tempListCountinterpretations = 0; 
     i_interpretations = source->p_interpretations.begin() ; 
     for ( ; i_interpretations != source->p_interpretations.end(); ++i_interpretations ) 
        {
          *i_interpretations = tempListinterpretations[tempListCountinterpretations] ;
          tempListCountinterpretations++; 
        }
      delete [] tempListinterpretations; 
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmInterpretationListStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgAsmInterpretationPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmInterpretationListStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgAsmInterpretationPtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmInterpretationListStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgAsmInterpretationPtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmInterpretationListStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgAsmInterpretationPtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 59488 "../../../src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmGenericFileListStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 59501 "../../../src/frontend/SageIII//StorageClasses.C" */


void
SgAsmGenericFileListStorageClass::pickOutIRNodeData ( SgAsmGenericFileList* pointer ) 
   { 
     SgAsmGenericFileList* source = (SgAsmGenericFileList*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     assert ( source != NULL ) ; 
     assert ( source->p_freepointer != NULL) ; 
#endif 
     SgAsmGenericFilePtrList::iterator i_files = source->p_files.begin() ; 
     unsigned int tempListCountfiles = 0; 
     SgAsmGenericFilePtrList::value_type *  tempListfiles = new SgAsmGenericFilePtrList::value_type[ source->p_files.size() ]; 
     for ( ; i_files != source->p_files.end(); ++i_files ) 
        {
          tempListfiles[tempListCountfiles] = *i_files;
          tempListCountfiles++; 
          (*i_files) = (SgAsmGenericFilePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_files ) );
        }
     storageOf_files.storeDataInEasyStorageClass(source->p_files);
     tempListCountfiles = 0; 
     i_files = source->p_files.begin() ; 
     for ( ; i_files != source->p_files.end(); ++i_files ) 
        {
          *i_files = tempListfiles[tempListCountfiles] ;
          tempListCountfiles++; 
        }
      delete [] tempListfiles; 
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_asmAttributeMechanism.storeDataInEasyStorageClass(source->p_asmAttributeMechanism);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
   }

void
SgAsmGenericFileListStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgAsmGenericFilePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmGenericFileListStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgAsmGenericFilePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmGenericFileListStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgAsmGenericFilePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmGenericFileListStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgAsmGenericFilePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/home/bronevet/Downloads/rose/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 59577 "../../../src/frontend/SageIII//StorageClasses.C" */



#endif // STORAGE_CLASSES_H

